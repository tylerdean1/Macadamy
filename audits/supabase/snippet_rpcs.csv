schema,function,definition
auth,email,"CREATE OR REPLACE FUNCTION auth.email()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$function$
"
auth,jwt,"CREATE OR REPLACE FUNCTION auth.jwt()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$function$
"
auth,role,"CREATE OR REPLACE FUNCTION auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$function$
"
auth,uid,"CREATE OR REPLACE FUNCTION auth.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$function$
"
extensions,armor,"CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_armor$function$
"
extensions,armor,"CREATE OR REPLACE FUNCTION extensions.armor(bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_armor$function$
"
extensions,crypt,"CREATE OR REPLACE FUNCTION extensions.crypt(text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_crypt$function$
"
extensions,dearmor,"CREATE OR REPLACE FUNCTION extensions.dearmor(text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_dearmor$function$
"
extensions,decrypt,"CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_decrypt$function$
"
extensions,decrypt_iv,"CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$
"
extensions,digest,"CREATE OR REPLACE FUNCTION extensions.digest(text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_digest$function$
"
extensions,digest,"CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_digest$function$
"
extensions,encrypt,"CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_encrypt$function$
"
extensions,encrypt_iv,"CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$
"
extensions,gen_random_bytes,"CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_random_bytes$function$
"
extensions,gen_random_uuid,"CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE
AS '$libdir/pgcrypto', $function$pg_random_uuid$function$
"
extensions,gen_salt,"CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)
 RETURNS text
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$
"
extensions,gen_salt,"CREATE OR REPLACE FUNCTION extensions.gen_salt(text)
 RETURNS text
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_gen_salt$function$
"
extensions,grant_pg_cron_access,"CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF EXISTS (
    SELECT
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_cron'
  )
  THEN
    grant usage on schema cron to postgres with grant option;

    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;

    alter default privileges for user supabase_admin in schema cron grant all
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on functions to postgres with grant option;

    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$function$
"
extensions,grant_pg_graphql_access,"CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    func_is_graphql_resolve bool;
BEGIN
    func_is_graphql_resolve = (
        SELECT n.proname = 'resolve'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_proc AS n
        ON ev.objid = n.oid
    );

    IF func_is_graphql_resolve
    THEN
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(
            ""operationName"" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language sql
        as $$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                ""operationName"" := ""operationName"",
                extensions := extensions
            );
        $$;

        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
        -- function in the extension so we need to grant permissions on existing entities AND
        -- update default permissions to any others that are created after `graphql.resolve`
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;

END;
$function$
"
extensions,grant_pg_net_access,"CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_net'
  )
  THEN
    IF NOT EXISTS (
      SELECT 1
      FROM pg_roles
      WHERE rolname = 'supabase_functions_admin'
    )
    THEN
      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;

    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

    IF EXISTS (
      SELECT FROM pg_extension
      WHERE extname = 'pg_net'
      -- all versions in use on existing projects as of 2025-02-20
      -- version 0.12.0 onwards don't need these applied
      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
    ) THEN
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
  END IF;
END;
$function$
"
extensions,hmac,"CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_hmac$function$
"
extensions,hmac,"CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_hmac$function$
"
extensions,pg_stat_statements,"CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)
 RETURNS SETOF record
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_11$function$
"
extensions,pg_stat_statements_info,"CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)
 RETURNS record
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$
"
extensions,pg_stat_statements_reset,"CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)
 RETURNS timestamp with time zone
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_11$function$
"
extensions,pgp_armor_headers,"CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)
 RETURNS SETOF record
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_armor_headers$function$
"
extensions,pgp_key_id,"CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_key_id_w$function$
"
extensions,pgp_pub_decrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
extensions,pgp_pub_decrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
extensions,pgp_pub_decrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
extensions,pgp_pub_decrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
extensions,pgp_pub_decrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
extensions,pgp_pub_decrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
extensions,pgp_pub_encrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$
"
extensions,pgp_pub_encrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$
"
extensions,pgp_pub_encrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$
"
extensions,pgp_pub_encrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$
"
extensions,pgp_sym_decrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$
"
extensions,pgp_sym_decrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$
"
extensions,pgp_sym_decrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$
"
extensions,pgp_sym_decrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$
"
extensions,pgp_sym_encrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$
"
extensions,pgp_sym_encrypt,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$
"
extensions,pgp_sym_encrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$
"
extensions,pgp_sym_encrypt_bytea,"CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$
"
extensions,pgrst_ddl_watch,"CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$
"
extensions,pgrst_drop_watch,"CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$
"
extensions,set_graphql_placeholder,"CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
    DECLARE
    graphql_is_dropped bool;
    BEGIN
    graphql_is_dropped = (
        SELECT ev.schema_name = 'graphql_public'
        FROM pg_event_trigger_dropped_objects() AS ev
        WHERE ev.schema_name = 'graphql_public'
    );

    IF graphql_is_dropped
    THEN
        create or replace function graphql_public.graphql(
            ""operationName"" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language plpgsql
        as $$
            DECLARE
                server_version float;
            BEGIN
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                IF server_version >= 14 THEN
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql extension is not enabled.'
                            )
                        )
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                            )
                        )
                    );
                END IF;
            END;
        $$;
    END IF;

    END;
$function$
"
extensions,uuid_generate_v1,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$
"
extensions,uuid_generate_v1mc,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$
"
extensions,uuid_generate_v3,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$
"
extensions,uuid_generate_v4,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$
"
extensions,uuid_generate_v5,"CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$
"
extensions,uuid_nil,"CREATE OR REPLACE FUNCTION extensions.uuid_nil()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_nil$function$
"
extensions,uuid_ns_dns,"CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$
"
extensions,uuid_ns_oid,"CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$
"
extensions,uuid_ns_url,"CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_url$function$
"
extensions,uuid_ns_x500,"CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$
"
graphql,_internal_resolve,"CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, ""operationName"" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE c
AS '$libdir/pg_graphql', $function$resolve_wrapper$function$
"
graphql,comment_directive,"CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)
 RETURNS jsonb
 LANGUAGE sql
 IMMUTABLE
AS $function$
    /*
    comment on column public.account.name is '@graphql.name: myField'
    */
    select
        coalesce(
            (
                regexp_match(
                    comment_,
                    '@graphql\((.+)\)'
                )
            )[1]::jsonb,
            jsonb_build_object()
        )
$function$
"
graphql,exception,"CREATE OR REPLACE FUNCTION graphql.exception(message text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
begin
    raise exception using errcode='22000', message=message;
end;
$function$
"
graphql,get_schema_version,"CREATE OR REPLACE FUNCTION graphql.get_schema_version()
 RETURNS integer
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    select last_value from graphql.seq_schema_version;
$function$
"
graphql,increment_schema_version,"CREATE OR REPLACE FUNCTION graphql.increment_schema_version()
 RETURNS event_trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
    perform pg_catalog.nextval('graphql.seq_schema_version');
end;
$function$
"
graphql,resolve,"CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, ""operationName"" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
declare
    res jsonb;
    message_text text;
begin
  begin
    select graphql._internal_resolve(""query"" := ""query"",
                                     ""variables"" := ""variables"",
                                     ""operationName"" := ""operationName"",
                                     ""extensions"" := ""extensions"") into res;
    return res;
  exception
    when others then
    get stacked diagnostics message_text = message_text;
    return
    jsonb_build_object('data', null,
                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));
  end;
end;
$function$
"
graphql_public,graphql,"CREATE OR REPLACE FUNCTION graphql_public.graphql(""operationName"" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE sql
AS $function$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                ""operationName"" := ""operationName"",
                extensions := extensions
            );
        $function$
"
pgbouncer,get_auth,"CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)
 RETURNS TABLE(username text, password text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  BEGIN
      RAISE DEBUG 'PgBouncer auth request: %', p_usename;

      RETURN QUERY
      SELECT
          rolname::text,
          CASE WHEN rolvaliduntil < now()
              THEN null
              ELSE rolpassword::text
          END
      FROM pg_authid
      WHERE rolname=$1 and rolcanlogin;
  END;
  $function$
"
public,advance_workflow,"CREATE OR REPLACE FUNCTION public.advance_workflow(_id uuid, _new_state text)
 RETURNS workflows
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  UPDATE public.workflows
     SET current_state = _new_state,
         updated_at    = now()
   WHERE id = _id
   RETURNING *;
$function$
"
public,check_access,"CREATE OR REPLACE FUNCTION public.check_access(_action text, _resource text, _project_id uuid DEFAULT NULL::uuid, _organization_id uuid DEFAULT NULL::uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  _role text;
  _org_id uuid;
BEGIN
  -- ðŸ” Load caller's role and org
  SELECT role, organization_id INTO _role, _org_id
  FROM public.profiles
  WHERE id = auth.uid();

  IF _role IS NULL THEN
    RAISE EXCEPTION 'Access denied: profile not found for user %', auth.uid();
  END IF;

  -- âœ… SYSTEM ADMIN â€” unrestricted access
  IF _role = 'system_admin' THEN
    RETURN;
  END IF;

  -- ðŸ”’ Always-denied resources for limited roles
  IF _role IN ('org_user', 'org_viewer', 'inspector', 'auditor') AND
     _resource IN ('organizations', 'organization_members', 'profiles', 'job_titles', 'integration_tokens') THEN
    RAISE EXCEPTION 'Access denied: role % cannot access resource %', _role, _resource;
  END IF;

  -- ðŸ¢ ORG-LEVEL CHECK
  IF _resource IN (
    'organizations', 'organization_members', 'profiles', 'job_titles', 'integration_tokens'
  ) THEN
    IF _organization_id IS NULL THEN
      RAISE EXCEPTION 'Access denied: _organization_id is required for org-level access to %', _resource;
    END IF;
    IF _organization_id != _org_id THEN
      RAISE EXCEPTION 'Access denied: you do not belong to organization %', _organization_id;
    END IF;
  END IF;

  -- ðŸ— PROJECT-LEVEL CHECK
  IF _project_id IS NOT NULL THEN
    PERFORM 1 FROM projects WHERE id = _project_id AND organization_id = _org_id;
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Access denied: project % not in your organization', _project_id;
    END IF;
  END IF;

  -- âœ… ORG ADMIN â€” full access within their org
  IF _role = 'org_admin' THEN
    RETURN;
  END IF;

  -- âœ… ORG SUPERVISOR â€” same as admin, minus org/user admin
  IF _role = 'org_supervisor' THEN
    IF _resource IN ('organizations', 'organization_members') THEN
      RAISE EXCEPTION 'Access denied: org_supervisor cannot manage organization metadata or users';
    END IF;
    RETURN;
  END IF;

  -- ðŸ”§ ORG USER â€” hybrid policy: mostly read, scoped write
  IF _role = 'org_user' THEN
    -- Denied for sensitive reads
    IF _action = 'select' AND _resource IN (
      'organizations', 'organization_members', 'profiles', 'job_titles', 'integration_tokens'
    ) THEN
      RAISE EXCEPTION 'Access denied: org_user cannot read %', _resource;
    END IF;

    -- Allowed writes (insert/update/delete)
    IF _action IN ('insert', 'update', 'delete') THEN
      IF _resource IN (
        'daily_logs', 'photos', 'documents', 'rfis', 'submittals',
        'inspections', 'line_item_entries', 'labor_records',
        'equipment_usage', 'issues', 'punch_lists', 'quality_reviews',
        'meeting_minutes'
      ) THEN
        RETURN;
      ELSE
        RAISE EXCEPTION 'Access denied: org_user cannot write to %', _resource;
      END IF;
    END IF;

    RETURN; -- For valid reads
  END IF;

  -- ðŸ” ORG VIEWER â€” read-only
  IF _role = 'org_viewer' THEN
    IF _action = 'select' THEN
      RETURN;
    ELSE
      RAISE EXCEPTION 'Access denied: org_viewer is read-only';
    END IF;
  END IF;

  -- ðŸ•µï¸ INSPECTOR â€” must be assigned to project, and only on select resources
  IF _role = 'inspector' THEN
    IF _action = 'select' THEN
      RETURN;
    ELSIF _action IN ('insert', 'update') AND _resource IN (
      'inspections', 'reports', 'documents', 'regulatory_documents'
    ) THEN
      IF NOT EXISTS (
        SELECT 1 FROM project_inspectors
        WHERE project_id = _project_id AND profile_id = auth.uid()
      ) THEN
        RAISE EXCEPTION 'Access denied: inspector not assigned to project %', _project_id;
      END IF;
      RETURN;
    ELSE
      RAISE EXCEPTION 'Access denied: inspector cannot % on %', _action, _resource;
    END IF;
  END IF;

  -- ðŸ§¾ AUDITOR â€” global read-only
  IF _role = 'auditor' THEN
    IF _action = 'select' THEN
      RETURN;
    ELSE
      RAISE EXCEPTION 'Access denied: auditor is read-only';
    END IF;
  END IF;

  -- ðŸš« Fallback catch-all
  RAISE EXCEPTION 'Access denied: unrecognized role % or unsupported action % on %', _role, _action, _resource;
END;
$function$
"
public,check_access_bool,"CREATE OR REPLACE FUNCTION public.check_access_bool(_action text, _table text, _proj uuid, _org uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  PERFORM check_access(_action, _table, _proj, _org);
  RETURN true;
EXCEPTION
  WHEN others THEN
    RETURN false;
END;
$function$
"
public,complete_my_profile,"CREATE OR REPLACE FUNCTION public.complete_my_profile(p_full_name text, p_phone text, p_job_title_id uuid, p_avatar_id uuid, p_role user_role_type)
 RETURNS profiles
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user_id uuid;
  v_profile public.profiles;
  v_role public.user_role_type;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  v_role := p_role;
  if v_role = 'system_admin' then
    raise exception 'system_admin role cannot be assigned via onboarding';
  end if;

  update public.profiles
  set
    full_name = nullif(btrim(p_full_name), ''),
    phone = nullif(btrim(p_phone), ''),
    job_title_id = p_job_title_id,
    avatar_id = p_avatar_id,
    role = case when v_role is not null then v_role else role end,
    profile_completed_at = coalesce(profile_completed_at, now()),
    updated_at = now()
  where id = v_user_id
  returning * into v_profile;

  return v_profile;
end;
$function$
"
public,count_unread_notifications,"CREATE OR REPLACE FUNCTION public.count_unread_notifications()
 RETURNS integer
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT COUNT(*) 
    FROM public.notifications
   WHERE user_id = auth.uid()
     AND is_read = false;
$function$
"
public,create_my_organization,"CREATE OR REPLACE FUNCTION public.create_my_organization(p_name text, p_description text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user_id uuid;
  v_org_id uuid;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  insert into public.organizations (name, description, created_at, updated_at)
  values (p_name, nullif(btrim(p_description), ''), now(), now())
  returning id into v_org_id;

  insert into public.organization_members (organization_id, profile_id, role, created_at, updated_at)
  values (v_org_id, v_user_id, 'org_admin', now(), now());

  update public.profiles
  set organization_id = v_org_id,
      updated_at = now()
  where id = v_user_id;

  return v_org_id;
end;
$function$
"
public,delete_accounts_payable,"CREATE OR REPLACE FUNCTION public.delete_accounts_payable(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.accounts_payable;
        BEGIN
          SELECT * INTO _row FROM public.accounts_payable WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','accounts_payable', _row.project_id, _row.organization_id);

          UPDATE public.accounts_payable
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_accounts_receivable,"CREATE OR REPLACE FUNCTION public.delete_accounts_receivable(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.accounts_receivable;
        BEGIN
          SELECT * INTO _row FROM public.accounts_receivable WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','accounts_receivable', _row.project_id, _row.organization_id);

          UPDATE public.accounts_receivable
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_activity_logs,"CREATE OR REPLACE FUNCTION public.delete_activity_logs(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.activity_logs;
        BEGIN
          SELECT * INTO _row FROM public.activity_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','activity_logs', _row.project_id, _row.organization_id);

          UPDATE public.activity_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_asphalt_types,"CREATE OR REPLACE FUNCTION public.delete_asphalt_types(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.asphalt_types;
        BEGIN
          SELECT * INTO _row FROM public.asphalt_types WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','asphalt_types', _row.project_id, _row.organization_id);

          UPDATE public.asphalt_types
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_audit_logs,"CREATE OR REPLACE FUNCTION public.delete_audit_logs(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.audit_logs;
        BEGIN
          SELECT * INTO _row FROM public.audit_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','audit_logs', _row.project_id, _row.organization_id);

          UPDATE public.audit_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_avatars,"CREATE OR REPLACE FUNCTION public.delete_avatars(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.avatars;
        BEGIN
          SELECT * INTO _row FROM public.avatars WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','avatars', _row.project_id, _row.organization_id);

          UPDATE public.avatars
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_bid_packages,"CREATE OR REPLACE FUNCTION public.delete_bid_packages(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.bid_packages;
        BEGIN
          SELECT * INTO _row FROM public.bid_packages WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bid_packages', _row.project_id, _row.organization_id);

          UPDATE public.bid_packages
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_bid_vendors,"CREATE OR REPLACE FUNCTION public.delete_bid_vendors(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.bid_vendors;
        BEGIN
          SELECT * INTO _row FROM public.bid_vendors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bid_vendors', _row.project_id, _row.organization_id);

          UPDATE public.bid_vendors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_bids,"CREATE OR REPLACE FUNCTION public.delete_bids(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.bids;
        BEGIN
          SELECT * INTO _row FROM public.bids WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bids', _row.project_id, _row.organization_id);

          UPDATE public.bids
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_bim_models,"CREATE OR REPLACE FUNCTION public.delete_bim_models(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.bim_models;
        BEGIN
          SELECT * INTO _row FROM public.bim_models WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bim_models', _row.project_id, _row.organization_id);

          UPDATE public.bim_models
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_certifications,"CREATE OR REPLACE FUNCTION public.delete_certifications(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.certifications;
        BEGIN
          SELECT * INTO _row FROM public.certifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','certifications', _row.project_id, _row.organization_id);

          UPDATE public.certifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_change_orders,"CREATE OR REPLACE FUNCTION public.delete_change_orders(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.change_orders;
        BEGIN
          SELECT * INTO _row FROM public.change_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','change_orders', _row.project_id, _row.organization_id);

          UPDATE public.change_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_commitments,"CREATE OR REPLACE FUNCTION public.delete_commitments(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.commitments;
        BEGIN
          SELECT * INTO _row FROM public.commitments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','commitments', _row.project_id, _row.organization_id);

          UPDATE public.commitments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_compliance_checks,"CREATE OR REPLACE FUNCTION public.delete_compliance_checks(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.compliance_checks;
        BEGIN
          SELECT * INTO _row FROM public.compliance_checks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','compliance_checks', _row.project_id, _row.organization_id);

          UPDATE public.compliance_checks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_compliance_tracking,"CREATE OR REPLACE FUNCTION public.delete_compliance_tracking(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.compliance_tracking;
        BEGIN
          SELECT * INTO _row FROM public.compliance_tracking WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','compliance_tracking', _row.project_id, _row.organization_id);

          UPDATE public.compliance_tracking
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_cost_codes,"CREATE OR REPLACE FUNCTION public.delete_cost_codes(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.cost_codes;
        BEGIN
          SELECT * INTO _row FROM public.cost_codes WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','cost_codes', _row.project_id, _row.organization_id);

          UPDATE public.cost_codes
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_crew_assignments,"CREATE OR REPLACE FUNCTION public.delete_crew_assignments(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.crew_assignments;
        BEGIN
          SELECT * INTO _row FROM public.crew_assignments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crew_assignments', _row.project_id, _row.organization_id);

          UPDATE public.crew_assignments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_crew_members,"CREATE OR REPLACE FUNCTION public.delete_crew_members(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.crew_members;
        BEGIN
          SELECT * INTO _row FROM public.crew_members WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crew_members', _row.project_id, _row.organization_id);

          UPDATE public.crew_members
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_crews,"CREATE OR REPLACE FUNCTION public.delete_crews(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.crews;
        BEGIN
          SELECT * INTO _row FROM public.crews WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crews', _row.project_id, _row.organization_id);

          UPDATE public.crews
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_daily_logs,"CREATE OR REPLACE FUNCTION public.delete_daily_logs(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.daily_logs;
        BEGIN
          SELECT * INTO _row FROM public.daily_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','daily_logs', _row.project_id, _row.organization_id);

          UPDATE public.daily_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_dashboard_configs,"CREATE OR REPLACE FUNCTION public.delete_dashboard_configs(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.dashboard_configs;
        BEGIN
          SELECT * INTO _row FROM public.dashboard_configs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','dashboard_configs', _row.project_id, _row.organization_id);

          UPDATE public.dashboard_configs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_document_references,"CREATE OR REPLACE FUNCTION public.delete_document_references(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.document_references;
        BEGIN
          SELECT * INTO _row FROM public.document_references WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','document_references', _row.project_id, _row.organization_id);

          UPDATE public.document_references
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_documents,"CREATE OR REPLACE FUNCTION public.delete_documents(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.documents;
        BEGIN
          SELECT * INTO _row FROM public.documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','documents', _row.project_id, _row.organization_id);

          UPDATE public.documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_drawing_versions,"CREATE OR REPLACE FUNCTION public.delete_drawing_versions(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.drawing_versions;
        BEGIN
          SELECT * INTO _row FROM public.drawing_versions WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','drawing_versions', _row.project_id, _row.organization_id);

          UPDATE public.drawing_versions
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_dump_trucks,"CREATE OR REPLACE FUNCTION public.delete_dump_trucks(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.dump_trucks;
        BEGIN
          SELECT * INTO _row FROM public.dump_trucks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','dump_trucks', _row.project_id, _row.organization_id);

          UPDATE public.dump_trucks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_employees,"CREATE OR REPLACE FUNCTION public.delete_employees(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.employees;
        BEGIN
          SELECT * INTO _row FROM public.employees WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','employees', _row.project_id, _row.organization_id);

          UPDATE public.employees
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_equipment,"CREATE OR REPLACE FUNCTION public.delete_equipment(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.equipment;
        BEGIN
          SELECT * INTO _row FROM public.equipment WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment', _row.project_id, _row.organization_id);

          UPDATE public.equipment
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_equipment_assignments,"CREATE OR REPLACE FUNCTION public.delete_equipment_assignments(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.equipment_assignments;
        BEGIN
          SELECT * INTO _row FROM public.equipment_assignments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_assignments', _row.project_id, _row.organization_id);

          UPDATE public.equipment_assignments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_equipment_maintenance,"CREATE OR REPLACE FUNCTION public.delete_equipment_maintenance(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.equipment_maintenance;
        BEGIN
          SELECT * INTO _row FROM public.equipment_maintenance WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_maintenance', _row.project_id, _row.organization_id);

          UPDATE public.equipment_maintenance
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_equipment_usage,"CREATE OR REPLACE FUNCTION public.delete_equipment_usage(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.equipment_usage;
        BEGIN
          SELECT * INTO _row FROM public.equipment_usage WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_usage', _row.project_id, _row.organization_id);

          UPDATE public.equipment_usage
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_estimate_line_items,"CREATE OR REPLACE FUNCTION public.delete_estimate_line_items(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.estimate_line_items;
        BEGIN
          SELECT * INTO _row FROM public.estimate_line_items WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','estimate_line_items', _row.project_id, _row.organization_id);

          UPDATE public.estimate_line_items
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_estimates,"CREATE OR REPLACE FUNCTION public.delete_estimates(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.estimates;
        BEGIN
          SELECT * INTO _row FROM public.estimates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','estimates', _row.project_id, _row.organization_id);

          UPDATE public.estimates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_financial_documents,"CREATE OR REPLACE FUNCTION public.delete_financial_documents(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.financial_documents;
        BEGIN
          SELECT * INTO _row FROM public.financial_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','financial_documents', _row.project_id, _row.organization_id);

          UPDATE public.financial_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_general_ledger,"CREATE OR REPLACE FUNCTION public.delete_general_ledger(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.general_ledger;
        BEGIN
          SELECT * INTO _row FROM public.general_ledger WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','general_ledger', _row.project_id, _row.organization_id);

          UPDATE public.general_ledger
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_hr_documents,"CREATE OR REPLACE FUNCTION public.delete_hr_documents(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.hr_documents;
        BEGIN
          SELECT * INTO _row FROM public.hr_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','hr_documents', _row.project_id, _row.organization_id);

          UPDATE public.hr_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_inspections,"CREATE OR REPLACE FUNCTION public.delete_inspections(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.inspections;
        BEGIN
          SELECT * INTO _row FROM public.inspections WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','inspections', _row.project_id, _row.organization_id);

          UPDATE public.inspections
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_integration_tokens,"CREATE OR REPLACE FUNCTION public.delete_integration_tokens(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.integration_tokens;
        BEGIN
          SELECT * INTO _row FROM public.integration_tokens WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','integration_tokens', _row.project_id, _row.organization_id);

          UPDATE public.integration_tokens
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_inventory_transactions,"CREATE OR REPLACE FUNCTION public.delete_inventory_transactions(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.inventory_transactions;
        BEGIN
          SELECT * INTO _row FROM public.inventory_transactions WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','inventory_transactions', _row.project_id, _row.organization_id);

          UPDATE public.inventory_transactions
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_issues,"CREATE OR REPLACE FUNCTION public.delete_issues(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.issues;
        BEGIN
          SELECT * INTO _row FROM public.issues WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','issues', _row.project_id, _row.organization_id);

          UPDATE public.issues
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_job_titles,"CREATE OR REPLACE FUNCTION public.delete_job_titles(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.job_titles;
        BEGIN
          SELECT * INTO _row FROM public.job_titles WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','job_titles', _row.project_id, _row.organization_id);

          UPDATE public.job_titles
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_labor_records,"CREATE OR REPLACE FUNCTION public.delete_labor_records(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.labor_records;
        BEGIN
          SELECT * INTO _row FROM public.labor_records WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','labor_records', _row.project_id, _row.organization_id);

          UPDATE public.labor_records
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_line_item_entries,"CREATE OR REPLACE FUNCTION public.delete_line_item_entries(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.line_item_entries;
        BEGIN
          SELECT * INTO _row FROM public.line_item_entries WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_item_entries', _row.project_id, _row.organization_id);

          UPDATE public.line_item_entries
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_line_item_templates,"CREATE OR REPLACE FUNCTION public.delete_line_item_templates(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.line_item_templates;
        BEGIN
          SELECT * INTO _row FROM public.line_item_templates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_item_templates', _row.project_id, _row.organization_id);

          UPDATE public.line_item_templates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_line_items,"CREATE OR REPLACE FUNCTION public.delete_line_items(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.line_items;
        BEGIN
          SELECT * INTO _row FROM public.line_items WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_items', _row.project_id, _row.organization_id);

          UPDATE public.line_items
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_maps,"CREATE OR REPLACE FUNCTION public.delete_maps(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.maps;
        BEGIN
          SELECT * INTO _row FROM public.maps WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','maps', _row.project_id, _row.organization_id);

          UPDATE public.maps
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_material_inventory,"CREATE OR REPLACE FUNCTION public.delete_material_inventory(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.material_inventory;
        BEGIN
          SELECT * INTO _row FROM public.material_inventory WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_inventory', _row.project_id, _row.organization_id);

          UPDATE public.material_inventory
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_material_orders,"CREATE OR REPLACE FUNCTION public.delete_material_orders(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.material_orders;
        BEGIN
          SELECT * INTO _row FROM public.material_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_orders', _row.project_id, _row.organization_id);

          UPDATE public.material_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_material_receipts,"CREATE OR REPLACE FUNCTION public.delete_material_receipts(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.material_receipts;
        BEGIN
          SELECT * INTO _row FROM public.material_receipts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_receipts', _row.project_id, _row.organization_id);

          UPDATE public.material_receipts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_materials,"CREATE OR REPLACE FUNCTION public.delete_materials(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.materials;
        BEGIN
          SELECT * INTO _row FROM public.materials WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','materials', _row.project_id, _row.organization_id);

          UPDATE public.materials
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_meeting_minutes,"CREATE OR REPLACE FUNCTION public.delete_meeting_minutes(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.meeting_minutes;
        BEGIN
          SELECT * INTO _row FROM public.meeting_minutes WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','meeting_minutes', _row.project_id, _row.organization_id);

          UPDATE public.meeting_minutes
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_notifications,"CREATE OR REPLACE FUNCTION public.delete_notifications(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.notifications;
        BEGIN
          SELECT * INTO _row FROM public.notifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','notifications', _row.project_id, _row.organization_id);

          UPDATE public.notifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_organization_members,"CREATE OR REPLACE FUNCTION public.delete_organization_members(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.organization_members;
        BEGIN
          SELECT * INTO _row FROM public.organization_members WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','organization_members', _row.project_id, _row.organization_id);

          UPDATE public.organization_members
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_organization_projects,"CREATE OR REPLACE FUNCTION public.delete_organization_projects(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.organization_projects;
        BEGIN
          SELECT * INTO _row FROM public.organization_projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','organization_projects', _row.project_id, _row.organization_id);

          UPDATE public.organization_projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_organizations,"CREATE OR REPLACE FUNCTION public.delete_organizations(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.organizations;
        BEGIN
          SELECT * INTO _row FROM public.organizations WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','organizations', _row.project_id, _row.organization_id);

          UPDATE public.organizations
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_payments,"CREATE OR REPLACE FUNCTION public.delete_payments(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.payments;
        BEGIN
          SELECT * INTO _row FROM public.payments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','payments', _row.project_id, _row.organization_id);

          UPDATE public.payments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_payroll,"CREATE OR REPLACE FUNCTION public.delete_payroll(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.payroll;
        BEGIN
          SELECT * INTO _row FROM public.payroll WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','payroll', _row.project_id, _row.organization_id);

          UPDATE public.payroll
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_photos,"CREATE OR REPLACE FUNCTION public.delete_photos(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.photos;
        BEGIN
          SELECT * INTO _row FROM public.photos WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','photos', _row.project_id, _row.organization_id);

          UPDATE public.photos
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_prequalifications,"CREATE OR REPLACE FUNCTION public.delete_prequalifications(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.prequalifications;
        BEGIN
          SELECT * INTO _row FROM public.prequalifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','prequalifications', _row.project_id, _row.organization_id);

          UPDATE public.prequalifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_procurement_workflows,"CREATE OR REPLACE FUNCTION public.delete_procurement_workflows(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.procurement_workflows;
        BEGIN
          SELECT * INTO _row FROM public.procurement_workflows WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','procurement_workflows', _row.project_id, _row.organization_id);

          UPDATE public.procurement_workflows
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_profiles,"CREATE OR REPLACE FUNCTION public.delete_profiles(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.profiles;
        BEGIN
          SELECT * INTO _row FROM public.profiles WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','profiles', _row.project_id, _row.organization_id);

          UPDATE public.profiles
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_progress_billings,"CREATE OR REPLACE FUNCTION public.delete_progress_billings(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.progress_billings;
        BEGIN
          SELECT * INTO _row FROM public.progress_billings WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','progress_billings', _row.project_id, _row.organization_id);

          UPDATE public.progress_billings
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_project_inspectors,"CREATE OR REPLACE FUNCTION public.delete_project_inspectors(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.project_inspectors;
        BEGIN
          SELECT * INTO _row FROM public.project_inspectors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','project_inspectors', _row.project_id, _row.organization_id);

          UPDATE public.project_inspectors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_projects,"CREATE OR REPLACE FUNCTION public.delete_projects(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.projects;
        BEGIN
          SELECT * INTO _row FROM public.projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','projects', _row.project_id, _row.organization_id);

          UPDATE public.projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_punch_lists,"CREATE OR REPLACE FUNCTION public.delete_punch_lists(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.punch_lists;
        BEGIN
          SELECT * INTO _row FROM public.punch_lists WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','punch_lists', _row.project_id, _row.organization_id);

          UPDATE public.punch_lists
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_purchase_orders,"CREATE OR REPLACE FUNCTION public.delete_purchase_orders(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.purchase_orders;
        BEGIN
          SELECT * INTO _row FROM public.purchase_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','purchase_orders', _row.project_id, _row.organization_id);

          UPDATE public.purchase_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_quality_reviews,"CREATE OR REPLACE FUNCTION public.delete_quality_reviews(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.quality_reviews;
        BEGIN
          SELECT * INTO _row FROM public.quality_reviews WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','quality_reviews', _row.project_id, _row.organization_id);

          UPDATE public.quality_reviews
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_regulatory_documents,"CREATE OR REPLACE FUNCTION public.delete_regulatory_documents(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.regulatory_documents;
        BEGIN
          SELECT * INTO _row FROM public.regulatory_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','regulatory_documents', _row.project_id, _row.organization_id);

          UPDATE public.regulatory_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_reports,"CREATE OR REPLACE FUNCTION public.delete_reports(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.reports;
        BEGIN
          SELECT * INTO _row FROM public.reports WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','reports', _row.project_id, _row.organization_id);

          UPDATE public.reports
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_rfis,"CREATE OR REPLACE FUNCTION public.delete_rfis(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.rfis;
        BEGIN
          SELECT * INTO _row FROM public.rfis WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','rfis', _row.project_id, _row.organization_id);

          UPDATE public.rfis
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_safety_incidents,"CREATE OR REPLACE FUNCTION public.delete_safety_incidents(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.safety_incidents;
        BEGIN
          SELECT * INTO _row FROM public.safety_incidents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','safety_incidents', _row.project_id, _row.organization_id);

          UPDATE public.safety_incidents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_sensor_data,"CREATE OR REPLACE FUNCTION public.delete_sensor_data(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.sensor_data;
        BEGIN
          SELECT * INTO _row FROM public.sensor_data WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','sensor_data', _row.project_id, _row.organization_id);

          UPDATE public.sensor_data
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_subcontractor_agreements,"CREATE OR REPLACE FUNCTION public.delete_subcontractor_agreements(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.subcontractor_agreements;
        BEGIN
          SELECT * INTO _row FROM public.subcontractor_agreements WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','subcontractor_agreements', _row.project_id, _row.organization_id);

          UPDATE public.subcontractor_agreements
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_subcontracts,"CREATE OR REPLACE FUNCTION public.delete_subcontracts(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.subcontracts;
        BEGIN
          SELECT * INTO _row FROM public.subcontracts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','subcontracts', _row.project_id, _row.organization_id);

          UPDATE public.subcontracts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_submittals,"CREATE OR REPLACE FUNCTION public.delete_submittals(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.submittals;
        BEGIN
          SELECT * INTO _row FROM public.submittals WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','submittals', _row.project_id, _row.organization_id);

          UPDATE public.submittals
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_tack_rates,"CREATE OR REPLACE FUNCTION public.delete_tack_rates(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.tack_rates;
        BEGIN
          SELECT * INTO _row FROM public.tack_rates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','tack_rates', _row.project_id, _row.organization_id);

          UPDATE public.tack_rates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_task_dependencies,"CREATE OR REPLACE FUNCTION public.delete_task_dependencies(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.task_dependencies;
        BEGIN
          SELECT * INTO _row FROM public.task_dependencies WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','task_dependencies', _row.project_id, _row.organization_id);

          UPDATE public.task_dependencies
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_task_status_logs,"CREATE OR REPLACE FUNCTION public.delete_task_status_logs(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.task_status_logs;
        BEGIN
          SELECT * INTO _row FROM public.task_status_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','task_status_logs', _row.project_id, _row.organization_id);

          UPDATE public.task_status_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_tasks,"CREATE OR REPLACE FUNCTION public.delete_tasks(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.tasks;
        BEGIN
          SELECT * INTO _row FROM public.tasks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','tasks', _row.project_id, _row.organization_id);

          UPDATE public.tasks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_training_records,"CREATE OR REPLACE FUNCTION public.delete_training_records(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.training_records;
        BEGIN
          SELECT * INTO _row FROM public.training_records WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','training_records', _row.project_id, _row.organization_id);

          UPDATE public.training_records
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_user_projects,"CREATE OR REPLACE FUNCTION public.delete_user_projects(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.user_projects;
        BEGIN
          SELECT * INTO _row FROM public.user_projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','user_projects', _row.project_id, _row.organization_id);

          UPDATE public.user_projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_vendor_bid_packages,"CREATE OR REPLACE FUNCTION public.delete_vendor_bid_packages(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.vendor_bid_packages;
        BEGIN
          SELECT * INTO _row FROM public.vendor_bid_packages WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_bid_packages', _row.project_id, _row.organization_id);

          UPDATE public.vendor_bid_packages
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_vendor_contacts,"CREATE OR REPLACE FUNCTION public.delete_vendor_contacts(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.vendor_contacts;
        BEGIN
          SELECT * INTO _row FROM public.vendor_contacts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_contacts', _row.project_id, _row.organization_id);

          UPDATE public.vendor_contacts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_vendor_documents,"CREATE OR REPLACE FUNCTION public.delete_vendor_documents(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.vendor_documents;
        BEGIN
          SELECT * INTO _row FROM public.vendor_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_documents', _row.project_id, _row.organization_id);

          UPDATE public.vendor_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_vendor_qualifications,"CREATE OR REPLACE FUNCTION public.delete_vendor_qualifications(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.vendor_qualifications;
        BEGIN
          SELECT * INTO _row FROM public.vendor_qualifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_qualifications', _row.project_id, _row.organization_id);

          UPDATE public.vendor_qualifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_vendors,"CREATE OR REPLACE FUNCTION public.delete_vendors(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.vendors;
        BEGIN
          SELECT * INTO _row FROM public.vendors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendors', _row.project_id, _row.organization_id);

          UPDATE public.vendors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_wbs,"CREATE OR REPLACE FUNCTION public.delete_wbs(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.wbs;
        BEGIN
          SELECT * INTO _row FROM public.wbs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','wbs', _row.project_id, _row.organization_id);

          UPDATE public.wbs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,delete_workflows,"CREATE OR REPLACE FUNCTION public.delete_workflows(_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
        DECLARE
          _row public.workflows;
        BEGIN
          SELECT * INTO _row FROM public.workflows WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','workflows', _row.project_id, _row.organization_id);

          UPDATE public.workflows
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $function$
"
public,ensure_fk_indexes_for_schema,"CREATE OR REPLACE FUNCTION public.ensure_fk_indexes_for_schema(_schema text DEFAULT 'public'::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'pg_catalog', 'public'
AS $function$
DECLARE
  r RECORD;
  idx_name text;
BEGIN
  FOR r IN
    WITH fks AS (
      SELECT
        con.oid                              AS con_oid,        -- (fixed: was c.oid)
        n.nspname                            AS child_schema,
        t.relname                            AS child_table,
        con.conname                          AS fk_name,
        con.conrelid                         AS child_relid,
        con.conkey                           AS child_attnums
      FROM pg_constraint con
      JOIN pg_class     t  ON t.oid = con.conrelid
      JOIN pg_namespace n  ON n.oid = t.relnamespace
      WHERE con.contype = 'f'
        AND n.nspname = _schema
    ),
    fk_cols AS (
      -- ordered FK column names
      SELECT
        f.con_oid,
        f.child_schema,
        f.child_table,
        f.fk_name,
        f.child_relid,
        ARRAY_AGG(a.attname ORDER BY s.ord) AS child_cols
      FROM fks f
      JOIN LATERAL generate_subscripts(f.child_attnums, 1) AS s(ord) ON TRUE
      JOIN pg_attribute a
        ON a.attrelid = f.child_relid
       AND a.attnum   = f.child_attnums[s.ord]
      GROUP BY f.con_oid, f.child_schema, f.child_table, f.fk_name, f.child_relid
    ),
    idx_cols AS (
      -- for each index on the child table, get its ordered column NAMES
      SELECT
        i.indrelid                                  AS tbl_relid,
        i.indexrelid                                AS idx_relid,
        ARRAY_AGG(att.attname ORDER BY k.ord)       AS idx_colnames
      FROM pg_index i
      JOIN LATERAL unnest(i.indkey) WITH ORDINALITY AS k(attnum, ord) ON TRUE
      JOIN pg_attribute att
        ON att.attrelid = i.indexrelid
       AND att.attnum   = k.ord      -- attribute order within index
      GROUP BY i.indrelid, i.indexrelid
    ),
    needs AS (
      SELECT
        fk.child_schema,
        fk.child_table,
        fk.fk_name,
        fk.child_relid,
        fk.child_cols
      FROM fk_cols fk
      WHERE NOT EXISTS (
        SELECT 1
        FROM idx_cols ix
        WHERE ix.tbl_relid = fk.child_relid
          AND ix.idx_colnames = fk.child_cols
      )
    )
    SELECT *
    FROM needs
    ORDER BY child_schema, child_table, fk_name
  LOOP
    -- Build a deterministic (and short) index name, add suffix if collides
    idx_name := format('ix_%s__fk_%s', r.child_table, r.fk_name);
    WHILE EXISTS (
      SELECT 1
      FROM pg_class c
      JOIN pg_namespace n ON n.oid = c.relnamespace
      WHERE n.nspname = r.child_schema
        AND c.relname = idx_name
    ) LOOP
      idx_name := idx_name || '_' || floor(random()*1000)::int;
    END LOOP;

    -- CREATE INDEX ON child table over the FK columns in order
    EXECUTE format(
      'CREATE INDEX %I ON %I.%I (%s);',
      idx_name,
      r.child_schema,
      r.child_table,
      (
        SELECT string_agg(quote_ident(col), ', ')
        FROM unnest(r.child_cols) AS col
      )
    );

    RAISE NOTICE 'Created FK index % on %.% (%).',
      idx_name, r.child_schema, r.child_table, array_to_string(r.child_cols, ', ');
  END LOOP;
END
$function$
"
public,ensure_soft_delete_cols,"CREATE OR REPLACE FUNCTION public.ensure_soft_delete_cols(_tbl regclass)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  col_exists bool;
begin
  select exists (
    select 1 from pg_attribute 
     where attrelid = _tbl
       and attname  = 'deleted_at'
       and not attisdropped)
  into col_exists;

  if not col_exists then
    execute format('alter table %s add column deleted_at timestamptz', _tbl);
  end if;
end;
$function$
"
public,filter_accounts_payable,"CREATE OR REPLACE FUNCTION public.filter_accounts_payable(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF accounts_payable
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','accounts_payable', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='accounts_payable'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='accounts_payable'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='accounts_payable'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.accounts_payable WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_accounts_receivable,"CREATE OR REPLACE FUNCTION public.filter_accounts_receivable(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF accounts_receivable
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','accounts_receivable', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='accounts_receivable'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='accounts_receivable'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='accounts_receivable'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.accounts_receivable WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_activity_logs,"CREATE OR REPLACE FUNCTION public.filter_activity_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF activity_logs
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','activity_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='activity_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='activity_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='activity_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.activity_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_asphalt_types,"CREATE OR REPLACE FUNCTION public.filter_asphalt_types(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF asphalt_types
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','asphalt_types', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='asphalt_types'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='asphalt_types'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='asphalt_types'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.asphalt_types WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_audit_logs,"CREATE OR REPLACE FUNCTION public.filter_audit_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF audit_logs
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','audit_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='audit_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='audit_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='audit_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.audit_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_avatars,"CREATE OR REPLACE FUNCTION public.filter_avatars(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF avatars
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','avatars', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='avatars'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='avatars'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='avatars'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.avatars WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_bid_packages,"CREATE OR REPLACE FUNCTION public.filter_bid_packages(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF bid_packages
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bid_packages', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bid_packages'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bid_packages'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bid_packages'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bid_packages WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_bid_vendors,"CREATE OR REPLACE FUNCTION public.filter_bid_vendors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF bid_vendors
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bid_vendors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bid_vendors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bid_vendors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bid_vendors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bid_vendors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_bids,"CREATE OR REPLACE FUNCTION public.filter_bids(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF bids
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bids', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bids'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bids'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bids'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bids WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_bim_models,"CREATE OR REPLACE FUNCTION public.filter_bim_models(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF bim_models
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bim_models', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bim_models'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bim_models'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bim_models'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bim_models WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_certifications,"CREATE OR REPLACE FUNCTION public.filter_certifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF certifications
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','certifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='certifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='certifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='certifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.certifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_change_orders,"CREATE OR REPLACE FUNCTION public.filter_change_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF change_orders
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','change_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='change_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='change_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='change_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.change_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_commitments,"CREATE OR REPLACE FUNCTION public.filter_commitments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF commitments
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','commitments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='commitments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='commitments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='commitments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.commitments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_compliance_checks,"CREATE OR REPLACE FUNCTION public.filter_compliance_checks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF compliance_checks
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','compliance_checks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='compliance_checks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='compliance_checks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='compliance_checks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.compliance_checks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_compliance_tracking,"CREATE OR REPLACE FUNCTION public.filter_compliance_tracking(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF compliance_tracking
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','compliance_tracking', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='compliance_tracking'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='compliance_tracking'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='compliance_tracking'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.compliance_tracking WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_cost_codes,"CREATE OR REPLACE FUNCTION public.filter_cost_codes(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF cost_codes
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','cost_codes', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='cost_codes'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='cost_codes'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='cost_codes'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.cost_codes WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_crew_assignments,"CREATE OR REPLACE FUNCTION public.filter_crew_assignments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF crew_assignments
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crew_assignments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crew_assignments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crew_assignments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crew_assignments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crew_assignments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_crew_members,"CREATE OR REPLACE FUNCTION public.filter_crew_members(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF crew_members
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crew_members', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crew_members'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crew_members'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crew_members'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crew_members WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_crews,"CREATE OR REPLACE FUNCTION public.filter_crews(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF crews
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crews', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crews'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crews'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crews'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crews WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_daily_logs,"CREATE OR REPLACE FUNCTION public.filter_daily_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF daily_logs
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','daily_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='daily_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='daily_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='daily_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.daily_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_dashboard_configs,"CREATE OR REPLACE FUNCTION public.filter_dashboard_configs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF dashboard_configs
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','dashboard_configs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='dashboard_configs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='dashboard_configs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='dashboard_configs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.dashboard_configs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_document_references,"CREATE OR REPLACE FUNCTION public.filter_document_references(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF document_references
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','document_references', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='document_references'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='document_references'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='document_references'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.document_references WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_documents,"CREATE OR REPLACE FUNCTION public.filter_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF documents
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_drawing_versions,"CREATE OR REPLACE FUNCTION public.filter_drawing_versions(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF drawing_versions
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','drawing_versions', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='drawing_versions'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='drawing_versions'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='drawing_versions'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.drawing_versions WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_dump_trucks,"CREATE OR REPLACE FUNCTION public.filter_dump_trucks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF dump_trucks
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','dump_trucks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='dump_trucks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='dump_trucks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='dump_trucks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.dump_trucks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_employees,"CREATE OR REPLACE FUNCTION public.filter_employees(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF employees
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','employees', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='employees'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='employees'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='employees'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.employees WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_equipment,"CREATE OR REPLACE FUNCTION public.filter_equipment(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF equipment
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_equipment_assignments,"CREATE OR REPLACE FUNCTION public.filter_equipment_assignments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF equipment_assignments
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_assignments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_assignments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_assignments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_assignments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_assignments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_equipment_maintenance,"CREATE OR REPLACE FUNCTION public.filter_equipment_maintenance(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF equipment_maintenance
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_maintenance', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_maintenance'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_maintenance'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_maintenance'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_maintenance WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_equipment_usage,"CREATE OR REPLACE FUNCTION public.filter_equipment_usage(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF equipment_usage
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_usage', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_usage'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_usage'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_usage'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_usage WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_estimate_line_items,"CREATE OR REPLACE FUNCTION public.filter_estimate_line_items(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF estimate_line_items
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','estimate_line_items', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='estimate_line_items'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='estimate_line_items'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='estimate_line_items'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.estimate_line_items WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_estimates,"CREATE OR REPLACE FUNCTION public.filter_estimates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF estimates
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','estimates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='estimates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='estimates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='estimates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.estimates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_financial_documents,"CREATE OR REPLACE FUNCTION public.filter_financial_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF financial_documents
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','financial_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='financial_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='financial_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='financial_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.financial_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_general_ledger,"CREATE OR REPLACE FUNCTION public.filter_general_ledger(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF general_ledger
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','general_ledger', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='general_ledger'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='general_ledger'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='general_ledger'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.general_ledger WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_hr_documents,"CREATE OR REPLACE FUNCTION public.filter_hr_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF hr_documents
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','hr_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='hr_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='hr_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='hr_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.hr_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_inspections,"CREATE OR REPLACE FUNCTION public.filter_inspections(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF inspections
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','inspections', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='inspections'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='inspections'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='inspections'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.inspections WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_integration_tokens,"CREATE OR REPLACE FUNCTION public.filter_integration_tokens(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF integration_tokens
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','integration_tokens', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='integration_tokens'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='integration_tokens'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='integration_tokens'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.integration_tokens WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_inventory_transactions,"CREATE OR REPLACE FUNCTION public.filter_inventory_transactions(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF inventory_transactions
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','inventory_transactions', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='inventory_transactions'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='inventory_transactions'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='inventory_transactions'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.inventory_transactions WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_issues,"CREATE OR REPLACE FUNCTION public.filter_issues(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF issues
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','issues', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='issues'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='issues'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='issues'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.issues WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_job_titles,"CREATE OR REPLACE FUNCTION public.filter_job_titles(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF job_titles
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','job_titles', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='job_titles'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='job_titles'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='job_titles'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.job_titles WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_labor_records,"CREATE OR REPLACE FUNCTION public.filter_labor_records(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF labor_records
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','labor_records', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='labor_records'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='labor_records'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='labor_records'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.labor_records WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_line_item_entries,"CREATE OR REPLACE FUNCTION public.filter_line_item_entries(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF line_item_entries
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_item_entries', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_item_entries'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_item_entries'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_item_entries'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_item_entries WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_line_item_templates,"CREATE OR REPLACE FUNCTION public.filter_line_item_templates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF line_item_templates
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_item_templates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_item_templates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_item_templates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_item_templates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_item_templates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_line_items,"CREATE OR REPLACE FUNCTION public.filter_line_items(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF line_items
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_items', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_items'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_items'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_items'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_items WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_maps,"CREATE OR REPLACE FUNCTION public.filter_maps(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF maps
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','maps', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='maps'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='maps'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='maps'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.maps WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_material_inventory,"CREATE OR REPLACE FUNCTION public.filter_material_inventory(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF material_inventory
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_inventory', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_inventory'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_inventory'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_inventory'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_inventory WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_material_orders,"CREATE OR REPLACE FUNCTION public.filter_material_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF material_orders
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_material_receipts,"CREATE OR REPLACE FUNCTION public.filter_material_receipts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF material_receipts
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_receipts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_receipts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_receipts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_receipts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_receipts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_materials,"CREATE OR REPLACE FUNCTION public.filter_materials(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF materials
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','materials', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='materials'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='materials'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='materials'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.materials WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_meeting_minutes,"CREATE OR REPLACE FUNCTION public.filter_meeting_minutes(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF meeting_minutes
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','meeting_minutes', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='meeting_minutes'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='meeting_minutes'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='meeting_minutes'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.meeting_minutes WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_notifications,"CREATE OR REPLACE FUNCTION public.filter_notifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF notifications
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','notifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='notifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='notifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='notifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.notifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_organization_members,"CREATE OR REPLACE FUNCTION public.filter_organization_members(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF organization_members
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','organization_members', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organization_members'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='organization_members'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='organization_members'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.organization_members WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_organization_projects,"CREATE OR REPLACE FUNCTION public.filter_organization_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF organization_projects
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','organization_projects', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organization_projects'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='organization_projects'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='organization_projects'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.organization_projects WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_organizations,"CREATE OR REPLACE FUNCTION public.filter_organizations(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF organizations
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','organizations', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organizations'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='organizations'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='organizations'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.organizations WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_payments,"CREATE OR REPLACE FUNCTION public.filter_payments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF payments
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','payments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='payments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='payments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='payments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.payments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_payroll,"CREATE OR REPLACE FUNCTION public.filter_payroll(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF payroll
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','payroll', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='payroll'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='payroll'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='payroll'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.payroll WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_photos,"CREATE OR REPLACE FUNCTION public.filter_photos(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF photos
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','photos', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='photos'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='photos'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='photos'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.photos WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_prequalifications,"CREATE OR REPLACE FUNCTION public.filter_prequalifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF prequalifications
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','prequalifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='prequalifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='prequalifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='prequalifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.prequalifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_procurement_workflows,"CREATE OR REPLACE FUNCTION public.filter_procurement_workflows(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF procurement_workflows
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','procurement_workflows', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='procurement_workflows'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='procurement_workflows'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='procurement_workflows'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.procurement_workflows WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_profiles,"CREATE OR REPLACE FUNCTION public.filter_profiles(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF profiles
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','profiles', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='profiles'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='profiles'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='profiles'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.profiles WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_progress_billings,"CREATE OR REPLACE FUNCTION public.filter_progress_billings(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF progress_billings
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','progress_billings', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='progress_billings'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='progress_billings'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='progress_billings'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.progress_billings WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_project_inspectors,"CREATE OR REPLACE FUNCTION public.filter_project_inspectors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF project_inspectors
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','project_inspectors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='project_inspectors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='project_inspectors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='project_inspectors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.project_inspectors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_projects,"CREATE OR REPLACE FUNCTION public.filter_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF projects
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
DECLARE
  _project_id      uuid;
  _organization_id uuid;
  _where           text := 'deleted_at IS NULL';
  kv               record;
  sqltxt           text;
  dir              text := lower(coalesce(_direction, 'asc'));
  order_col        text := coalesce(nullif(_order_by, ''), 'id');
  v_text           text;
BEGIN
  -- normalize filters
  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
    _filters := '{}'::jsonb;
  END IF;

  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;
  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;

  IF NOT public.check_access_bool('select','projects', _project_id, _organization_id) THEN
    RETURN;
  END IF;

  -- safe order_by (fallback instead of raising)
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema='public'
      AND table_name='projects'
      AND column_name=order_col
  ) THEN
    order_col := 'id';
  END IF;

  IF dir NOT IN ('asc','desc') THEN
    dir := 'asc';
  END IF;

  -- build WHERE
  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
    IF kv.key NOT IN ('project_id','organization_id') THEN

      -- ignore unknown columns instead of erroring
      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='projects'
          AND column_name=kv.key
      ) THEN
        CONTINUE;
      END IF;

      IF kv.value = 'null'::jsonb THEN
        _where := _where || ' AND ' || quote_ident(kv.key) || ' IS NULL';

      ELSIF jsonb_typeof(kv.value) = 'object' THEN
        IF (kv.value ? '$gte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' >= ' || quote_literal(kv.value->>'$gte');
        END IF;

        IF (kv.value ? '$lte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' <= ' || quote_literal(kv.value->>'$lte');
        END IF;

        IF (kv.value ? '$ilike') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        END IF;

        IF (kv.value ? '$in') THEN
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'ARRAY(SELECT jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';
        END IF;

      ELSE
        v_text := kv.value #>> '{}';
        _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(v_text);
      END IF;
    END IF;
  END LOOP;

  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where
         || ' ORDER BY ' || quote_ident(order_col) || ' ' || dir;

  IF _limit IS NOT NULL THEN
    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);
  END IF;

  IF _offset IS NOT NULL THEN
    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);
  END IF;

  RETURN QUERY EXECUTE sqltxt;
END;
$function$
"
public,filter_punch_lists,"CREATE OR REPLACE FUNCTION public.filter_punch_lists(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF punch_lists
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','punch_lists', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='punch_lists'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='punch_lists'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='punch_lists'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.punch_lists WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_purchase_orders,"CREATE OR REPLACE FUNCTION public.filter_purchase_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF purchase_orders
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','purchase_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='purchase_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='purchase_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='purchase_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.purchase_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_quality_reviews,"CREATE OR REPLACE FUNCTION public.filter_quality_reviews(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF quality_reviews
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','quality_reviews', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='quality_reviews'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='quality_reviews'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='quality_reviews'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.quality_reviews WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_regulatory_documents,"CREATE OR REPLACE FUNCTION public.filter_regulatory_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF regulatory_documents
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','regulatory_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='regulatory_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='regulatory_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='regulatory_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.regulatory_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_reports,"CREATE OR REPLACE FUNCTION public.filter_reports(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF reports
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','reports', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='reports'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='reports'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='reports'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.reports WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_rfis,"CREATE OR REPLACE FUNCTION public.filter_rfis(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF rfis
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','rfis', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='rfis'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='rfis'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='rfis'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.rfis WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_safety_incidents,"CREATE OR REPLACE FUNCTION public.filter_safety_incidents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF safety_incidents
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','safety_incidents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='safety_incidents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='safety_incidents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='safety_incidents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.safety_incidents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_sensor_data,"CREATE OR REPLACE FUNCTION public.filter_sensor_data(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF sensor_data
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','sensor_data', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='sensor_data'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='sensor_data'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='sensor_data'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.sensor_data WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_subcontractor_agreements,"CREATE OR REPLACE FUNCTION public.filter_subcontractor_agreements(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF subcontractor_agreements
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','subcontractor_agreements', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='subcontractor_agreements'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='subcontractor_agreements'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='subcontractor_agreements'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.subcontractor_agreements WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_subcontracts,"CREATE OR REPLACE FUNCTION public.filter_subcontracts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF subcontracts
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','subcontracts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='subcontracts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='subcontracts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='subcontracts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.subcontracts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_submittals,"CREATE OR REPLACE FUNCTION public.filter_submittals(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF submittals
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','submittals', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='submittals'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='submittals'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='submittals'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.submittals WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_tack_rates,"CREATE OR REPLACE FUNCTION public.filter_tack_rates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF tack_rates
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','tack_rates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='tack_rates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='tack_rates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='tack_rates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.tack_rates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_task_dependencies,"CREATE OR REPLACE FUNCTION public.filter_task_dependencies(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF task_dependencies
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','task_dependencies', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='task_dependencies'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='task_dependencies'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='task_dependencies'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.task_dependencies WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_task_status_logs,"CREATE OR REPLACE FUNCTION public.filter_task_status_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF task_status_logs
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','task_status_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='task_status_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='task_status_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='task_status_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.task_status_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_tasks,"CREATE OR REPLACE FUNCTION public.filter_tasks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF tasks
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','tasks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='tasks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='tasks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='tasks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.tasks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_training_records,"CREATE OR REPLACE FUNCTION public.filter_training_records(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF training_records
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','training_records', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='training_records'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='training_records'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='training_records'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.training_records WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_user_projects,"CREATE OR REPLACE FUNCTION public.filter_user_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF user_projects
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','user_projects', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='user_projects'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='user_projects'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='user_projects'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.user_projects WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_vendor_bid_packages,"CREATE OR REPLACE FUNCTION public.filter_vendor_bid_packages(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF vendor_bid_packages
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_bid_packages', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_bid_packages'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_bid_packages'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_bid_packages'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_bid_packages WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_vendor_contacts,"CREATE OR REPLACE FUNCTION public.filter_vendor_contacts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF vendor_contacts
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_contacts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_contacts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_contacts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_contacts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_contacts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_vendor_documents,"CREATE OR REPLACE FUNCTION public.filter_vendor_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF vendor_documents
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_vendor_qualifications,"CREATE OR REPLACE FUNCTION public.filter_vendor_qualifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF vendor_qualifications
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_qualifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_qualifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_qualifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_qualifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_qualifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_vendors,"CREATE OR REPLACE FUNCTION public.filter_vendors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF vendors
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_wbs,"CREATE OR REPLACE FUNCTION public.filter_wbs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF wbs
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','wbs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='wbs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='wbs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='wbs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.wbs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,filter_workflows,"CREATE OR REPLACE FUNCTION public.filter_workflows(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer)
 RETURNS SETOF workflows
 LANGUAGE plpgsql
 STABLE
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','workflows', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic ""IN"": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='workflows'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='workflows'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='workflows'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.workflows WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $function$
"
public,fn_cashflow_curve,"CREATE OR REPLACE FUNCTION public.fn_cashflow_curve(p_project_id uuid)
 RETURNS TABLE(cur_date date, billed numeric, cost numeric)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  WITH bills AS (
    SELECT created_at::date AS d, SUM(amount) AS amt
    FROM public.progress_billings
    WHERE project_id = p_project_id
    GROUP BY 1
  ), costs AS (
    SELECT entry_date::date AS d, SUM(debit) AS amt
    FROM public.general_ledger
    WHERE project_id = p_project_id
    GROUP BY 1
  ), dates AS (
    SELECT d::date FROM bills
    UNION
    SELECT d::date FROM costs
  )
  SELECT
    dates.d AS cur_date,
    SUM(b.amt) OVER (ORDER BY dates.d
                     ROWS UNBOUNDED PRECEDING) AS billed,
    SUM(c.amt) OVER (ORDER BY dates.d
                     ROWS UNBOUNDED PRECEDING) AS cost
  FROM dates
  LEFT JOIN bills b ON b.d = dates.d
  LEFT JOIN costs c ON c.d = dates.d
  ORDER BY cur_date;
$function$
"
public,fn_eqp_7d_avg_hours,"CREATE OR REPLACE FUNCTION public.fn_eqp_7d_avg_hours(p_equipment_id uuid)
 RETURNS TABLE(day date, avg_hours numeric)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT
    eu.date,
    ROUND(
      AVG(eu.hours_used)
      OVER (
        ORDER BY eu.date
        RANGE BETWEEN INTERVAL '6 days' PRECEDING 
              AND CURRENT ROW
      ), 2
    ) AS avg_hours
  FROM public.equipment_usage eu
  WHERE eu.equipment_id = p_equipment_id
  ORDER BY eu.date;
$function$
"
public,fn_find_rpc_dupes,"CREATE OR REPLACE FUNCTION public.fn_find_rpc_dupes()
 RETURNS TABLE(fname text, args text, cnt integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT
    p.proname             AS fname,
    pg_catalog.pg_get_function_arguments(p.oid) AS args,
    COUNT(*) OVER (PARTITION BY p.proname)     AS cnt
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
  ORDER BY cnt DESC, fname;
$function$
"
public,fn_inventory_balance,"CREATE OR REPLACE FUNCTION public.fn_inventory_balance(_material_id uuid)
 RETURNS TABLE(day date, balance numeric)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  WITH tx AS (
    SELECT
      (transaction_date::date) AS day,
      CASE
        WHEN transaction_type IN ('receive', 'in', 'purchase') THEN quantity
        WHEN transaction_type IN ('issue', 'out', 'usage')     THEN -quantity
        ELSE 0
      END AS qty
    FROM public.inventory_transactions
    WHERE material_id = _material_id
  )
  SELECT
    day,
    SUM(qty) OVER (
      ORDER BY day
      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS balance
  FROM tx
  ORDER BY day;
$function$
"
public,fn_list_tables_and_columns,"CREATE OR REPLACE FUNCTION public.fn_list_tables_and_columns()
 RETURNS TABLE(table_name text, column_name text)
 LANGUAGE sql
 IMMUTABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT table_name, column_name
  FROM information_schema.columns
  WHERE table_schema = 'public'
  ORDER BY table_name, ordinal_position;
$function$
"
public,fn_materials_on_hand,"CREATE OR REPLACE FUNCTION public.fn_materials_on_hand(p_material_id uuid)
 RETURNS TABLE(trans_date date, on_hand bigint)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT
    it.transaction_date::date                           AS trans_date,
    SUM((it.transaction_type = 'receipt')::int
      - (it.transaction_type = 'issue')::int)
      OVER (ORDER BY it.transaction_date::date
            ROWS UNBOUNDED PRECEDING)                   AS on_hand
  FROM public.inventory_transactions it
  WHERE it.material_id = p_material_id
  ORDER BY trans_date;
$function$
"
public,fn_task_cycle_time,"CREATE OR REPLACE FUNCTION public.fn_task_cycle_time(p_task_id uuid)
 RETURNS TABLE(status text, days_in_phase integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  WITH logs AS (
    SELECT
      status,
      changed_at,
      LEAD(changed_at) OVER (ORDER BY changed_at) AS next_change
    FROM public.task_status_logs
    WHERE task_id = p_task_id
  )
  SELECT
    status,
    EXTRACT(epoch FROM (next_change - changed_at))/86400::int AS days_in_phase
  FROM logs
  WHERE next_change IS NOT NULL;
$function$
"
public,fn_top5_cost_codes,"CREATE OR REPLACE FUNCTION public.fn_top5_cost_codes(p_project_id uuid)
 RETURNS TABLE(cost_code_id uuid, total_spend numeric, rank integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT
    eli.cost_code_id,
    SUM(eli.total_cost)             AS total_spend,
    RANK() OVER (ORDER BY SUM(eli.total_cost) DESC) AS rank
  FROM public.estimate_line_items eli
  JOIN public.estimates e ON e.id = eli.estimate_id
  WHERE e.project_id = p_project_id
  GROUP BY eli.cost_code_id
  ORDER BY total_spend DESC
  LIMIT 5;
$function$
"
public,fn_weekly_receipt_perf,"CREATE OR REPLACE FUNCTION public.fn_weekly_receipt_perf(p_project_id uuid)
 RETURNS TABLE(week_start date, on_time_count integer, late_count integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  WITH rec AS (
    SELECT
      mr.material_order_id,
      mr.received_date,
      mo.project_id,
      mo.order_date,
      date_trunc('week', mr.received_date)::date AS wk
    FROM public.material_receipts mr
    JOIN public.material_orders  mo ON mo.id = mr.material_order_id
    WHERE mo.project_id = p_project_id
  )
  SELECT
    wk                  AS week_start,
    SUM((received_date <= order_date)::int) AS on_time_count,
    SUM((received_date >  order_date)::int) AS late_count
  FROM rec
  GROUP BY wk
  ORDER BY wk;
$function$
"
public,fn_worst10_crews_by_incidents,"CREATE OR REPLACE FUNCTION public.fn_worst10_crews_by_incidents()
 RETURNS TABLE(crew_id uuid, incident_count integer, rank integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT
    ca.crew_id,
    COUNT(si.*)                      AS incident_count,
    RANK() OVER (ORDER BY COUNT(si.*) DESC) AS rank
  FROM public.safety_incidents si
  JOIN public.crew_assignments ca
    ON ca.profile_id = si.reported_by
  GROUP BY ca.crew_id
  ORDER BY incident_count DESC
  LIMIT 10;
$function$
"
public,get_avatar_by_id_public,"CREATE OR REPLACE FUNCTION public.get_avatar_by_id_public(p_avatar_id uuid)
 RETURNS avatars
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_row public.avatars;
begin
  select *
  into v_row
  from public.avatars
  where id = p_avatar_id
    and deleted_at is null;

  return v_row;
end;
$function$
"
public,get_job_titles_public,"CREATE OR REPLACE FUNCTION public.get_job_titles_public()
 RETURNS SETOF job_titles
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  return query
  select *
  from public.job_titles
  where deleted_at is null
  order by name asc;
end;
$function$
"
public,get_my_org_profiles_minimal,"CREATE OR REPLACE FUNCTION public.get_my_org_profiles_minimal()
 RETURNS TABLE(id uuid, full_name text, email text, avatar_id uuid)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_org_id uuid;
begin
  v_org_id := (
    select organization_id
    from public.profiles
    where id = auth.uid()
  );

  return query
  select p.id, p.full_name, p.email, p.avatar_id
  from public.profiles p
  where p.organization_id = v_org_id
    and p.deleted_at is null;
end;
$function$
"
public,get_my_profile,"CREATE OR REPLACE FUNCTION public.get_my_profile()
 RETURNS profiles
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user_id uuid;
  v_profile public.profiles;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    return null;
  end if;

  select *
  into v_profile
  from public.profiles
  where id = v_user_id;

  return v_profile;
end;
$function$
"
public,get_organizations_public,"CREATE OR REPLACE FUNCTION public.get_organizations_public(p_query text)
 RETURNS TABLE(id uuid, name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  return query
  select o.id, o.name
  from public.organizations o
  where o.deleted_at is null
    and o.name ilike '%' || coalesce(p_query, '') || '%'
  order by o.name asc
  limit 10;
end;
$function$
"
public,get_preset_avatars_public,"CREATE OR REPLACE FUNCTION public.get_preset_avatars_public()
 RETURNS SETOF avatars
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  return query
  select *
  from public.avatars
  where deleted_at is null
    and coalesce(is_preset, false) = true
  order by created_at asc;
end;
$function$
"
public,handle_auth_user_profile_sync,"CREATE OR REPLACE FUNCTION public.handle_auth_user_profile_sync()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
 SET row_security TO 'off'
AS $function$
begin
  -- Ensure a profile row exists, and keep email in sync.
  -- Do NOT touch role/org/full_name/phone here.
  insert into public.profiles as p
    (id, email, created_at, updated_at)
  values
    (new.id, new.email, now(), now())
  on conflict (id) do update
    set email = excluded.email,
        updated_at = now();

  return new;
end;
$function$
"
public,insert_accounts_payable,"CREATE OR REPLACE FUNCTION public.insert_accounts_payable(_input jsonb)
 RETURNS SETOF accounts_payable
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.accounts_payable;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','accounts_payable', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.accounts_payable
        SELECT (jsonb_populate_record(NULL::public.accounts_payable, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_accounts_receivable,"CREATE OR REPLACE FUNCTION public.insert_accounts_receivable(_input jsonb)
 RETURNS SETOF accounts_receivable
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.accounts_receivable;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','accounts_receivable', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.accounts_receivable
        SELECT (jsonb_populate_record(NULL::public.accounts_receivable, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_activity_logs,"CREATE OR REPLACE FUNCTION public.insert_activity_logs(_input jsonb)
 RETURNS SETOF activity_logs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.activity_logs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','activity_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.activity_logs
        SELECT (jsonb_populate_record(NULL::public.activity_logs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_asphalt_types,"CREATE OR REPLACE FUNCTION public.insert_asphalt_types(_input jsonb)
 RETURNS SETOF asphalt_types
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.asphalt_types;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','asphalt_types', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.asphalt_types
        SELECT (jsonb_populate_record(NULL::public.asphalt_types, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_audit_logs,"CREATE OR REPLACE FUNCTION public.insert_audit_logs(_input jsonb)
 RETURNS SETOF audit_logs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.audit_logs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','audit_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.audit_logs
        SELECT (jsonb_populate_record(NULL::public.audit_logs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_avatars,"CREATE OR REPLACE FUNCTION public.insert_avatars(_input jsonb)
 RETURNS SETOF avatars
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.avatars;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','avatars', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.avatars
        SELECT (jsonb_populate_record(NULL::public.avatars, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_bid_packages,"CREATE OR REPLACE FUNCTION public.insert_bid_packages(_input jsonb)
 RETURNS SETOF bid_packages
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bid_packages;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bid_packages', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.bid_packages
        SELECT (jsonb_populate_record(NULL::public.bid_packages, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_bid_vendors,"CREATE OR REPLACE FUNCTION public.insert_bid_vendors(_input jsonb)
 RETURNS SETOF bid_vendors
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bid_vendors;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bid_vendors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.bid_vendors
        SELECT (jsonb_populate_record(NULL::public.bid_vendors, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_bids,"CREATE OR REPLACE FUNCTION public.insert_bids(_input jsonb)
 RETURNS SETOF bids
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bids;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bids', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.bids
        SELECT (jsonb_populate_record(NULL::public.bids, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_bim_models,"CREATE OR REPLACE FUNCTION public.insert_bim_models(_input jsonb)
 RETURNS SETOF bim_models
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bim_models;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bim_models', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.bim_models
        SELECT (jsonb_populate_record(NULL::public.bim_models, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_certifications,"CREATE OR REPLACE FUNCTION public.insert_certifications(_input jsonb)
 RETURNS SETOF certifications
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.certifications;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','certifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.certifications
        SELECT (jsonb_populate_record(NULL::public.certifications, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_change_orders,"CREATE OR REPLACE FUNCTION public.insert_change_orders(_input jsonb)
 RETURNS SETOF change_orders
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.change_orders;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','change_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.change_orders
        SELECT (jsonb_populate_record(NULL::public.change_orders, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_commitments,"CREATE OR REPLACE FUNCTION public.insert_commitments(_input jsonb)
 RETURNS SETOF commitments
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.commitments;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','commitments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.commitments
        SELECT (jsonb_populate_record(NULL::public.commitments, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_compliance_checks,"CREATE OR REPLACE FUNCTION public.insert_compliance_checks(_input jsonb)
 RETURNS SETOF compliance_checks
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.compliance_checks;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','compliance_checks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.compliance_checks
        SELECT (jsonb_populate_record(NULL::public.compliance_checks, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_compliance_tracking,"CREATE OR REPLACE FUNCTION public.insert_compliance_tracking(_input jsonb)
 RETURNS SETOF compliance_tracking
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.compliance_tracking;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','compliance_tracking', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.compliance_tracking
        SELECT (jsonb_populate_record(NULL::public.compliance_tracking, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_cost_codes,"CREATE OR REPLACE FUNCTION public.insert_cost_codes(_input jsonb)
 RETURNS SETOF cost_codes
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.cost_codes;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','cost_codes', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.cost_codes
        SELECT (jsonb_populate_record(NULL::public.cost_codes, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_crew_assignments,"CREATE OR REPLACE FUNCTION public.insert_crew_assignments(_input jsonb)
 RETURNS SETOF crew_assignments
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crew_assignments;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crew_assignments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.crew_assignments
        SELECT (jsonb_populate_record(NULL::public.crew_assignments, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_crew_members,"CREATE OR REPLACE FUNCTION public.insert_crew_members(_input jsonb)
 RETURNS SETOF crew_members
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crew_members;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crew_members', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.crew_members
        SELECT (jsonb_populate_record(NULL::public.crew_members, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_crews,"CREATE OR REPLACE FUNCTION public.insert_crews(_input jsonb)
 RETURNS SETOF crews
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crews;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crews', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.crews
        SELECT (jsonb_populate_record(NULL::public.crews, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_daily_logs,"CREATE OR REPLACE FUNCTION public.insert_daily_logs(_input jsonb)
 RETURNS SETOF daily_logs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.daily_logs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','daily_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.daily_logs
        SELECT (jsonb_populate_record(NULL::public.daily_logs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_dashboard_configs,"CREATE OR REPLACE FUNCTION public.insert_dashboard_configs(_input jsonb)
 RETURNS SETOF dashboard_configs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.dashboard_configs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','dashboard_configs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.dashboard_configs
        SELECT (jsonb_populate_record(NULL::public.dashboard_configs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_document_references,"CREATE OR REPLACE FUNCTION public.insert_document_references(_input jsonb)
 RETURNS SETOF document_references
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.document_references;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','document_references', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.document_references
        SELECT (jsonb_populate_record(NULL::public.document_references, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_documents,"CREATE OR REPLACE FUNCTION public.insert_documents(_input jsonb)
 RETURNS SETOF documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.documents
        SELECT (jsonb_populate_record(NULL::public.documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_drawing_versions,"CREATE OR REPLACE FUNCTION public.insert_drawing_versions(_input jsonb)
 RETURNS SETOF drawing_versions
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.drawing_versions;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','drawing_versions', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.drawing_versions
        SELECT (jsonb_populate_record(NULL::public.drawing_versions, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_dump_trucks,"CREATE OR REPLACE FUNCTION public.insert_dump_trucks(_input jsonb)
 RETURNS SETOF dump_trucks
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.dump_trucks;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','dump_trucks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.dump_trucks
        SELECT (jsonb_populate_record(NULL::public.dump_trucks, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_employees,"CREATE OR REPLACE FUNCTION public.insert_employees(_input jsonb)
 RETURNS SETOF employees
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.employees;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','employees', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.employees
        SELECT (jsonb_populate_record(NULL::public.employees, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_equipment,"CREATE OR REPLACE FUNCTION public.insert_equipment(_input jsonb)
 RETURNS SETOF equipment
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.equipment
        SELECT (jsonb_populate_record(NULL::public.equipment, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_equipment_assignments,"CREATE OR REPLACE FUNCTION public.insert_equipment_assignments(_input jsonb)
 RETURNS SETOF equipment_assignments
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_assignments;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_assignments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.equipment_assignments
        SELECT (jsonb_populate_record(NULL::public.equipment_assignments, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_equipment_maintenance,"CREATE OR REPLACE FUNCTION public.insert_equipment_maintenance(_input jsonb)
 RETURNS SETOF equipment_maintenance
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_maintenance;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_maintenance', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.equipment_maintenance
        SELECT (jsonb_populate_record(NULL::public.equipment_maintenance, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_equipment_usage,"CREATE OR REPLACE FUNCTION public.insert_equipment_usage(_input jsonb)
 RETURNS SETOF equipment_usage
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_usage;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_usage', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.equipment_usage
        SELECT (jsonb_populate_record(NULL::public.equipment_usage, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_estimate_line_items,"CREATE OR REPLACE FUNCTION public.insert_estimate_line_items(_input jsonb)
 RETURNS SETOF estimate_line_items
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.estimate_line_items;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','estimate_line_items', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.estimate_line_items
        SELECT (jsonb_populate_record(NULL::public.estimate_line_items, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_estimates,"CREATE OR REPLACE FUNCTION public.insert_estimates(_input jsonb)
 RETURNS SETOF estimates
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.estimates;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','estimates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.estimates
        SELECT (jsonb_populate_record(NULL::public.estimates, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_financial_documents,"CREATE OR REPLACE FUNCTION public.insert_financial_documents(_input jsonb)
 RETURNS SETOF financial_documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.financial_documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','financial_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.financial_documents
        SELECT (jsonb_populate_record(NULL::public.financial_documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_general_ledger,"CREATE OR REPLACE FUNCTION public.insert_general_ledger(_input jsonb)
 RETURNS SETOF general_ledger
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.general_ledger;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','general_ledger', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.general_ledger
        SELECT (jsonb_populate_record(NULL::public.general_ledger, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_hr_documents,"CREATE OR REPLACE FUNCTION public.insert_hr_documents(_input jsonb)
 RETURNS SETOF hr_documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.hr_documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','hr_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.hr_documents
        SELECT (jsonb_populate_record(NULL::public.hr_documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_inspections,"CREATE OR REPLACE FUNCTION public.insert_inspections(_input jsonb)
 RETURNS SETOF inspections
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.inspections;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','inspections', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.inspections
        SELECT (jsonb_populate_record(NULL::public.inspections, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_integration_tokens,"CREATE OR REPLACE FUNCTION public.insert_integration_tokens(_input jsonb)
 RETURNS SETOF integration_tokens
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.integration_tokens;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','integration_tokens', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.integration_tokens
        SELECT (jsonb_populate_record(NULL::public.integration_tokens, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_inventory_transactions,"CREATE OR REPLACE FUNCTION public.insert_inventory_transactions(_input jsonb)
 RETURNS SETOF inventory_transactions
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.inventory_transactions;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','inventory_transactions', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.inventory_transactions
        SELECT (jsonb_populate_record(NULL::public.inventory_transactions, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_issues,"CREATE OR REPLACE FUNCTION public.insert_issues(_input jsonb)
 RETURNS SETOF issues
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.issues;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','issues', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.issues
        SELECT (jsonb_populate_record(NULL::public.issues, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_job_title_public,"CREATE OR REPLACE FUNCTION public.insert_job_title_public(p_name text)
 RETURNS job_titles
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_name text;
  v_existing public.job_titles;
  v_row public.job_titles;
begin
  v_name := nullif(btrim(p_name), '');
  if v_name is null then
    raise exception 'Job title cannot be empty';
  end if;

  select * into v_existing
  from public.job_titles
  where lower(name) = lower(v_name)
    and deleted_at is null
  limit 1;

  if v_existing.id is not null then
    return v_existing;
  end if;

  insert into public.job_titles (name, created_at, updated_at)
  values (v_name, now(), now())
  returning * into v_row;

  return v_row;
end;
$function$
"
public,insert_job_titles,"CREATE OR REPLACE FUNCTION public.insert_job_titles(_input jsonb)
 RETURNS SETOF job_titles
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.job_titles;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','job_titles', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.job_titles
        SELECT (jsonb_populate_record(NULL::public.job_titles, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_labor_records,"CREATE OR REPLACE FUNCTION public.insert_labor_records(_input jsonb)
 RETURNS SETOF labor_records
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.labor_records;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','labor_records', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.labor_records
        SELECT (jsonb_populate_record(NULL::public.labor_records, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_line_item_entries,"CREATE OR REPLACE FUNCTION public.insert_line_item_entries(_input jsonb)
 RETURNS SETOF line_item_entries
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_item_entries;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_item_entries', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.line_item_entries
        SELECT (jsonb_populate_record(NULL::public.line_item_entries, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_line_item_templates,"CREATE OR REPLACE FUNCTION public.insert_line_item_templates(_input jsonb)
 RETURNS SETOF line_item_templates
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_item_templates;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_item_templates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.line_item_templates
        SELECT (jsonb_populate_record(NULL::public.line_item_templates, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_line_items,"CREATE OR REPLACE FUNCTION public.insert_line_items(_input jsonb)
 RETURNS SETOF line_items
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_items;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_items', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.line_items
        SELECT (jsonb_populate_record(NULL::public.line_items, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_maps,"CREATE OR REPLACE FUNCTION public.insert_maps(_input jsonb)
 RETURNS SETOF maps
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.maps;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','maps', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.maps
        SELECT (jsonb_populate_record(NULL::public.maps, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_material_inventory,"CREATE OR REPLACE FUNCTION public.insert_material_inventory(_input jsonb)
 RETURNS SETOF material_inventory
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_inventory;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_inventory', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.material_inventory
        SELECT (jsonb_populate_record(NULL::public.material_inventory, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_material_orders,"CREATE OR REPLACE FUNCTION public.insert_material_orders(_input jsonb)
 RETURNS SETOF material_orders
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_orders;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.material_orders
        SELECT (jsonb_populate_record(NULL::public.material_orders, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_material_receipts,"CREATE OR REPLACE FUNCTION public.insert_material_receipts(_input jsonb)
 RETURNS SETOF material_receipts
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_receipts;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_receipts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.material_receipts
        SELECT (jsonb_populate_record(NULL::public.material_receipts, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_materials,"CREATE OR REPLACE FUNCTION public.insert_materials(_input jsonb)
 RETURNS SETOF materials
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.materials;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','materials', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.materials
        SELECT (jsonb_populate_record(NULL::public.materials, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_meeting_minutes,"CREATE OR REPLACE FUNCTION public.insert_meeting_minutes(_input jsonb)
 RETURNS SETOF meeting_minutes
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.meeting_minutes;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','meeting_minutes', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.meeting_minutes
        SELECT (jsonb_populate_record(NULL::public.meeting_minutes, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_notifications,"CREATE OR REPLACE FUNCTION public.insert_notifications(_input jsonb)
 RETURNS SETOF notifications
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.notifications;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','notifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.notifications
        SELECT (jsonb_populate_record(NULL::public.notifications, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_organization_members,"CREATE OR REPLACE FUNCTION public.insert_organization_members(_input jsonb)
 RETURNS SETOF organization_members
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organization_members;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organization_members', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.organization_members
        SELECT (jsonb_populate_record(NULL::public.organization_members, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_organization_projects,"CREATE OR REPLACE FUNCTION public.insert_organization_projects(_input jsonb)
 RETURNS SETOF organization_projects
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organization_projects;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organization_projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.organization_projects
        SELECT (jsonb_populate_record(NULL::public.organization_projects, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_organizations,"CREATE OR REPLACE FUNCTION public.insert_organizations(_input jsonb)
 RETURNS SETOF organizations
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organizations;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organizations', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.organizations
        SELECT (jsonb_populate_record(NULL::public.organizations, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_payments,"CREATE OR REPLACE FUNCTION public.insert_payments(_input jsonb)
 RETURNS SETOF payments
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.payments;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','payments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.payments
        SELECT (jsonb_populate_record(NULL::public.payments, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_payroll,"CREATE OR REPLACE FUNCTION public.insert_payroll(_input jsonb)
 RETURNS SETOF payroll
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.payroll;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','payroll', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.payroll
        SELECT (jsonb_populate_record(NULL::public.payroll, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_photos,"CREATE OR REPLACE FUNCTION public.insert_photos(_input jsonb)
 RETURNS SETOF photos
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.photos;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','photos', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.photos
        SELECT (jsonb_populate_record(NULL::public.photos, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_prequalifications,"CREATE OR REPLACE FUNCTION public.insert_prequalifications(_input jsonb)
 RETURNS SETOF prequalifications
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.prequalifications;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','prequalifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.prequalifications
        SELECT (jsonb_populate_record(NULL::public.prequalifications, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_procurement_workflows,"CREATE OR REPLACE FUNCTION public.insert_procurement_workflows(_input jsonb)
 RETURNS SETOF procurement_workflows
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.procurement_workflows;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','procurement_workflows', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.procurement_workflows
        SELECT (jsonb_populate_record(NULL::public.procurement_workflows, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_profiles,"CREATE OR REPLACE FUNCTION public.insert_profiles(_input jsonb)
 RETURNS SETOF profiles
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.profiles;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','profiles', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.profiles
        SELECT (jsonb_populate_record(NULL::public.profiles, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_progress_billings,"CREATE OR REPLACE FUNCTION public.insert_progress_billings(_input jsonb)
 RETURNS SETOF progress_billings
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.progress_billings;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','progress_billings', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.progress_billings
        SELECT (jsonb_populate_record(NULL::public.progress_billings, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_project_inspectors,"CREATE OR REPLACE FUNCTION public.insert_project_inspectors(_input jsonb)
 RETURNS SETOF project_inspectors
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.project_inspectors;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','project_inspectors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.project_inspectors
        SELECT (jsonb_populate_record(NULL::public.project_inspectors, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_projects,"CREATE OR REPLACE FUNCTION public.insert_projects(_input jsonb)
 RETURNS SETOF projects
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.projects;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.projects
        SELECT (jsonb_populate_record(NULL::public.projects, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_punch_lists,"CREATE OR REPLACE FUNCTION public.insert_punch_lists(_input jsonb)
 RETURNS SETOF punch_lists
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.punch_lists;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','punch_lists', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.punch_lists
        SELECT (jsonb_populate_record(NULL::public.punch_lists, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_purchase_orders,"CREATE OR REPLACE FUNCTION public.insert_purchase_orders(_input jsonb)
 RETURNS SETOF purchase_orders
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.purchase_orders;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','purchase_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.purchase_orders
        SELECT (jsonb_populate_record(NULL::public.purchase_orders, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_quality_reviews,"CREATE OR REPLACE FUNCTION public.insert_quality_reviews(_input jsonb)
 RETURNS SETOF quality_reviews
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.quality_reviews;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','quality_reviews', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.quality_reviews
        SELECT (jsonb_populate_record(NULL::public.quality_reviews, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_regulatory_documents,"CREATE OR REPLACE FUNCTION public.insert_regulatory_documents(_input jsonb)
 RETURNS SETOF regulatory_documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.regulatory_documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','regulatory_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.regulatory_documents
        SELECT (jsonb_populate_record(NULL::public.regulatory_documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_reports,"CREATE OR REPLACE FUNCTION public.insert_reports(_input jsonb)
 RETURNS SETOF reports
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.reports;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','reports', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.reports
        SELECT (jsonb_populate_record(NULL::public.reports, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_rfis,"CREATE OR REPLACE FUNCTION public.insert_rfis(_input jsonb)
 RETURNS SETOF rfis
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.rfis;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','rfis', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.rfis
        SELECT (jsonb_populate_record(NULL::public.rfis, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_safety_incidents,"CREATE OR REPLACE FUNCTION public.insert_safety_incidents(_input jsonb)
 RETURNS SETOF safety_incidents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.safety_incidents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','safety_incidents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.safety_incidents
        SELECT (jsonb_populate_record(NULL::public.safety_incidents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_sensor_data,"CREATE OR REPLACE FUNCTION public.insert_sensor_data(_input jsonb)
 RETURNS SETOF sensor_data
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.sensor_data;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','sensor_data', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.sensor_data
        SELECT (jsonb_populate_record(NULL::public.sensor_data, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_subcontractor_agreements,"CREATE OR REPLACE FUNCTION public.insert_subcontractor_agreements(_input jsonb)
 RETURNS SETOF subcontractor_agreements
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.subcontractor_agreements;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','subcontractor_agreements', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.subcontractor_agreements
        SELECT (jsonb_populate_record(NULL::public.subcontractor_agreements, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_subcontracts,"CREATE OR REPLACE FUNCTION public.insert_subcontracts(_input jsonb)
 RETURNS SETOF subcontracts
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.subcontracts;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','subcontracts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.subcontracts
        SELECT (jsonb_populate_record(NULL::public.subcontracts, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_submittals,"CREATE OR REPLACE FUNCTION public.insert_submittals(_input jsonb)
 RETURNS SETOF submittals
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.submittals;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','submittals', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.submittals
        SELECT (jsonb_populate_record(NULL::public.submittals, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_tack_rates,"CREATE OR REPLACE FUNCTION public.insert_tack_rates(_input jsonb)
 RETURNS SETOF tack_rates
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.tack_rates;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','tack_rates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.tack_rates
        SELECT (jsonb_populate_record(NULL::public.tack_rates, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_task_dependencies,"CREATE OR REPLACE FUNCTION public.insert_task_dependencies(_input jsonb)
 RETURNS SETOF task_dependencies
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.task_dependencies;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','task_dependencies', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.task_dependencies
        SELECT (jsonb_populate_record(NULL::public.task_dependencies, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_task_status_logs,"CREATE OR REPLACE FUNCTION public.insert_task_status_logs(_input jsonb)
 RETURNS SETOF task_status_logs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.task_status_logs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','task_status_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.task_status_logs
        SELECT (jsonb_populate_record(NULL::public.task_status_logs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_tasks,"CREATE OR REPLACE FUNCTION public.insert_tasks(_input jsonb)
 RETURNS SETOF tasks
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.tasks;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','tasks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.tasks
        SELECT (jsonb_populate_record(NULL::public.tasks, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_training_records,"CREATE OR REPLACE FUNCTION public.insert_training_records(_input jsonb)
 RETURNS SETOF training_records
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.training_records;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','training_records', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.training_records
        SELECT (jsonb_populate_record(NULL::public.training_records, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_user_projects,"CREATE OR REPLACE FUNCTION public.insert_user_projects(_input jsonb)
 RETURNS SETOF user_projects
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.user_projects;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','user_projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.user_projects
        SELECT (jsonb_populate_record(NULL::public.user_projects, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_vendor_bid_packages,"CREATE OR REPLACE FUNCTION public.insert_vendor_bid_packages(_input jsonb)
 RETURNS SETOF vendor_bid_packages
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_bid_packages;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_bid_packages', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendor_bid_packages
        SELECT (jsonb_populate_record(NULL::public.vendor_bid_packages, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_vendor_contacts,"CREATE OR REPLACE FUNCTION public.insert_vendor_contacts(_input jsonb)
 RETURNS SETOF vendor_contacts
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_contacts;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_contacts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendor_contacts
        SELECT (jsonb_populate_record(NULL::public.vendor_contacts, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_vendor_documents,"CREATE OR REPLACE FUNCTION public.insert_vendor_documents(_input jsonb)
 RETURNS SETOF vendor_documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendor_documents
        SELECT (jsonb_populate_record(NULL::public.vendor_documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_vendor_qualifications,"CREATE OR REPLACE FUNCTION public.insert_vendor_qualifications(_input jsonb)
 RETURNS SETOF vendor_qualifications
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_qualifications;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_qualifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendor_qualifications
        SELECT (jsonb_populate_record(NULL::public.vendor_qualifications, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_vendors,"CREATE OR REPLACE FUNCTION public.insert_vendors(_input jsonb)
 RETURNS SETOF vendors
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendors;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendors
        SELECT (jsonb_populate_record(NULL::public.vendors, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_wbs,"CREATE OR REPLACE FUNCTION public.insert_wbs(_input jsonb)
 RETURNS SETOF wbs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.wbs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','wbs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.wbs
        SELECT (jsonb_populate_record(NULL::public.wbs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,insert_workflows,"CREATE OR REPLACE FUNCTION public.insert_workflows(_input jsonb)
 RETURNS SETOF workflows
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.workflows;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','workflows', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.workflows
        SELECT (jsonb_populate_record(NULL::public.workflows, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,notify_new_bid,"CREATE OR REPLACE FUNCTION public.notify_new_bid()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  PERFORM public.create_notification(
    (SELECT owner_id FROM public.projects WHERE id = NEW.project_id),
    'bid_received',
    'A new bid ('||NEW.id||') was submitted.',
    jsonb_build_object('bid_id', NEW.id, 'vendor_id', NEW.vendor_id)
  );
  RETURN NEW;
END;
$function$
"
public,on_create_function_pin_search_path,"CREATE OR REPLACE FUNCTION public.on_create_function_pin_search_path()
 RETURNS event_trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'pg_catalog', 'public'
AS $function$
DECLARE
  r record;
  regproc text;
BEGIN
  FOR r IN
    SELECT *
    FROM pg_event_trigger_ddl_commands()
  LOOP
    -- Only act on CREATE FUNCTION and ALTER FUNCTION
    IF r.command_tag IN ('CREATE FUNCTION', 'ALTER FUNCTION') THEN
      regproc := (r.objid::regprocedure)::text;

      IF EXISTS (
        SELECT 1
        FROM pg_proc p
        WHERE p.oid = r.objid
          AND p.prosecdef = TRUE
          AND NOT EXISTS (
            SELECT 1
            FROM unnest(coalesce(p.proconfig, '{}'::text[])) kv
            WHERE split_part(kv, '=', 1) = 'search_path'
          )
      ) THEN
        EXECUTE format(
          'ALTER FUNCTION %s SET search_path = pg_catalog, public;',
          regproc
        );
        RAISE NOTICE 'Pinned search_path for %', regproc;
      END IF;
    END IF;
  END LOOP;
END
$function$
"
public,on_ddl_ensure_fk_indexes,"CREATE OR REPLACE FUNCTION public.on_ddl_ensure_fk_indexes()
 RETURNS event_trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'pg_catalog', 'public'
AS $function$
BEGIN
  PERFORM public.ensure_fk_indexes_for_schema('public');
END
$function$
"
public,rank_equipment_usage,"CREATE OR REPLACE FUNCTION public.rank_equipment_usage(p_project_id uuid)
 RETURNS TABLE(equipment_id uuid, total_hours numeric, usage_rank integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  WITH usage AS (
    SELECT ea.equipment_id, SUM(eu.hours_used) AS total_hours
      FROM public.equipment_usage eu
      JOIN public.equipment_assignments ea
        ON eu.equipment_id = ea.equipment_id
     WHERE ea.project_id = p_project_id
     GROUP BY ea.equipment_id
  )
  SELECT
    equipment_id,
    total_hours,
    RANK() OVER (ORDER BY total_hours DESC) AS usage_rank
  FROM usage;
$function$
"
public,refresh_project_cost_summary,"CREATE OR REPLACE FUNCTION public.refresh_project_cost_summary()
 RETURNS void
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  REFRESH MATERIALIZED VIEW public.project_cost_summary;
$function$
"
public,rpc_org_dashboard_payload,"CREATE OR REPLACE FUNCTION public.rpc_org_dashboard_payload(p_organization_id uuid, p_members_page integer DEFAULT 1, p_page_size integer DEFAULT 10)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
  v_role text;
  v_has_membership boolean := false;
  v_page int := GREATEST(COALESCE(p_members_page, 1), 1);
  v_page_size int := GREATEST(COALESCE(p_page_size, 10), 1);
  v_offset int := (v_page - 1) * v_page_size;
  v_organization jsonb;
  v_service_areas jsonb;
  v_members_items jsonb;
  v_members_total int := 0;
  v_total_members int := 0;
  v_total_projects int := 0;
BEGIN
  -- ðŸ” Access check follows existing security patterns.
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role
  INTO v_role
  FROM public.profiles
  WHERE id = v_user_id;

  IF v_role IS NULL THEN
    RAISE EXCEPTION 'Access denied: profile not found for user %', v_user_id;
  END IF;

  IF v_role = 'system_admin' THEN
    v_has_membership := true;
  ELSE
    SELECT EXISTS (
      SELECT 1
      FROM public.organization_members
      WHERE organization_id = p_organization_id
        AND profile_id = v_user_id
        AND deleted_at IS NULL
    )
    INTO v_has_membership;
  END IF;

  IF v_has_membership IS NOT TRUE THEN
    RAISE EXCEPTION 'Access denied: not a member of organization %', p_organization_id;
  END IF;

  -- ðŸ¢ Organization header payload.
  SELECT jsonb_build_object(
    'id', id,
    'name', name,
    'description', description,
    'mission_statement', mission_statement,
    'headquarters', headquarters,
    'logo_url', logo_url
  )
  INTO v_organization
  FROM public.organizations
  WHERE id = p_organization_id
    AND deleted_at IS NULL;

  IF v_organization IS NULL THEN
    RAISE EXCEPTION 'Organization not found: %', p_organization_id;
  END IF;

  -- ðŸ“ Service areas, ordered alphabetically.
  SELECT COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'service_area_text', service_area_text
      )
      ORDER BY service_area_text
    ),
    '[]'::jsonb
  )
  INTO v_service_areas
  FROM public.organization_service_areas
  WHERE organization_id = p_organization_id;

  -- ðŸ‘¥ Members pagination and total count.
  SELECT COUNT(*)
  INTO v_members_total
  FROM public.organization_members
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  SELECT COALESCE(jsonb_agg(to_jsonb(member_row)), '[]'::jsonb)
  INTO v_members_items
  FROM (
    SELECT
      p.id AS profile_id,
      p.full_name,
      p.email,
      p.role AS global_role,
      om.role AS membership_role
    FROM public.organization_members om
    JOIN public.profiles p ON p.id = om.profile_id
    WHERE om.organization_id = p_organization_id
      AND om.deleted_at IS NULL
    ORDER BY p.full_name NULLS LAST, p.email
    LIMIT v_page_size
    OFFSET v_offset
  ) member_row;

  -- ðŸ“Š Basic metrics for the dashboard.
  SELECT COUNT(*)
  INTO v_total_members
  FROM public.organization_members
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  SELECT COUNT(*)
  INTO v_total_projects
  FROM public.projects
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  RETURN jsonb_build_object(
    'organization', v_organization,
    'service_areas', v_service_areas,
    'members', jsonb_build_object(
      'total_count', v_members_total,
      'items', v_members_items
    ),
    'metrics', jsonb_build_object(
      'total_members', v_total_members,
      'total_projects', v_total_projects
    )
  );
END;
$function$
"
public,set_org_member_role,"CREATE OR REPLACE FUNCTION public.set_org_member_role(p_org_id uuid, p_profile_id uuid, p_role org_role)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
  v_is_owner boolean;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_org_id IS NULL OR p_profile_id IS NULL THEN
    RAISE EXCEPTION 'Missing organization or profile id';
  END IF;

  SELECT EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.organization_id = p_org_id
      AND om.profile_id = v_user_id
      AND om.role = 'owner'
  ) INTO v_is_owner;

  IF NOT v_is_owner THEN
    RAISE EXCEPTION 'Access denied: not an owner';
  END IF;

  UPDATE public.organization_members
  SET role = p_role,
      updated_at = now()
  WHERE organization_id = p_org_id
    AND profile_id = p_profile_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Member not found';
  END IF;
END;
$function$
"
public,set_updated_at,"CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'UPDATE' THEN
    NEW.updated_at := now();
  END IF;
  RETURN NEW;
END;
$function$
"
public,touch_created_at,"CREATE OR REPLACE FUNCTION public.touch_created_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' THEN
    NEW.created_at := now();
  END IF;
  RETURN NEW;
END;
$function$
"
public,update_accounts_payable,"CREATE OR REPLACE FUNCTION public.update_accounts_payable(_id uuid, _input jsonb)
 RETURNS SETOF accounts_payable
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.accounts_payable;
        _new_row public.accounts_payable;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.accounts_payable := (jsonb_populate_record(NULL::public.accounts_payable, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.accounts_payable WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','accounts_payable', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.accounts_payable
           SET amount_due = COALESCE(_row.amount_due, amount_due), due_date = COALESCE(_row.due_date, due_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_accounts_receivable,"CREATE OR REPLACE FUNCTION public.update_accounts_receivable(_id uuid, _input jsonb)
 RETURNS SETOF accounts_receivable
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.accounts_receivable;
        _new_row public.accounts_receivable;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.accounts_receivable := (jsonb_populate_record(NULL::public.accounts_receivable, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.accounts_receivable WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','accounts_receivable', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.accounts_receivable
           SET amount_due = COALESCE(_row.amount_due, amount_due), due_date = COALESCE(_row.due_date, due_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_activity_logs,"CREATE OR REPLACE FUNCTION public.update_activity_logs(_id uuid, _input jsonb)
 RETURNS SETOF activity_logs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.activity_logs;
        _new_row public.activity_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.activity_logs := (jsonb_populate_record(NULL::public.activity_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.activity_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','activity_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.activity_logs
           SET profile_id = COALESCE(_row.profile_id, profile_id), activity_type = COALESCE(_row.activity_type, activity_type), activity_at = COALESCE(_row.activity_at, activity_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_asphalt_types,"CREATE OR REPLACE FUNCTION public.update_asphalt_types(_id uuid, _input jsonb)
 RETURNS SETOF asphalt_types
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.asphalt_types;
        _new_row public.asphalt_types;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.asphalt_types := (jsonb_populate_record(NULL::public.asphalt_types, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.asphalt_types WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','asphalt_types', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.asphalt_types
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_audit_logs,"CREATE OR REPLACE FUNCTION public.update_audit_logs(_id uuid, _input jsonb)
 RETURNS SETOF audit_logs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.audit_logs;
        _new_row public.audit_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.audit_logs := (jsonb_populate_record(NULL::public.audit_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.audit_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','audit_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.audit_logs
           SET action = COALESCE(_row.action, action), performed_by = COALESCE(_row.performed_by, performed_by), performed_at = COALESCE(_row.performed_at, performed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_avatars,"CREATE OR REPLACE FUNCTION public.update_avatars(_id uuid, _input jsonb)
 RETURNS SETOF avatars
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.avatars;
        _new_row public.avatars;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.avatars := (jsonb_populate_record(NULL::public.avatars, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.avatars WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','avatars', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.avatars
           SET url = COALESCE(_row.url, url), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_bid_packages,"CREATE OR REPLACE FUNCTION public.update_bid_packages(_id uuid, _input jsonb)
 RETURNS SETOF bid_packages
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.bid_packages;
        _new_row public.bid_packages;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bid_packages := (jsonb_populate_record(NULL::public.bid_packages, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bid_packages WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bid_packages', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bid_packages
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_bid_vendors,"CREATE OR REPLACE FUNCTION public.update_bid_vendors(_id uuid, _input jsonb)
 RETURNS SETOF bid_vendors
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.bid_vendors;
        _new_row public.bid_vendors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bid_vendors := (jsonb_populate_record(NULL::public.bid_vendors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bid_vendors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bid_vendors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bid_vendors
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), invited_at = COALESCE(_row.invited_at, invited_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_bids,"CREATE OR REPLACE FUNCTION public.update_bids(_id uuid, _input jsonb)
 RETURNS SETOF bids
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.bids;
        _new_row public.bids;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bids := (jsonb_populate_record(NULL::public.bids, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bids WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bids', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bids
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), amount = COALESCE(_row.amount, amount), submitted_at = COALESCE(_row.submitted_at, submitted_at), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_bim_models,"CREATE OR REPLACE FUNCTION public.update_bim_models(_id uuid, _input jsonb)
 RETURNS SETOF bim_models
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.bim_models;
        _new_row public.bim_models;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bim_models := (jsonb_populate_record(NULL::public.bim_models, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bim_models WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bim_models', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bim_models
           SET name = COALESCE(_row.name, name), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_certifications,"CREATE OR REPLACE FUNCTION public.update_certifications(_id uuid, _input jsonb)
 RETURNS SETOF certifications
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.certifications;
        _new_row public.certifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.certifications := (jsonb_populate_record(NULL::public.certifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.certifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','certifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.certifications
           SET employee_id = COALESCE(_row.employee_id, employee_id), certification_type = COALESCE(_row.certification_type, certification_type), issue_date = COALESCE(_row.issue_date, issue_date), expiry_date = COALESCE(_row.expiry_date, expiry_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_change_orders,"CREATE OR REPLACE FUNCTION public.update_change_orders(_id uuid, _input jsonb)
 RETURNS SETOF change_orders
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.change_orders;
        _new_row public.change_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.change_orders := (jsonb_populate_record(NULL::public.change_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.change_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','change_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.change_orders
           SET number = COALESCE(_row.number, number), description = COALESCE(_row.description, description), status = COALESCE(_row.status, status), amount = COALESCE(_row.amount, amount), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_commitments,"CREATE OR REPLACE FUNCTION public.update_commitments(_id uuid, _input jsonb)
 RETURNS SETOF commitments
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.commitments;
        _new_row public.commitments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.commitments := (jsonb_populate_record(NULL::public.commitments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.commitments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','commitments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.commitments
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), type = COALESCE(_row.type, type), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_compliance_checks,"CREATE OR REPLACE FUNCTION public.update_compliance_checks(_id uuid, _input jsonb)
 RETURNS SETOF compliance_checks
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.compliance_checks;
        _new_row public.compliance_checks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.compliance_checks := (jsonb_populate_record(NULL::public.compliance_checks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.compliance_checks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','compliance_checks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.compliance_checks
           SET check_date = COALESCE(_row.check_date, check_date), description = COALESCE(_row.description, description), result = COALESCE(_row.result, result), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_compliance_tracking,"CREATE OR REPLACE FUNCTION public.update_compliance_tracking(_id uuid, _input jsonb)
 RETURNS SETOF compliance_tracking
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.compliance_tracking;
        _new_row public.compliance_tracking;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.compliance_tracking := (jsonb_populate_record(NULL::public.compliance_tracking, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.compliance_tracking WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','compliance_tracking', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.compliance_tracking
           SET tracking_type = COALESCE(_row.tracking_type, tracking_type), status = COALESCE(_row.status, status), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_cost_codes,"CREATE OR REPLACE FUNCTION public.update_cost_codes(_id uuid, _input jsonb)
 RETURNS SETOF cost_codes
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.cost_codes;
        _new_row public.cost_codes;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.cost_codes := (jsonb_populate_record(NULL::public.cost_codes, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.cost_codes WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','cost_codes', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.cost_codes
           SET code = COALESCE(_row.code, code), description = COALESCE(_row.description, description), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_crew_assignments,"CREATE OR REPLACE FUNCTION public.update_crew_assignments(_id uuid, _input jsonb)
 RETURNS SETOF crew_assignments
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.crew_assignments;
        _new_row public.crew_assignments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crew_assignments := (jsonb_populate_record(NULL::public.crew_assignments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crew_assignments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crew_assignments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crew_assignments
           SET crew_id = COALESCE(_row.crew_id, crew_id), profile_id = COALESCE(_row.profile_id, profile_id), assigned_date = COALESCE(_row.assigned_date, assigned_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_crew_members,"CREATE OR REPLACE FUNCTION public.update_crew_members(_id uuid, _input jsonb)
 RETURNS SETOF crew_members
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.crew_members;
        _new_row public.crew_members;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crew_members := (jsonb_populate_record(NULL::public.crew_members, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crew_members WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crew_members', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crew_members
           SET crew_id = COALESCE(_row.crew_id, crew_id), profile_id = COALESCE(_row.profile_id, profile_id), role = COALESCE(_row.role, role), start_date = COALESCE(_row.start_date, start_date), end_date = COALESCE(_row.end_date, end_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_crews,"CREATE OR REPLACE FUNCTION public.update_crews(_id uuid, _input jsonb)
 RETURNS SETOF crews
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.crews;
        _new_row public.crews;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crews := (jsonb_populate_record(NULL::public.crews, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crews WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crews', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crews
           SET name = COALESCE(_row.name, name), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_daily_logs,"CREATE OR REPLACE FUNCTION public.update_daily_logs(_id uuid, _input jsonb)
 RETURNS SETOF daily_logs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.daily_logs;
        _new_row public.daily_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.daily_logs := (jsonb_populate_record(NULL::public.daily_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.daily_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','daily_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.daily_logs
           SET date = COALESCE(_row.date, date), weather = COALESCE(_row.weather, weather), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_dashboard_configs,"CREATE OR REPLACE FUNCTION public.update_dashboard_configs(_id uuid, _input jsonb)
 RETURNS SETOF dashboard_configs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.dashboard_configs;
        _new_row public.dashboard_configs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.dashboard_configs := (jsonb_populate_record(NULL::public.dashboard_configs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.dashboard_configs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','dashboard_configs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.dashboard_configs
           SET profile_id = COALESCE(_row.profile_id, profile_id), config = COALESCE(_row.config, config), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_document_references,"CREATE OR REPLACE FUNCTION public.update_document_references(_id uuid, _input jsonb)
 RETURNS SETOF document_references
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.document_references;
        _new_row public.document_references;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.document_references := (jsonb_populate_record(NULL::public.document_references, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.document_references WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','document_references', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.document_references
           SET document_id = COALESCE(_row.document_id, document_id), reference_type = COALESCE(_row.reference_type, reference_type), reference_id = COALESCE(_row.reference_id, reference_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_documents,"CREATE OR REPLACE FUNCTION public.update_documents(_id uuid, _input jsonb)
 RETURNS SETOF documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.documents;
        _new_row public.documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.documents
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_drawing_versions,"CREATE OR REPLACE FUNCTION public.update_drawing_versions(_id uuid, _input jsonb)
 RETURNS SETOF drawing_versions
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.drawing_versions;
        _new_row public.drawing_versions;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.drawing_versions := (jsonb_populate_record(NULL::public.drawing_versions, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.drawing_versions WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','drawing_versions', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.drawing_versions
           SET document_id = COALESCE(_row.document_id, document_id), version = COALESCE(_row.version, version), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_dump_trucks,"CREATE OR REPLACE FUNCTION public.update_dump_trucks(_id uuid, _input jsonb)
 RETURNS SETOF dump_trucks
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.dump_trucks;
        _new_row public.dump_trucks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.dump_trucks := (jsonb_populate_record(NULL::public.dump_trucks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.dump_trucks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','dump_trucks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.dump_trucks
           SET make = COALESCE(_row.make, make), model = COALESCE(_row.model, model), capacity = COALESCE(_row.capacity, capacity), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_employees,"CREATE OR REPLACE FUNCTION public.update_employees(_id uuid, _input jsonb)
 RETURNS SETOF employees
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.employees;
        _new_row public.employees;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.employees := (jsonb_populate_record(NULL::public.employees, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.employees WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','employees', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.employees
           SET profile_id = COALESCE(_row.profile_id, profile_id), hire_date = COALESCE(_row.hire_date, hire_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_equipment,"CREATE OR REPLACE FUNCTION public.update_equipment(_id uuid, _input jsonb)
 RETURNS SETOF equipment
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.equipment;
        _new_row public.equipment;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment := (jsonb_populate_record(NULL::public.equipment, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), model = COALESCE(_row.model, model), serial_number = COALESCE(_row.serial_number, serial_number), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_equipment_assignments,"CREATE OR REPLACE FUNCTION public.update_equipment_assignments(_id uuid, _input jsonb)
 RETURNS SETOF equipment_assignments
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.equipment_assignments;
        _new_row public.equipment_assignments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_assignments := (jsonb_populate_record(NULL::public.equipment_assignments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_assignments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_assignments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_assignments
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), assigned_to = COALESCE(_row.assigned_to, assigned_to), assigned_date = COALESCE(_row.assigned_date, assigned_date), released_date = COALESCE(_row.released_date, released_date), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_equipment_maintenance,"CREATE OR REPLACE FUNCTION public.update_equipment_maintenance(_id uuid, _input jsonb)
 RETURNS SETOF equipment_maintenance
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.equipment_maintenance;
        _new_row public.equipment_maintenance;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_maintenance := (jsonb_populate_record(NULL::public.equipment_maintenance, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_maintenance WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_maintenance', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_maintenance
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), maintenance_date = COALESCE(_row.maintenance_date, maintenance_date), type = COALESCE(_row.type, type), description = COALESCE(_row.description, description), performed_by = COALESCE(_row.performed_by, performed_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_equipment_usage,"CREATE OR REPLACE FUNCTION public.update_equipment_usage(_id uuid, _input jsonb)
 RETURNS SETOF equipment_usage
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.equipment_usage;
        _new_row public.equipment_usage;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_usage := (jsonb_populate_record(NULL::public.equipment_usage, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_usage WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_usage', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_usage
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), date = COALESCE(_row.date, date), hours_used = COALESCE(_row.hours_used, hours_used), quantity = COALESCE(_row.quantity, quantity), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_estimate_line_items,"CREATE OR REPLACE FUNCTION public.update_estimate_line_items(_id uuid, _input jsonb)
 RETURNS SETOF estimate_line_items
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.estimate_line_items;
        _new_row public.estimate_line_items;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.estimate_line_items := (jsonb_populate_record(NULL::public.estimate_line_items, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.estimate_line_items WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','estimate_line_items', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.estimate_line_items
           SET estimate_id = COALESCE(_row.estimate_id, estimate_id), cost_code_id = COALESCE(_row.cost_code_id, cost_code_id), name = COALESCE(_row.name, name), unit_measure = COALESCE(_row.unit_measure, unit_measure), quantity = COALESCE(_row.quantity, quantity), unit_price = COALESCE(_row.unit_price, unit_price), total_cost = COALESCE(_row.total_cost, total_cost), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_estimates,"CREATE OR REPLACE FUNCTION public.update_estimates(_id uuid, _input jsonb)
 RETURNS SETOF estimates
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.estimates;
        _new_row public.estimates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.estimates := (jsonb_populate_record(NULL::public.estimates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.estimates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','estimates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.estimates
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_financial_documents,"CREATE OR REPLACE FUNCTION public.update_financial_documents(_id uuid, _input jsonb)
 RETURNS SETOF financial_documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.financial_documents;
        _new_row public.financial_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.financial_documents := (jsonb_populate_record(NULL::public.financial_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.financial_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','financial_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.financial_documents
           SET document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_general_ledger,"CREATE OR REPLACE FUNCTION public.update_general_ledger(_id uuid, _input jsonb)
 RETURNS SETOF general_ledger
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.general_ledger;
        _new_row public.general_ledger;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.general_ledger := (jsonb_populate_record(NULL::public.general_ledger, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.general_ledger WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','general_ledger', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.general_ledger
           SET entry_date = COALESCE(_row.entry_date, entry_date), description = COALESCE(_row.description, description), debit = COALESCE(_row.debit, debit), credit = COALESCE(_row.credit, credit), balance = COALESCE(_row.balance, balance), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_hr_documents,"CREATE OR REPLACE FUNCTION public.update_hr_documents(_id uuid, _input jsonb)
 RETURNS SETOF hr_documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.hr_documents;
        _new_row public.hr_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.hr_documents := (jsonb_populate_record(NULL::public.hr_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.hr_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','hr_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.hr_documents
           SET employee_id = COALESCE(_row.employee_id, employee_id), document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_inspections,"CREATE OR REPLACE FUNCTION public.update_inspections(_id uuid, _input jsonb)
 RETURNS SETOF inspections
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.inspections;
        _new_row public.inspections;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.inspections := (jsonb_populate_record(NULL::public.inspections, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.inspections WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','inspections', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.inspections
           SET name = COALESCE(_row.name, name), inspection_type = COALESCE(_row.inspection_type, inspection_type), date = COALESCE(_row.date, date), status = COALESCE(_row.status, status), result = COALESCE(_row.result, result), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_integration_tokens,"CREATE OR REPLACE FUNCTION public.update_integration_tokens(_id uuid, _input jsonb)
 RETURNS SETOF integration_tokens
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.integration_tokens;
        _new_row public.integration_tokens;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.integration_tokens := (jsonb_populate_record(NULL::public.integration_tokens, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.integration_tokens WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','integration_tokens', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.integration_tokens
           SET profile_id = COALESCE(_row.profile_id, profile_id), service_name = COALESCE(_row.service_name, service_name), token = COALESCE(_row.token, token), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_inventory_transactions,"CREATE OR REPLACE FUNCTION public.update_inventory_transactions(_id uuid, _input jsonb)
 RETURNS SETOF inventory_transactions
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.inventory_transactions;
        _new_row public.inventory_transactions;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.inventory_transactions := (jsonb_populate_record(NULL::public.inventory_transactions, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.inventory_transactions WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','inventory_transactions', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.inventory_transactions
           SET material_id = COALESCE(_row.material_id, material_id), transaction_type = COALESCE(_row.transaction_type, transaction_type), quantity = COALESCE(_row.quantity, quantity), transaction_date = COALESCE(_row.transaction_date, transaction_date), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_issues,"CREATE OR REPLACE FUNCTION public.update_issues(_id uuid, _input jsonb)
 RETURNS SETOF issues
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.issues;
        _new_row public.issues;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.issues := (jsonb_populate_record(NULL::public.issues, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.issues WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','issues', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.issues
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), status = COALESCE(_row.status, status), reported_by = COALESCE(_row.reported_by, reported_by), description = COALESCE(_row.description, description), resolved = COALESCE(_row.resolved, resolved), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_job_titles,"CREATE OR REPLACE FUNCTION public.update_job_titles(_id uuid, _input jsonb)
 RETURNS SETOF job_titles
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.job_titles;
        _new_row public.job_titles;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.job_titles := (jsonb_populate_record(NULL::public.job_titles, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.job_titles WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','job_titles', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.job_titles
           SET name = COALESCE(_row.name, name), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_labor_records,"CREATE OR REPLACE FUNCTION public.update_labor_records(_id uuid, _input jsonb)
 RETURNS SETOF labor_records
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.labor_records;
        _new_row public.labor_records;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.labor_records := (jsonb_populate_record(NULL::public.labor_records, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.labor_records WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','labor_records', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.labor_records
           SET line_item_id = COALESCE(_row.line_item_id, line_item_id), worker_count = COALESCE(_row.worker_count, worker_count), hours_worked = COALESCE(_row.hours_worked, hours_worked), work_date = COALESCE(_row.work_date, work_date), work_type = COALESCE(_row.work_type, work_type), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_line_item_entries,"CREATE OR REPLACE FUNCTION public.update_line_item_entries(_id uuid, _input jsonb)
 RETURNS SETOF line_item_entries
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.line_item_entries;
        _new_row public.line_item_entries;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_item_entries := (jsonb_populate_record(NULL::public.line_item_entries, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_item_entries WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_item_entries', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_item_entries
           SET line_item_id = COALESCE(_row.line_item_id, line_item_id), date = COALESCE(_row.date, date), quantity_completed = COALESCE(_row.quantity_completed, quantity_completed), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_line_item_templates,"CREATE OR REPLACE FUNCTION public.update_line_item_templates(_id uuid, _input jsonb)
 RETURNS SETOF line_item_templates
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.line_item_templates;
        _new_row public.line_item_templates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_item_templates := (jsonb_populate_record(NULL::public.line_item_templates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_item_templates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_item_templates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_item_templates
           SET name = COALESCE(_row.name, name), formula = COALESCE(_row.formula, formula), variables = COALESCE(_row.variables, variables), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_line_items,"CREATE OR REPLACE FUNCTION public.update_line_items(_id uuid, _input jsonb)
 RETURNS SETOF line_items
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.line_items;
        _new_row public.line_items;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_items := (jsonb_populate_record(NULL::public.line_items, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_items WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_items', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_items
           SET map_id = COALESCE(_row.map_id, map_id), wbs_id = COALESCE(_row.wbs_id, wbs_id), cost_code_id = COALESCE(_row.cost_code_id, cost_code_id), template_id = COALESCE(_row.template_id, template_id), name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), unit_measure = COALESCE(_row.unit_measure, unit_measure), quantity = COALESCE(_row.quantity, quantity), unit_price = COALESCE(_row.unit_price, unit_price), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_maps,"CREATE OR REPLACE FUNCTION public.update_maps(_id uuid, _input jsonb)
 RETURNS SETOF maps
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.maps;
        _new_row public.maps;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.maps := (jsonb_populate_record(NULL::public.maps, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.maps WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','maps', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.maps
           SET wbs_id = COALESCE(_row.wbs_id, wbs_id), name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), coordinates = COALESCE(_row.coordinates, coordinates), scope = COALESCE(_row.scope, scope), order_num = COALESCE(_row.order_num, order_num), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_material_inventory,"CREATE OR REPLACE FUNCTION public.update_material_inventory(_id uuid, _input jsonb)
 RETURNS SETOF material_inventory
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.material_inventory;
        _new_row public.material_inventory;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_inventory := (jsonb_populate_record(NULL::public.material_inventory, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_inventory WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_inventory', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_inventory
           SET material_id = COALESCE(_row.material_id, material_id), quantity = COALESCE(_row.quantity, quantity), last_updated = COALESCE(_row.last_updated, last_updated), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_material_orders,"CREATE OR REPLACE FUNCTION public.update_material_orders(_id uuid, _input jsonb)
 RETURNS SETOF material_orders
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.material_orders;
        _new_row public.material_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_orders := (jsonb_populate_record(NULL::public.material_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_orders
           SET material_id = COALESCE(_row.material_id, material_id), order_date = COALESCE(_row.order_date, order_date), quantity = COALESCE(_row.quantity, quantity), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_material_receipts,"CREATE OR REPLACE FUNCTION public.update_material_receipts(_id uuid, _input jsonb)
 RETURNS SETOF material_receipts
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.material_receipts;
        _new_row public.material_receipts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_receipts := (jsonb_populate_record(NULL::public.material_receipts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_receipts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_receipts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_receipts
           SET material_order_id = COALESCE(_row.material_order_id, material_order_id), received_date = COALESCE(_row.received_date, received_date), quantity = COALESCE(_row.quantity, quantity), received_by = COALESCE(_row.received_by, received_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_materials,"CREATE OR REPLACE FUNCTION public.update_materials(_id uuid, _input jsonb)
 RETURNS SETOF materials
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.materials;
        _new_row public.materials;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.materials := (jsonb_populate_record(NULL::public.materials, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.materials WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','materials', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.materials
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), unit = COALESCE(_row.unit, unit), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_meeting_minutes,"CREATE OR REPLACE FUNCTION public.update_meeting_minutes(_id uuid, _input jsonb)
 RETURNS SETOF meeting_minutes
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.meeting_minutes;
        _new_row public.meeting_minutes;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.meeting_minutes := (jsonb_populate_record(NULL::public.meeting_minutes, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.meeting_minutes WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','meeting_minutes', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.meeting_minutes
           SET meeting_date = COALESCE(_row.meeting_date, meeting_date), notes = COALESCE(_row.notes, notes), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_notifications,"CREATE OR REPLACE FUNCTION public.update_notifications(_id uuid, _input jsonb)
 RETURNS SETOF notifications
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.notifications;
        _new_row public.notifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.notifications := (jsonb_populate_record(NULL::public.notifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.notifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','notifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.notifications
           SET user_id = COALESCE(_row.user_id, user_id), category = COALESCE(_row.category, category), message = COALESCE(_row.message, message), payload = COALESCE(_row.payload, payload), is_read = COALESCE(_row.is_read, is_read), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_organization_members,"CREATE OR REPLACE FUNCTION public.update_organization_members(_id uuid, _input jsonb)
 RETURNS SETOF organization_members
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.organization_members;
        _new_row public.organization_members;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.organization_members := (jsonb_populate_record(NULL::public.organization_members, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.organization_members WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','organization_members', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.organization_members
           SET profile_id = COALESCE(_row.profile_id, profile_id), role = COALESCE(_row.role, role), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_organization_projects,"CREATE OR REPLACE FUNCTION public.update_organization_projects(_id uuid, _input jsonb)
 RETURNS SETOF organization_projects
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.organization_projects;
        _new_row public.organization_projects;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.organization_projects := (jsonb_populate_record(NULL::public.organization_projects, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.organization_projects WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','organization_projects', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.organization_projects
           SET updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_organizations,"CREATE OR REPLACE FUNCTION public.update_organizations(_id uuid, _input jsonb)
 RETURNS SETOF organizations
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.organizations;
        _new_row public.organizations;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.organizations := (jsonb_populate_record(NULL::public.organizations, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.organizations WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','organizations', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.organizations
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_payments,"CREATE OR REPLACE FUNCTION public.update_payments(_id uuid, _input jsonb)
 RETURNS SETOF payments
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.payments;
        _new_row public.payments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.payments := (jsonb_populate_record(NULL::public.payments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.payments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','payments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.payments
           SET commitment_id = COALESCE(_row.commitment_id, commitment_id), amount = COALESCE(_row.amount, amount), paid_at = COALESCE(_row.paid_at, paid_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_payroll,"CREATE OR REPLACE FUNCTION public.update_payroll(_id uuid, _input jsonb)
 RETURNS SETOF payroll
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.payroll;
        _new_row public.payroll;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.payroll := (jsonb_populate_record(NULL::public.payroll, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.payroll WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','payroll', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.payroll
           SET employee_id = COALESCE(_row.employee_id, employee_id), pay_period_start = COALESCE(_row.pay_period_start, pay_period_start), pay_period_end = COALESCE(_row.pay_period_end, pay_period_end), gross_pay = COALESCE(_row.gross_pay, gross_pay), net_pay = COALESCE(_row.net_pay, net_pay), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_photos,"CREATE OR REPLACE FUNCTION public.update_photos(_id uuid, _input jsonb)
 RETURNS SETOF photos
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.photos;
        _new_row public.photos;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.photos := (jsonb_populate_record(NULL::public.photos, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.photos WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','photos', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.photos
           SET url = COALESCE(_row.url, url), caption = COALESCE(_row.caption, caption), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_prequalifications,"CREATE OR REPLACE FUNCTION public.update_prequalifications(_id uuid, _input jsonb)
 RETURNS SETOF prequalifications
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.prequalifications;
        _new_row public.prequalifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.prequalifications := (jsonb_populate_record(NULL::public.prequalifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.prequalifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','prequalifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.prequalifications
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), status = COALESCE(_row.status, status), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_procurement_workflows,"CREATE OR REPLACE FUNCTION public.update_procurement_workflows(_id uuid, _input jsonb)
 RETURNS SETOF procurement_workflows
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.procurement_workflows;
        _new_row public.procurement_workflows;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.procurement_workflows := (jsonb_populate_record(NULL::public.procurement_workflows, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.procurement_workflows WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','procurement_workflows', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.procurement_workflows
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_profiles,"CREATE OR REPLACE FUNCTION public.update_profiles(_id uuid, _input jsonb)
 RETURNS SETOF profiles
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.profiles;
        _new_row public.profiles;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.profiles := (jsonb_populate_record(NULL::public.profiles, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.profiles WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','profiles', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.profiles
           SET email = COALESCE(_row.email, email), full_name = COALESCE(_row.full_name, full_name), phone = COALESCE(_row.phone, phone), job_title_id = COALESCE(_row.job_title_id, job_title_id), avatar_url = COALESCE(_row.avatar_url, avatar_url), role = COALESCE(_row.role, role), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_progress_billings,"CREATE OR REPLACE FUNCTION public.update_progress_billings(_id uuid, _input jsonb)
 RETURNS SETOF progress_billings
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.progress_billings;
        _new_row public.progress_billings;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.progress_billings := (jsonb_populate_record(NULL::public.progress_billings, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.progress_billings WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','progress_billings', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.progress_billings
           SET billing_number = COALESCE(_row.billing_number, billing_number), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_project_inspectors,"CREATE OR REPLACE FUNCTION public.update_project_inspectors(_id uuid, _input jsonb)
 RETURNS SETOF project_inspectors
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.project_inspectors;
        _new_row public.project_inspectors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.project_inspectors := (jsonb_populate_record(NULL::public.project_inspectors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.project_inspectors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','project_inspectors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.project_inspectors
           SET profile_id = COALESCE(_row.profile_id, profile_id), assigned_by = COALESCE(_row.assigned_by, assigned_by), assigned_at = COALESCE(_row.assigned_at, assigned_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_projects,"CREATE OR REPLACE FUNCTION public.update_projects(_id uuid, _input jsonb)
 RETURNS SETOF projects
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.projects;
        _new_row public.projects;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.projects := (jsonb_populate_record(NULL::public.projects, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.projects WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','projects', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.projects
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), status = COALESCE(_row.status, status), start_date = COALESCE(_row.start_date, start_date), end_date = COALESCE(_row.end_date, end_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_punch_lists,"CREATE OR REPLACE FUNCTION public.update_punch_lists(_id uuid, _input jsonb)
 RETURNS SETOF punch_lists
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.punch_lists;
        _new_row public.punch_lists;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.punch_lists := (jsonb_populate_record(NULL::public.punch_lists, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.punch_lists WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','punch_lists', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.punch_lists
           SET item = COALESCE(_row.item, item), status = COALESCE(_row.status, status), assigned_to = COALESCE(_row.assigned_to, assigned_to), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_purchase_orders,"CREATE OR REPLACE FUNCTION public.update_purchase_orders(_id uuid, _input jsonb)
 RETURNS SETOF purchase_orders
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.purchase_orders;
        _new_row public.purchase_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.purchase_orders := (jsonb_populate_record(NULL::public.purchase_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.purchase_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','purchase_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.purchase_orders
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), order_number = COALESCE(_row.order_number, order_number), order_date = COALESCE(_row.order_date, order_date), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_quality_reviews,"CREATE OR REPLACE FUNCTION public.update_quality_reviews(_id uuid, _input jsonb)
 RETURNS SETOF quality_reviews
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.quality_reviews;
        _new_row public.quality_reviews;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.quality_reviews := (jsonb_populate_record(NULL::public.quality_reviews, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.quality_reviews WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','quality_reviews', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.quality_reviews
           SET review_date = COALESCE(_row.review_date, review_date), reviewer = COALESCE(_row.reviewer, reviewer), findings = COALESCE(_row.findings, findings), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_regulatory_documents,"CREATE OR REPLACE FUNCTION public.update_regulatory_documents(_id uuid, _input jsonb)
 RETURNS SETOF regulatory_documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.regulatory_documents;
        _new_row public.regulatory_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.regulatory_documents := (jsonb_populate_record(NULL::public.regulatory_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.regulatory_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','regulatory_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.regulatory_documents
           SET document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_reports,"CREATE OR REPLACE FUNCTION public.update_reports(_id uuid, _input jsonb)
 RETURNS SETOF reports
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.reports;
        _new_row public.reports;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.reports := (jsonb_populate_record(NULL::public.reports, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.reports WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','reports', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.reports
           SET report_type = COALESCE(_row.report_type, report_type), generated_at = COALESCE(_row.generated_at, generated_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_rfis,"CREATE OR REPLACE FUNCTION public.update_rfis(_id uuid, _input jsonb)
 RETURNS SETOF rfis
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.rfis;
        _new_row public.rfis;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.rfis := (jsonb_populate_record(NULL::public.rfis, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.rfis WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','rfis', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.rfis
           SET subject = COALESCE(_row.subject, subject), status = COALESCE(_row.status, status), question = COALESCE(_row.question, question), answer = COALESCE(_row.answer, answer), submitted_by = COALESCE(_row.submitted_by, submitted_by), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), submitted_at = COALESCE(_row.submitted_at, submitted_at), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_safety_incidents,"CREATE OR REPLACE FUNCTION public.update_safety_incidents(_id uuid, _input jsonb)
 RETURNS SETOF safety_incidents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.safety_incidents;
        _new_row public.safety_incidents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.safety_incidents := (jsonb_populate_record(NULL::public.safety_incidents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.safety_incidents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','safety_incidents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.safety_incidents
           SET incident_date = COALESCE(_row.incident_date, incident_date), description = COALESCE(_row.description, description), reported_by = COALESCE(_row.reported_by, reported_by), severity = COALESCE(_row.severity, severity), resolved = COALESCE(_row.resolved, resolved), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_sensor_data,"CREATE OR REPLACE FUNCTION public.update_sensor_data(_id uuid, _input jsonb)
 RETURNS SETOF sensor_data
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.sensor_data;
        _new_row public.sensor_data;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.sensor_data := (jsonb_populate_record(NULL::public.sensor_data, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.sensor_data WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','sensor_data', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.sensor_data
           SET data = COALESCE(_row.data, data), collected_at = COALESCE(_row.collected_at, collected_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_subcontractor_agreements,"CREATE OR REPLACE FUNCTION public.update_subcontractor_agreements(_id uuid, _input jsonb)
 RETURNS SETOF subcontractor_agreements
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.subcontractor_agreements;
        _new_row public.subcontractor_agreements;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.subcontractor_agreements := (jsonb_populate_record(NULL::public.subcontractor_agreements, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.subcontractor_agreements WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','subcontractor_agreements', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.subcontractor_agreements
           SET subcontract_id = COALESCE(_row.subcontract_id, subcontract_id), agreement_url = COALESCE(_row.agreement_url, agreement_url), signed_at = COALESCE(_row.signed_at, signed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_subcontracts,"CREATE OR REPLACE FUNCTION public.update_subcontracts(_id uuid, _input jsonb)
 RETURNS SETOF subcontracts
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.subcontracts;
        _new_row public.subcontracts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.subcontracts := (jsonb_populate_record(NULL::public.subcontracts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.subcontracts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','subcontracts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.subcontracts
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), signed_at = COALESCE(_row.signed_at, signed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_submittals,"CREATE OR REPLACE FUNCTION public.update_submittals(_id uuid, _input jsonb)
 RETURNS SETOF submittals
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.submittals;
        _new_row public.submittals;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.submittals := (jsonb_populate_record(NULL::public.submittals, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.submittals WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','submittals', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.submittals
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), submitted_by = COALESCE(_row.submitted_by, submitted_by), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), submitted_at = COALESCE(_row.submitted_at, submitted_at), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_tack_rates,"CREATE OR REPLACE FUNCTION public.update_tack_rates(_id uuid, _input jsonb)
 RETURNS SETOF tack_rates
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.tack_rates;
        _new_row public.tack_rates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.tack_rates := (jsonb_populate_record(NULL::public.tack_rates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.tack_rates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','tack_rates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.tack_rates
           SET rate = COALESCE(_row.rate, rate), material_type = COALESCE(_row.material_type, material_type), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_task_dependencies,"CREATE OR REPLACE FUNCTION public.update_task_dependencies(_id uuid, _input jsonb)
 RETURNS SETOF task_dependencies
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.task_dependencies;
        _new_row public.task_dependencies;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.task_dependencies := (jsonb_populate_record(NULL::public.task_dependencies, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.task_dependencies WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','task_dependencies', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.task_dependencies
           SET task_id = COALESCE(_row.task_id, task_id), depends_on_task_id = COALESCE(_row.depends_on_task_id, depends_on_task_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_task_status_logs,"CREATE OR REPLACE FUNCTION public.update_task_status_logs(_id uuid, _input jsonb)
 RETURNS SETOF task_status_logs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.task_status_logs;
        _new_row public.task_status_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.task_status_logs := (jsonb_populate_record(NULL::public.task_status_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.task_status_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','task_status_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.task_status_logs
           SET task_id = COALESCE(_row.task_id, task_id), status = COALESCE(_row.status, status), changed_at = COALESCE(_row.changed_at, changed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_tasks,"CREATE OR REPLACE FUNCTION public.update_tasks(_id uuid, _input jsonb)
 RETURNS SETOF tasks
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.tasks;
        _new_row public.tasks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.tasks := (jsonb_populate_record(NULL::public.tasks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.tasks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','tasks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.tasks
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), start_date = COALESCE(_row.start_date, start_date), end_date = COALESCE(_row.end_date, end_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_training_records,"CREATE OR REPLACE FUNCTION public.update_training_records(_id uuid, _input jsonb)
 RETURNS SETOF training_records
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.training_records;
        _new_row public.training_records;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.training_records := (jsonb_populate_record(NULL::public.training_records, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.training_records WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','training_records', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.training_records
           SET employee_id = COALESCE(_row.employee_id, employee_id), training_type = COALESCE(_row.training_type, training_type), completion_date = COALESCE(_row.completion_date, completion_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_user_projects,"CREATE OR REPLACE FUNCTION public.update_user_projects(_id uuid, _input jsonb)
 RETURNS SETOF user_projects
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.user_projects;
        _new_row public.user_projects;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.user_projects := (jsonb_populate_record(NULL::public.user_projects, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.user_projects WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','user_projects', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.user_projects
           SET user_id = COALESCE(_row.user_id, user_id), role = COALESCE(_row.role, role), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_vendor_bid_packages,"CREATE OR REPLACE FUNCTION public.update_vendor_bid_packages(_id uuid, _input jsonb)
 RETURNS SETOF vendor_bid_packages
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.vendor_bid_packages;
        _new_row public.vendor_bid_packages;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_bid_packages := (jsonb_populate_record(NULL::public.vendor_bid_packages, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_bid_packages WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_bid_packages', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_bid_packages
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_vendor_contacts,"CREATE OR REPLACE FUNCTION public.update_vendor_contacts(_id uuid, _input jsonb)
 RETURNS SETOF vendor_contacts
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.vendor_contacts;
        _new_row public.vendor_contacts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_contacts := (jsonb_populate_record(NULL::public.vendor_contacts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_contacts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_contacts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_contacts
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), name = COALESCE(_row.name, name), email = COALESCE(_row.email, email), phone = COALESCE(_row.phone, phone), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_vendor_documents,"CREATE OR REPLACE FUNCTION public.update_vendor_documents(_id uuid, _input jsonb)
 RETURNS SETOF vendor_documents
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.vendor_documents;
        _new_row public.vendor_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_documents := (jsonb_populate_record(NULL::public.vendor_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_documents
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_vendor_qualifications,"CREATE OR REPLACE FUNCTION public.update_vendor_qualifications(_id uuid, _input jsonb)
 RETURNS SETOF vendor_qualifications
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.vendor_qualifications;
        _new_row public.vendor_qualifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_qualifications := (jsonb_populate_record(NULL::public.vendor_qualifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_qualifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_qualifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_qualifications
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), qualification_type = COALESCE(_row.qualification_type, qualification_type), status = COALESCE(_row.status, status), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_vendors,"CREATE OR REPLACE FUNCTION public.update_vendors(_id uuid, _input jsonb)
 RETURNS SETOF vendors
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.vendors;
        _new_row public.vendors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendors := (jsonb_populate_record(NULL::public.vendors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendors
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), contact_email = COALESCE(_row.contact_email, contact_email), contact_phone = COALESCE(_row.contact_phone, contact_phone), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_wbs,"CREATE OR REPLACE FUNCTION public.update_wbs(_id uuid, _input jsonb)
 RETURNS SETOF wbs
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.wbs;
        _new_row public.wbs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.wbs := (jsonb_populate_record(NULL::public.wbs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.wbs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','wbs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.wbs
           SET name = COALESCE(_row.name, name), location = COALESCE(_row.location, location), order_num = COALESCE(_row.order_num, order_num), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
public,update_workflows,"CREATE OR REPLACE FUNCTION public.update_workflows(_id uuid, _input jsonb)
 RETURNS SETOF workflows
 LANGUAGE plpgsql
 SET search_path TO 'public', 'pg_temp'
AS $function$
      DECLARE
        _old_row public.workflows;
        _new_row public.workflows;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.workflows := (jsonb_populate_record(NULL::public.workflows, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.workflows WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','workflows', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.workflows
           SET entity_schema = COALESCE(_row.entity_schema, entity_schema), entity_table = COALESCE(_row.entity_table, entity_table), entity_id = COALESCE(_row.entity_id, entity_id), workflow_name = COALESCE(_row.workflow_name, workflow_name), current_state = COALESCE(_row.current_state, current_state), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $function$
"
realtime,apply_rls,"CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))
 RETURNS SETOF realtime.wal_rls
 LANGUAGE plpgsql
AS $function$
declare
-- Regclass of the table e.g. public.notes
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;

-- I, U, D, T: insert, update ...
action realtime.action = (
    case wal ->> 'action'
        when 'I' then 'INSERT'
        when 'U' then 'UPDATE'
        when 'D' then 'DELETE'
        else 'ERROR'
    end
);

-- Is row level security enabled for the table
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;

subscriptions realtime.subscription[] = array_agg(subs)
    from
        realtime.subscription subs
    where
        subs.entity = entity_
        -- Filter by action early - only get subscriptions interested in this action
        -- action_filter column can be: '*' (all), 'INSERT', 'UPDATE', or 'DELETE'
        and (subs.action_filter = '*' or subs.action_filter = action::text);

-- Subscription vars
roles regrole[] = array_agg(distinct us.claims_role::text)
    from
        unnest(subscriptions) us;

working_role regrole;
claimed_role regrole;
claims jsonb;

subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';

-- structured info for wal's columns
columns realtime.wal_column[];
-- previous identity values for update/delete
old_columns realtime.wal_column[];

error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;

-- Primary jsonb output for record
output jsonb;

begin
perform set_config('role', null, true);

columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'columns') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

old_columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'identity') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

for working_role in select * from unnest(roles) loop

    -- Update `is_selectable` for columns and old_columns
    columns =
        array_agg(
            (
                c.name,
                c.type_name,
                c.type_oid,
                c.value,
                c.is_pkey,
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
            )::realtime.wal_column
        )
        from
            unnest(columns) c;

    old_columns =
            array_agg(
                (
                    c.name,
                    c.type_name,
                    c.type_oid,
                    c.value,
                    c.is_pkey,
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
                )::realtime.wal_column
            )
            from
                unnest(old_columns) c;

    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            -- subscriptions is already filtered by entity
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 400: Bad Request, no primary key']
        )::realtime.wal_rls;

    -- The claims role does not have SELECT permission to the primary key of entity
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 401: Unauthorized']
        )::realtime.wal_rls;

    else
        output = jsonb_build_object(
            'schema', wal ->> 'schema',
            'table', wal ->> 'table',
            'type', action,
            'commit_timestamp', to_char(
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),
                'YYYY-MM-DD""T""HH24:MI:SS.MS""Z""'
            ),
            'columns', (
                select
                    jsonb_agg(
                        jsonb_build_object(
                            'name', pa.attname,
                            'type', pt.typname
                        )
                        order by pa.attnum asc
                    )
                from
                    pg_attribute pa
                    join pg_type pt
                        on pa.atttypid = pt.oid
                where
                    attrelid = entity_
                    and attnum > 0
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')
            )
        )
        -- Add ""record"" key for insert and update
        || case
            when action in ('INSERT', 'UPDATE') then
                jsonb_build_object(
                    'record',
                    (
                        select
                            jsonb_object_agg(
                                -- if unchanged toast, get column name and value from old record
                                coalesce((c).name, (oc).name),
                                case
                                    when (c).name is null then (oc).value
                                    else (c).value
                                end
                            )
                        from
                            unnest(columns) c
                            full outer join unnest(old_columns) oc
                                on (c).name = (oc).name
                        where
                            coalesce((c).is_selectable, (oc).is_selectable)
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                    )
                )
            else '{}'::jsonb
        end
        -- Add ""old_record"" key for update and delete
        || case
            when action = 'UPDATE' then
                jsonb_build_object(
                        'old_record',
                        (
                            select jsonb_object_agg((c).name, (c).value)
                            from unnest(old_columns) c
                            where
                                (c).is_selectable
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                        )
                    )
            when action = 'DELETE' then
                jsonb_build_object(
                    'old_record',
                    (
                        select jsonb_object_agg((c).name, (c).value)
                        from unnest(old_columns) c
                        where
                            (c).is_selectable
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey
                    )
                )
            else '{}'::jsonb
        end;

        -- Create the prepared statement
        if is_rls_enabled and action <> 'DELETE' then
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;

        visible_to_subscription_ids = '{}';

        for subscription_id, claims in (
                select
                    subs.subscription_id,
                    subs.claims
                from
                    unnest(subscriptions) subs
                where
                    subs.entity = entity_
                    and subs.claims_role = working_role
                    and (
                        realtime.is_visible_through_filters(columns, subs.filters)
                        or (
                          action = 'DELETE'
                          and realtime.is_visible_through_filters(old_columns, subs.filters)
                        )
                    )
        ) loop

            if not is_rls_enabled or action = 'DELETE' then
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else
                -- Check if RLS allows the role to see the record
                perform
                    -- Trim leading and trailing quotes from working_role because set_config
                    -- doesn't recognize the role as valid if they are included
                    set_config('role', trim(both '""' from working_role::text), true),
                    set_config('request.jwt.claims', claims::text, true);

                execute 'execute walrus_rls_stmt' into subscription_has_access;

                if subscription_has_access then
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;

        perform set_config('role', null, true);

        return next (
            output,
            is_rls_enabled,
            visible_to_subscription_ids,
            case
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']
                else '{}'
            end
        )::realtime.wal_rls;

    end if;
end loop;

perform set_config('role', null, true);
end;
$function$
"
realtime,broadcast_changes,"CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare a variable to hold the JSONB representation of the row
    row_data jsonb := '{}'::jsonb;
BEGIN
    IF level = 'STATEMENT' THEN
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;

$function$
"
realtime,build_prepared_statement_sql,"CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])
 RETURNS text
 LANGUAGE sql
AS $function$
      /*
      Builds a sql string that, if executed, creates a prepared statement to
      tests retrive a row from *entity* by its primary key columns.
      Example
          select realtime.build_prepared_statement_sql('public.notes', '{""id""}'::text[], '{""bigint""}'::text[])
      */
          select
      'prepare ' || prepared_statement_name || ' as
          select
              exists(
                  select
                      1
                  from
                      ' || entity || '
                  where
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '
              )'
          from
              unnest(columns) pkc
          where
              pkc.is_pkey
          group by
              entity
      $function$
"
realtime,cast,"CREATE OR REPLACE FUNCTION realtime.""cast""(val text, type_ regtype)
 RETURNS jsonb
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
    declare
      res jsonb;
    begin
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end
    $function$
"
realtime,check_equality_op,"CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)
 RETURNS boolean
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
      /*
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness
      */
      declare
          op_symbol text = (
              case
                  when op = 'eq' then '='
                  when op = 'neq' then '!='
                  when op = 'lt' then '<'
                  when op = 'lte' then '<='
                  when op = 'gt' then '>'
                  when op = 'gte' then '>='
                  when op = 'in' then '= any'
                  else 'UNKNOWN OP'
              end
          );
          res boolean;
      begin
          execute format(
              'select %L::'|| type_::text || ' ' || op_symbol
              || ' ( %L::'
              || (
                  case
                      when op = 'in' then type_::text || '[]'
                      else type_::text end
              )
              || ')', val_1, val_2) into res;
          return res;
      end;
      $function$
"
realtime,is_visible_through_filters,"CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])
 RETURNS boolean
 LANGUAGE sql
 IMMUTABLE
AS $function$
    /*
    Should the record be visible (true) or filtered out (false) after *filters* are applied
    */
        select
            -- Default to allowed when no filters present
            $2 is null -- no filters. this should not happen because subscriptions has a default
            or array_length($2, 1) is null -- array length of an empty array is null
            or bool_and(
                coalesce(
                    realtime.check_equality_op(
                        op:=f.op,
                        type_:=coalesce(
                            col.type_oid::regtype, -- null when wal2json version <= 2.4
                            col.type_name::regtype
                        ),
                        -- cast jsonb to text
                        val_1:=col.value #>> '{}',
                        val_2:=f.value
                    ),
                    false -- if null, filter does not match
                )
            )
        from
            unnest(filters) f
            join unnest(columns) col
                on f.column_name = col.name;
    $function$
"
realtime,list_changes,"CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)
 RETURNS SETOF realtime.wal_rls
 LANGUAGE sql
 SET log_min_messages TO 'fatal'
AS $function$
      with pub as (
        select
          concat_ws(
            ',',
            case when bool_or(pubinsert) then 'insert' else null end,
            case when bool_or(pubupdate) then 'update' else null end,
            case when bool_or(pubdelete) then 'delete' else null end
          ) as w2j_actions,
          coalesce(
            string_agg(
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),
              ','
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),
            ''
          ) w2j_add_tables
        from
          pg_publication pp
          left join pg_publication_tables ppt
            on pp.pubname = ppt.pubname
        where
          pp.pubname = publication
        group by
          pp.pubname
        limit 1
      ),
      w2j as (
        select
          x.*, pub.w2j_add_tables
        from
          pub,
          pg_logical_slot_get_changes(
            slot_name, null, max_changes,
            'include-pk', 'true',
            'include-transaction', 'false',
            'include-timestamp', 'true',
            'include-type-oids', 'true',
            'format-version', '2',
            'actions', pub.w2j_actions,
            'add-tables', pub.w2j_add_tables
          ) x
      )
      select
        xyz.wal,
        xyz.is_rls_enabled,
        xyz.subscription_ids,
        xyz.errors
      from
        w2j,
        realtime.apply_rls(
          wal := w2j.data::jsonb,
          max_record_bytes := max_record_bytes
        ) xyz(wal, is_rls_enabled, subscription_ids, errors)
      where
        w2j.w2j_add_tables <> ''
        and xyz.subscription_ids[1] is not null
    $function$
"
realtime,quote_wal2json,"CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
      select
        (
          select string_agg('' || ch,'')
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '""')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '""'
            )
        )
        || '.'
        || (
          select string_agg('' || ch,'')
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '""')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '""'
            )
          )
      from
        pg_class pc
        join pg_namespace nsp
          on pc.relnamespace = nsp.oid
      where
        pc.oid = entity
    $function$
"
realtime,send,"CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  generated_id uuid;
  final_payload jsonb;
BEGIN
  BEGIN
    -- Generate a new UUID for the id
    generated_id := gen_random_uuid();

    -- Check if payload has an 'id' key, if not, add the generated UUID
    IF payload ? 'id' THEN
      final_payload := payload;
    ELSE
      final_payload := jsonb_set(payload, '{id}', to_jsonb(generated_id));
    END IF;

    -- Set the topic configuration
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);

    -- Attempt to insert the message
    INSERT INTO realtime.messages (id, payload, event, topic, private, extension)
    VALUES (generated_id, final_payload, event, topic, private, 'broadcast');
  EXCEPTION
    WHEN OTHERS THEN
      -- Capture and notify the error
      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;
  END;
END;
$function$
"
realtime,subscription_check_filters,"CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
    /*
    Validates that the user defined filters for a subscription:
    - refer to valid columns that the claimed role may access
    - values are coercable to the correct column type
    */
    declare
        col_names text[] = coalesce(
                array_agg(c.column_name order by c.ordinal_position),
                '{}'::text[]
            )
            from
                information_schema.columns c
            where
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity
                and pg_catalog.has_column_privilege(
                    (new.claims ->> 'role'),
                    format('%I.%I', c.table_schema, c.table_name)::regclass,
                    c.column_name,
                    'SELECT'
                );
        filter realtime.user_defined_filter;
        col_type regtype;

        in_val jsonb;
    begin
        for filter in select * from unnest(new.filters) loop
            -- Filtered column is valid
            if not filter.column_name = any(col_names) then
                raise exception 'invalid column for filter %', filter.column_name;
            end if;

            -- Type is sanitized and safe for string interpolation
            col_type = (
                select atttypid::regtype
                from pg_catalog.pg_attribute
                where attrelid = new.entity
                      and attname = filter.column_name
            );
            if col_type is null then
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;

            -- Set maximum number of entries for in filter
            if filter.op = 'in'::realtime.equality_op then
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else
                -- raises an exception if value is not coercable to type
                perform realtime.cast(filter.value, col_type);
            end if;

        end loop;

        -- Apply consistent order to filters so the unique constraint on
        -- (subscription_id, entity, filters) can't be tricked by a different filter order
        new.filters = coalesce(
            array_agg(f order by f.column_name, f.op, f.value),
            '{}'
        ) from unnest(new.filters) f;

        return new;
    end;
    $function$
"
realtime,to_regrole,"CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)
 RETURNS regrole
 LANGUAGE sql
 IMMUTABLE
AS $function$ select role_name::regrole $function$
"
realtime,topic,"CREATE OR REPLACE FUNCTION realtime.topic()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
select nullif(current_setting('realtime.topic', true), '')::text;
$function$
"
storage,add_prefixes,"CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    prefixes text[];
BEGIN
    prefixes := ""storage"".""get_prefixes""(""_name"");

    IF array_length(prefixes, 1) > 0 THEN
        INSERT INTO storage.prefixes (name, bucket_id)
        SELECT UNNEST(prefixes) as name, ""_bucket_id"" ON CONFLICT DO NOTHING;
    END IF;
END;
$function$
"
storage,can_insert_object,"CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO ""storage"".""objects"" (""bucket_id"", ""name"", ""owner"", ""metadata"") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$function$
"
storage,delete_leaf_prefixes,"CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_rows_deleted integer;
BEGIN
    LOOP
        WITH candidates AS (
            SELECT DISTINCT
                t.bucket_id,
                unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        ),
        uniq AS (
             SELECT
                 bucket_id,
                 name,
                 storage.get_level(name) AS level
             FROM candidates
             WHERE name <> ''
             GROUP BY bucket_id, name
        ),
        leaf AS (
             SELECT
                 p.bucket_id,
                 p.name,
                 p.level
             FROM storage.prefixes AS p
                  JOIN uniq AS u
                       ON u.bucket_id = p.bucket_id
                           AND u.name = p.name
                           AND u.level = p.level
             WHERE NOT EXISTS (
                 SELECT 1
                 FROM storage.objects AS o
                 WHERE o.bucket_id = p.bucket_id
                   AND o.level = p.level + 1
                   AND o.name COLLATE ""C"" LIKE p.name || '/%'
             )
             AND NOT EXISTS (
                 SELECT 1
                 FROM storage.prefixes AS c
                 WHERE c.bucket_id = p.bucket_id
                   AND c.level = p.level + 1
                   AND c.name COLLATE ""C"" LIKE p.name || '/%'
             )
        )
        DELETE
        FROM storage.prefixes AS p
            USING leaf AS l
        WHERE p.bucket_id = l.bucket_id
          AND p.name = l.name
          AND p.level = l.level;

        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;
        EXIT WHEN v_rows_deleted = 0;
    END LOOP;
END;
$function$
"
storage,delete_prefix,"CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Check if we can delete the prefix
    IF EXISTS(
        SELECT FROM ""storage"".""prefixes""
        WHERE ""prefixes"".""bucket_id"" = ""_bucket_id""
          AND level = ""storage"".""get_level""(""_name"") + 1
          AND ""prefixes"".""name"" COLLATE ""C"" LIKE ""_name"" || '/%'
        LIMIT 1
    )
    OR EXISTS(
        SELECT FROM ""storage"".""objects""
        WHERE ""objects"".""bucket_id"" = ""_bucket_id""
          AND ""storage"".""get_level""(""objects"".""name"") = ""storage"".""get_level""(""_name"") + 1
          AND ""objects"".""name"" COLLATE ""C"" LIKE ""_name"" || '/%'
        LIMIT 1
    ) THEN
    -- There are sub-objects, skip deletion
    RETURN false;
    ELSE
        DELETE FROM ""storage"".""prefixes""
        WHERE ""prefixes"".""bucket_id"" = ""_bucket_id""
          AND level = ""storage"".""get_level""(""_name"")
          AND ""prefixes"".""name"" = ""_name"";
        RETURN true;
    END IF;
END;
$function$
"
storage,delete_prefix_hierarchy_trigger,"CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    prefix text;
BEGIN
    prefix := ""storage"".""get_prefix""(OLD.""name"");

    IF coalesce(prefix, '') != '' THEN
        PERFORM ""storage"".""delete_prefix""(OLD.""bucket_id"", prefix);
    END IF;

    RETURN OLD;
END;
$function$
"
storage,enforce_bucket_name_length,"CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    if length(new.name) > 100 then
        raise exception 'bucket name ""%"" is too long (% characters). Max is 100.', new.name, length(new.name);
    end if;
    return new;
end;
$function$
"
storage,extension,"CREATE OR REPLACE FUNCTION storage.extension(name text)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    _parts text[];
    _filename text;
BEGIN
    SELECT string_to_array(name, '/') INTO _parts;
    SELECT _parts[array_length(_parts,1)] INTO _filename;
    RETURN reverse(split_part(reverse(_filename), '.', 1));
END
$function$
"
storage,filename,"CREATE OR REPLACE FUNCTION storage.filename(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$function$
"
storage,foldername,"CREATE OR REPLACE FUNCTION storage.foldername(name text)
 RETURNS text[]
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    _parts text[];
BEGIN
    -- Split on ""/"" to get path segments
    SELECT string_to_array(name, '/') INTO _parts;
    -- Return everything except the last segment
    RETURN _parts[1 : array_length(_parts,1) - 1];
END
$function$
"
storage,get_level,"CREATE OR REPLACE FUNCTION storage.get_level(name text)
 RETURNS integer
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
SELECT array_length(string_to_array(""name"", '/'), 1);
$function$
"
storage,get_prefix,"CREATE OR REPLACE FUNCTION storage.get_prefix(name text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
SELECT
    CASE WHEN strpos(""name"", '/') > 0 THEN
             regexp_replace(""name"", '[\/]{1}[^\/]+\/?$', '')
         ELSE
             ''
        END;
$function$
"
storage,get_prefixes,"CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)
 RETURNS text[]
 LANGUAGE plpgsql
 IMMUTABLE STRICT
AS $function$
DECLARE
    parts text[];
    prefixes text[];
    prefix text;
BEGIN
    -- Split the name into parts by '/'
    parts := string_to_array(""name"", '/');
    prefixes := '{}';

    -- Construct the prefixes, stopping one level below the last part
    FOR i IN 1..array_length(parts, 1) - 1 LOOP
            prefix := array_to_string(parts[1:i], '/');
            prefixes := array_append(prefixes, prefix);
    END LOOP;

    RETURN prefixes;
END;
$function$
"
storage,get_size_by_bucket,"CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()
 RETURNS TABLE(size bigint, bucket_id text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    return query
        select sum((metadata->>'size')::bigint) as size, obj.bucket_id
        from ""storage"".objects as obj
        group by obj.bucket_id;
END
$function$
"
storage,list_multipart_uploads_with_delimiter,"CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)
 RETURNS TABLE(key text, id text, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE ""C"") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE ""C"" > $4
                            ELSE
                                key COLLATE ""C"" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE ""C"" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE ""C"" ASC, created_at ASC) as e order by key COLLATE ""C"" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$function$
"
storage,list_objects_with_delimiter,"CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)
 RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE ""C"") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE ""C"" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE ""C"" > $4
                            ELSE
                                name COLLATE ""C"" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE ""C"" ASC) as e order by name COLLATE ""C"" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$function$
"
storage,lock_top_prefixes,"CREATE OR REPLACE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_bucket text;
    v_top text;
BEGIN
    FOR v_bucket, v_top IN
        SELECT DISTINCT t.bucket_id,
            split_part(t.name, '/', 1) AS top
        FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        WHERE t.name <> ''
        ORDER BY 1, 2
        LOOP
            PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));
        END LOOP;
END;
$function$
"
storage,objects_delete_cleanup,"CREATE OR REPLACE FUNCTION storage.objects_delete_cleanup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_bucket_ids text[];
    v_names      text[];
BEGIN
    IF current_setting('storage.gc.prefixes', true) = '1' THEN
        RETURN NULL;
    END IF;

    PERFORM set_config('storage.gc.prefixes', '1', true);

    SELECT COALESCE(array_agg(d.bucket_id), '{}'),
           COALESCE(array_agg(d.name), '{}')
    INTO v_bucket_ids, v_names
    FROM deleted AS d
    WHERE d.name <> '';

    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);

    RETURN NULL;
END;
$function$
"
storage,objects_insert_prefix_trigger,"CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    PERFORM ""storage"".""add_prefixes""(NEW.""bucket_id"", NEW.""name"");
    NEW.level := ""storage"".""get_level""(NEW.""name"");

    RETURN NEW;
END;
$function$
"
storage,objects_update_cleanup,"CREATE OR REPLACE FUNCTION storage.objects_update_cleanup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    -- NEW - OLD (destinations to create prefixes for)
    v_add_bucket_ids text[];
    v_add_names      text[];

    -- OLD - NEW (sources to prune)
    v_src_bucket_ids text[];
    v_src_names      text[];
BEGIN
    IF TG_OP <> 'UPDATE' THEN
        RETURN NULL;
    END IF;

    -- 1) Compute NEWâˆ’OLD (added paths) and OLDâˆ’NEW (moved-away paths)
    WITH added AS (
        SELECT n.bucket_id, n.name
        FROM new_rows n
        WHERE n.name <> '' AND position('/' in n.name) > 0
        EXCEPT
        SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> ''
    ),
    moved AS (
         SELECT o.bucket_id, o.name
         FROM old_rows o
         WHERE o.name <> ''
         EXCEPT
         SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> ''
    )
    SELECT
        -- arrays for ADDED (dest) in stable order
        COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),
        COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),
        -- arrays for MOVED (src) in stable order
        COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),
        COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' )
    INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;

    -- Nothing to do?
    IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN
        RETURN NULL;
    END IF;

    -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks
    DECLARE
        v_all_bucket_ids text[];
        v_all_names text[];
    BEGIN
        -- Combine source and destination arrays for consistent lock ordering
        v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');
        v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');

        -- Single lock call ensures consistent global ordering across all transactions
        IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN
            PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);
        END IF;
    END;

    -- 3) Create destination prefixes (NEWâˆ’OLD) BEFORE pruning sources
    IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN
        WITH candidates AS (
            SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name)
            WHERE name <> ''
        )
        INSERT INTO storage.prefixes (bucket_id, name)
        SELECT c.bucket_id, c.name
        FROM candidates c
        ON CONFLICT DO NOTHING;
    END IF;

    -- 4) Prune source prefixes bottom-up for OLDâˆ’NEW
    IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN
        -- re-entrancy guard so DELETE on prefixes won't recurse
        IF current_setting('storage.gc.prefixes', true) <> '1' THEN
            PERFORM set_config('storage.gc.prefixes', '1', true);
        END IF;

        PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);
    END IF;

    RETURN NULL;
END;
$function$
"
storage,objects_update_level_trigger,"CREATE OR REPLACE FUNCTION storage.objects_update_level_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW.""name"" <> OLD.""name"" OR NEW.""bucket_id"" <> OLD.""bucket_id"") THEN
        -- Set the new level
        NEW.""level"" := ""storage"".""get_level""(NEW.""name"");
    END IF;
    RETURN NEW;
END;
$function$
"
storage,objects_update_prefix_trigger,"CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    old_prefixes TEXT[];
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW.""name"" <> OLD.""name"" OR NEW.""bucket_id"" <> OLD.""bucket_id"") THEN
        -- Retrieve old prefixes
        old_prefixes := ""storage"".""get_prefixes""(OLD.""name"");

        -- Remove old prefixes that are only used by this object
        WITH all_prefixes as (
            SELECT unnest(old_prefixes) as prefix
        ),
        can_delete_prefixes as (
             SELECT prefix
             FROM all_prefixes
             WHERE NOT EXISTS (
                 SELECT 1 FROM ""storage"".""objects""
                 WHERE ""bucket_id"" = OLD.""bucket_id""
                   AND ""name"" <> OLD.""name""
                   AND ""name"" LIKE (prefix || '%')
             )
         )
        DELETE FROM ""storage"".""prefixes"" WHERE name IN (SELECT prefix FROM can_delete_prefixes);

        -- Add new prefixes
        PERFORM ""storage"".""add_prefixes""(NEW.""bucket_id"", NEW.""name"");
    END IF;
    -- Set the new level
    NEW.""level"" := ""storage"".""get_level""(NEW.""name"");

    RETURN NEW;
END;
$function$
"
storage,operation,"CREATE OR REPLACE FUNCTION storage.operation()
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$function$
"
storage,prefixes_delete_cleanup,"CREATE OR REPLACE FUNCTION storage.prefixes_delete_cleanup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_bucket_ids text[];
    v_names      text[];
BEGIN
    IF current_setting('storage.gc.prefixes', true) = '1' THEN
        RETURN NULL;
    END IF;

    PERFORM set_config('storage.gc.prefixes', '1', true);

    SELECT COALESCE(array_agg(d.bucket_id), '{}'),
           COALESCE(array_agg(d.name), '{}')
    INTO v_bucket_ids, v_names
    FROM deleted AS d
    WHERE d.name <> '';

    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);

    RETURN NULL;
END;
$function$
"
storage,prefixes_insert_trigger,"CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    PERFORM ""storage"".""add_prefixes""(NEW.""bucket_id"", NEW.""name"");
    RETURN NEW;
END;
$function$
"
storage,search,"CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
AS $function$
declare
    can_bypass_rls BOOLEAN;
begin
    SELECT rolbypassrls
    INTO can_bypass_rls
    FROM pg_roles
    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);

    IF can_bypass_rls THEN
        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    ELSE
        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    END IF;
end;
$function$
"
storage,search_legacy_v1,"CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select path_tokens[$1] as folder
           from storage.objects
             where objects.name ilike $2 || $3 || ''%''
               and bucket_id = $4
               and array_length(objects.path_tokens, 1) <> $1
           group by folder
           order by folder ' || v_sort_order || '
     )
     (select folder as ""name"",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as ""name"",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$
"
storage,search_v1_optimised,"CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select (string_to_array(name, ''/''))[level] as name
           from storage.prefixes
             where lower(prefixes.name) like lower($2 || $3) || ''%''
               and bucket_id = $4
               and level = $1
           order by name ' || v_sort_order || '
     )
     (select name,
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[level] as ""name"",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where lower(objects.name) like lower($2 || $3) || ''%''
       and bucket_id = $4
       and level = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$
"
storage,search_v2,"CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)
 RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    sort_col text;
    sort_ord text;
    cursor_op text;
    cursor_expr text;
    sort_expr text;
BEGIN
    -- Validate sort_order
    sort_ord := lower(sort_order);
    IF sort_ord NOT IN ('asc', 'desc') THEN
        sort_ord := 'asc';
    END IF;

    -- Determine cursor comparison operator
    IF sort_ord = 'asc' THEN
        cursor_op := '>';
    ELSE
        cursor_op := '<';
    END IF;
    
    sort_col := lower(sort_column);
    -- Validate sort column  
    IF sort_col IN ('updated_at', 'created_at') THEN
        cursor_expr := format(
            '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE ""C"") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',
            sort_col, cursor_op
        );
        sort_expr := format(
            'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE ""C"" %s',
            sort_col, sort_ord, sort_ord
        );
    ELSE
        cursor_expr := format('($5 = '''' OR name COLLATE ""C"" %s $5)', cursor_op);
        sort_expr := format('name COLLATE ""C"" %s', sort_ord);
    END IF;

    RETURN QUERY EXECUTE format(
        $sql$
        SELECT * FROM (
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name,
                    NULL::uuid AS id,
                    updated_at,
                    created_at,
                    NULL::timestamptz AS last_accessed_at,
                    NULL::jsonb AS metadata
                FROM storage.prefixes
                WHERE name COLLATE ""C"" LIKE $1 || '%%'
                    AND bucket_id = $2
                    AND level = $4
                    AND %s
                ORDER BY %s
                LIMIT $3
            )
            UNION ALL
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name,
                    id,
                    updated_at,
                    created_at,
                    last_accessed_at,
                    metadata
                FROM storage.objects
                WHERE name COLLATE ""C"" LIKE $1 || '%%'
                    AND bucket_id = $2
                    AND level = $4
                    AND %s
                ORDER BY %s
                LIMIT $3
            )
        ) obj
        ORDER BY %s
        LIMIT $3
        $sql$,
        cursor_expr,    -- prefixes WHERE
        sort_expr,      -- prefixes ORDER BY
        cursor_expr,    -- objects WHERE
        sort_expr,      -- objects ORDER BY
        sort_expr       -- final ORDER BY
    )
    USING prefix, bucket_name, limits, levels, start_after, sort_column_after;
END;
$function$
"
storage,update_updated_at_column,"CREATE OR REPLACE FUNCTION storage.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$function$
"
vault,_crypto_aead_det_decrypt,"CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$
"
vault,_crypto_aead_det_encrypt,"CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$
"
vault,_crypto_aead_det_noncegen,"CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$
"
vault,create_secret,"CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  rec record;
BEGIN
  INSERT INTO vault.secrets (secret, name, description)
  VALUES (
    new_secret,
    new_name,
    new_description
  )
  RETURNING * INTO rec;
  UPDATE vault.secrets s
  SET secret = encode(vault._crypto_aead_det_encrypt(
    message := convert_to(rec.secret, 'utf8'),
    additional := convert_to(s.id::text, 'utf8'),
    key_id := 0,
    context := 'pgsodium'::bytea,
    nonce := rec.nonce
  ), 'base64')
  WHERE id = rec.id;
  RETURN rec.id;
END
$function$
"
vault,update_secret,"CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);
BEGIN
  UPDATE vault.secrets s
  SET
    secret = CASE WHEN new_secret IS NULL THEN s.secret
                  ELSE encode(vault._crypto_aead_det_encrypt(
                    message := convert_to(new_secret, 'utf8'),
                    additional := convert_to(s.id::text, 'utf8'),
                    key_id := 0,
                    context := 'pgsodium'::bytea,
                    nonce := s.nonce
                  ), 'base64') END,
    name = coalesce(new_name, s.name),
    description = coalesce(new_description, s.description),
    updated_at = now()
  WHERE s.id = secret_id;
END
$function$
"
