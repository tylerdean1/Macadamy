query,calls,total_time_ms,mean_time_ms,rows
SELECT name FROM pg_timezone_names,1396,103693.647862,74.2791173796561,1666824
"with tables as (
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          $12, c.oid::int8,
          $13, n.nspname,
          $14, c.relname,
          $15, a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      n.nspname IN ($16) AND
      
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND
      
      c.contype = $19
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  nc.nspname IN ($20) AND
  
  
  c.relkind IN ($21, $22)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $23)
    OR has_table_privilege(
      c.oid,
      $24
    )
    OR has_any_column_privilege(c.oid, $25)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys


)
  , columns as (
-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $26 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $27
  END AS default_value,
  CASE
    WHEN t.typtype = $28 THEN CASE
      WHEN bt.typelem <> $29 :: oid
      AND bt.typlen = $30 THEN $31
      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)
      ELSE $34
    END
    ELSE CASE
      WHEN t.typelem <> $35 :: oid
      AND t.typlen = $36 THEN $37
      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)
      ELSE $40
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($41, $42) AS is_identity,
  CASE
    a.attidentity
    WHEN $43 THEN $44
    WHEN $45 THEN $46
    ELSE $47
  END AS identity_generation,
  a.attgenerated IN ($48) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $49 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($50, $51)
    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $55
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$56] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $57 AND cardinality(conkey) = $58
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$59] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $60),
        $61,
        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $64 AND cardinality(conkey) = $65
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  nc.nspname IN ($66) AND
  
  
  
  
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $67
  AND NOT a.attisdropped
  AND (c.relkind IN ($68, $69, $70, $71, $72))
  AND (
    pg_has_role(c.relowner, $73)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $74
    )
  )


)
select
  *
  , 
COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $75
) AS columns
from tables",55,40384.84643,734.269935090909,3969
"WITH
-- Recursively get the base types of domains
base_types AS (
  WITH RECURSIVE
  recurse AS (
    SELECT
      oid,
      typbasetype,
      typnamespace AS base_namespace,
      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type
    FROM pg_type
    UNION
    SELECT
      t.oid,
      b.typbasetype,
      b.typnamespace AS base_namespace,
      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type
    FROM recurse t
    JOIN pg_type b ON t.typbasetype = b.oid
  )
  SELECT
    oid,
    base_namespace,
    base_type
  FROM recurse
  WHERE typbasetype = $5
),
arguments AS (
  SELECT
    oid,
    array_agg((
      COALESCE(name, $6), -- name
      type::regtype::text, -- type
      CASE type
        WHEN $7::regtype THEN $8
        WHEN $9::regtype THEN $10
        WHEN $11::regtype THEN $12
        WHEN $13::regtype THEN $14
        ELSE type::regtype::text
      END, -- convert types that ignore the length and accept any value till maximum size
      idx <= (pronargs - pronargdefaults), -- is_required
      COALESCE(mode = $15, $16) -- is_variadic
    ) ORDER BY idx) AS args,
    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments
      WHEN $17 THEN $18
      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)
      ELSE $26
    END AS callable
  FROM pg_proc,
       unnest(proargnames, proargtypes, proargmodes)
         WITH ORDINALITY AS _ (name, type, mode, idx)
  WHERE type IS NOT NULL -- only input arguments
  GROUP BY oid
)
SELECT
  pn.nspname AS proc_schema,
  p.proname AS proc_name,
  d.description AS proc_description,
  COALESCE(a.args, $27) AS args,
  tn.nspname AS schema,
  COALESCE(comp.relname, t.typname) AS name,
  p.proretset AS rettype_is_setof,
  (t.typtype = $28
   -- if any TABLE, INOUT or OUT arguments present, treat as composite
   or COALESCE(proargmodes::text[] && $29, $30)
  ) AS rettype_is_composite,
  bt.oid <> bt.base_type as rettype_is_composite_alias,
  p.provolatile,
  p.provariadic > $31 as hasvariadic,
  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,
  coalesce(func_settings.kvs, $36) as kvs
FROM pg_proc p
LEFT JOIN arguments a ON a.oid = p.oid
JOIN pg_namespace pn ON pn.oid = p.pronamespace
JOIN base_types bt ON bt.oid = p.prorettype
JOIN pg_type t ON t.oid = bt.base_type
JOIN pg_namespace tn ON tn.oid = t.typnamespace
LEFT JOIN pg_class comp ON comp.oid = t.typrelid
LEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass
LEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38
LEFT JOIN LATERAL (
  SELECT
    array_agg(row(
      substr(setting, $39, strpos(setting, $40) - $41),
      substr(setting, strpos(setting, $42) + $43)
    )) as kvs
  FROM unnest(proconfig) setting
  WHERE setting ~ ANY($2)
) func_settings ON $44
WHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)
AND prokind = $47
AND p.pronamespace = ANY($1::regnamespace[])",1397,34323.32903,24.5693121188261,311820
"WITH
-- Recursively get the base types of domains
base_types AS (
  WITH RECURSIVE
  recurse AS (
    SELECT
      oid,
      typbasetype,
      typnamespace AS base_namespace,
      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type
    FROM pg_type
    UNION
    SELECT
      t.oid,
      b.typbasetype,
      b.typnamespace AS base_namespace,
      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type
    FROM recurse t
    JOIN pg_type b ON t.typbasetype = b.oid
  )
  SELECT
    oid,
    base_namespace,
    base_type
  FROM recurse
  WHERE typbasetype = $4
),
columns AS (
    SELECT
        c.oid AS relid,
        a.attname::name AS column_name,
        d.description AS description,
        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column
        CASE
          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)
          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)
          WHEN a.attgenerated = $9 THEN $10
          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text
        END AS column_default,
        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,
        CASE
            WHEN t.typtype = $12 THEN
            CASE
                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)
                ELSE format_type(a.atttypid, a.atttypmod)
            END
            ELSE
            CASE
                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)
                ELSE format_type(a.atttypid, a.atttypmod)
            END
        END::text AS data_type,
        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,
        information_schema._pg_char_max_length(
            information_schema._pg_truetypid(a.*, t.*),
            information_schema._pg_truetypmod(a.*, t.*)
        )::integer AS character_maximum_length,
        bt.base_type,
        a.attnum::integer AS position
    FROM pg_attribute a
        LEFT JOIN pg_description AS d
            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass
        LEFT JOIN pg_attrdef ad
            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
        JOIN pg_class c
            ON a.attrelid = c.oid
        JOIN pg_type t
            ON a.atttypid = t.oid
        LEFT JOIN base_types bt
            ON t.oid = bt.oid
        LEFT JOIN pg_depend seq
            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18
    WHERE
        NOT pg_is_other_temp_schema(c.relnamespace)
        AND a.attnum > $19
        AND NOT a.attisdropped
        AND c.relkind in ($20, $21, $22, $23, $24)
        AND c.relnamespace = ANY($1::regnamespace[])
),
columns_agg AS (
  SELECT
    relid,
    array_agg(row(
      column_name,
      description,
      is_nullable::boolean,
      data_type,
      nominal_data_type,
      character_maximum_length,
      column_default,
      coalesce(
        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),
        $25
      )
    ) order by position) as columns
  FROM columns
  GROUP BY relid
),
tbl_pk_cols AS (
  SELECT
    r.oid AS relid,
    array_agg(a.attname ORDER BY a.attname) AS pk_cols
  FROM pg_class r
  JOIN pg_constraint c
    ON r.oid = c.conrelid
  JOIN pg_attribute a
    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)
  WHERE
    c.contype in ($26)
    AND r.relkind IN ($27, $28)
    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)
    AND NOT pg_is_other_temp_schema(r.relnamespace)
    AND NOT a.attisdropped
  GROUP BY r.oid
)
SELECT
  n.nspname AS table_schema,
  c.relname AS table_name,
  d.description AS table_description,
  c.relkind IN ($31,$32) as is_view,
  (
    c.relkind IN ($33,$34)
    OR (
      c.relkind in ($35,$36)
      -- The function `pg_relation_is_updateable` returns a bitmask where 8
      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.
      -- it's possible to insert into the relation.
      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39
    )
  ) AS insertable,
  (
    c.relkind IN ($40,$41)
    OR (
      c.relkind in ($42,$43)
      -- CMD_UPDATE
      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46
    )
  ) AS updatable,
  (
    c.relkind IN ($47,$48)
    OR (
      c.relkind in ($49,$50)
      -- CMD_DELETE
      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53
    )
  ) AS deletable,
  coalesce(tpks.pk_cols, $54) as pk_cols,
  coalesce(cols_agg.columns, $55) as columns
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
LEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass
LEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid
LEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid
WHERE c.relkind IN ($58,$59,$60,$61,$62)
AND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)
AND not c.relispartition
ORDER BY table_schema, table_name",1397,33851.555228,24.2316071782391,167758
"with views as (
SELECT
  c.oid :: int8 AS id,
  n.nspname AS schema,
  c.relname AS name,
  -- See definition of information_schema.views
  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,
  obj_description(c.oid) AS comment
FROM
  pg_class c
  JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE
  n.nspname IN ($4) AND
  
  
  c.relkind = $5


)
  , columns as (
-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $6 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $7
  END AS default_value,
  CASE
    WHEN t.typtype = $8 THEN CASE
      WHEN bt.typelem <> $9 :: oid
      AND bt.typlen = $10 THEN $11
      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)
      ELSE $14
    END
    ELSE CASE
      WHEN t.typelem <> $15 :: oid
      AND t.typlen = $16 THEN $17
      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)
      ELSE $20
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($21, $22) AS is_identity,
  CASE
    a.attidentity
    WHEN $23 THEN $24
    WHEN $25 THEN $26
    ELSE $27
  END AS identity_generation,
  a.attgenerated IN ($28) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $29 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($30, $31)
    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $35
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$36] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $37 AND cardinality(conkey) = $38
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$39] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $40),
        $41,
        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $44 AND cardinality(conkey) = $45
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  nc.nspname IN ($46) AND
  
  
  
  
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $47
  AND NOT a.attisdropped
  AND (c.relkind IN ($48, $49, $50, $51, $52))
  AND (
    pg_has_role(c.relowner, $53)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $54
    )
  )


)
select
  *
  , 
COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)
    FROM
      columns
  ),
  $55
) AS columns
from views",50,32448.44921,648.9689842,3347
"with f as (
      
-- CTE with sane arg_modes, arg_names, and arg_types.
-- All three are always of the same length.
-- All three include all args, including OUT and TABLE args.
with functions as (
  select
    *,
    -- proargmodes is null when all arg modes are IN
    coalesce(
      p.proargmodes,
      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_modes,
    -- proargnames is null when all args are unnamed
    coalesce(
      p.proargnames,
      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_names,
    -- proallargtypes is null when all arg modes are IN
    coalesce(p.proallargtypes, p.proargtypes) as arg_types,
    array_cat(
      array_fill($3, array[pronargs - pronargdefaults]),
      array_fill($4, array[pronargdefaults])) as arg_has_defaults
  from
    pg_proc as p
  where
    p.prokind = $5
)
select
  f.oid as id,
  n.nspname as schema,
  f.proname as name,
  l.lanname as language,
  case
    when l.lanname = $6 then $7
    else f.prosrc
  end as definition,
  case
    when l.lanname = $8 then f.prosrc
    else pg_get_functiondef(f.oid)
  end as complete_statement,
  coalesce(f_args.args, $9) as args,
  pg_get_function_arguments(f.oid) as argument_types,
  pg_get_function_identity_arguments(f.oid) as identity_argument_types,
  f.prorettype as return_type_id,
  pg_get_function_result(f.oid) as return_type,
  nullif(rt.typrelid, $10) as return_type_relation_id,
  f.proretset as is_set_returning_function,
  case
    when f.provolatile = $11 then $12
    when f.provolatile = $13 then $14
    when f.provolatile = $15 then $16
  end as behavior,
  f.prosecdef as security_definer,
  f_config.config_params as config_params
from
  functions f
  left join pg_namespace n on f.pronamespace = n.oid
  left join pg_language l on f.prolang = l.oid
  left join pg_type rt on rt.oid = f.prorettype
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as config_params
    from
      (
        select
          oid,
          (string_to_array(unnest(proconfig), $17))[$18] as param,
          (string_to_array(unnest(proconfig), $19))[$20] as value
        from
          functions
      ) as t
    group by
      oid
  ) f_config on f_config.oid = f.oid
  left join (
    select
      oid,
      jsonb_agg(jsonb_build_object(
        $21, t2.mode,
        $22, name,
        $23, type_id,
        -- Cast null into false boolean
        $24, COALESCE(has_default, $25)
      )) as args
    from
      (
        select
          oid,
          unnest(arg_modes) as mode,
          unnest(arg_names) as name,
          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume
          -- integer, we need to cast it to be properly parsed
          unnest(arg_types)::int8 as type_id,
          unnest(arg_has_defaults) as has_default
        from
          functions
      ) as t1,
      lateral (
        select
          case
            when t1.mode = $26 then $27
            when t1.mode = $28 then $29
            when t1.mode = $30 then $31
            when t1.mode = $32 then $33
            else $34
          end as mode
      ) as t2
    group by
      t1.oid
  ) f_args on f_args.oid = f.oid

    )
    select
      f.*
    from f
   where schema NOT IN ($35,$36,$37)

-- source: dashboard
-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101
-- date: 2026-02-01T06:23:07.129Z",56,29046.709733,518.691245232143,27529
"with tables as (
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          $12, c.oid::int8,
          $13, n.nspname,
          $14, c.relname,
          $15, a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      n.nspname IN ($16,$17) AND
      
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND
      
      c.contype = $22
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  nc.nspname IN ($23,$24) AND
  
  
  c.relkind IN ($25, $26)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $27)
    OR has_table_privilege(
      c.oid,
      $28
    )
    OR has_any_column_privilege(c.oid, $29)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys


)
  
select
  *
  
from tables",80,14684.666536,183.5583317,7692
"with recursive
pks_fks as (
  -- pk + fk referencing col
  select
    contype::text as contype,
    conname,
    array_length(conkey, $3) as ncol,
    conrelid as resorigtbl,
    col as resorigcol,
    ord
  from pg_constraint
  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4
  where contype IN ($5, $6)
  union
  -- fk referenced col
  select
    concat(contype, $7) as contype,
    conname,
    array_length(confkey, $8) as ncol,
    confrelid,
    col,
    ord
  from pg_constraint
  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9
  where contype=$10
),
views as (
  select
    c.oid          as view_id,
    c.relnamespace as view_schema_id,
    n.nspname      as view_schema,
    c.relname      as view_name,
    r.ev_action    as view_definition
  from pg_class c
  join pg_namespace n on n.oid = c.relnamespace
  join pg_rewrite r on r.ev_class = c.oid
  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])
),
transform_json as (
  select
    view_id, view_schema_id, view_schema, view_name,
    -- the following formatting is without indentation on purpose
    -- to allow simple diffs, with less whitespace noise
    replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      regexp_replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
        view_definition::text,
      -- This conversion to json is heavily optimized for performance.
      -- The general idea is to use as few regexp_replace() calls as possible.
      -- Simple replace() is a lot faster, so we jump through some hoops
      -- to be able to use regexp_replace() only once.
      -- This has been tested against a huge schema with 250+ different views.
      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!
      -- -----------------------------------------------
      -- pattern           | replacement         | flags
      -- -----------------------------------------------
      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof
      -- we need to make this an empty array here to prevent json_array_elements from throwing an error
      -- when the targetList is null.
      -- We'll need to put it first, to make the node protection below work for node lists that start with
      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.
         $13              , $14
      -- `,` is not part of the pg_node_tree format, but used in the regex.
      -- This removes all `,` that might be part of column names.
      ), $15               , $16
      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.
      -- We remove the escaped ones, which might be part of column names again.
      ), $17            , $18
      ), $19            , $20
      -- The fields we need are formatted as json manually to protect them from the regex.
      ), $21   , $22
      ), $23        , $24
      ), $25   , $26
      ), $27   , $28
      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.
      ), $29               , $30
      -- Protect node lists, which start with `({` or `((` from the greedy regex.
      -- The extra `{` is removed again later.
      ), $31              , $32
      ), $33              , $34
      -- This regex removes all unused fields to avoid the need to format all of them correctly.
      -- This leads to a smaller json result as well.
      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.
      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and
      -- add an empty key for the followig node.
      ), $35       , $36              , $37
      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.
      -- Those are removed next.
      ), $38           , $39
      ), $40           , $41
      -- This reverses the ""node list protection"" from above.
      ), $42              , $43
      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.
      ), $44              , $45
      -- pg_node_tree has `()` around lists, but JSON uses `[]`
      ), $46               , $47
      ), $48               , $49
      -- pg_node_tree has ` ` between list items, but JSON uses `,`
      ), $50             , $51
    )::json as view_definition
  from views
),
target_entries as(
  select
    view_id, view_schema_id, view_schema, view_name,
    json_array_elements(view_definition->$52->$53) as entry
  from transform_json
),
results as(
  select
    view_id, view_schema_id, view_schema, view_name,
    (entry->>$54)::int as view_column,
    (entry->>$55)::oid as resorigtbl,
    (entry->>$56)::int as resorigcol
  from target_entries
),
-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE
-- Can be replaced with CYCLE clause once PG v13 is EOL.
recursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(
  select
    r.*,
    $57,
    ARRAY[resorigtbl]
  from results r
  where view_schema_id = ANY ($1::regnamespace[])
  union all
  select
    view.view_id,
    view.view_schema_id,
    view.view_schema,
    view.view_name,
    view.view_column,
    tab.resorigtbl,
    tab.resorigcol,
    tab.resorigtbl = ANY(path),
    path || tab.resorigtbl
  from recursion view
  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column
  where not is_cycle
),
repeated_references as(
  select
    view_id,
    view_schema,
    view_name,
    resorigtbl,
    resorigcol,
    array_agg(attname) as view_columns
  from recursion
  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column
  group by
    view_id,
    view_schema,
    view_name,
    resorigtbl,
    resorigcol
)
select
  sch.nspname as table_schema,
  tbl.relname as table_name,
  rep.view_schema,
  rep.view_name,
  pks_fks.conname as constraint_name,
  pks_fks.contype as constraint_type,
  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies
from repeated_references rep
join pks_fks using (resorigtbl, resorigcol)
join pg_class tbl on tbl.oid = rep.resorigtbl
join pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol
join pg_namespace sch on sch.oid = tbl.relnamespace
group by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol
-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs
having ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",1397,13353.197756,9.55848085612025,64172
"SELECT
  e.name,
  n.nspname AS schema,
  e.default_version,
  x.extversion AS installed_version,
  e.comment
FROM
  pg_available_extensions() e(name, default_version, comment)
  LEFT JOIN pg_extension x ON e.name = x.extname
  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid
WHERE
  $1",100,9967.864957,99.67864957,7800
"SELECT
    tbl.schemaname,
    tbl.tablename,
    tbl.quoted_name,
    tbl.is_table,
    json_agg(a) as columns
  FROM
    (
      SELECT
        n.nspname as schemaname,
        c.relname as tablename,
        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,
        $2 as is_table
      FROM
        pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
      WHERE
        c.relkind = $3
        AND n.nspname not in ($4, $5, $6)
        AND n.nspname not like $7
        AND n.nspname not like $8
        AND has_schema_privilege(n.oid, $9) = $10
        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13
      union all
      SELECT
        n.nspname as schemaname,
        c.relname as tablename,
        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,
        $15 as is_table
      FROM
        pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
      WHERE
        c.relkind in ($16, $17)
        AND n.nspname not in ($18, $19, $20)
        AND n.nspname not like $21
        AND n.nspname not like $22
        AND has_schema_privilege(n.oid, $23) = $24
        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27
    ) as tbl
    LEFT JOIN (
      SELECT
        attrelid,
        attname,
        format_type(atttypid, atttypmod) as data_type,
        attnum,
        attisdropped
      FROM
        pg_attribute
    ) as a ON (
      a.attrelid = tbl.quoted_name::regclass
      AND a.attnum > $28
      AND NOT a.attisdropped
      AND has_column_privilege(tbl.quoted_name, a.attname, $29)
    )
  
  GROUP BY schemaname, tablename, quoted_name, is_table",54,9479.365463,175.54380487037,11508
"-- CTE with sane arg_modes, arg_names, and arg_types.
-- All three are always of the same length.
-- All three include all args, including OUT and TABLE args.
with functions as (
  select
    p.*,
    -- proargmodes is null when all arg modes are IN
    coalesce(
      p.proargmodes,
      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_modes,
    -- proargnames is null when all args are unnamed
    coalesce(
      p.proargnames,
      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_names,
    -- proallargtypes is null when all arg modes are IN
    coalesce(p.proallargtypes, p.proargtypes) as arg_types,
    array_cat(
      array_fill($3, array[pronargs - pronargdefaults]),
      array_fill($4, array[pronargdefaults])) as arg_has_defaults
  from
    pg_proc as p
    join pg_namespace n on p.pronamespace = n.oid
  where
    n.nspname IN ($5,$6) AND
    
    
    
    p.prokind = $7
)
select
  f.oid::int8 as id,
  n.nspname as schema,
  f.proname as name,
  l.lanname as language,
  case
    when l.lanname = $8 then $9
    else f.prosrc
  end as definition,
  case
    when l.lanname = $10 then f.prosrc
    else pg_get_functiondef(f.oid)
  end as complete_statement,
  coalesce(f_args.args, $11) as args,
  pg_get_function_arguments(f.oid) as argument_types,
  pg_get_function_identity_arguments(f.oid) as identity_argument_types,
  f.prorettype::int8 as return_type_id,
  pg_get_function_result(f.oid) as return_type,
  nullif(rt.typrelid::int8, $12) as return_type_relation_id,
  f.proretset as is_set_returning_function,
  case
    when f.proretset then nullif(f.prorows, $13)
    else $14
  end as prorows,
  case
    when f.provolatile = $15 then $16
    when f.provolatile = $17 then $18
    when f.provolatile = $19 then $20
  end as behavior,
  f.prosecdef as security_definer,
  f_config.config_params as config_params
from
  functions f
  left join pg_namespace n on f.pronamespace = n.oid
  left join pg_language l on f.prolang = l.oid
  left join pg_type rt on rt.oid = f.prorettype
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as config_params
    from
      (
        select
          oid,
          (string_to_array(unnest(proconfig), $21))[$22] as param,
          (string_to_array(unnest(proconfig), $23))[$24] as value
        from
          functions
      ) as t
    group by
      oid
  ) f_config on f_config.oid = f.oid
  left join (
    select
      oid,
      jsonb_agg(jsonb_build_object(
        $25, t2.mode,
        $26, name,
        $27, type_id,
        $28, has_default
      )) as args
    from
      (
        select
          oid,
          unnest(arg_modes) as mode,
          unnest(arg_names) as name,
          unnest(arg_types)::int8 as type_id,
          unnest(arg_has_defaults) as has_default
        from
          functions
      ) as t1,
      lateral (
        select
          case
            when t1.mode = $29 then $30
            when t1.mode = $31 then $32
            when t1.mode = $33 then $34
            when t1.mode = $35 then $36
            else $37
          end as mode
      ) as t2
    group by
      t1.oid
  ) f_args on f_args.oid = f.oid",80,6978.442858,87.230535725,26106
"-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $1 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $2
  END AS default_value,
  CASE
    WHEN t.typtype = $3 THEN CASE
      WHEN bt.typelem <> $4 :: oid
      AND bt.typlen = $5 THEN $6
      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)
      ELSE $9
    END
    ELSE CASE
      WHEN t.typelem <> $10 :: oid
      AND t.typlen = $11 THEN $12
      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)
      ELSE $15
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($16, $17) AS is_identity,
  CASE
    a.attidentity
    WHEN $18 THEN $19
    WHEN $20 THEN $21
    ELSE $22
  END AS identity_generation,
  a.attgenerated IN ($23) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $24 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($25, $26)
    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $30
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$31] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $32 AND cardinality(conkey) = $33
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$34] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $35),
        $36,
        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $39 AND cardinality(conkey) = $40
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  nc.nspname IN ($41,$42) AND
  
  
  
  
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $43
  AND NOT a.attisdropped
  AND (c.relkind IN ($44, $45, $46, $47, $48))
  AND (
    pg_has_role(c.relowner, $49)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $50
    )
  )",80,6176.415442,77.205193025,114718
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM ""public"".""fn_list_tables_and_columns""() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT ""record"".* FROM ""pgrst_source"" AS ""record""   LIMIT $1 OFFSET $2) _postgrest_t",113,5259.748893,46.546450380531,113
"with table_privileges as (
-- Despite the name `table_privileges`, this includes other kinds of relations:
-- views, matviews, etc. ""Relation privileges"" just doesn't roll off the tongue.
--
-- For each relation, get its relacl in a jsonb format,
-- e.g.
--
-- '{postgres=arwdDxt/postgres}'
--
-- becomes
--
-- [
--   {
--     ""grantee"": ""postgres"",
--     ""grantor"": ""postgres"",
--     ""is_grantable"": false,
--     ""privilege_type"": ""INSERT""
--   },
--   ...
-- ]
select
  c.oid as relation_id,
  nc.nspname as schema,
  c.relname as name,
  case
    when c.relkind = $1 then $2
    when c.relkind = $3 then $4
    when c.relkind = $5 then $6
    when c.relkind = $7 then $8
    when c.relkind = $9 then $10
  end as kind,
  coalesce(
    jsonb_agg(
      jsonb_build_object(
        $11, grantor.rolname,
        $12, grantee.rolname,
        $13, _priv.privilege_type,
        $14, _priv.is_grantable
      )
    ) filter (where _priv is not null),
    $15
  ) as privileges
from pg_class c
join pg_namespace as nc
  on nc.oid = c.relnamespace
left join lateral (
  select grantor, grantee, privilege_type, is_grantable
  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))
) as _priv on $17
left join pg_roles as grantor
  on grantor.oid = _priv.grantor
left join (
  select
    pg_roles.oid,
    pg_roles.rolname
  from pg_roles
  union all
  select
    ($18)::oid as oid, $19
) as grantee (oid, rolname)
  on grantee.oid = _priv.grantee
where c.relkind in ($20, $21, $22, $23, $24)
  and not pg_is_other_temp_schema(c.relnamespace)
  and (
    pg_has_role(c.relowner, $25)
    or has_table_privilege(
      c.oid,
      $26
      || case when current_setting($27)::int4 >= $28 then $29 else $30 end
    )
    or has_any_column_privilege(c.oid, $31)
  )
group by
  c.oid,
  nc.nspname,
  c.relname,
  c.relkind
)
select *
from table_privileges
 where schema NOT IN ($32,$33,$34)

-- source: dashboard
-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101
-- date: 2026-02-01T06:16:21.723Z",22,4059.943647,184.542893045455,4573
"SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = $1 THEN $2::""char"" ELSE $3::""char"" END, c.relowner) AS acldefault, CASE WHEN c.relkind = $4 THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE $5 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, $6 AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,$7),$8) AS reloptions, CASE WHEN $9 = ANY (c.reloptions) THEN $10::text WHEN $11 = ANY (c.reloptions) THEN $12::text ELSE $13 END AS checkoption, am.amname, (d.deptype = $14) IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
FROM pg_class c
LEFT JOIN pg_depend d ON (c.relkind = $15 AND d.classid = $16::regclass AND d.objid = c.oid AND d.objsubid = $17 AND d.refclassid = $18::regclass AND d.deptype IN ($19, $20))
LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
LEFT JOIN pg_am am ON (c.relam = am.oid)
LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = $21 AND c.relkind <> $22)
WHERE c.relkind IN ($23, $24, $25, $26, $27, $28, $29)
ORDER BY c.oid",36,3448.801096,95.8000304444444,14824
"with tables as (
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          $12, c.oid::int8,
          $13, n.nspname,
          $14, c.relname,
          $15, a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = $16
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ($17, $18)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $19)
    OR has_table_privilege(
      c.oid,
      $20
    )
    OR has_any_column_privilege(c.oid, $21)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
)
  , columns as (
-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $22 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $23
  END AS default_value,
  CASE
    WHEN t.typtype = $24 THEN CASE
      WHEN bt.typelem <> $25 :: oid
      AND bt.typlen = $26 THEN $27
      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)
      ELSE $30
    END
    ELSE CASE
      WHEN t.typelem <> $31 :: oid
      AND t.typlen = $32 THEN $33
      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)
      ELSE $36
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($37, $38) AS is_identity,
  CASE
    a.attidentity
    WHEN $39 THEN $40
    WHEN $41 THEN $42
    ELSE $43
  END AS identity_generation,
  a.attgenerated IN ($44) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $45 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($46, $47)
    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $51
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$52] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $53 AND cardinality(conkey) = $54
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$55] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $56),
        $57,
        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $60 AND cardinality(conkey) = $61
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $62
  AND NOT a.attisdropped
  AND (c.relkind IN ($63, $64, $65, $66, $67))
  AND (
    pg_has_role(c.relowner, $68)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $69
    )
  )
)
  select
    *
    , 
COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $70
) AS columns
  from tables where name = $71 and schema = $72",30,3255.608133,108.5202711,30
"with
role_setting as (
  select r.rolname, unnest(r.rolconfig) as setting
  from pg_auth_members m
  join pg_roles r on r.oid = m.roleid
  where member = current_user::regrole::oid
),
kv_settings AS (
  SELECT
    rolname,
    substr(setting, $1, strpos(setting, $2) - $3) as key,
    lower(substr(setting, strpos(setting, $4) + $5)) as value
  FROM role_setting
),
iso_setting AS (
  SELECT rolname, value
  FROM kv_settings
  WHERE key = $6
)
select
  kv.rolname,
  i.value as iso_lvl,
  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings
from kv_settings kv
join pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))
left join iso_setting i on i.rolname = kv.rolname
group by kv.rolname, i.value",1397,2836.51774799999,2.03043503793844,2794
"with
all_relations as (
  select reltype
  from pg_class
  where relkind in ($1,$2,$3,$4,$5)
),
computed_rels as (
  select
    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,
    p.proname::text                  as name,
    arg_schema.nspname::text         as rel_table_schema,
    arg_name.typname::text           as rel_table_name,
    ret_schema.nspname::text         as rel_ftable_schema,
    ret_name.typname::text           as rel_ftable_name,
    not p.proretset or p.prorows = $7 as single_row
  from pg_proc p
    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]
    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace
    join pg_type      ret_name   on ret_name.oid = p.prorettype
    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace
  where
    p.pronargs = $9
    and p.proargtypes[$10] in (select reltype from all_relations)
    and p.prorettype in (select reltype from all_relations)
)
select
  *,
  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self
from computed_rels",1397,2365.774295,1.69346764137437,0
"with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",104,2117.180412,20.3575039615385,103
"-- Adapted from
-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820
with recursive
pks_fks as (
  -- pk + fk referencing col
  select
    contype::text as contype,
    conname,
    array_length(conkey, $1) as ncol,
    conrelid as resorigtbl,
    col as resorigcol,
    ord
  from pg_constraint
  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2
  where contype IN ($3, $4)
  union
  -- fk referenced col
  select
    concat(contype, $5) as contype,
    conname,
    array_length(confkey, $6) as ncol,
    confrelid,
    col,
    ord
  from pg_constraint
  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7
  where contype=$8
  and connamespace::regnamespace::text IN ($9,$10)
),
views as (
  select
    c.oid       as view_id,
    n.nspname   as view_schema,
    c.relname   as view_name,
    r.ev_action as view_definition
  from pg_class c
  join pg_namespace n on n.oid = c.relnamespace
  join pg_rewrite r on r.ev_class = c.oid
  where c.relkind in ($11, $12) 
    and n.nspname IN ($13,$14)
),
transform_json as (
  select
    view_id, view_schema, view_name,
    -- the following formatting is without indentation on purpose
    -- to allow simple diffs, with less whitespace noise
    replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      regexp_replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
      replace(
        view_definition::text,
      -- This conversion to json is heavily optimized for performance.
      -- The general idea is to use as few regexp_replace() calls as possible.
      -- Simple replace() is a lot faster, so we jump through some hoops
      -- to be able to use regexp_replace() only once.
      -- This has been tested against a huge schema with 250+ different views.
      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!
      -- -----------------------------------------------
      -- pattern           | replacement         | flags
      -- -----------------------------------------------
      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof
      -- we need to make this an empty array here to prevent json_array_elements from throwing an error
      -- when the targetList is null.
      -- We'll need to put it first, to make the node protection below work for node lists that start with
      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.
         $15              , $16
      -- , is not part of the pg_node_tree format, but used in the regex.
      -- This removes all , that might be part of column names.
      ), $17               , $18
      -- The same applies for { and }, although those are used a lot in pg_node_tree.
      -- We remove the escaped ones, which might be part of column names again.
      ), $19            , $20
      ), $21            , $22
      -- The fields we need are formatted as json manually to protect them from the regex.
      ), $23   , $24
      ), $25        , $26
      ), $27   , $28
      ), $29   , $30
      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.
      ), $31               , $32
      -- Protect node lists, which start with `({` or `((` from the greedy regex.
      -- The extra `{` is removed again later.
      ), $33              , $34
      ), $35              , $36
      -- This regex removes all unused fields to avoid the need to format all of them correctly.
      -- This leads to a smaller json result as well.
      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.
      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and
      -- add an empty key for the followig node.
      ), $37       , $38              , $39
      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.
      -- Those are removed next.
      ), $40           , $41
      ), $42           , $43
      -- This reverses the ""node list protection"" from above.
      ), $44              , $45
      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.
      ), $46              , $47
      -- pg_node_tree has `()` around lists, but JSON uses `[]`
      ), $48               , $49
      ), $50               , $51
      -- pg_node_tree has ` ` between list items, but JSON uses `,`
      ), $52             , $53
    )::json as view_definition
  from views
),
target_entries as(
  select
    view_id, view_schema, view_name,
    json_array_elements(view_definition->$54->$55) as entry
  from transform_json
),
results as(
  select
    view_id, view_schema, view_name,
    (entry->>$56)::int as view_column,
    (entry->>$57)::oid as resorigtbl,
    (entry->>$58)::int as resorigcol
  from target_entries
),
-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE
-- Can be replaced with CYCLE clause once PG v13 is EOL.
recursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(
  select
    r.*,
    $59,
    ARRAY[resorigtbl]
  from results r
  where view_schema IN ($60,$61)
  union all
  select
    view.view_id,
    view.view_schema,
    view.view_name,
    view.view_column,
    tab.resorigtbl,
    tab.resorigcol,
    tab.resorigtbl = ANY(path),
    path || tab.resorigtbl
  from recursion view
  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column
  where not is_cycle
),
repeated_references as(
  select
    view_id,
    view_schema,
    view_name,
    resorigtbl,
    resorigcol,
    array_agg(attname) as view_columns
  from recursion
  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column
  group by
    view_id,
    view_schema,
    view_name,
    resorigtbl,
    resorigcol
)
select
  sch.nspname as table_schema,
  tbl.relname as table_name,
  rep.view_schema,
  rep.view_name,
  pks_fks.conname as constraint_name,
  pks_fks.contype as constraint_type,
  jsonb_agg(
    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord
  ) as column_dependencies
from repeated_references rep
join pks_fks using (resorigtbl, resorigcol)
join pg_class tbl on tbl.oid = rep.resorigtbl
join pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol
join pg_namespace sch on sch.oid = tbl.relnamespace
group by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol
-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs
having ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",80,2106.986161,26.3373270125,26088
"select
  t.oid::int8 as id,
  t.typname as name,
  n.nspname as schema,
  format_type (t.oid, $1) as format,
  coalesce(t_enums.enums, $2) as enums,
  coalesce(t_attributes.attributes, $3) as attributes,
  obj_description (t.oid, $4) as comment,
  nullif(t.typrelid::int8, $5) as type_relation_id
from
  pg_type t
  left join pg_namespace n on n.oid = t.typnamespace
  left join (
    select
      enumtypid,
      jsonb_agg(enumlabel order by enumsortorder) as enums
    from
      pg_enum
    group by
      enumtypid
  ) as t_enums on t_enums.enumtypid = t.oid
  left join (
    select
      oid,
      jsonb_agg(
        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)
        order by a.attnum asc
      ) as attributes
    from
      pg_class c
      join pg_attribute a on a.attrelid = c.oid
    where
      c.relkind = $8 and not a.attisdropped
    group by
      c.oid
  ) as t_attributes on t_attributes.oid = t.typrelid
  where
      (
        t.typrelid = $9
        or (
          select
            c.relkind in ($10, $11, $12, $13, $14)
          from
            pg_class c
          where
            c.oid = t.typrelid
        )
      )",80,1873.557554,23.419469425,83576
"WITH
pks_uniques_cols AS (
  SELECT
    conrelid,
    array_agg(key order by key) as cols
  FROM pg_constraint,
  LATERAL unnest(conkey) AS _(key)
  WHERE
    contype IN ($1, $2)
    AND connamespace <> $3::regnamespace
  GROUP BY oid, conrelid
)
SELECT
  ns1.nspname AS table_schema,
  tab.relname AS table_name,
  ns2.nspname AS foreign_table_schema,
  other.relname AS foreign_table_name,
  traint.conrelid = traint.confrelid AS is_self,
  traint.conname  AS constraint_name,
  column_info.cols_and_fcols,
  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one
FROM pg_constraint traint
JOIN LATERAL (
  SELECT
    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,
    array_agg(cols.attnum order by cols.attnum) AS cols
  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)
  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col
  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref
) AS column_info ON $4
JOIN pg_namespace ns1 ON ns1.oid = traint.connamespace
JOIN pg_class tab ON tab.oid = traint.conrelid
JOIN pg_class other ON other.oid = traint.confrelid
JOIN pg_namespace ns2 ON ns2.oid = other.relnamespace
WHERE traint.contype = $5
AND traint.conparentid = $6
ORDER BY traint.conrelid, traint.conname",1397,1715.286118,1.22783544595562,46811
"WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""p_organization_id"", ""p_members_page"", ""p_page_size"" FROM json_to_record(pgrst_payload.json_data) AS _(""p_organization_id"" uuid, ""p_members_page"" integer, ""p_page_size"" integer) LIMIT $4) pgrst_body , LATERAL (SELECT ""public"".""rpc_org_dashboard_payload""(""p_organization_id"" := pgrst_body.""p_organization_id"", ""p_members_page"" := pgrst_body.""p_members_page"", ""p_page_size"" := pgrst_body.""p_page_size"") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT ""rpc_org_dashboard_payload"".* FROM ""pgrst_source"" AS ""rpc_org_dashboard_payload""   LIMIT $2 OFFSET $3) _postgrest_t",88,1485.024353,16.8752767386364,88
SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef,2848,1301.024127,0.456820269311797,2848
"PREPARE dumpFunc(pg_catalog.oid) AS
SELECT
proretset,
prosrc,
probin,
provolatile,
proisstrict,
prosecdef,
lanname,
proconfig,
procost,
prorows,
pg_catalog.pg_get_function_arguments(p.oid) AS funcargs,
pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,
pg_catalog.pg_get_function_result(p.oid) AS funcresult,
proleakproof,
array_to_string(protrftypes, $2) AS protrftypes,
proparallel,
prokind,
prosupport,
pg_get_function_sqlbody(p.oid) AS prosqlbody
FROM pg_catalog.pg_proc p, pg_catalog.pg_language l
WHERE p.oid = $1 AND l.oid = p.prolang",12281,1230.18216,0.100169543196808,12281
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM ""public"".""get_my_profile""() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""profiles"".* FROM ""pgrst_source"" AS ""profiles""   LIMIT $1 OFFSET $2) _postgrest_t",475,1203.426561,2.53352960210526,475
"CREATE OR REPLACE FUNCTION pg_temp.count_estimate(
    query text
) RETURNS integer LANGUAGE plpgsql AS $$
DECLARE
    plan jsonb;
BEGIN
    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;
    RETURN plan->0->'Plan'->'Plan Rows';
END;
$$",48,1039.996381,21.6665912708333,0
"with materialized_views as (
select
  c.oid::int8 as id,
  n.nspname as schema,
  c.relname as name,
  c.relispopulated as is_populated,
  obj_description(c.oid) as comment
from
  pg_class c
  join pg_namespace n on n.oid = c.relnamespace
where
  n.nspname IN ($1) AND
  
  
  c.relkind = $2


)
  , columns as (
-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $3 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $4
  END AS default_value,
  CASE
    WHEN t.typtype = $5 THEN CASE
      WHEN bt.typelem <> $6 :: oid
      AND bt.typlen = $7 THEN $8
      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)
      ELSE $11
    END
    ELSE CASE
      WHEN t.typelem <> $12 :: oid
      AND t.typlen = $13 THEN $14
      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)
      ELSE $17
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($18, $19) AS is_identity,
  CASE
    a.attidentity
    WHEN $20 THEN $21
    WHEN $22 THEN $23
    ELSE $24
  END AS identity_generation,
  a.attgenerated IN ($25) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $26 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($27, $28)
    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $32
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$33] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $34 AND cardinality(conkey) = $35
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$36] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $37),
        $38,
        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $41 AND cardinality(conkey) = $42
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  nc.nspname IN ($43) AND
  
  
  
  
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $44
  AND NOT a.attisdropped
  AND (c.relkind IN ($45, $46, $47, $48, $49))
  AND (
    pg_has_role(c.relowner, $50)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $51
    )
  )


)
select
  *
  , 
COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)
    FROM
      columns
  ),
  $52
) AS columns
from materialized_views",50,896.677722,17.93355444,38
"SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",5,783.325132,156.6650264,5
"SELECT
  c.castsource::regtype::text,
  c.casttarget::regtype::text,
  c.castfunc::regproc::text
FROM
  pg_catalog.pg_cast c
JOIN pg_catalog.pg_type src_t
  ON c.castsource::oid = src_t.oid
JOIN pg_catalog.pg_type dst_t
  ON c.casttarget::oid = dst_t.oid
WHERE
  c.castcontext = $1
  AND c.castmethod = $2
  AND has_function_privilege(c.castfunc, $3)
  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))
   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",1397,667.382252000001,0.477725305654975,0
"SELECT
  pol.oid :: int8 AS id,
  n.nspname AS schema,
  c.relname AS table,
  c.oid :: int8 AS table_id,
  pol.polname AS name,
  CASE
    WHEN pol.polpermissive THEN $1 :: text
    ELSE $2 :: text
  END AS action,
  CASE
    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(
      string_to_array($4 :: text, $5 :: text) :: name []
    )
    ELSE array_to_json(
      ARRAY(
        SELECT
          pg_roles.rolname
        FROM
          pg_roles
        WHERE
          pg_roles.oid = ANY (pol.polroles)
        ORDER BY
          pg_roles.rolname
      )
    )
  END AS roles,
  CASE
    pol.polcmd
    WHEN $6 :: ""char"" THEN $7 :: text
    WHEN $8 :: ""char"" THEN $9 :: text
    WHEN $10 :: ""char"" THEN $11 :: text
    WHEN $12 :: ""char"" THEN $13 :: text
    WHEN $14 :: ""char"" THEN $15 :: text
    ELSE $16 :: text
  END AS command,
  pg_get_expr(pol.polqual, pol.polrelid) AS definition,
  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check
FROM
  pg_policy pol
  JOIN pg_class c ON c.oid = pol.polrelid
  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE
  n.nspname NOT IN ($17,$18,$19)",24,664.760387,27.6983494583333,9760
"SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid",36,644.090406,17.8914001666667,189526
"select
  t.oid::int8 as id,
  t.typname as name,
  n.nspname as schema,
  format_type (t.oid, $1) as format,
  coalesce(t_enums.enums, $2) as enums,
  coalesce(t_attributes.attributes, $3) as attributes,
  obj_description (t.oid, $4) as comment,
  nullif(t.typrelid::int8, $5) as type_relation_id
from
  pg_type t
  left join pg_namespace n on n.oid = t.typnamespace
  left join (
    select
      enumtypid,
      jsonb_agg(enumlabel order by enumsortorder) as enums
    from
      pg_enum
    group by
      enumtypid
  ) as t_enums on t_enums.enumtypid = t.oid
  left join (
    select
      oid,
      jsonb_agg(
        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)
        order by a.attnum asc
      ) as attributes
    from
      pg_class c
      join pg_attribute a on a.attrelid = c.oid
    where
      c.relkind = $8 and not a.attisdropped
    group by
      c.oid
  ) as t_attributes on t_attributes.oid = t.typrelid
  where
      (
        t.typrelid = $9
        or (
          select
            c.relkind = $10
          from
            pg_class c
          where
            c.oid = t.typrelid
        )
      )
      and not exists (
                 select
                 from
                   pg_type el
                 where
                   el.oid = t.typelem
                   and el.typarray = t.oid
               )
      and n.nspname NOT IN ($11,$12,$13)",46,596.622214,12.9700481304348,1236
"with views as (
SELECT
  c.oid :: int8 AS id,
  n.nspname AS schema,
  c.relname AS name,
  -- See definition of information_schema.views
  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,
  obj_description(c.oid) AS comment
FROM
  pg_class c
  JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE
  n.nspname IN ($4,$5) AND
  
  
  c.relkind = $6


)
  
select
  *
  
from views",80,590.210851,7.3776356375,5984
"with
all_relations as (
  select reltype
  from pg_class
  where relkind in ($2,$3,$4,$5,$6)
  union
  select oid
  from pg_type
  where typname = $7
),
media_types as (
    SELECT
      t.oid,
      lower(t.typname) as typname,
      t.typnamespace,
      case t.typname
        when $8 then $9
        else t.typname
      end as resolved_media_type
    FROM pg_type t
    JOIN pg_type b ON t.typbasetype = b.oid
    WHERE
      t.typbasetype <> $10 and
      (t.typname ~* $11 or t.typname = $12)
)
select
  proc_schema.nspname           as handler_schema,
  proc.proname                  as handler_name,
  arg_schema.nspname::text      as target_schema,
  arg_name.typname::text        as target_name,
  media_types.typname           as media_type,
  media_types.resolved_media_type
from media_types
  join pg_proc      proc         on proc.prorettype = media_types.oid
  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace
  join pg_aggregate agg          on agg.aggfnoid = proc.oid
  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]
  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace
where
  proc.pronamespace = ANY($1::regnamespace[]) and
  proc.pronargs = $14 and
  arg_name.oid in (select reltype from all_relations)
union
select
    typ_sch.nspname as handler_schema,
    mtype.typname   as handler_name,
    pro_sch.nspname as target_schema,
    proname         as target_name,
    mtype.typname   as media_type,
    mtype.resolved_media_type
from pg_proc proc
  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace
  join media_types mtype on proc.prorettype = mtype.oid
  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace
where
  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset
  and prokind = $15",1397,571.449586,0.409054821760916,0
"SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, $1) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $2) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $3) AS indstatvals, i.indnullsnotdistinct FROM unnest($4::pg_catalog.oid[]) AS src(tbloid)
JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ($5,$6,$7)) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = $8) AND i.indisready ORDER BY i.indrelid, indexname",36,544.603807,15.1278835277778,10108
"SELECT
a.attrelid,
a.attnum,
a.attname,
a.attstattarget,
a.attstorage,
t.typstorage,
a.attnotnull,
a.atthasdef,
a.attisdropped,
a.attlen,
a.attalign,
a.attislocal,
pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
array_to_string(a.attoptions, $1) AS attoptions,
CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE $2 END AS attcollation,
pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || $3 || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), $4) AS attfdwoptions,
a.attcompression AS attcompression,
a.attidentity,
CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE $5 END AS attmissingval,
a.attgenerated
FROM unnest($6::pg_catalog.oid[]) AS src(tbloid)
JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
WHERE a.attnum > $7::pg_catalog.int2
ORDER BY a.attrelid, a.attnum",36,477.764626,13.2712396111111,53780
"-- Adapted from information_schema.schemata

select
  n.oid as id,
  n.nspname as name,
  u.rolname as owner,
   obj_description(n.oid, $1) AS comment
from
  pg_namespace n,
  pg_roles u
where
  n.nspowner = u.oid
  and (
    pg_has_role(n.nspowner, $2)
    or has_schema_privilege(n.oid, $3)
  )
  and not pg_catalog.starts_with(n.nspname, $4)
  and not pg_catalog.starts_with(n.nspname, $5)
 and not (n.nspname in ($6,$7,$8))

-- source: dashboard
-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101
-- date: 2026-02-01T01:59:40.011Z",113,472.05049,4.17743796460177,1017
"with tables as (
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          $12, c.oid::int8,
          $13, n.nspname,
          $14, c.relname,
          $15, a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      n.nspname IN ($16) AND
      
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND
      
      c.contype = $19
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  nc.nspname IN ($20) AND
  
  
  c.relkind IN ($21, $22)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $23)
    OR has_table_privilege(
      c.oid,
      $24
    )
    OR has_any_column_privilege(c.oid, $25)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys


)
  
select
  *
  
from tables",13,469.941505,36.1493465384615,532
"ALTER TABLE public.avatars ADD COLUMN is_preset bool
    DEFAULT 'false'
    NOT NULL",1,420.238451,420.238451,0
"-- Adapted from
-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722
WITH
pks_uniques_cols AS (
  SELECT
    connamespace,
    conrelid,
    jsonb_agg(column_info.cols) as cols
  FROM pg_constraint
  JOIN lateral (
    SELECT array_agg(cols.attname order by cols.attnum) as cols
    FROM ( select unnest(conkey) as col) _
    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col
  ) column_info ON $1
  WHERE
    contype IN ($2, $3) and
    connamespace::regnamespace::text <> $4
    and connamespace::regnamespace::text IN ($5,$6)
  GROUP BY connamespace, conrelid
)
SELECT
  traint.conname AS foreign_key_name,
  ns1.nspname AS schema,
  tab.relname AS relation,
  column_info.cols AS columns,
  ns2.nspname AS referenced_schema,
  other.relname AS referenced_relation,
  column_info.refs AS referenced_columns,
  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one
FROM pg_constraint traint
JOIN LATERAL (
  SELECT
    jsonb_agg(cols.attname order by ord) AS cols,
    jsonb_agg(refs.attname order by ord) AS refs
  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)
  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col
  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref
  WHERE traint.connamespace::regnamespace::text IN ($7,$8)
) AS column_info ON $9
JOIN pg_namespace ns1 ON ns1.oid = traint.connamespace
JOIN pg_class tab ON tab.oid = traint.conrelid
JOIN pg_class other ON other.oid = traint.confrelid
JOIN pg_namespace ns2 ON ns2.oid = other.relnamespace
LEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid
WHERE traint.contype = $10
AND traint.conparentid = $11
and ns1.nspname IN ($12,$13)",80,417.70789,5.221348625,10019
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM ""public"".""get_job_titles_public""() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT ""job_titles"".* FROM ""pgrst_source"" AS ""job_titles""   LIMIT $1 OFFSET $2) _postgrest_t",391,416.396113,1.06495169565218,391
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""p_query"" FROM json_to_record(pgrst_payload.json_data) AS _(""p_query"" text) LIMIT $4) pgrst_body , LATERAL ""public"".""get_organizations_public""(""p_query"" := pgrst_body.""p_query"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""record"".* FROM ""pgrst_source"" AS ""record""   LIMIT $2 OFFSET $3) _postgrest_t",298,410.95613,1.37904741610738,298
"COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",1,405.91149,405.91149,496
"SELECT pg_catalog.obj_description($1::regnamespace, $2)",92,396.812123,4.31317525,92
"INSERT INTO ""refresh_tokens"" (""created_at"", ""instance_id"", ""parent"", ""revoked"", ""session_id"", ""token"", ""updated_at"", ""user_id"") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",69,396.493198,5.74627823188406,69
"SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault($1, p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = $2::regclass AND pip.objsubid = $3) WHERE p.prokind <> $4
  AND NOT EXISTS (SELECT $5 FROM pg_depend WHERE classid = $6::regclass AND objid = p.oid AND deptype = $7)
  AND (
  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = $8)
  OR EXISTS (SELECT $9 FROM pg_cast
  WHERE pg_cast.oid > $10 
  AND p.oid = pg_cast.castfunc)
  OR EXISTS (SELECT $11 FROM pg_transform
  WHERE pg_transform.oid > $12 AND 
  (p.oid = pg_transform.trffromsql
  OR p.oid = pg_transform.trftosql))
  OR p.proacl IS DISTINCT FROM pip.initprivs)",36,396.306517,11.0085143611111,16637
"SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != $1 AND deptype != $2
UNION ALL
SELECT $3::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ($4, $5, $6) AND classid = $7::regclass AND objid = o.oid AND NOT (refclassid = $8::regclass AND amopfamily = refobjid)
UNION ALL
SELECT $9::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ($10, $11, $12) AND classid = $13::regclass AND objid = p.oid AND NOT (refclassid = $14::regclass AND amprocfamily = refobjid)
ORDER BY 1,2",36,394.801907,10.9667196388889,274216
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""_filters"", ""_order_by"", ""_direction"" FROM json_to_record(pgrst_payload.json_data) AS _(""_filters"" jsonb, ""_order_by"" text, ""_direction"" text) LIMIT $4) pgrst_body , LATERAL ""public"".""filter_projects""(""_filters"" := pgrst_body.""_filters"", ""_order_by"" := pgrst_body.""_order_by"", ""_direction"" := pgrst_body.""_direction"") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT ""projects"".* FROM ""pgrst_source"" AS ""projects""   LIMIT $2 OFFSET $3) _postgrest_t",36,393.437611,10.9288225277778,36
"SELECT tableoid, oid, typname, typnamespace, typacl, acldefault($1, typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = $2 THEN $3::""char"" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[$4] = $5 AND typelem != $6 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type",36,383.257885,10.6460523611111,38148
"-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size
WITH tables AS (
  SELECT
    c.oid                                         AS table_oid,
    n.nspname                                     AS schema_name,
    c.relname                                     AS table_name,
    c.reltuples                                   AS approx_rows,
    c.relrowsecurity                              AS rls_enabled,
    c.relforcerowsecurity                         AS rls_forced,
    pg_total_relation_size(c.oid)                 AS total_bytes,
    pg_relation_size(c.oid)                       AS table_bytes,
    pg_indexes_size(c.oid)                        AS index_bytes,
    obj_description(c.oid, $1)            AS table_comment
  FROM pg_class c
  JOIN pg_namespace n ON n.oid = c.relnamespace
  WHERE c.relkind = $2 -- ordinary tables
    AND n.nspname IN ($3, $4)
)
SELECT
  t.schema_name,
  t.table_name,
  t.table_comment,
  t.rls_enabled,
  t.rls_forced,
  t.approx_rows,
  t.total_bytes,
  t.table_bytes,
  t.index_bytes,

  -- columns
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        $5, a.attnum,
        $6, a.attname,
        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),
        $8, a.attnotnull,
        $9, pg_get_expr(ad.adbin, ad.adrelid),
        $10, a.attidentity,
        $11, a.attgenerated
      )
      ORDER BY a.attnum
    )
    FROM pg_attribute a
    LEFT JOIN pg_attrdef ad
      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
    WHERE a.attrelid = t.table_oid
      AND a.attnum > $12
      AND NOT a.attisdropped
  ) AS columns,

  -- constraints (pk/uk/fk/check)
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        $13, con.conname,
        $14, con.contype,
        $15, pg_get_constraintdef(con.oid, $16)
      )
      ORDER BY con.conname
    )
    FROM pg_constraint con
    WHERE con.conrelid = t.table_oid
  ) AS constraints,

  -- indexes
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        $17, i.relname,
        $18, pg_get_indexdef(i.oid)
      )
      ORDER BY i.relname
    )
    FROM pg_index ix
    JOIN pg_class i ON i.oid = ix.indexrelid
    WHERE ix.indrelid = t.table_oid
  ) AS indexes,

  -- triggers (excluding internal)
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        $19, tg.tgname,
        $20, tg.tgenabled,
        $21, pg_get_triggerdef(tg.oid, $22)
      )
      ORDER BY tg.tgname
    )
    FROM pg_trigger tg
    WHERE tg.tgrelid = t.table_oid
      AND NOT tg.tgisinternal
  ) AS triggers

FROM tables t
ORDER BY t.schema_name, t.table_name",1,381.49694,381.49694,112
"INSERT INTO ""users"" (""aud"", ""banned_until"", ""confirmation_sent_at"", ""confirmation_token"", ""created_at"", ""deleted_at"", ""email"", ""email_change"", ""email_change_confirm_status"", ""email_change_sent_at"", ""email_change_token_current"", ""email_change_token_new"", ""email_confirmed_at"", ""encrypted_password"", ""id"", ""instance_id"", ""invited_at"", ""is_anonymous"", ""is_sso_user"", ""last_sign_in_at"", ""phone"", ""phone_change"", ""phone_change_sent_at"", ""phone_change_token"", ""phone_confirmed_at"", ""raw_app_meta_data"", ""raw_user_meta_data"", ""reauthentication_sent_at"", ""reauthentication_token"", ""recovery_sent_at"", ""recovery_token"", ""role"", ""updated_at"") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)",7,370.288915,52.8984164285714,7
DROP SCHEMA IF EXISTS public CASCADE,1,354.783696,354.783696,0
"SELECT 
  con.oid as id, 
  con.conname as constraint_name, 
  con.confdeltype as deletion_action,
  con.confupdtype as update_action,
  rel.oid as source_id,
  nsp.nspname as source_schema, 
  rel.relname as source_table, 
  (
    SELECT 
      array_agg(
        att.attname 
        ORDER BY 
          un.ord
      ) 
    FROM 
      unnest(con.conkey) WITH ORDINALITY un (attnum, ord) 
      INNER JOIN pg_attribute att ON att.attnum = un.attnum 
    WHERE 
      att.attrelid = rel.oid
  ) source_columns, 
  frel.oid as target_id,
  fnsp.nspname as target_schema, 
  frel.relname as target_table, 
  (
    SELECT 
      array_agg(
        att.attname 
        ORDER BY 
          un.ord
      ) 
    FROM 
      unnest(con.confkey) WITH ORDINALITY un (attnum, ord) 
      INNER JOIN pg_attribute att ON att.attnum = un.attnum 
    WHERE 
      att.attrelid = frel.oid
  ) target_columns 
FROM 
  pg_constraint con 
  INNER JOIN pg_class rel ON rel.oid = con.conrelid 
  INNER JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace 
  INNER JOIN pg_class frel ON frel.oid = con.confrelid 
  INNER JOIN pg_namespace fnsp ON fnsp.oid = frel.relnamespace 
WHERE 
  con.contype = $1
  AND nsp.nspname = $2

-- source: dashboard
-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101
-- date: 2026-02-01T05:13:26.471Z",34,350.834465,10.3186607352941,3900
"WITH pgrst_source AS (SELECT ""pgrst_call"".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""p_avatar_id"" FROM json_to_record(pgrst_payload.json_data) AS _(""p_avatar_id"" uuid) LIMIT $4) pgrst_body , LATERAL ""public"".""get_avatar_by_id_public""(""p_avatar_id"" := pgrst_body.""p_avatar_id"") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT ""avatars"".* FROM ""pgrst_source"" AS ""avatars""   LIMIT $2 OFFSET $3) _postgrest_t",362,342.799267,0.946959301104972,362
"do $$
    declare
        tbl record;
        seq_name text;
        new_seq_name text;
        archive_table_name text;
    begin
        -- No tables should be owned by the extension.
        -- We want them to be included in logical backups
        for tbl in
            select c.relname as table_name
            from pg_class c
              join pg_depend d
                on c.oid = d.objid
              join pg_extension e
                on d.refobjid = e.oid
            where
              c.relkind in ('r', 'p', 'u')
              and e.extname = 'pgmq'
              and (c.relname like 'q\_%' or c.relname like 'a\_%')
        loop
          execute format('
            alter extension pgmq drop table pgmq.""%s"";',
            tbl.table_name
          );
        end loop;
    end $$",4,323.330854,80.8327135,0
SELECT * FROM pgbouncer.get_auth($1),133,313.882881,2.36002166165414,133
"SELECT
  pg_t.oid AS id,
  pg_t.tgrelid AS table_id,
  CASE
    WHEN pg_t.tgenabled = $1 THEN $2
    WHEN pg_t.tgenabled = $3 THEN $4
    WHEN pg_t.tgenabled = $5 THEN $6
    WHEN pg_t.tgenabled = $7 THEN $8
    END AS enabled_mode,
  (
    STRING_TO_ARRAY(
      ENCODE(pg_t.tgargs, $9), $10
    )
  )[:pg_t.tgnargs] AS function_args,
  is_t.trigger_name AS name,
  is_t.event_object_table AS table,
  is_t.event_object_schema AS schema,
  is_t.action_condition AS condition,
  is_t.action_orientation AS orientation,
  is_t.action_timing AS activation,
  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,
  pg_p.proname AS function_name,
  pg_n.nspname AS function_schema
FROM
  pg_trigger AS pg_t
JOIN
  pg_class AS pg_c
ON pg_t.tgrelid = pg_c.oid
JOIN pg_namespace AS table_ns
ON pg_c.relnamespace = table_ns.oid
JOIN information_schema.triggers AS is_t
ON is_t.trigger_name = pg_t.tgname
AND pg_c.relname = is_t.event_object_table
AND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace
JOIN pg_proc AS pg_p
ON pg_t.tgfoid = pg_p.oid
JOIN pg_namespace AS pg_n
ON pg_p.pronamespace = pg_n.oid
WHERE
  table_ns.nspname NOT IN ($11,$12,$13)
  
  
  
GROUP BY
  pg_t.oid,
  pg_t.tgrelid,
  pg_t.tgenabled,
  pg_t.tgargs,
  pg_t.tgnargs,
  is_t.trigger_name,
  is_t.event_object_table,
  is_t.event_object_schema,
  is_t.action_condition,
  is_t.action_orientation,
  is_t.action_timing,
  pg_p.proname,
  pg_n.nspname",17,310.477875,18.2634044117647,2872
delete from public.profiles where id in ($1),6,308.323666,51.3872776666667,6
"SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation",36,303.222024,8.422834,29340
"-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)
SELECT
  n.nspname                                                      AS schema_name,
  p.proname                                                      AS function_name,
  p.oid                                                          AS function_oid,
  pg_get_userbyid(p.proowner)                                    AS owner,
  p.prosecdef                                                    AS security_definer,
  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile
  pg_get_function_identity_arguments(p.oid)                      AS identity_args,
  pg_get_function_arguments(p.oid)                               AS full_args,
  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,
  pg_get_functiondef(p.oid)                                      AS definition
FROM pg_proc p
JOIN pg_namespace n ON n.oid = p.pronamespace
WHERE n.nspname IN ($2, $3)
  AND p.prokind = $4 -- function (not procedure/aggregate/window)
  AND p.proname NOT LIKE $5
ORDER BY n.nspname, p.proname, identity_args",1,274.966629,274.966629,387
"COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",2,273.3887,136.69435,902
"ALTER TABLE public.organizations
    ADD COLUMN IF NOT EXISTS mission_statement text,
    ADD COLUMN IF NOT EXISTS headquarters text,
    ADD COLUMN IF NOT EXISTS logo_url text",1,269.306295,269.306295,0
"INSERT INTO ""sessions"" (""aal"", ""created_at"", ""factor_id"", ""id"", ""ip"", ""not_after"", ""oauth_client_id"", ""refresh_token_counter"", ""refresh_token_hmac_key"", ""refreshed_at"", ""scopes"", ""tag"", ""updated_at"", ""user_agent"", ""user_id"") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",60,267.54152,4.45902533333333,60
"select * from storage.search($1,$2,$3,$4,$5,$6,$7,$8)",30,263.756364,8.7918788,330
"SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
FROM unnest($1::pg_catalog.oid[]) AS src(tbloid)
JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
ORDER BY a.adrelid, a.adnum",36,230.075726,6.39099238888889,10081
"CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.documents;
        _new_row public.documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.documents
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$",2,220.062577,110.0312885,0
"SELECT concat(schemaname, $1, tablename, $2, policyname) as policy
    FROM   pg_policies",5,215.448357,43.0896714,1777
"COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",2,207.808953,103.9044765,0
"COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",2,206.381392,103.190696,0
"COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",2,206.062412,103.031206,0
"COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",2,205.673718,102.836859,0
"COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",2,205.463539,102.7317695,0
"SELECT labelfile, spcmapfile, lsn FROM pg_backup_stop($1)",5,204.326571,40.8653142,5
"COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",2,204.001209,102.0006045,0
"COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",2,203.976468,101.988234,0
"COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",2,202.699628,101.349814,0
"COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",2,202.517924,101.258962,0
"COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",2,202.514213,101.2571065,0
"COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",2,202.451113,101.2255565,0
"COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",2,202.02539,101.012695,0
"COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",2,202.014789,101.0073945,0
"COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",2,201.994657,100.9973285,0
"COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",2,201.979829,100.9899145,0
"COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",2,201.977313,100.9886565,0
"COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",2,201.95722,100.97861,0
"COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",2,201.852303,100.9261515,0
"COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",2,201.743704,100.871852,0
"COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",2,201.709249,100.8546245,0
"COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",2,201.368563,100.6842815,0
"COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",2,201.250924,100.625462,2
"COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",2,201.235425,100.6177125,0
"COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",2,201.062897,100.5314485,0
"COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",2,200.595134,100.297567,0
"COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",2,200.491872,100.245936,0
"COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",2,200.426622,100.213311,0
"COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",2,200.351478,100.175739,0
"COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",2,200.275125,100.1375625,0
"COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",2,199.807887,99.9039435,0
"COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",2,199.698604,99.849302,0
