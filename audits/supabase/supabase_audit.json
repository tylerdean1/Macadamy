{
  "meta": {
    "generatedAt": "2026-02-04T20:15:47.118Z",
    "inputDir": "audits/supabase",
    "files": [
      {
        "file": "all_schema_tables_query.csv",
        "rows": 216,
        "headers": [
          "schema",
          "table",
          "table_type"
        ],
        "kind": "tables"
      },
      {
        "file": "query_performance_most_frequent.csv",
        "rows": 100,
        "headers": [
          "query",
          "calls",
          "total_time_ms",
          "rows"
        ],
        "kind": "queries"
      },
      {
        "file": "query_performance_most_time_consuming.csv",
        "rows": 100,
        "headers": [
          "query",
          "calls",
          "total_time_ms",
          "mean_time_ms",
          "rows"
        ],
        "kind": "queries"
      },
      {
        "file": "query_performance_slowest.csv",
        "rows": 100,
        "headers": [
          "query",
          "calls",
          "mean_time_ms",
          "max_time_ms",
          "total_time_ms",
          "rows"
        ],
        "kind": "queries"
      },
      {
        "file": "rpc_roles_query.csv",
        "rows": 496,
        "headers": [
          "schema",
          "function",
          "role",
          "security_definer"
        ],
        "kind": "rpcRoles"
      },
      {
        "file": "snippet_policies.csv",
        "rows": 451,
        "headers": [
          "schema",
          "table",
          "policy",
          "permissive",
          "roles",
          "command",
          "using",
          "check"
        ],
        "kind": "policies"
      },
      {
        "file": "snippet_roles.csv",
        "rows": 29,
        "headers": [
          "role",
          "superuser",
          "create_role",
          "create_db",
          "replication",
          "bypass_rls"
        ],
        "kind": "roles"
      },
      {
        "file": "snippet_rpcs.csv",
        "rows": 496,
        "headers": [
          "schema",
          "function",
          "definition"
        ],
        "kind": "rpc"
      },
      {
        "file": "snippet_triggers_search.csv",
        "rows": 179,
        "headers": [
          "schema",
          "table",
          "trigger",
          "definition"
        ],
        "kind": "triggers"
      }
    ]
  },
  "sections": {
    "security": {
      "rows": [],
      "summary": {
        "severityKey": null,
        "categoryKey": null,
        "tableKey": null,
        "functionKey": null,
        "bySeverity": {},
        "byCategory": {},
        "byTable": {},
        "byFunction": {}
      }
    },
    "performance": {
      "rows": []
    },
    "queries": {
      "slowest": [
        {
          "query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "calls": "12281",
          "total_time_ms": "1230.18216",
          "rows": "12281",
          "Query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "Fingerprint": "dacc823a"
        },
        {
          "query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "calls": "12281",
          "total_time_ms": "1230.18216",
          "mean_time_ms": "0.100169543196808",
          "rows": "12281",
          "Query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "Fingerprint": "dacc823a"
        },
        {
          "query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "calls": "2848",
          "total_time_ms": "1301.024127",
          "rows": "2848",
          "Query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "Fingerprint": "0c4f8f7c"
        },
        {
          "query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "calls": "2848",
          "total_time_ms": "1301.024127",
          "mean_time_ms": "0.456820269311797",
          "rows": "2848",
          "Query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "Fingerprint": "0c4f8f7c"
        },
        {
          "query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
          "calls": "2388",
          "total_time_ms": "167.845012000001",
          "rows": "2388",
          "Query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
          "Fingerprint": "7174daf9"
        },
        {
          "query": "SET client_min_messages TO WARNING",
          "calls": "1983",
          "total_time_ms": "11.741692",
          "rows": "0",
          "Query": "SET client_min_messages TO WARNING",
          "Fingerprint": "d2883c6f"
        },
        {
          "query": "SET client_encoding = 'UTF8'",
          "calls": "1983",
          "total_time_ms": "17.447639",
          "rows": "0",
          "Query": "SET client_encoding = 'UTF8'",
          "Fingerprint": "2684e31e"
        },
        {
          "query": "BEGIN ISOLATION LEVEL READ COMMITTED READ ONLY",
          "calls": "1756",
          "total_time_ms": "19.396537",
          "rows": "0",
          "Query": "BEGIN ISOLATION LEVEL READ COMMITTED READ ONLY",
          "Fingerprint": "3c5b6168"
        },
        {
          "query": "SHOW transaction_read_only",
          "calls": "1644",
          "total_time_ms": "40.2912989999999",
          "rows": "0",
          "Query": "SHOW transaction_read_only",
          "Fingerprint": "e52c5054"
        },
        {
          "query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "calls": "1397",
          "total_time_ms": "1715.286118",
          "rows": "46811",
          "Query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "Fingerprint": "ee3d52f8"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "calls": "1397",
          "total_time_ms": "34323.32903",
          "rows": "311820",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "Fingerprint": "5eac5f98"
        },
        {
          "query": "WITH\nrole_setting AS (\n  SELECT setdatabase as database,\n         unnest(setconfig) as setting\n  FROM pg_catalog.pg_db_role_setting\n  WHERE setrole = CURRENT_USER::regrole::oid\n    AND setdatabase IN ($2, (SELECT oid FROM pg_catalog.pg_database WHERE datname = CURRENT_CATALOG))\n),\nkv_settings AS (\n  SELECT database,\n         substr(setting, $3, strpos(setting, $4) - $5) as k,\n         substr(setting, strpos(setting, $6) + $7) as v\n  FROM role_setting\n  \n)\nSELECT DISTINCT ON (key)\n       replace(k, $8, $9) AS key,\n       v AS value\nFROM kv_settings\nWHERE k = ANY($1) AND v IS NOT NULL\nORDER BY key, database DESC NULLS LAST",
          "calls": "1397",
          "total_time_ms": "92.493663",
          "rows": "0",
          "Query": "WITH\nrole_setting AS (\n  SELECT setdatabase as database,\n         unnest(setconfig) as setting\n  FROM pg_catalog.pg_db_role_setting\n  WHERE setrole = CURRENT_USER::regrole::oid\n    AND setdatabase IN ($2, (SELECT oid FROM pg_catalog.pg_database WHERE datname = CURRENT_CATALOG))\n),\nkv_settings AS (\n  SELECT database,\n         substr(setting, $3, strpos(setting, $4) - $5) as k,\n         substr(setting, strpos(setting, $6) + $7) as v\n  FROM role_setting\n  \n)\nSELECT DISTINCT ON (key)\n       replace(k, $8, $9) AS key,\n       v AS value\nFROM kv_settings\nWHERE k = ANY($1) AND v IS NOT NULL\nORDER BY key, database DESC NULLS LAST",
          "Fingerprint": "3a2c1e7e"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "calls": "1397",
          "total_time_ms": "33851.555228",
          "rows": "167758",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "Fingerprint": "2eb78329"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "calls": "1397",
          "total_time_ms": "571.449586",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "Fingerprint": "c5bdd355"
        },
        {
          "query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "calls": "1397",
          "total_time_ms": "2836.51774799999",
          "rows": "2794",
          "Query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "Fingerprint": "06396590"
        },
        {
          "query": "SELECT current_setting($1)::integer, current_setting($2), version()",
          "calls": "1397",
          "total_time_ms": "15.246181",
          "rows": "1397",
          "Query": "SELECT current_setting($1)::integer, current_setting($2), version()",
          "Fingerprint": "120b789e"
        },
        {
          "query": "COMMIT",
          "calls": "1397",
          "total_time_ms": "1.737483",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "calls": "1397",
          "total_time_ms": "2365.774295",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "Fingerprint": "b9ce39db"
        },
        {
          "query": "set local schema ''",
          "calls": "1397",
          "total_time_ms": "8.34740599999999",
          "rows": "0",
          "Query": "set local schema ''",
          "Fingerprint": "50e59e1c"
        },
        {
          "query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "calls": "1397",
          "total_time_ms": "667.382252000001",
          "rows": "0",
          "Query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "Fingerprint": "5d91a149"
        },
        {
          "query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "calls": "1397",
          "total_time_ms": "13353.197756",
          "rows": "64172",
          "Query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "Fingerprint": "d0298bd6"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "calls": "1397",
          "total_time_ms": "34323.32903",
          "mean_time_ms": "24.5693121188261",
          "rows": "311820",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "Fingerprint": "5eac5f98"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "calls": "1397",
          "total_time_ms": "33851.555228",
          "mean_time_ms": "24.2316071782391",
          "rows": "167758",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "Fingerprint": "2eb78329"
        },
        {
          "query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "calls": "1397",
          "total_time_ms": "13353.197756",
          "mean_time_ms": "9.55848085612025",
          "rows": "64172",
          "Query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "Fingerprint": "d0298bd6"
        },
        {
          "query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "calls": "1397",
          "total_time_ms": "2836.51774799999",
          "mean_time_ms": "2.03043503793844",
          "rows": "2794",
          "Query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "Fingerprint": "06396590"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "calls": "1397",
          "total_time_ms": "2365.774295",
          "mean_time_ms": "1.69346764137437",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "Fingerprint": "b9ce39db"
        },
        {
          "query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "calls": "1397",
          "total_time_ms": "1715.286118",
          "mean_time_ms": "1.22783544595562",
          "rows": "46811",
          "Query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "Fingerprint": "ee3d52f8"
        },
        {
          "query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "calls": "1397",
          "total_time_ms": "667.382252000001",
          "mean_time_ms": "0.477725305654975",
          "rows": "0",
          "Query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "Fingerprint": "5d91a149"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "calls": "1397",
          "total_time_ms": "571.449586",
          "mean_time_ms": "0.409054821760916",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "Fingerprint": "c5bdd355"
        },
        {
          "query": "SELECT name FROM pg_timezone_names",
          "calls": "1396",
          "total_time_ms": "103693.647862",
          "rows": "1666824",
          "Query": "SELECT name FROM pg_timezone_names",
          "Fingerprint": "f174234e"
        },
        {
          "query": "SELECT name FROM pg_timezone_names",
          "calls": "1396",
          "total_time_ms": "103693.647862",
          "mean_time_ms": "74.2791173796561",
          "rows": "1666824",
          "Query": "SELECT name FROM pg_timezone_names",
          "Fingerprint": "f174234e"
        },
        {
          "query": "SET idle_session_timeout='58s'",
          "calls": "1057",
          "total_time_ms": "3.192387",
          "rows": "0",
          "Query": "SET idle_session_timeout='58s'",
          "Fingerprint": "9469d6d2"
        },
        {
          "query": "SET statement_timeout='58s'",
          "calls": "1057",
          "total_time_ms": "15.915253",
          "rows": "0",
          "Query": "SET statement_timeout='58s'",
          "Fingerprint": "caa62bbc"
        },
        {
          "query": "PREPARE dumpEnumType(pg_catalog.oid) AS\nSELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder",
          "calls": "740",
          "total_time_ms": "13.1952",
          "rows": "4063",
          "Query": "PREPARE dumpEnumType(pg_catalog.oid) AS\nSELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder",
          "Fingerprint": "7c26b364"
        },
        {
          "query": "SELECT sessions.aal, sessions.created_at, sessions.factor_id, sessions.id, sessions.ip, sessions.not_after, sessions.oauth_client_id, sessions.refresh_token_counter, sessions.refresh_token_hmac_key, sessions.refreshed_at, sessions.scopes, sessions.tag, sessions.updated_at, sessions.user_agent, sessions.user_id FROM sessions AS sessions WHERE id = $1 LIMIT $2",
          "calls": "609",
          "total_time_ms": "108.247794",
          "rows": "609",
          "Query": "SELECT sessions.aal, sessions.created_at, sessions.factor_id, sessions.id, sessions.ip, sessions.not_after, sessions.oauth_client_id, sessions.refresh_token_counter, sessions.refresh_token_hmac_key, sessions.refreshed_at, sessions.scopes, sessions.tag, sessions.updated_at, sessions.user_agent, sessions.user_id FROM sessions AS sessions WHERE id = $1 LIMIT $2",
          "Fingerprint": "57f49ab9"
        },
        {
          "query": "SELECT mfa_amr_claims.authentication_method, mfa_amr_claims.created_at, mfa_amr_claims.id, mfa_amr_claims.session_id, mfa_amr_claims.updated_at FROM mfa_amr_claims AS mfa_amr_claims WHERE session_id = $1",
          "calls": "609",
          "total_time_ms": "32.246395",
          "rows": "609",
          "Query": "SELECT mfa_amr_claims.authentication_method, mfa_amr_claims.created_at, mfa_amr_claims.id, mfa_amr_claims.session_id, mfa_amr_claims.updated_at FROM mfa_amr_claims AS mfa_amr_claims WHERE session_id = $1",
          "Fingerprint": "a87b5d71"
        },
        {
          "query": "SELECT mfa_factors.created_at, mfa_factors.factor_type, mfa_factors.friendly_name, mfa_factors.id, mfa_factors.last_challenged_at, mfa_factors.last_webauthn_challenge_data, mfa_factors.phone, mfa_factors.secret, mfa_factors.status, mfa_factors.updated_at, mfa_factors.user_id, mfa_factors.web_authn_aaguid, mfa_factors.web_authn_credential FROM mfa_factors AS mfa_factors WHERE user_id = $1",
          "calls": "605",
          "total_time_ms": "7.48317799999999",
          "rows": "0",
          "Query": "SELECT mfa_factors.created_at, mfa_factors.factor_type, mfa_factors.friendly_name, mfa_factors.id, mfa_factors.last_challenged_at, mfa_factors.last_webauthn_challenge_data, mfa_factors.phone, mfa_factors.secret, mfa_factors.status, mfa_factors.updated_at, mfa_factors.user_id, mfa_factors.web_authn_aaguid, mfa_factors.web_authn_credential FROM mfa_factors AS mfa_factors WHERE user_id = $1",
          "Fingerprint": "dacebddc"
        },
        {
          "query": "SELECT identities.created_at, identities.email, identities.id, identities.identity_data, identities.last_sign_in_at, identities.provider, identities.provider_id, identities.updated_at, identities.user_id FROM identities AS identities WHERE user_id = $1",
          "calls": "605",
          "total_time_ms": "75.081424",
          "rows": "605",
          "Query": "SELECT identities.created_at, identities.email, identities.id, identities.identity_data, identities.last_sign_in_at, identities.provider, identities.provider_id, identities.updated_at, identities.user_id FROM identities AS identities WHERE user_id = $1",
          "Fingerprint": "85b8dd01"
        },
        {
          "query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and id = $2 LIMIT $3",
          "calls": "560",
          "total_time_ms": "74.639599",
          "rows": "551",
          "Query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and id = $2 LIMIT $3",
          "Fingerprint": "35e8447e"
        },
        {
          "query": "select setting from pg_config where name = $1",
          "calls": "548",
          "total_time_ms": "101.908625",
          "rows": "548",
          "Query": "select setting from pg_config where name = $1",
          "Fingerprint": "4fe9ed11"
        },
        {
          "query": "BEGIN ISOLATION LEVEL READ COMMITTED READ WRITE",
          "calls": "490",
          "total_time_ms": "7.89980099999999",
          "rows": "0",
          "Query": "BEGIN ISOLATION LEVEL READ COMMITTED READ WRITE",
          "Fingerprint": "3e989d19"
        },
        {
          "query": "COMMIT",
          "calls": "488",
          "total_time_ms": "0.664983",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "475",
          "total_time_ms": "1203.426561",
          "rows": "475",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "475",
          "total_time_ms": "1203.426561",
          "mean_time_ms": "2.53352960210526",
          "rows": "475",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "SET statement_timeout='58s'",
          "calls": "393",
          "total_time_ms": "6.13669699999999",
          "rows": "0",
          "Query": "SET statement_timeout='58s'",
          "Fingerprint": "caa62bbc"
        },
        {
          "query": "SET idle_session_timeout='58s'",
          "calls": "393",
          "total_time_ms": "2.087518",
          "rows": "0",
          "Query": "SET idle_session_timeout='58s'",
          "Fingerprint": "9469d6d2"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "391",
          "total_time_ms": "416.396113",
          "rows": "391",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "169ad58d"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "391",
          "total_time_ms": "416.396113",
          "mean_time_ms": "1.06495169565218",
          "rows": "391",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "169ad58d"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "362",
          "total_time_ms": "342.799267",
          "rows": "362",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "840a08d4"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "362",
          "total_time_ms": "342.799267",
          "mean_time_ms": "0.946959301104972",
          "rows": "362",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "840a08d4"
        },
        {
          "query": "COMMIT",
          "calls": "300",
          "total_time_ms": "0.348386",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "298",
          "total_time_ms": "410.95613",
          "rows": "298",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "fef63b48"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "298",
          "total_time_ms": "410.95613",
          "mean_time_ms": "1.37904741610738",
          "rows": "298",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "fef63b48"
        },
        {
          "query": "BEGIN",
          "calls": "292",
          "total_time_ms": "0.683945",
          "rows": "0",
          "Query": "BEGIN",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "SELECT set_config($2, $1, $3)",
          "calls": "292",
          "total_time_ms": "34.603603",
          "rows": "292",
          "Query": "SELECT set_config($2, $1, $3)",
          "Fingerprint": "372553e8"
        },
        {
          "query": "SELECT\n          set_config('role', $1, true),\n          set_config('request.jwt.claim.role', $2, true),\n          set_config('request.jwt', $3, true),\n          set_config('request.jwt.claim.sub', $4, true),\n          set_config('request.jwt.claims', $5, true),\n          set_config('request.headers', $6, true),\n          set_config('request.method', $7, true),\n          set_config('request.path', $8, true),\n          set_config('storage.operation', $9, true)",
          "calls": "290",
          "total_time_ms": "39.868987",
          "rows": "290",
          "Query": "SELECT\n          set_config('role', $1, true),\n          set_config('request.jwt.claim.role', $2, true),\n          set_config('request.jwt', $3, true),\n          set_config('request.jwt.claim.sub', $4, true),\n          set_config('request.jwt.claims', $5, true),\n          set_config('request.headers', $6, true),\n          set_config('request.method', $7, true),\n          set_config('request.path', $8, true),\n          set_config('storage.operation', $9, true)",
          "Fingerprint": "88c09e41"
        },
        {
          "query": "ABORT",
          "calls": "263",
          "total_time_ms": "0.356416",
          "rows": "0",
          "Query": "ABORT",
          "Fingerprint": "a52bcaf9"
        },
        {
          "query": "SELECT pg_catalog.format_type($1::pg_catalog.oid, $2)",
          "calls": "238",
          "total_time_ms": "3.276142",
          "rows": "238",
          "Query": "SELECT pg_catalog.format_type($1::pg_catalog.oid, $2)",
          "Fingerprint": "5f21d07e"
        },
        {
          "query": "set pg_stat_statements.track = none",
          "calls": "224",
          "total_time_ms": "0.504548",
          "rows": "0",
          "Query": "set pg_stat_statements.track = none",
          "Fingerprint": "564e7202"
        },
        {
          "query": "begin",
          "calls": "170",
          "total_time_ms": "0.167079",
          "rows": "0",
          "Query": "begin",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "commit",
          "calls": "168",
          "total_time_ms": "0.166121",
          "rows": "0",
          "Query": "commit",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "select exists(select $1 from auth.users)",
          "calls": "165",
          "total_time_ms": "30.342953",
          "rows": "165",
          "Query": "select exists(select $1 from auth.users)",
          "Fingerprint": "a6403a8d"
        },
        {
          "query": "deallocate $1",
          "calls": "149",
          "total_time_ms": "0.377356",
          "rows": "0",
          "Query": "deallocate $1",
          "Fingerprint": "67c106f6"
        },
        {
          "query": "BEGIN",
          "calls": "147",
          "total_time_ms": "0.193195",
          "rows": "0",
          "Query": "BEGIN",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "COMMIT",
          "calls": "143",
          "total_time_ms": "0.204349",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "SELECT * FROM pgbouncer.get_auth($1)",
          "calls": "133",
          "total_time_ms": "313.882881",
          "rows": "133",
          "Query": "SELECT * FROM pgbouncer.get_auth($1)",
          "Fingerprint": "6e8f1775"
        },
        {
          "query": "SELECT * FROM pgbouncer.get_auth($1)",
          "calls": "133",
          "total_time_ms": "313.882881",
          "mean_time_ms": "2.36002166165414",
          "rows": "133",
          "Query": "SELECT * FROM pgbouncer.get_auth($1)",
          "Fingerprint": "6e8f1775"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "113",
          "total_time_ms": "5259.748893",
          "rows": "113",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "5a244b78"
        },
        {
          "query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "calls": "113",
          "total_time_ms": "472.05049",
          "rows": "1017",
          "Query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "Fingerprint": "83726034"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "113",
          "total_time_ms": "5259.748893",
          "mean_time_ms": "46.546450380531",
          "rows": "113",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "5a244b78"
        },
        {
          "query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "calls": "113",
          "total_time_ms": "472.05049",
          "mean_time_ms": "4.17743796460177",
          "rows": "1017",
          "Query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "Fingerprint": "83726034"
        },
        {
          "query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "calls": "104",
          "total_time_ms": "2117.180412",
          "rows": "103",
          "Query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "Fingerprint": "de72792d"
        },
        {
          "query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "calls": "104",
          "total_time_ms": "2117.180412",
          "mean_time_ms": "20.3575039615385",
          "rows": "103",
          "Query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "Fingerprint": "de72792d"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "total_time_ms": "9967.864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "total_time_ms": "9967.864957",
          "mean_time_ms": "99.67864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "mean_time_ms": "99.67864957",
          "max_time_ms": "316.835546",
          "total_time_ms": "9967.864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "select\n      s.oid as \"id\",\n      w.fdwname as \"name\",\n      s.srvname as \"server_name\",\n      s.srvoptions as \"server_options\",\n      c.proname as \"handler\",\n      (\n        select jsonb_agg(\n          jsonb_build_object(\n            $1, c.oid::bigint,\n            $2, relnamespace::regnamespace::text,\n            $3, c.relname,\n            $4, (\n              select jsonb_agg(\n                jsonb_build_object(\n                  $5, a.attname,\n                  $6, pg_catalog.format_type(a.atttypid, a.atttypmod)\n                )\n              )\n              from pg_catalog.pg_attribute a\n              where a.attrelid = c.oid and a.attnum > $7 and not a.attisdropped\n            ),\n            $8, t.ftoptions\n          )\n        )\n        from pg_catalog.pg_class c\n        join pg_catalog.pg_foreign_table t on c.oid = t.ftrelid\n        where c.oid = any (select t.ftrelid from pg_catalog.pg_foreign_table t where t.ftserver = s.oid)\n      ) as \"tables\"\n    from pg_catalog.pg_foreign_server s\n    join pg_catalog.pg_foreign_data_wrapper w on s.srvfdw = w.oid\n    join pg_catalog.pg_proc c on w.fdwhandler = c.oid",
          "calls": "97",
          "total_time_ms": "2.233936",
          "rows": "0",
          "Query": "select\n      s.oid as \"id\",\n      w.fdwname as \"name\",\n      s.srvname as \"server_name\",\n      s.srvoptions as \"server_options\",\n      c.proname as \"handler\",\n      (\n        select jsonb_agg(\n          jsonb_build_object(\n            $1, c.oid::bigint,\n            $2, relnamespace::regnamespace::text,\n            $3, c.relname,\n            $4, (\n              select jsonb_agg(\n                jsonb_build_object(\n                  $5, a.attname,\n                  $6, pg_catalog.format_type(a.atttypid, a.atttypmod)\n                )\n              )\n              from pg_catalog.pg_attribute a\n              where a.attrelid = c.oid and a.attnum > $7 and not a.attisdropped\n            ),\n            $8, t.ftoptions\n          )\n        )\n        from pg_catalog.pg_class c\n        join pg_catalog.pg_foreign_table t on c.oid = t.ftrelid\n        where c.oid = any (select t.ftrelid from pg_catalog.pg_foreign_table t where t.ftserver = s.oid)\n      ) as \"tables\"\n    from pg_catalog.pg_foreign_server s\n    join pg_catalog.pg_foreign_data_wrapper w on s.srvfdw = w.oid\n    join pg_catalog.pg_proc c on w.fdwhandler = c.oid",
          "Fingerprint": "8e6d3b19"
        },
        {
          "query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "calls": "92",
          "total_time_ms": "396.812123",
          "rows": "92",
          "Query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "Fingerprint": "24390c08"
        },
        {
          "query": "select set_config('search_path', $1, true), set_config('role', $2, true), set_config('request.jwt.claims', $3, true), set_config('request.method', $4, true), set_config('request.path', $5, true), set_config('request.headers', $6, true), set_config('request.cookies', $7, true)",
          "calls": "92",
          "total_time_ms": "12.934942",
          "rows": "92",
          "Query": "select set_config('search_path', $1, true), set_config('role', $2, true), set_config('request.jwt.claims', $3, true), set_config('request.method', $4, true), set_config('request.path', $5, true), set_config('request.headers', $6, true), set_config('request.cookies', $7, true)",
          "Fingerprint": "2a976cc9"
        },
        {
          "query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "calls": "92",
          "total_time_ms": "396.812123",
          "mean_time_ms": "4.31317525",
          "rows": "92",
          "Query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "Fingerprint": "24390c08"
        },
        {
          "query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "88",
          "total_time_ms": "1485.024353",
          "rows": "88",
          "Query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "6eaa5bc4"
        },
        {
          "query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "88",
          "total_time_ms": "1485.024353",
          "mean_time_ms": "16.8752767386364",
          "rows": "88",
          "Query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "6eaa5bc4"
        },
        {
          "query": "SELECT pg_catalog.set_config($1, $2, $3)",
          "calls": "83",
          "total_time_ms": "0.904006",
          "rows": "83",
          "Query": "SELECT pg_catalog.set_config($1, $2, $3)",
          "Fingerprint": "f5e5553f"
        },
        {
          "query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "calls": "80",
          "total_time_ms": "6978.442858",
          "rows": "26106",
          "Query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "Fingerprint": "62d7ef17"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom materialized_views",
          "calls": "80",
          "total_time_ms": "23.678557",
          "rows": "68",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom materialized_views",
          "Fingerprint": "5fdd6c91"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "total_time_ms": "14684.666536",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "calls": "80",
          "total_time_ms": "2106.986161",
          "rows": "26088",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "Fingerprint": "dbb85dbe"
        },
        {
          "query": "with foreign_tables as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom foreign_tables",
          "calls": "80",
          "total_time_ms": "17.288298",
          "rows": "0",
          "Query": "with foreign_tables as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom foreign_tables",
          "Fingerprint": "4ab2deba"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "calls": "80",
          "total_time_ms": "1873.557554",
          "rows": "83576",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "Fingerprint": "b7f8e58a"
        },
        {
          "query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "calls": "80",
          "total_time_ms": "6176.415442",
          "rows": "114718",
          "Query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "Fingerprint": "5b79696f"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "calls": "80",
          "total_time_ms": "590.210851",
          "rows": "5984",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "Fingerprint": "03495dc3"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "calls": "80",
          "total_time_ms": "417.70789",
          "rows": "10019",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "Fingerprint": "63fbfa7d"
        },
        {
          "query": "-- Adapted from information_schema.schemata\nselect\n  n.oid::int8 as id,\n  n.nspname as name,\n  u.rolname as owner\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  \n  and n.nspname IN ($1,$2)\n  and not pg_catalog.starts_with(n.nspname, $3)\n  and (\n    pg_has_role(n.nspowner, $4)\n    or has_schema_privilege(n.oid, $5)\n  )\n  and not pg_catalog.starts_with(n.nspname, $6)\n  and not pg_catalog.starts_with(n.nspname, $7)",
          "calls": "80",
          "total_time_ms": "16.45004",
          "rows": "160",
          "Query": "-- Adapted from information_schema.schemata\nselect\n  n.oid::int8 as id,\n  n.nspname as name,\n  u.rolname as owner\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  \n  and n.nspname IN ($1,$2)\n  and not pg_catalog.starts_with(n.nspname, $3)\n  and (\n    pg_has_role(n.nspowner, $4)\n    or has_schema_privilege(n.oid, $5)\n  )\n  and not pg_catalog.starts_with(n.nspname, $6)\n  and not pg_catalog.starts_with(n.nspname, $7)",
          "Fingerprint": "6e38ce8d"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "total_time_ms": "14684.666536",
          "mean_time_ms": "183.5583317",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "calls": "80",
          "total_time_ms": "6978.442858",
          "mean_time_ms": "87.230535725",
          "rows": "26106",
          "Query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "Fingerprint": "62d7ef17"
        },
        {
          "query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "calls": "80",
          "total_time_ms": "6176.415442",
          "mean_time_ms": "77.205193025",
          "rows": "114718",
          "Query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "Fingerprint": "5b79696f"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "calls": "80",
          "total_time_ms": "2106.986161",
          "mean_time_ms": "26.3373270125",
          "rows": "26088",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "Fingerprint": "dbb85dbe"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "calls": "80",
          "total_time_ms": "1873.557554",
          "mean_time_ms": "23.419469425",
          "rows": "83576",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "Fingerprint": "b7f8e58a"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "calls": "80",
          "total_time_ms": "590.210851",
          "mean_time_ms": "7.3776356375",
          "rows": "5984",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "Fingerprint": "03495dc3"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "calls": "80",
          "total_time_ms": "417.70789",
          "mean_time_ms": "5.221348625",
          "rows": "10019",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "Fingerprint": "63fbfa7d"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "mean_time_ms": "183.5583317",
          "max_time_ms": "562.106136",
          "total_time_ms": "14684.666536",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "SELECT oid FROM pg_catalog.pg_namespace n\nWHERE n.nspname OPERATOR(pg_catalog.~) $1 COLLATE pg_catalog.default",
          "calls": "72",
          "total_time_ms": "2.960007",
          "rows": "72",
          "Query": "SELECT oid FROM pg_catalog.pg_namespace n\nWHERE n.nspname OPERATOR(pg_catalog.~) $1 COLLATE pg_catalog.default",
          "Fingerprint": "7c8009f7"
        },
        {
          "query": "LOCK TABLE \"realtime\".\"schema_migrations\" IN SHARE UPDATE EXCLUSIVE MODE",
          "calls": "71",
          "total_time_ms": "1.127289",
          "rows": "0",
          "Query": "LOCK TABLE \"realtime\".\"schema_migrations\" IN SHARE UPDATE EXCLUSIVE MODE",
          "Fingerprint": "deecdf8c"
        },
        {
          "query": "SELECT s0.\"version\" FROM \"realtime\".\"schema_migrations\" AS s0",
          "calls": "70",
          "total_time_ms": "3.596576",
          "rows": "2284",
          "Query": "SELECT s0.\"version\" FROM \"realtime\".\"schema_migrations\" AS s0",
          "Fingerprint": "aed88797"
        },
        {
          "query": "UPDATE \"users\" AS users SET \"last_sign_in_at\" = $1, \"updated_at\" = $2 WHERE users.id = $3",
          "calls": "69",
          "total_time_ms": "44.248527",
          "rows": "69",
          "Query": "UPDATE \"users\" AS users SET \"last_sign_in_at\" = $1, \"updated_at\" = $2 WHERE users.id = $3",
          "Fingerprint": "c94cfe49"
        },
        {
          "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "calls": "69",
          "total_time_ms": "396.493198",
          "rows": "69",
          "Query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "Fingerprint": "9d6d3db1"
        },
        {
          "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "calls": "69",
          "total_time_ms": "396.493198",
          "mean_time_ms": "5.74627823188406",
          "rows": "69",
          "Query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "Fingerprint": "9d6d3db1"
        },
        {
          "query": "INSERT INTO \"realtime\".\"schema_migrations\" (\"version\",\"inserted_at\") VALUES ($1,$2)",
          "calls": "67",
          "total_time_ms": "8.465681",
          "rows": "67",
          "Query": "INSERT INTO \"realtime\".\"schema_migrations\" (\"version\",\"inserted_at\") VALUES ($1,$2)",
          "Fingerprint": "7bfa5972"
        },
        {
          "query": "insert into schema_migrations (version) values ($1)",
          "calls": "65",
          "total_time_ms": "1.325092",
          "rows": "65",
          "Query": "insert into schema_migrations (version) values ($1)",
          "Fingerprint": "81bd7952"
        },
        {
          "query": "SELECT EXISTS (SELECT schema_migrations.* FROM schema_migrations AS schema_migrations WHERE version = $1)",
          "calls": "65",
          "total_time_ms": "1.322896",
          "rows": "65",
          "Query": "SELECT EXISTS (SELECT schema_migrations.* FROM schema_migrations AS schema_migrations WHERE version = $1)",
          "Fingerprint": "b97dc1f8"
        },
        {
          "query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and LOWER(email) = $2 and aud = $3 and is_sso_user = $4 LIMIT $5",
          "calls": "65",
          "total_time_ms": "17.461435",
          "rows": "54",
          "Query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and LOWER(email) = $2 and aud = $3 and is_sso_user = $4 LIMIT $5",
          "Fingerprint": "7121590d"
        },
        {
          "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "calls": "60",
          "total_time_ms": "267.54152",
          "rows": "60",
          "Query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "Fingerprint": "9ddfc8bb"
        },
        {
          "query": "INSERT INTO mfa_amr_claims(id, session_id, created_at, updated_at, authentication_method) values ($1, $2, $3, $4, $5)\n\t\t\tON CONFLICT ON CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey\n\t\t\tDO UPDATE SET updated_at = $6",
          "calls": "60",
          "total_time_ms": "68.695646",
          "rows": "60",
          "Query": "INSERT INTO mfa_amr_claims(id, session_id, created_at, updated_at, authentication_method) values ($1, $2, $3, $4, $5)\n\t\t\tON CONFLICT ON CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey\n\t\t\tDO UPDATE SET updated_at = $6",
          "Fingerprint": "b3c191e7"
        },
        {
          "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "calls": "60",
          "total_time_ms": "267.54152",
          "mean_time_ms": "4.45902533333333",
          "rows": "60",
          "Query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "Fingerprint": "9ddfc8bb"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "total_time_ms": "29046.709733",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "total_time_ms": "29046.709733",
          "mean_time_ms": "518.691245232143",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "mean_time_ms": "518.691245232143",
          "max_time_ms": "1137.156924",
          "total_time_ms": "29046.709733",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "total_time_ms": "40384.84643",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "total_time_ms": "40384.84643",
          "mean_time_ms": "734.269935090909",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "mean_time_ms": "734.269935090909",
          "max_time_ms": "1384.405776",
          "total_time_ms": "40384.84643",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "total_time_ms": "9479.365463",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "SELECT word FROM pg_get_keywords()",
          "calls": "54",
          "total_time_ms": "25.665143",
          "rows": "26514",
          "Query": "SELECT word FROM pg_get_keywords()",
          "Fingerprint": "93722fc9"
        },
        {
          "query": "select pid, query, query_start from pg_stat_activity where state = $1 and datname = $2",
          "calls": "54",
          "total_time_ms": "28.544478",
          "rows": "149",
          "Query": "select pid, query, query_start from pg_stat_activity where state = $1 and datname = $2",
          "Fingerprint": "09f3a758"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "total_time_ms": "9479.365463",
          "mean_time_ms": "175.54380487037",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "mean_time_ms": "175.54380487037",
          "max_time_ms": "292.478765",
          "total_time_ms": "9479.365463",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "calls": "50",
          "total_time_ms": "896.677722",
          "rows": "38",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "Fingerprint": "a7b5eaa1"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "total_time_ms": "32448.44921",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "INSERT INTO migrations (\"id\", \"name\", \"hash\") VALUES ($1,$2,$3)",
          "calls": "50",
          "total_time_ms": "4.90032",
          "rows": "50",
          "Query": "INSERT INTO migrations (\"id\", \"name\", \"hash\") VALUES ($1,$2,$3)",
          "Fingerprint": "08deba80"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "total_time_ms": "32448.44921",
          "mean_time_ms": "648.9689842",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "calls": "50",
          "total_time_ms": "896.677722",
          "mean_time_ms": "17.93355444",
          "rows": "38",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "Fingerprint": "a7b5eaa1"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "mean_time_ms": "648.9689842",
          "max_time_ms": "1199.324807",
          "total_time_ms": "32448.44921",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "49",
          "total_time_ms": "69.16763",
          "rows": "49",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "calls": "48",
          "total_time_ms": "1039.996381",
          "rows": "0",
          "Query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "Fingerprint": "b05429e3"
        },
        {
          "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "calls": "48",
          "total_time_ms": "1039.996381",
          "mean_time_ms": "21.6665912708333",
          "rows": "0",
          "Query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "Fingerprint": "b05429e3"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "calls": "46",
          "total_time_ms": "596.622214",
          "rows": "1236",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "Fingerprint": "2d4e922a"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "calls": "46",
          "total_time_ms": "596.622214",
          "mean_time_ms": "12.9700481304348",
          "rows": "1236",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "Fingerprint": "2d4e922a"
        },
        {
          "query": "COMMIT",
          "calls": "44",
          "total_time_ms": "0.033668",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "START TRANSACTION",
          "calls": "44",
          "total_time_ms": "0.027186",
          "rows": "0",
          "Query": "START TRANSACTION",
          "Fingerprint": "cd946f1b"
        },
        {
          "query": "SELECT\n  p.oid :: int8 AS id,\n  p.pubname AS name,\n  p.pubowner::regrole::text AS owner,\n  p.pubinsert AS publish_insert,\n  p.pubupdate AS publish_update,\n  p.pubdelete AS publish_delete,\n  p.pubtruncate AS publish_truncate,\n  CASE\n    WHEN p.puballtables THEN $1\n    ELSE pr.tables\n  END AS tables\nFROM\n  pg_catalog.pg_publication AS p\n  LEFT JOIN LATERAL (\n    SELECT\n      COALESCE(\n        array_agg(\n          json_build_object(\n            $2,\n            c.oid :: int8,\n            $3,\n            c.relname,\n            $4,\n            nc.nspname\n          )\n        ),\n        $5\n      ) AS tables\n    FROM\n      pg_catalog.pg_publication_rel AS pr\n      JOIN pg_class AS c ON pr.prrelid = c.oid\n      join pg_namespace as nc on c.relnamespace = nc.oid\n    WHERE\n      pr.prpubid = p.oid\n  ) AS pr ON $6 = $7\nWHERE\n  $8",
          "calls": "43",
          "total_time_ms": "24.366404",
          "rows": "43",
          "Query": "SELECT\n  p.oid :: int8 AS id,\n  p.pubname AS name,\n  p.pubowner::regrole::text AS owner,\n  p.pubinsert AS publish_insert,\n  p.pubupdate AS publish_update,\n  p.pubdelete AS publish_delete,\n  p.pubtruncate AS publish_truncate,\n  CASE\n    WHEN p.puballtables THEN $1\n    ELSE pr.tables\n  END AS tables\nFROM\n  pg_catalog.pg_publication AS p\n  LEFT JOIN LATERAL (\n    SELECT\n      COALESCE(\n        array_agg(\n          json_build_object(\n            $2,\n            c.oid :: int8,\n            $3,\n            c.relname,\n            $4,\n            nc.nspname\n          )\n        ),\n        $5\n      ) AS tables\n    FROM\n      pg_catalog.pg_publication_rel AS pr\n      JOIN pg_class AS c ON pr.prrelid = c.oid\n      join pg_namespace as nc on c.relnamespace = nc.oid\n    WHERE\n      pr.prpubid = p.oid\n  ) AS pr ON $6 = $7\nWHERE\n  $8",
          "Fingerprint": "2e2e4cdd"
        },
        {
          "query": "SET idle_in_transaction_session_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.401828",
          "rows": "0",
          "Query": "SET idle_in_transaction_session_timeout = 0",
          "Fingerprint": "419d6119"
        },
        {
          "query": "SET transaction_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.344597",
          "rows": "0",
          "Query": "SET transaction_timeout = 0",
          "Fingerprint": "c9aafa99"
        },
        {
          "query": "SET statement_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.957163",
          "rows": "0",
          "Query": "SET statement_timeout = 0",
          "Fingerprint": "27ded464"
        },
        {
          "query": "SET row_security = off",
          "calls": "41",
          "total_time_ms": "0.250875",
          "rows": "0",
          "Query": "SET row_security = off",
          "Fingerprint": "fb6611bc"
        },
        {
          "query": "with foreign_tables as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  obj_description(c.oid) as comment,\n  fs.srvname as foreign_server_name,\n  fdw.fdwname as foreign_data_wrapper_name,\n  handler.proname as foreign_data_wrapper_handler\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  inner join pg_foreign_table ft on ft.ftrelid = c.oid\n  inner join pg_foreign_server fs on fs.oid = ft.ftserver\n  inner join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw\n  inner join pg_proc handler on handler.oid = fdw.fdwhandler\nwhere\n  c.relkind = $1\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $2 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $3\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $4 THEN CASE\n      WHEN bt.typelem <> $5 :: oid\n      AND bt.typlen = $6 THEN $7\n      WHEN nbt.nspname = $8 THEN format_type(t.typbasetype, $9)\n      ELSE $10\n    END\n    ELSE CASE\n      WHEN t.typelem <> $11 :: oid\n      AND t.typlen = $12 THEN $13\n      WHEN nt.nspname = $14 THEN format_type(a.atttypid, $15)\n      ELSE $16\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($17, $18) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $19 THEN $20\n    WHEN $21 THEN $22\n    ELSE $23\n  END AS identity_generation,\n  a.attgenerated IN ($24) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $25 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($26, $27)\n    OR c.relkind IN ($28, $29) AND pg_column_is_updatable(c.oid, a.attnum, $30)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $31\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$32] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $33 AND cardinality(conkey) = $34\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$35] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $36),\n        $37,\n        length(pg_get_constraintdef(pg_constraint.oid, $38)) - $39\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $40 AND cardinality(conkey) = $41\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $42\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($43, $44, $45, $46, $47))\n  AND (\n    pg_has_role(c.relowner, $48)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $49\n    )\n  )\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = foreign_tables.id)\n    FROM\n      columns\n  ),\n  $50\n) AS columns\nfrom foreign_tables where schema IN ($51)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:17:01.330Z",
          "calls": "41",
          "total_time_ms": "0.858437",
          "rows": "0",
          "Query": "with foreign_tables as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  obj_description(c.oid) as comment,\n  fs.srvname as foreign_server_name,\n  fdw.fdwname as foreign_data_wrapper_name,\n  handler.proname as foreign_data_wrapper_handler\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  inner join pg_foreign_table ft on ft.ftrelid = c.oid\n  inner join pg_foreign_server fs on fs.oid = ft.ftserver\n  inner join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw\n  inner join pg_proc handler on handler.oid = fdw.fdwhandler\nwhere\n  c.relkind = $1\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $2 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $3\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $4 THEN CASE\n      WHEN bt.typelem <> $5 :: oid\n      AND bt.typlen = $6 THEN $7\n      WHEN nbt.nspname = $8 THEN format_type(t.typbasetype, $9)\n      ELSE $10\n    END\n    ELSE CASE\n      WHEN t.typelem <> $11 :: oid\n      AND t.typlen = $12 THEN $13\n      WHEN nt.nspname = $14 THEN format_type(a.atttypid, $15)\n      ELSE $16\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($17, $18) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $19 THEN $20\n    WHEN $21 THEN $22\n    ELSE $23\n  END AS identity_generation,\n  a.attgenerated IN ($24) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $25 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($26, $27)\n    OR c.relkind IN ($28, $29) AND pg_column_is_updatable(c.oid, a.attnum, $30)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $31\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$32] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $33 AND cardinality(conkey) = $34\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$35] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $36),\n        $37,\n        length(pg_get_constraintdef(pg_constraint.oid, $38)) - $39\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $40 AND cardinality(conkey) = $41\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $42\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($43, $44, $45, $46, $47))\n  AND (\n    pg_has_role(c.relowner, $48)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $49\n    )\n  )\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = foreign_tables.id)\n    FROM\n      columns\n  ),\n  $50\n) AS columns\nfrom foreign_tables where schema IN ($51)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:17:01.330Z",
          "Fingerprint": "805f0060"
        },
        {
          "query": "SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = $1 THEN $2::\"char\" ELSE $3::\"char\" END, c.relowner) AS acldefault, CASE WHEN c.relkind = $4 THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE $5 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, $6 AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,$7),$8) AS reloptions, CASE WHEN $9 = ANY (c.reloptions) THEN $10::text WHEN $11 = ANY (c.reloptions) THEN $12::text ELSE $13 END AS checkoption, am.amname, (d.deptype = $14) IS TRUE AS is_identity_sequence, c.relispartition AS ispartition \nFROM pg_class c\nLEFT JOIN pg_depend d ON (c.relkind = $15 AND d.classid = $16::regclass AND d.objid = c.oid AND d.objsubid = $17 AND d.refclassid = $18::regclass AND d.deptype IN ($19, $20))\nLEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)\nLEFT JOIN pg_am am ON (c.relam = am.oid)\nLEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = $21 AND c.relkind <> $22)\nWHERE c.relkind IN ($23, $24, $25, $26, $27, $28, $29)\nORDER BY c.oid",
          "calls": "36",
          "total_time_ms": "3448.801096",
          "mean_time_ms": "95.8000304444444",
          "rows": "14824",
          "Query": "SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = $1 THEN $2::\"char\" ELSE $3::\"char\" END, c.relowner) AS acldefault, CASE WHEN c.relkind = $4 THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE $5 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, $6 AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,$7),$8) AS reloptions, CASE WHEN $9 = ANY (c.reloptions) THEN $10::text WHEN $11 = ANY (c.reloptions) THEN $12::text ELSE $13 END AS checkoption, am.amname, (d.deptype = $14) IS TRUE AS is_identity_sequence, c.relispartition AS ispartition \nFROM pg_class c\nLEFT JOIN pg_depend d ON (c.relkind = $15 AND d.classid = $16::regclass AND d.objid = c.oid AND d.objsubid = $17 AND d.refclassid = $18::regclass AND d.deptype IN ($19, $20))\nLEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)\nLEFT JOIN pg_am am ON (c.relam = am.oid)\nLEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = $21 AND c.relkind <> $22)\nWHERE c.relkind IN ($23, $24, $25, $26, $27, $28, $29)\nORDER BY c.oid",
          "Fingerprint": "43860e47"
        },
        {
          "query": "SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid",
          "calls": "36",
          "total_time_ms": "644.090406",
          "mean_time_ms": "17.8914001666667",
          "rows": "189526",
          "Query": "SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid",
          "Fingerprint": "189d6e81"
        },
        {
          "query": "SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, $1) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $2) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $3) AS indstatvals, i.indnullsnotdistinct FROM unnest($4::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ($5,$6,$7)) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = $8) AND i.indisready ORDER BY i.indrelid, indexname",
          "calls": "36",
          "total_time_ms": "544.603807",
          "mean_time_ms": "15.1278835277778",
          "rows": "10108",
          "Query": "SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, $1) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $2) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $3) AS indstatvals, i.indnullsnotdistinct FROM unnest($4::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ($5,$6,$7)) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = $8) AND i.indisready ORDER BY i.indrelid, indexname",
          "Fingerprint": "8c28798a"
        },
        {
          "query": "SELECT\na.attrelid,\na.attnum,\na.attname,\na.attstattarget,\na.attstorage,\nt.typstorage,\na.attnotnull,\na.atthasdef,\na.attisdropped,\na.attlen,\na.attalign,\na.attislocal,\npg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,\narray_to_string(a.attoptions, $1) AS attoptions,\nCASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE $2 END AS attcollation,\npg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || $3 || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), $4) AS attfdwoptions,\na.attcompression AS attcompression,\na.attidentity,\nCASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE $5 END AS attmissingval,\na.attgenerated\nFROM unnest($6::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)\nWHERE a.attnum > $7::pg_catalog.int2\nORDER BY a.attrelid, a.attnum",
          "calls": "36",
          "total_time_ms": "477.764626",
          "mean_time_ms": "13.2712396111111",
          "rows": "53780",
          "Query": "SELECT\na.attrelid,\na.attnum,\na.attname,\na.attstattarget,\na.attstorage,\nt.typstorage,\na.attnotnull,\na.atthasdef,\na.attisdropped,\na.attlen,\na.attalign,\na.attislocal,\npg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,\narray_to_string(a.attoptions, $1) AS attoptions,\nCASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE $2 END AS attcollation,\npg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || $3 || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), $4) AS attfdwoptions,\na.attcompression AS attcompression,\na.attidentity,\nCASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE $5 END AS attmissingval,\na.attgenerated\nFROM unnest($6::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)\nWHERE a.attnum > $7::pg_catalog.int2\nORDER BY a.attrelid, a.attnum",
          "Fingerprint": "8a143ec8"
        },
        {
          "query": "SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault($1, p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = $2::regclass AND pip.objsubid = $3) WHERE p.prokind <> $4\n  AND NOT EXISTS (SELECT $5 FROM pg_depend WHERE classid = $6::regclass AND objid = p.oid AND deptype = $7)\n  AND (\n  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = $8)\n  OR EXISTS (SELECT $9 FROM pg_cast\n  WHERE pg_cast.oid > $10 \n  AND p.oid = pg_cast.castfunc)\n  OR EXISTS (SELECT $11 FROM pg_transform\n  WHERE pg_transform.oid > $12 AND \n  (p.oid = pg_transform.trffromsql\n  OR p.oid = pg_transform.trftosql))\n  OR p.proacl IS DISTINCT FROM pip.initprivs)",
          "calls": "36",
          "total_time_ms": "396.306517",
          "mean_time_ms": "11.0085143611111",
          "rows": "16637",
          "Query": "SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault($1, p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = $2::regclass AND pip.objsubid = $3) WHERE p.prokind <> $4\n  AND NOT EXISTS (SELECT $5 FROM pg_depend WHERE classid = $6::regclass AND objid = p.oid AND deptype = $7)\n  AND (\n  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = $8)\n  OR EXISTS (SELECT $9 FROM pg_cast\n  WHERE pg_cast.oid > $10 \n  AND p.oid = pg_cast.castfunc)\n  OR EXISTS (SELECT $11 FROM pg_transform\n  WHERE pg_transform.oid > $12 AND \n  (p.oid = pg_transform.trffromsql\n  OR p.oid = pg_transform.trftosql))\n  OR p.proacl IS DISTINCT FROM pip.initprivs)",
          "Fingerprint": "21a0331a"
        },
        {
          "query": "SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != $1 AND deptype != $2\nUNION ALL\nSELECT $3::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ($4, $5, $6) AND classid = $7::regclass AND objid = o.oid AND NOT (refclassid = $8::regclass AND amopfamily = refobjid)\nUNION ALL\nSELECT $9::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ($10, $11, $12) AND classid = $13::regclass AND objid = p.oid AND NOT (refclassid = $14::regclass AND amprocfamily = refobjid)\nORDER BY 1,2",
          "calls": "36",
          "total_time_ms": "394.801907",
          "mean_time_ms": "10.9667196388889",
          "rows": "274216",
          "Query": "SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != $1 AND deptype != $2\nUNION ALL\nSELECT $3::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ($4, $5, $6) AND classid = $7::regclass AND objid = o.oid AND NOT (refclassid = $8::regclass AND amopfamily = refobjid)\nUNION ALL\nSELECT $9::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ($10, $11, $12) AND classid = $13::regclass AND objid = p.oid AND NOT (refclassid = $14::regclass AND amprocfamily = refobjid)\nORDER BY 1,2",
          "Fingerprint": "72852126"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"_filters\", \"_order_by\", \"_direction\" FROM json_to_record(pgrst_payload.json_data) AS _(\"_filters\" jsonb, \"_order_by\" text, \"_direction\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"filter_projects\"(\"_filters\" := pgrst_body.\"_filters\", \"_order_by\" := pgrst_body.\"_order_by\", \"_direction\" := pgrst_body.\"_direction\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"projects\".* FROM \"pgrst_source\" AS \"projects\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "36",
          "total_time_ms": "393.437611",
          "mean_time_ms": "10.9288225277778",
          "rows": "36",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"_filters\", \"_order_by\", \"_direction\" FROM json_to_record(pgrst_payload.json_data) AS _(\"_filters\" jsonb, \"_order_by\" text, \"_direction\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"filter_projects\"(\"_filters\" := pgrst_body.\"_filters\", \"_order_by\" := pgrst_body.\"_order_by\", \"_direction\" := pgrst_body.\"_direction\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"projects\".* FROM \"pgrst_source\" AS \"projects\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "0bad5e6b"
        },
        {
          "query": "SELECT tableoid, oid, typname, typnamespace, typacl, acldefault($1, typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = $2 THEN $3::\"char\" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[$4] = $5 AND typelem != $6 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type",
          "calls": "36",
          "total_time_ms": "383.257885",
          "mean_time_ms": "10.6460523611111",
          "rows": "38148",
          "Query": "SELECT tableoid, oid, typname, typnamespace, typacl, acldefault($1, typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = $2 THEN $3::\"char\" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[$4] = $5 AND typelem != $6 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type",
          "Fingerprint": "7fd9aab0"
        },
        {
          "query": "SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation",
          "calls": "36",
          "total_time_ms": "303.222024",
          "mean_time_ms": "8.422834",
          "rows": "29340",
          "Query": "SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation",
          "Fingerprint": "fb4316d3"
        },
        {
          "query": "SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc\nFROM unnest($1::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)\nORDER BY a.adrelid, a.adnum",
          "calls": "36",
          "total_time_ms": "230.075726",
          "mean_time_ms": "6.39099238888889",
          "rows": "10081",
          "Query": "SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc\nFROM unnest($1::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)\nORDER BY a.adrelid, a.adnum",
          "Fingerprint": "d4507d78"
        },
        {
          "query": "SELECT \n  con.oid as id, \n  con.conname as constraint_name, \n  con.confdeltype as deletion_action,\n  con.confupdtype as update_action,\n  rel.oid as source_id,\n  nsp.nspname as source_schema, \n  rel.relname as source_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.conkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = rel.oid\n  ) source_columns, \n  frel.oid as target_id,\n  fnsp.nspname as target_schema, \n  frel.relname as target_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.confkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = frel.oid\n  ) target_columns \nFROM \n  pg_constraint con \n  INNER JOIN pg_class rel ON rel.oid = con.conrelid \n  INNER JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace \n  INNER JOIN pg_class frel ON frel.oid = con.confrelid \n  INNER JOIN pg_namespace fnsp ON fnsp.oid = frel.relnamespace \nWHERE \n  con.contype = $1\n  AND nsp.nspname = $2\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T05:13:26.471Z",
          "calls": "34",
          "total_time_ms": "350.834465",
          "mean_time_ms": "10.3186607352941",
          "rows": "3900",
          "Query": "SELECT \n  con.oid as id, \n  con.conname as constraint_name, \n  con.confdeltype as deletion_action,\n  con.confupdtype as update_action,\n  rel.oid as source_id,\n  nsp.nspname as source_schema, \n  rel.relname as source_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.conkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = rel.oid\n  ) source_columns, \n  frel.oid as target_id,\n  fnsp.nspname as target_schema, \n  frel.relname as target_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.confkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = frel.oid\n  ) target_columns \nFROM \n  pg_constraint con \n  INNER JOIN pg_class rel ON rel.oid = con.conrelid \n  INNER JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace \n  INNER JOIN pg_class frel ON frel.oid = con.confrelid \n  INNER JOIN pg_namespace fnsp ON fnsp.oid = frel.relnamespace \nWHERE \n  con.contype = $1\n  AND nsp.nspname = $2\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T05:13:26.471Z",
          "Fingerprint": "d62b169a"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "calls": "30",
          "total_time_ms": "3255.608133",
          "mean_time_ms": "108.5202711",
          "rows": "30",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "Fingerprint": "393cf5c5"
        },
        {
          "query": "select * from storage.search($1,$2,$3,$4,$5,$6,$7,$8)",
          "calls": "30",
          "total_time_ms": "263.756364",
          "mean_time_ms": "8.7918788",
          "rows": "330",
          "Query": "select * from storage.search($1,$2,$3,$4,$5,$6,$7,$8)",
          "Fingerprint": "4855f2f1"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "calls": "30",
          "mean_time_ms": "108.5202711",
          "max_time_ms": "205.438253",
          "total_time_ms": "3255.608133",
          "rows": "30",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "Fingerprint": "393cf5c5"
        },
        {
          "query": "SELECT\n  pol.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS table,\n  c.oid :: int8 AS table_id,\n  pol.polname AS name,\n  CASE\n    WHEN pol.polpermissive THEN $1 :: text\n    ELSE $2 :: text\n  END AS action,\n  CASE\n    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(\n      string_to_array($4 :: text, $5 :: text) :: name []\n    )\n    ELSE array_to_json(\n      ARRAY(\n        SELECT\n          pg_roles.rolname\n        FROM\n          pg_roles\n        WHERE\n          pg_roles.oid = ANY (pol.polroles)\n        ORDER BY\n          pg_roles.rolname\n      )\n    )\n  END AS roles,\n  CASE\n    pol.polcmd\n    WHEN $6 :: \"char\" THEN $7 :: text\n    WHEN $8 :: \"char\" THEN $9 :: text\n    WHEN $10 :: \"char\" THEN $11 :: text\n    WHEN $12 :: \"char\" THEN $13 :: text\n    WHEN $14 :: \"char\" THEN $15 :: text\n    ELSE $16 :: text\n  END AS command,\n  pg_get_expr(pol.polqual, pol.polrelid) AS definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check\nFROM\n  pg_policy pol\n  JOIN pg_class c ON c.oid = pol.polrelid\n  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname NOT IN ($17,$18,$19)",
          "calls": "24",
          "total_time_ms": "664.760387",
          "mean_time_ms": "27.6983494583333",
          "rows": "9760",
          "Query": "SELECT\n  pol.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS table,\n  c.oid :: int8 AS table_id,\n  pol.polname AS name,\n  CASE\n    WHEN pol.polpermissive THEN $1 :: text\n    ELSE $2 :: text\n  END AS action,\n  CASE\n    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(\n      string_to_array($4 :: text, $5 :: text) :: name []\n    )\n    ELSE array_to_json(\n      ARRAY(\n        SELECT\n          pg_roles.rolname\n        FROM\n          pg_roles\n        WHERE\n          pg_roles.oid = ANY (pol.polroles)\n        ORDER BY\n          pg_roles.rolname\n      )\n    )\n  END AS roles,\n  CASE\n    pol.polcmd\n    WHEN $6 :: \"char\" THEN $7 :: text\n    WHEN $8 :: \"char\" THEN $9 :: text\n    WHEN $10 :: \"char\" THEN $11 :: text\n    WHEN $12 :: \"char\" THEN $13 :: text\n    WHEN $14 :: \"char\" THEN $15 :: text\n    ELSE $16 :: text\n  END AS command,\n  pg_get_expr(pol.polqual, pol.polrelid) AS definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check\nFROM\n  pg_policy pol\n  JOIN pg_class c ON c.oid = pol.polrelid\n  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname NOT IN ($17,$18,$19)",
          "Fingerprint": "2bc926bd"
        },
        {
          "query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "calls": "22",
          "total_time_ms": "4059.943647",
          "mean_time_ms": "184.542893045455",
          "rows": "4573",
          "Query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "Fingerprint": "ac49b202"
        },
        {
          "query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "calls": "22",
          "mean_time_ms": "184.542893045455",
          "max_time_ms": "547.889806",
          "total_time_ms": "4059.943647",
          "rows": "4573",
          "Query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "Fingerprint": "ac49b202"
        },
        {
          "query": "SELECT\n  pg_t.oid AS id,\n  pg_t.tgrelid AS table_id,\n  CASE\n    WHEN pg_t.tgenabled = $1 THEN $2\n    WHEN pg_t.tgenabled = $3 THEN $4\n    WHEN pg_t.tgenabled = $5 THEN $6\n    WHEN pg_t.tgenabled = $7 THEN $8\n    END AS enabled_mode,\n  (\n    STRING_TO_ARRAY(\n      ENCODE(pg_t.tgargs, $9), $10\n    )\n  )[:pg_t.tgnargs] AS function_args,\n  is_t.trigger_name AS name,\n  is_t.event_object_table AS table,\n  is_t.event_object_schema AS schema,\n  is_t.action_condition AS condition,\n  is_t.action_orientation AS orientation,\n  is_t.action_timing AS activation,\n  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,\n  pg_p.proname AS function_name,\n  pg_n.nspname AS function_schema\nFROM\n  pg_trigger AS pg_t\nJOIN\n  pg_class AS pg_c\nON pg_t.tgrelid = pg_c.oid\nJOIN pg_namespace AS table_ns\nON pg_c.relnamespace = table_ns.oid\nJOIN information_schema.triggers AS is_t\nON is_t.trigger_name = pg_t.tgname\nAND pg_c.relname = is_t.event_object_table\nAND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace\nJOIN pg_proc AS pg_p\nON pg_t.tgfoid = pg_p.oid\nJOIN pg_namespace AS pg_n\nON pg_p.pronamespace = pg_n.oid\nWHERE\n  table_ns.nspname NOT IN ($11,$12,$13)\n  \n  \n  \nGROUP BY\n  pg_t.oid,\n  pg_t.tgrelid,\n  pg_t.tgenabled,\n  pg_t.tgargs,\n  pg_t.tgnargs,\n  is_t.trigger_name,\n  is_t.event_object_table,\n  is_t.event_object_schema,\n  is_t.action_condition,\n  is_t.action_orientation,\n  is_t.action_timing,\n  pg_p.proname,\n  pg_n.nspname",
          "calls": "17",
          "total_time_ms": "310.477875",
          "mean_time_ms": "18.2634044117647",
          "rows": "2872",
          "Query": "SELECT\n  pg_t.oid AS id,\n  pg_t.tgrelid AS table_id,\n  CASE\n    WHEN pg_t.tgenabled = $1 THEN $2\n    WHEN pg_t.tgenabled = $3 THEN $4\n    WHEN pg_t.tgenabled = $5 THEN $6\n    WHEN pg_t.tgenabled = $7 THEN $8\n    END AS enabled_mode,\n  (\n    STRING_TO_ARRAY(\n      ENCODE(pg_t.tgargs, $9), $10\n    )\n  )[:pg_t.tgnargs] AS function_args,\n  is_t.trigger_name AS name,\n  is_t.event_object_table AS table,\n  is_t.event_object_schema AS schema,\n  is_t.action_condition AS condition,\n  is_t.action_orientation AS orientation,\n  is_t.action_timing AS activation,\n  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,\n  pg_p.proname AS function_name,\n  pg_n.nspname AS function_schema\nFROM\n  pg_trigger AS pg_t\nJOIN\n  pg_class AS pg_c\nON pg_t.tgrelid = pg_c.oid\nJOIN pg_namespace AS table_ns\nON pg_c.relnamespace = table_ns.oid\nJOIN information_schema.triggers AS is_t\nON is_t.trigger_name = pg_t.tgname\nAND pg_c.relname = is_t.event_object_table\nAND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace\nJOIN pg_proc AS pg_p\nON pg_t.tgfoid = pg_p.oid\nJOIN pg_namespace AS pg_n\nON pg_p.pronamespace = pg_n.oid\nWHERE\n  table_ns.nspname NOT IN ($11,$12,$13)\n  \n  \n  \nGROUP BY\n  pg_t.oid,\n  pg_t.tgrelid,\n  pg_t.tgenabled,\n  pg_t.tgargs,\n  pg_t.tgnargs,\n  is_t.trigger_name,\n  is_t.event_object_table,\n  is_t.event_object_schema,\n  is_t.action_condition,\n  is_t.action_orientation,\n  is_t.action_timing,\n  pg_p.proname,\n  pg_n.nspname",
          "Fingerprint": "fa5418aa"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "13",
          "total_time_ms": "469.941505",
          "mean_time_ms": "36.1493465384615",
          "rows": "532",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "335d3082"
        },
        {
          "query": "INSERT INTO \"users\" (\"aud\", \"banned_until\", \"confirmation_sent_at\", \"confirmation_token\", \"created_at\", \"deleted_at\", \"email\", \"email_change\", \"email_change_confirm_status\", \"email_change_sent_at\", \"email_change_token_current\", \"email_change_token_new\", \"email_confirmed_at\", \"encrypted_password\", \"id\", \"instance_id\", \"invited_at\", \"is_anonymous\", \"is_sso_user\", \"last_sign_in_at\", \"phone\", \"phone_change\", \"phone_change_sent_at\", \"phone_change_token\", \"phone_confirmed_at\", \"raw_app_meta_data\", \"raw_user_meta_data\", \"reauthentication_sent_at\", \"reauthentication_token\", \"recovery_sent_at\", \"recovery_token\", \"role\", \"updated_at\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)",
          "calls": "7",
          "total_time_ms": "370.288915",
          "mean_time_ms": "52.8984164285714",
          "rows": "7",
          "Query": "INSERT INTO \"users\" (\"aud\", \"banned_until\", \"confirmation_sent_at\", \"confirmation_token\", \"created_at\", \"deleted_at\", \"email\", \"email_change\", \"email_change_confirm_status\", \"email_change_sent_at\", \"email_change_token_current\", \"email_change_token_new\", \"email_confirmed_at\", \"encrypted_password\", \"id\", \"instance_id\", \"invited_at\", \"is_anonymous\", \"is_sso_user\", \"last_sign_in_at\", \"phone\", \"phone_change\", \"phone_change_sent_at\", \"phone_change_token\", \"phone_confirmed_at\", \"raw_app_meta_data\", \"raw_user_meta_data\", \"reauthentication_sent_at\", \"reauthentication_token\", \"recovery_sent_at\", \"recovery_token\", \"role\", \"updated_at\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)",
          "Fingerprint": "28bfbb4f"
        },
        {
          "query": "delete from public.profiles where id in ($1)",
          "calls": "6",
          "total_time_ms": "308.323666",
          "mean_time_ms": "51.3872776666667",
          "rows": "6",
          "Query": "delete from public.profiles where id in ($1)",
          "Fingerprint": "8fff047e"
        },
        {
          "query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "calls": "5",
          "total_time_ms": "783.325132",
          "mean_time_ms": "156.6650264",
          "rows": "5",
          "Query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "Fingerprint": "ad2f00c3"
        },
        {
          "query": "SELECT concat(schemaname, $1, tablename, $2, policyname) as policy\n    FROM   pg_policies",
          "calls": "5",
          "total_time_ms": "215.448357",
          "mean_time_ms": "43.0896714",
          "rows": "1777",
          "Query": "SELECT concat(schemaname, $1, tablename, $2, policyname) as policy\n    FROM   pg_policies",
          "Fingerprint": "46133688"
        },
        {
          "query": "SELECT labelfile, spcmapfile, lsn FROM pg_backup_stop($1)",
          "calls": "5",
          "total_time_ms": "204.326571",
          "mean_time_ms": "40.8653142",
          "rows": "5",
          "Query": "SELECT labelfile, spcmapfile, lsn FROM pg_backup_stop($1)",
          "Fingerprint": "11e57483"
        },
        {
          "query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "calls": "5",
          "mean_time_ms": "156.6650264",
          "max_time_ms": "178.818857",
          "total_time_ms": "783.325132",
          "rows": "5",
          "Query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "Fingerprint": "ad2f00c3"
        },
        {
          "query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
          "calls": "4",
          "total_time_ms": "323.330854",
          "mean_time_ms": "80.8327135",
          "rows": "0",
          "Query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
          "Fingerprint": "92e79eb0"
        },
        {
          "query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "calls": "2",
          "total_time_ms": "273.3887",
          "mean_time_ms": "136.69435",
          "rows": "902",
          "Query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "069b33dd"
        },
        {
          "query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "calls": "2",
          "total_time_ms": "220.062577",
          "mean_time_ms": "110.0312885",
          "rows": "0",
          "Query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "Fingerprint": "0f1f0b6b"
        },
        {
          "query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "207.808953",
          "mean_time_ms": "103.9044765",
          "rows": "0",
          "Query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "Fingerprint": "c6431895"
        },
        {
          "query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "206.381392",
          "mean_time_ms": "103.190696",
          "rows": "0",
          "Query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3607e581"
        },
        {
          "query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "206.062412",
          "mean_time_ms": "103.031206",
          "rows": "0",
          "Query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "393ce475"
        },
        {
          "query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "205.673718",
          "mean_time_ms": "102.836859",
          "rows": "0",
          "Query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3fea036f"
        },
        {
          "query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "205.463539",
          "mean_time_ms": "102.7317695",
          "rows": "0",
          "Query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "e68eeac4"
        },
        {
          "query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "204.001209",
          "mean_time_ms": "102.0006045",
          "rows": "0",
          "Query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0ecbf6a3"
        },
        {
          "query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "203.976468",
          "mean_time_ms": "101.988234",
          "rows": "0",
          "Query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a70a9671"
        },
        {
          "query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.699628",
          "mean_time_ms": "101.349814",
          "rows": "0",
          "Query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "fbbe9f07"
        },
        {
          "query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.517924",
          "mean_time_ms": "101.258962",
          "rows": "0",
          "Query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "985defa9"
        },
        {
          "query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.514213",
          "mean_time_ms": "101.2571065",
          "rows": "0",
          "Query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0cdfc356"
        },
        {
          "query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.451113",
          "mean_time_ms": "101.2255565",
          "rows": "0",
          "Query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9d63facb"
        },
        {
          "query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.02539",
          "mean_time_ms": "101.012695",
          "rows": "0",
          "Query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "af8cfe10"
        },
        {
          "query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.014789",
          "mean_time_ms": "101.0073945",
          "rows": "0",
          "Query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "4aa64b10"
        },
        {
          "query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.994657",
          "mean_time_ms": "100.9973285",
          "rows": "0",
          "Query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ab6ea55e"
        },
        {
          "query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.979829",
          "mean_time_ms": "100.9899145",
          "rows": "0",
          "Query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ee687845"
        },
        {
          "query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.977313",
          "mean_time_ms": "100.9886565",
          "rows": "0",
          "Query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "61246560"
        },
        {
          "query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.95722",
          "mean_time_ms": "100.97861",
          "rows": "0",
          "Query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "725b8f3c"
        },
        {
          "query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.852303",
          "mean_time_ms": "100.9261515",
          "rows": "0",
          "Query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b9c2a293"
        },
        {
          "query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.743704",
          "mean_time_ms": "100.871852",
          "rows": "0",
          "Query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "63153467"
        },
        {
          "query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.709249",
          "mean_time_ms": "100.8546245",
          "rows": "0",
          "Query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a27fced0"
        },
        {
          "query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.368563",
          "mean_time_ms": "100.6842815",
          "rows": "0",
          "Query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "11df5844"
        },
        {
          "query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.250924",
          "mean_time_ms": "100.625462",
          "rows": "2",
          "Query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "Fingerprint": "c8e5bf36"
        },
        {
          "query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.235425",
          "mean_time_ms": "100.6177125",
          "rows": "0",
          "Query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "Fingerprint": "254f4411"
        },
        {
          "query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.062897",
          "mean_time_ms": "100.5314485",
          "rows": "0",
          "Query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b24724cf"
        },
        {
          "query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.595134",
          "mean_time_ms": "100.297567",
          "rows": "0",
          "Query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "762656ca"
        },
        {
          "query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.491872",
          "mean_time_ms": "100.245936",
          "rows": "0",
          "Query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "d828f6ba"
        },
        {
          "query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.426622",
          "mean_time_ms": "100.213311",
          "rows": "0",
          "Query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9bf1c2fe"
        },
        {
          "query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.351478",
          "mean_time_ms": "100.175739",
          "rows": "0",
          "Query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dadb92a9"
        },
        {
          "query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.275125",
          "mean_time_ms": "100.1375625",
          "rows": "0",
          "Query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "Fingerprint": "cc50e652"
        },
        {
          "query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "199.807887",
          "mean_time_ms": "99.9039435",
          "rows": "0",
          "Query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "06813e78"
        },
        {
          "query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "199.698604",
          "mean_time_ms": "99.849302",
          "rows": "0",
          "Query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6c04fcb5"
        },
        {
          "query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "calls": "2",
          "mean_time_ms": "136.69435",
          "max_time_ms": "257.34823",
          "total_time_ms": "273.3887",
          "rows": "902",
          "Query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "069b33dd"
        },
        {
          "query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "calls": "2",
          "mean_time_ms": "110.0312885",
          "max_time_ms": "219.722141",
          "total_time_ms": "220.062577",
          "rows": "0",
          "Query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "Fingerprint": "0f1f0b6b"
        },
        {
          "query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.9044765",
          "max_time_ms": "104.666803",
          "total_time_ms": "207.808953",
          "rows": "0",
          "Query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "Fingerprint": "c6431895"
        },
        {
          "query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.190696",
          "max_time_ms": "107.763366",
          "total_time_ms": "206.381392",
          "rows": "0",
          "Query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3607e581"
        },
        {
          "query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.031206",
          "max_time_ms": "103.208161",
          "total_time_ms": "206.062412",
          "rows": "0",
          "Query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "393ce475"
        },
        {
          "query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.836859",
          "max_time_ms": "110.852408",
          "total_time_ms": "205.673718",
          "rows": "0",
          "Query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3fea036f"
        },
        {
          "query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.7317695",
          "max_time_ms": "111.358102",
          "total_time_ms": "205.463539",
          "rows": "0",
          "Query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "e68eeac4"
        },
        {
          "query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.0006045",
          "max_time_ms": "103.951377",
          "total_time_ms": "204.001209",
          "rows": "0",
          "Query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0ecbf6a3"
        },
        {
          "query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.988234",
          "max_time_ms": "108.352564",
          "total_time_ms": "203.976468",
          "rows": "0",
          "Query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a70a9671"
        },
        {
          "query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.349814",
          "max_time_ms": "104.02735",
          "total_time_ms": "202.699628",
          "rows": "0",
          "Query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "fbbe9f07"
        },
        {
          "query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.258962",
          "max_time_ms": "103.113763",
          "total_time_ms": "202.517924",
          "rows": "0",
          "Query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "985defa9"
        },
        {
          "query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.2571065",
          "max_time_ms": "103.900791",
          "total_time_ms": "202.514213",
          "rows": "0",
          "Query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0cdfc356"
        },
        {
          "query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.2255565",
          "max_time_ms": "103.772709",
          "total_time_ms": "202.451113",
          "rows": "0",
          "Query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9d63facb"
        },
        {
          "query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.012695",
          "max_time_ms": "103.267842",
          "total_time_ms": "202.02539",
          "rows": "0",
          "Query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "af8cfe10"
        },
        {
          "query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.0073945",
          "max_time_ms": "103.32245",
          "total_time_ms": "202.014789",
          "rows": "0",
          "Query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "4aa64b10"
        },
        {
          "query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9973285",
          "max_time_ms": "102.47602",
          "total_time_ms": "201.994657",
          "rows": "0",
          "Query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ab6ea55e"
        },
        {
          "query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9899145",
          "max_time_ms": "103.205074",
          "total_time_ms": "201.979829",
          "rows": "0",
          "Query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ee687845"
        },
        {
          "query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9886565",
          "max_time_ms": "103.240863",
          "total_time_ms": "201.977313",
          "rows": "0",
          "Query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "61246560"
        },
        {
          "query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.97861",
          "max_time_ms": "103.969483",
          "total_time_ms": "201.95722",
          "rows": "0",
          "Query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "725b8f3c"
        },
        {
          "query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9261515",
          "max_time_ms": "103.91475",
          "total_time_ms": "201.852303",
          "rows": "0",
          "Query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b9c2a293"
        },
        {
          "query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.871852",
          "max_time_ms": "103.079578",
          "total_time_ms": "201.743704",
          "rows": "0",
          "Query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "63153467"
        },
        {
          "query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.8546245",
          "max_time_ms": "103.134612",
          "total_time_ms": "201.709249",
          "rows": "0",
          "Query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a27fced0"
        },
        {
          "query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.6842815",
          "max_time_ms": "103.245174",
          "total_time_ms": "201.368563",
          "rows": "0",
          "Query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "11df5844"
        },
        {
          "query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.625462",
          "max_time_ms": "102.487678",
          "total_time_ms": "201.250924",
          "rows": "2",
          "Query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "Fingerprint": "c8e5bf36"
        },
        {
          "query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.6177125",
          "max_time_ms": "103.226005",
          "total_time_ms": "201.235425",
          "rows": "0",
          "Query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "Fingerprint": "254f4411"
        },
        {
          "query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.5314485",
          "max_time_ms": "103.15837",
          "total_time_ms": "201.062897",
          "rows": "0",
          "Query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b24724cf"
        },
        {
          "query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.297567",
          "max_time_ms": "103.2202",
          "total_time_ms": "200.595134",
          "rows": "0",
          "Query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "762656ca"
        },
        {
          "query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.245936",
          "max_time_ms": "104.799331",
          "total_time_ms": "200.491872",
          "rows": "0",
          "Query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "d828f6ba"
        },
        {
          "query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.213311",
          "max_time_ms": "102.488242",
          "total_time_ms": "200.426622",
          "rows": "0",
          "Query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9bf1c2fe"
        },
        {
          "query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.175739",
          "max_time_ms": "103.10024",
          "total_time_ms": "200.351478",
          "rows": "0",
          "Query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dadb92a9"
        },
        {
          "query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.1375625",
          "max_time_ms": "103.138458",
          "total_time_ms": "200.275125",
          "rows": "0",
          "Query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "Fingerprint": "cc50e652"
        },
        {
          "query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.9039435",
          "max_time_ms": "104.654816",
          "total_time_ms": "199.807887",
          "rows": "0",
          "Query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "06813e78"
        },
        {
          "query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.849302",
          "max_time_ms": "104.678428",
          "total_time_ms": "199.698604",
          "rows": "0",
          "Query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6c04fcb5"
        },
        {
          "query": "COPY public.tack_rates (id, project_id, rate, material_type, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.832495",
          "max_time_ms": "101.546485",
          "total_time_ms": "199.66499",
          "rows": "0",
          "Query": "COPY public.tack_rates (id, project_id, rate, material_type, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b0803b87"
        },
        {
          "query": "COPY public.audit_log (id, table_name, action, row_id, before_data, after_data, changed_by, changed_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.7842675",
          "max_time_ms": "103.065844",
          "total_time_ms": "199.568535",
          "rows": "0",
          "Query": "COPY public.audit_log (id, table_name, action, row_id, before_data, after_data, changed_by, changed_at, deleted_at) FROM stdin",
          "Fingerprint": "704b2583"
        },
        {
          "query": "COPY public.equipment_maintenance (id, equipment_id, maintenance_date, type, description, performed_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.463506",
          "max_time_ms": "103.164462",
          "total_time_ms": "198.927012",
          "rows": "0",
          "Query": "COPY public.equipment_maintenance (id, equipment_id, maintenance_date, type, description, performed_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6e8cab3d"
        },
        {
          "query": "COPY realtime.subscription (id, subscription_id, entity, filters, claims, created_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.4489215",
          "max_time_ms": "100.152143",
          "total_time_ms": "198.897843",
          "rows": "0",
          "Query": "COPY realtime.subscription (id, subscription_id, entity, filters, claims, created_at) FROM stdin",
          "Fingerprint": "b4bc70d0"
        },
        {
          "query": "COPY public.safety_incidents (id, project_id, incident_date, description, reported_by, severity, resolved, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.3453095",
          "max_time_ms": "103.06347",
          "total_time_ms": "198.690619",
          "rows": "0",
          "Query": "COPY public.safety_incidents (id, project_id, incident_date, description, reported_by, severity, resolved, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dd094ff1"
        },
        {
          "query": "COPY public.user_projects (id, user_id, project_id, role, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.1600695",
          "max_time_ms": "103.175814",
          "total_time_ms": "198.320139",
          "rows": "0",
          "Query": "COPY public.user_projects (id, user_id, project_id, role, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6494210b"
        },
        {
          "query": "COPY auth.saml_relay_states (id, sso_provider_id, request_id, for_email, redirect_to, created_at, updated_at, flow_state_id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.1385155",
          "max_time_ms": "99.562381",
          "total_time_ms": "198.277031",
          "rows": "0",
          "Query": "COPY auth.saml_relay_states (id, sso_provider_id, request_id, for_email, redirect_to, created_at, updated_at, flow_state_id) FROM stdin",
          "Fingerprint": "ea71b0bd"
        },
        {
          "query": "COPY public.task_dependencies (id, task_id, depends_on_task_id, created_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.132069",
          "max_time_ms": "102.400731",
          "total_time_ms": "198.264138",
          "rows": "0",
          "Query": "COPY public.task_dependencies (id, task_id, depends_on_task_id, created_at, deleted_at) FROM stdin",
          "Fingerprint": "084a3cc5"
        },
        {
          "query": "COPY public.avatars (id, url, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.115221",
          "max_time_ms": "103.966743",
          "total_time_ms": "198.230442",
          "rows": "0",
          "Query": "COPY public.avatars (id, url, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "10445d5c"
        },
        {
          "query": "COPY auth.mfa_factors (id, user_id, friendly_name, factor_type, status, created_at, updated_at, secret, phone, last_challenged_at, web_authn_credential, web_authn_aaguid) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.090762",
          "max_time_ms": "99.429246",
          "total_time_ms": "198.181524",
          "rows": "0",
          "Query": "COPY auth.mfa_factors (id, user_id, friendly_name, factor_type, status, created_at, updated_at, secret, phone, last_challenged_at, web_authn_credential, web_authn_aaguid) FROM stdin",
          "Fingerprint": "cec579ea"
        },
        {
          "query": "COPY public.materials (id, organization_id, name, description, unit, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0780935",
          "max_time_ms": "99.630832",
          "total_time_ms": "198.156187",
          "rows": "0",
          "Query": "COPY public.materials (id, organization_id, name, description, unit, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "8aa4d8bf"
        },
        {
          "query": "COPY public.vendor_documents (id, vendor_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0703345",
          "max_time_ms": "99.378792",
          "total_time_ms": "198.140669",
          "rows": "0",
          "Query": "COPY public.vendor_documents (id, vendor_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "581b0829"
        },
        {
          "query": "COPY public.accounts_receivable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0671665",
          "max_time_ms": "103.27019",
          "total_time_ms": "198.134333",
          "rows": "0",
          "Query": "COPY public.accounts_receivable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "1ecde75f"
        },
        {
          "query": "COPY public.daily_logs (id, project_id, date, weather, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.035697",
          "max_time_ms": "99.361033",
          "total_time_ms": "198.071394",
          "rows": "0",
          "Query": "COPY public.daily_logs (id, project_id, date, weather, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "5c027ac6"
        },
        {
          "query": "COPY auth.identities (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0258625",
          "max_time_ms": "99.488222",
          "total_time_ms": "198.051725",
          "rows": "0",
          "Query": "COPY auth.identities (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, id) FROM stdin",
          "Fingerprint": "58196849"
        },
        {
          "query": "COPY auth.flow_state (id, user_id, auth_code, code_challenge_method, code_challenge, provider_type, provider_access_token, provider_refresh_token, created_at, updated_at, authentication_method, auth_code_issued_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0232145",
          "max_time_ms": "103.023291",
          "total_time_ms": "198.046429",
          "rows": "0",
          "Query": "COPY auth.flow_state (id, user_id, auth_code, code_challenge_method, code_challenge, provider_type, provider_access_token, provider_refresh_token, created_at, updated_at, authentication_method, auth_code_issued_at) FROM stdin",
          "Fingerprint": "5fc5c63b"
        },
        {
          "query": "COPY auth.mfa_amr_claims (session_id, created_at, updated_at, authentication_method, id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.008733",
          "max_time_ms": "103.181295",
          "total_time_ms": "198.017466",
          "rows": "0",
          "Query": "COPY auth.mfa_amr_claims (session_id, created_at, updated_at, authentication_method, id) FROM stdin",
          "Fingerprint": "7760a2e4"
        },
        {
          "query": "COPY public.organization_projects (id, organization_id, project_id, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.003132",
          "max_time_ms": "99.318153",
          "total_time_ms": "198.006264",
          "rows": "0",
          "Query": "COPY public.organization_projects (id, organization_id, project_id, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3059abb3"
        },
        {
          "query": "COPY auth.refresh_tokens (instance_id, id, token, user_id, revoked, created_at, updated_at, parent, session_id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.947378",
          "max_time_ms": "99.36111",
          "total_time_ms": "197.894756",
          "rows": "0",
          "Query": "COPY auth.refresh_tokens (instance_id, id, token, user_id, revoked, created_at, updated_at, parent, session_id) FROM stdin",
          "Fingerprint": "5780d9c8"
        },
        {
          "query": "COPY public.labor_records (id, line_item_id, worker_count, hours_worked, work_date, work_type, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.9292225",
          "max_time_ms": "99.371704",
          "total_time_ms": "197.858445",
          "rows": "0",
          "Query": "COPY public.labor_records (id, line_item_id, worker_count, hours_worked, work_date, work_type, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "456f60d1"
        },
        {
          "query": "COPY public.material_inventory (id, material_id, organization_id, quantity, last_updated, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.928901",
          "max_time_ms": "102.343097",
          "total_time_ms": "197.857802",
          "rows": "0",
          "Query": "COPY public.material_inventory (id, material_id, organization_id, quantity, last_updated, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6ac46892"
        },
        {
          "query": "COPY auth.sso_providers (id, resource_id, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.885203",
          "max_time_ms": "99.914739",
          "total_time_ms": "197.770406",
          "rows": "0",
          "Query": "COPY auth.sso_providers (id, resource_id, created_at, updated_at) FROM stdin",
          "Fingerprint": "e3bc4723"
        },
        {
          "query": "COPY public.vendors (id, organization_id, name, status, contact_email, contact_phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7803365",
          "max_time_ms": "103.249249",
          "total_time_ms": "197.560673",
          "rows": "0",
          "Query": "COPY public.vendors (id, organization_id, name, status, contact_email, contact_phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "24075ca8"
        },
        {
          "query": "COPY public.change_orders (id, project_id, number, description, status, amount, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7662585",
          "max_time_ms": "98.798355",
          "total_time_ms": "197.532517",
          "rows": "0",
          "Query": "COPY public.change_orders (id, project_id, number, description, status, amount, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "5882c02d"
        },
        {
          "query": "COPY public.photos (id, project_id, url, caption, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7259615",
          "max_time_ms": "98.798059",
          "total_time_ms": "197.451923",
          "rows": "0",
          "Query": "COPY public.photos (id, project_id, url, caption, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "99b591f2"
        },
        {
          "query": "COPY public.bid_packages (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.715568",
          "max_time_ms": "98.786265",
          "total_time_ms": "197.431136",
          "rows": "0",
          "Query": "COPY public.bid_packages (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "33db00f2"
        },
        {
          "query": "COPY public.bim_models (id, project_id, name, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7117465",
          "max_time_ms": "103.064154",
          "total_time_ms": "197.423493",
          "rows": "0",
          "Query": "COPY public.bim_models (id, project_id, name, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "7cbd4961"
        },
        {
          "query": "COPY public.commitments (id, project_id, vendor_id, type, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7070115",
          "max_time_ms": "103.115353",
          "total_time_ms": "197.414023",
          "rows": "0",
          "Query": "COPY public.commitments (id, project_id, vendor_id, type, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "95986b7c"
        },
        {
          "query": "COPY public.material_receipts (id, material_order_id, received_date, quantity, received_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7029815",
          "max_time_ms": "98.706456",
          "total_time_ms": "197.405963",
          "rows": "0",
          "Query": "COPY public.material_receipts (id, material_order_id, received_date, quantity, received_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a41d9dfa"
        },
        {
          "query": "COPY public.crew_members (id, crew_id, profile_id, role, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6990605",
          "max_time_ms": "98.739759",
          "total_time_ms": "197.398121",
          "rows": "0",
          "Query": "COPY public.crew_members (id, crew_id, profile_id, role, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "c052cb3d"
        },
        {
          "query": "COPY public.drawing_versions (id, document_id, version, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.683518",
          "max_time_ms": "103.134743",
          "total_time_ms": "197.367036",
          "rows": "0",
          "Query": "COPY public.drawing_versions (id, document_id, version, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0b26fcaa"
        },
        {
          "query": "COPY public.dashboard_configs (id, profile_id, config, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6810585",
          "max_time_ms": "98.724536",
          "total_time_ms": "197.362117",
          "rows": "0",
          "Query": "COPY public.dashboard_configs (id, profile_id, config, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "1cd42ea2"
        },
        {
          "query": "COPY public.training_records (id, employee_id, training_type, completion_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.663368",
          "max_time_ms": "98.676634",
          "total_time_ms": "197.326736",
          "rows": "0",
          "Query": "COPY public.training_records (id, employee_id, training_type, completion_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "58dd9afa"
        },
        {
          "query": "COPY public.certifications (id, employee_id, certification_type, issue_date, expiry_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6559805",
          "max_time_ms": "103.158594",
          "total_time_ms": "197.311961",
          "rows": "0",
          "Query": "COPY public.certifications (id, employee_id, certification_type, issue_date, expiry_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "278a4a8b"
        },
        {
          "query": "COPY auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, invited_at, confirmation_token, confirmation_sent_at, recovery_token, recovery_sent_at, email_change_token_new, email_change, email_change_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, is_super_admin, created_at, updated_at, phone, phone_confirmed_at, phone_change, phone_change_token, phone_change_sent_at, email_change_token_current, email_change_confirm_status, banned_until, reauthentication_token, reauthentication_sent_at, is_sso_user, deleted_at, is_anonymous) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6528365",
          "max_time_ms": "102.373345",
          "total_time_ms": "197.305673",
          "rows": "0",
          "Query": "COPY auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, invited_at, confirmation_token, confirmation_sent_at, recovery_token, recovery_sent_at, email_change_token_new, email_change, email_change_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, is_super_admin, created_at, updated_at, phone, phone_confirmed_at, phone_change, phone_change_token, phone_change_sent_at, email_change_token_current, email_change_confirm_status, banned_until, reauthentication_token, reauthentication_sent_at, is_sso_user, deleted_at, is_anonymous) FROM stdin",
          "Fingerprint": "43fa7093"
        },
        {
          "query": "COPY auth.saml_providers (id, sso_provider_id, entity_id, metadata_xml, metadata_url, attribute_mapping, created_at, updated_at, name_id_format) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.617569",
          "max_time_ms": "98.653057",
          "total_time_ms": "197.235138",
          "rows": "0",
          "Query": "COPY auth.saml_providers (id, sso_provider_id, entity_id, metadata_xml, metadata_url, attribute_mapping, created_at, updated_at, name_id_format) FROM stdin",
          "Fingerprint": "66acf199"
        },
        {
          "query": "COPY public.audit_logs (id, project_id, action, performed_by, performed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6151865",
          "max_time_ms": "100.978198",
          "total_time_ms": "197.230373",
          "rows": "0",
          "Query": "COPY public.audit_logs (id, project_id, action, performed_by, performed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a3eec967"
        },
        {
          "query": "COPY public.job_titles (id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.60715",
          "max_time_ms": "98.828301",
          "total_time_ms": "197.2143",
          "rows": "0",
          "Query": "COPY public.job_titles (id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0327482d"
        },
        {
          "query": "COPY public.project_inspectors (project_id, profile_id, assigned_by, assigned_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3914115",
          "max_time_ms": "100.102467",
          "total_time_ms": "196.782823",
          "rows": "0",
          "Query": "COPY public.project_inspectors (project_id, profile_id, assigned_by, assigned_at, deleted_at) FROM stdin",
          "Fingerprint": "49a305d5"
        },
        {
          "query": "COPY public.projects (id, organization_id, name, description, status, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.381776",
          "max_time_ms": "98.711193",
          "total_time_ms": "196.763552",
          "rows": "0",
          "Query": "COPY public.projects (id, organization_id, name, description, status, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "87734e8e"
        },
        {
          "query": "COPY public.integration_tokens (id, profile_id, service_name, token, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3527905",
          "max_time_ms": "102.481523",
          "total_time_ms": "196.705581",
          "rows": "0",
          "Query": "COPY public.integration_tokens (id, profile_id, service_name, token, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "abb0fc43"
        },
        {
          "query": "COPY auth.one_time_tokens (id, user_id, token_type, token_hash, relates_to, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3484635",
          "max_time_ms": "98.649517",
          "total_time_ms": "196.696927",
          "rows": "0",
          "Query": "COPY auth.one_time_tokens (id, user_id, token_type, token_hash, relates_to, created_at, updated_at) FROM stdin",
          "Fingerprint": "0a6c105b"
        },
        {
          "query": "COPY public.progress_billings (id, project_id, billing_number, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3037135",
          "max_time_ms": "101.629248",
          "total_time_ms": "196.607427",
          "rows": "0",
          "Query": "COPY public.progress_billings (id, project_id, billing_number, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9f3aca0f"
        },
        {
          "query": "COPY public.task_status_logs (task_id, status, changed_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.2796635",
          "max_time_ms": "98.631252",
          "total_time_ms": "196.559327",
          "rows": "0",
          "Query": "COPY public.task_status_logs (task_id, status, changed_at, deleted_at) FROM stdin",
          "Fingerprint": "9b0f587c"
        },
        {
          "query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "calls": "1",
          "total_time_ms": "420.238451",
          "mean_time_ms": "420.238451",
          "rows": "0",
          "Query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "Fingerprint": "d77f9421"
        },
        {
          "query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "calls": "1",
          "total_time_ms": "405.91149",
          "mean_time_ms": "405.91149",
          "rows": "496",
          "Query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "96cb168f"
        },
        {
          "query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "calls": "1",
          "total_time_ms": "381.49694",
          "mean_time_ms": "381.49694",
          "rows": "112",
          "Query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "Fingerprint": "ad99e1e0"
        },
        {
          "query": "DROP SCHEMA IF EXISTS public CASCADE",
          "calls": "1",
          "total_time_ms": "354.783696",
          "mean_time_ms": "354.783696",
          "rows": "0",
          "Query": "DROP SCHEMA IF EXISTS public CASCADE",
          "Fingerprint": "2124d21d"
        },
        {
          "query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "calls": "1",
          "total_time_ms": "274.966629",
          "mean_time_ms": "274.966629",
          "rows": "387",
          "Query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "Fingerprint": "fa35e7f9"
        },
        {
          "query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "calls": "1",
          "total_time_ms": "269.306295",
          "mean_time_ms": "269.306295",
          "rows": "0",
          "Query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "Fingerprint": "bfd231e0"
        },
        {
          "query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "calls": "1",
          "mean_time_ms": "420.238451",
          "max_time_ms": "420.238451",
          "total_time_ms": "420.238451",
          "rows": "0",
          "Query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "Fingerprint": "d77f9421"
        },
        {
          "query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "calls": "1",
          "mean_time_ms": "405.91149",
          "max_time_ms": "405.91149",
          "total_time_ms": "405.91149",
          "rows": "496",
          "Query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "96cb168f"
        },
        {
          "query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "calls": "1",
          "mean_time_ms": "381.49694",
          "max_time_ms": "381.49694",
          "total_time_ms": "381.49694",
          "rows": "112",
          "Query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "Fingerprint": "ad99e1e0"
        },
        {
          "query": "DROP SCHEMA IF EXISTS public CASCADE",
          "calls": "1",
          "mean_time_ms": "354.783696",
          "max_time_ms": "354.783696",
          "total_time_ms": "354.783696",
          "rows": "0",
          "Query": "DROP SCHEMA IF EXISTS public CASCADE",
          "Fingerprint": "2124d21d"
        },
        {
          "query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "calls": "1",
          "mean_time_ms": "274.966629",
          "max_time_ms": "274.966629",
          "total_time_ms": "274.966629",
          "rows": "387",
          "Query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "Fingerprint": "fa35e7f9"
        },
        {
          "query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "calls": "1",
          "mean_time_ms": "269.306295",
          "max_time_ms": "269.306295",
          "total_time_ms": "269.306295",
          "rows": "0",
          "Query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "Fingerprint": "bfd231e0"
        },
        {
          "query": "-- QUERY 3: RLS policies + table grants + routine grants (single JSON output)\nWITH tbl AS (\n  SELECT\n    c.oid                                 AS table_oid,\n    n.nspname                             AS schema_name,\n    c.relname                             AS table_name,\n    c.relrowsecurity                      AS rls_enabled,\n    c.relforcerowsecurity                 AS rls_forced\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $1\n    AND n.nspname IN ($2, $3)\n),\npol AS (\n  SELECT\n    schemaname,\n    tablename,\n    jsonb_agg(\n      jsonb_build_object(\n        $4, policyname,\n        $5, permissive,\n        $6, roles,\n        $7, cmd,\n        $8, qual,\n        $9, with_check\n      )\n      ORDER BY policyname\n    ) AS policies\n  FROM pg_policies\n  WHERE schemaname IN ($10, $11)\n  GROUP BY schemaname, tablename\n),\ntable_grants AS (\n  SELECT\n    table_schema,\n    table_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $12, grantee,\n        $13, privilege_type,\n        $14, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_table_grants\n  WHERE table_schema IN ($15, $16)\n  GROUP BY table_schema, table_name\n),\nroutine_grants AS (\n  SELECT\n    routine_schema,\n    routine_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $17, grantee,\n        $18, privilege_type,\n        $19, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_routine_grants\n  WHERE routine_schema IN ($20, $21)\n  GROUP BY routine_schema, routine_name\n)\nSELECT jsonb_build_object(\n  $22, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $23, t.schema_name,\n        $24, t.table_name,\n        $25, t.rls_enabled,\n        $26, t.rls_forced,\n        $27, COALESCE(p.policies, $28::jsonb),\n        $29, COALESCE(g.grants, $30::jsonb)\n      )\n      ORDER BY t.schema_name, t.table_name\n    )\n    FROM tbl t\n    LEFT JOIN pol p\n      ON p.schemaname = t.schema_name AND p.tablename = t.table_name\n    LEFT JOIN table_grants g\n      ON g.table_schema = t.schema_name AND g.table_name = t.table_name\n  ),\n  $31, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $32, rg.routine_schema,\n        $33, rg.routine_name,\n        $34, rg.grants\n      )\n      ORDER BY rg.routine_schema, rg.routine_name\n    )\n    FROM routine_grants rg\n  )\n) AS security_dump",
          "calls": "1",
          "mean_time_ms": "197.888901",
          "max_time_ms": "197.888901",
          "total_time_ms": "197.888901",
          "rows": "1",
          "Query": "-- QUERY 3: RLS policies + table grants + routine grants (single JSON output)\nWITH tbl AS (\n  SELECT\n    c.oid                                 AS table_oid,\n    n.nspname                             AS schema_name,\n    c.relname                             AS table_name,\n    c.relrowsecurity                      AS rls_enabled,\n    c.relforcerowsecurity                 AS rls_forced\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $1\n    AND n.nspname IN ($2, $3)\n),\npol AS (\n  SELECT\n    schemaname,\n    tablename,\n    jsonb_agg(\n      jsonb_build_object(\n        $4, policyname,\n        $5, permissive,\n        $6, roles,\n        $7, cmd,\n        $8, qual,\n        $9, with_check\n      )\n      ORDER BY policyname\n    ) AS policies\n  FROM pg_policies\n  WHERE schemaname IN ($10, $11)\n  GROUP BY schemaname, tablename\n),\ntable_grants AS (\n  SELECT\n    table_schema,\n    table_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $12, grantee,\n        $13, privilege_type,\n        $14, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_table_grants\n  WHERE table_schema IN ($15, $16)\n  GROUP BY table_schema, table_name\n),\nroutine_grants AS (\n  SELECT\n    routine_schema,\n    routine_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $17, grantee,\n        $18, privilege_type,\n        $19, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_routine_grants\n  WHERE routine_schema IN ($20, $21)\n  GROUP BY routine_schema, routine_name\n)\nSELECT jsonb_build_object(\n  $22, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $23, t.schema_name,\n        $24, t.table_name,\n        $25, t.rls_enabled,\n        $26, t.rls_forced,\n        $27, COALESCE(p.policies, $28::jsonb),\n        $29, COALESCE(g.grants, $30::jsonb)\n      )\n      ORDER BY t.schema_name, t.table_name\n    )\n    FROM tbl t\n    LEFT JOIN pol p\n      ON p.schemaname = t.schema_name AND p.tablename = t.table_name\n    LEFT JOIN table_grants g\n      ON g.table_schema = t.schema_name AND g.table_name = t.table_name\n  ),\n  $31, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $32, rg.routine_schema,\n        $33, rg.routine_name,\n        $34, rg.grants\n      )\n      ORDER BY rg.routine_schema, rg.routine_name\n    )\n    FROM routine_grants rg\n  )\n) AS security_dump",
          "Fingerprint": "0a80504f"
        },
        {
          "query": "-- Org Dashboard foundations (service areas, member rates, project invites)\n\n-- [REF: org_dashboard_foundations START]\n\nCREATE TABLE IF NOT EXISTS public.organization_service_areas (\n    id uuid DEFAULT gen_random_uuid() NOT NULL,\n    organization_id uuid NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,\n    service_area_text text NOT NULL,\n    created_at timestamp with time zone DEFAULT now() NOT NULL,\n    updated_at timestamp with time zone DEFAULT now() NOT NULL,\n    CONSTRAINT organization_service_areas_pkey PRIMARY KEY (id)\n)",
          "calls": "1",
          "mean_time_ms": "189.125765",
          "max_time_ms": "189.125765",
          "total_time_ms": "189.125765",
          "rows": "0",
          "Query": "-- Org Dashboard foundations (service areas, member rates, project invites)\n\n-- [REF: org_dashboard_foundations START]\n\nCREATE TABLE IF NOT EXISTS public.organization_service_areas (\n    id uuid DEFAULT gen_random_uuid() NOT NULL,\n    organization_id uuid NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,\n    service_area_text text NOT NULL,\n    created_at timestamp with time zone DEFAULT now() NOT NULL,\n    updated_at timestamp with time zone DEFAULT now() NOT NULL,\n    CONSTRAINT organization_service_areas_pkey PRIMARY KEY (id)\n)",
          "Fingerprint": "08d5b208"
        },
        {
          "query": "with jwt as (\n  select\n    set_config($1, $2, $3) as a,\n    set_config($4, $5, $6) as b,\n    set_config(\n      $7,\n      format($8, $9),\n      $10\n    ) as c\n),\ncheck_auth as (\n  select auth.uid() as uid\n  from jwt\n),\np as (\n  select public.rpc_org_dashboard_payload(\n    $11::uuid,\n    $12,\n    $13\n  ) as payload\n  from check_auth\n)\nselect\n  (select uid from check_auth) as uid,\n  (select payload from p) as payload",
          "calls": "1",
          "mean_time_ms": "139.849526",
          "max_time_ms": "139.849526",
          "total_time_ms": "139.849526",
          "rows": "1",
          "Query": "with jwt as (\n  select\n    set_config($1, $2, $3) as a,\n    set_config($4, $5, $6) as b,\n    set_config(\n      $7,\n      format($8, $9),\n      $10\n    ) as c\n),\ncheck_auth as (\n  select auth.uid() as uid\n  from jwt\n),\np as (\n  select public.rpc_org_dashboard_payload(\n    $11::uuid,\n    $12,\n    $13\n  ) as payload\n  from check_auth\n)\nselect\n  (select uid from check_auth) as uid,\n  (select payload from p) as payload",
          "Fingerprint": "c71951cc"
        },
        {
          "query": "-- Safe org-scoped profile list for UI pickers\n\nCREATE OR REPLACE FUNCTION public.get_my_org_profiles_minimal()\nRETURNS TABLE (\n  id uuid,\n  email text,\n  full_name text,\n  avatar_url text\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  v_user_id uuid;\n  v_org_id uuid;\nBEGIN\n  v_user_id := auth.uid();\n  IF v_user_id IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  SELECT organization_id\n    INTO v_org_id\n  FROM public.profiles\n  WHERE id = v_user_id;\n\n  IF v_org_id IS NULL THEN\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  SELECT p.id, p.email, p.full_name, p.avatar_url\n  FROM public.profiles p\n  WHERE p.organization_id = v_org_id;\nEND;\n$$",
          "calls": "1",
          "mean_time_ms": "135.089398",
          "max_time_ms": "135.089398",
          "total_time_ms": "135.089398",
          "rows": "0",
          "Query": "-- Safe org-scoped profile list for UI pickers\n\nCREATE OR REPLACE FUNCTION public.get_my_org_profiles_minimal()\nRETURNS TABLE (\n  id uuid,\n  email text,\n  full_name text,\n  avatar_url text\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  v_user_id uuid;\n  v_org_id uuid;\nBEGIN\n  v_user_id := auth.uid();\n  IF v_user_id IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  SELECT organization_id\n    INTO v_org_id\n  FROM public.profiles\n  WHERE id = v_user_id;\n\n  IF v_org_id IS NULL THEN\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  SELECT p.id, p.email, p.full_name, p.avatar_url\n  FROM public.profiles p\n  WHERE p.organization_id = v_org_id;\nEND;\n$$",
          "Fingerprint": "9ba4385f"
        },
        {
          "query": "-- Public-safe RPCs for onboarding job titles\n\ncreate or replace function public.get_job_titles_public()\nreturns setof public.job_titles\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\nbegin\n  return query\n  select *\n  from public.job_titles\n  where deleted_at is null\n  order by name asc;\nend;\n$$",
          "calls": "1",
          "mean_time_ms": "117.711826",
          "max_time_ms": "117.711826",
          "total_time_ms": "117.711826",
          "rows": "0",
          "Query": "-- Public-safe RPCs for onboarding job titles\n\ncreate or replace function public.get_job_titles_public()\nreturns setof public.job_titles\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\nbegin\n  return query\n  select *\n  from public.job_titles\n  where deleted_at is null\n  order by name asc;\nend;\n$$",
          "Fingerprint": "08882903"
        },
        {
          "query": "-- =======================\n-- START PATCH: filter_projects hotfix\n-- =======================\n\nCREATE OR REPLACE FUNCTION public.filter_projects(\n  _filters jsonb DEFAULT '{}'::jsonb,\n  _select_cols text[] DEFAULT NULL::text[],\n  _order_by text DEFAULT 'id'::text,\n  _direction text DEFAULT 'asc'::text,\n  _limit integer DEFAULT NULL::integer,\n  _offset integer DEFAULT NULL::integer\n) RETURNS SETOF public.projects\nLANGUAGE plpgsql STABLE\nSET search_path TO 'public', 'pg_temp'\nAS $$\nDECLARE\n  _project_id      uuid;\n  _organization_id uuid;\n  _where           text := 'deleted_at IS NULL';\n  kv               record;\n  sqltxt           text;\n  dir              text := lower(coalesce(_direction, 'asc'));\n  v_text           text;\nBEGIN\n  -- Normalize filters to an object\n  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN\n    _filters := '{}'::jsonb;\n  END IF;\n\n  -- Safe casts (avoid \"\" -> uuid crash)\n  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;\n  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;\n\n  -- Access check (RLS still applies)\n  PERFORM check_access('select', 'projects', _project_id, _organization_id);\n\n  -- Build WHERE from filters (ignore special keys)\n  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP\n    IF kv.key NOT IN ('project_id', 'organization_id') THEN\n\n      -- JSON null\n      IF kv.value = 'null'::jsonb THEN\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' IS NULL';\n\n      ELSIF jsonb_typeof(kv.value) = 'object' THEN\n        IF (kv.value ? '$gte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' >= '  || quote_literal(kv.value->>'$gte');\n        END IF;\n\n        IF (kv.value ? '$lte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' <= '  || quote_literal(kv.value->>'$lte');\n        END IF;\n\n        IF (kv.value ? '$ilike') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' ILIKE ' || quote_literal(kv.value->>'$ilike');\n        END IF;\n\n        IF (kv.value ? '$in') THEN\n          -- col::text = ANY(text[])\n          _where := _where\n            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('\n            || 'ARRAY(SELECT jsonb_array_elements_text('\n            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';\n        END IF;\n\n      ELSE\n        -- Primitive value: use #>> '{}' to avoid JSON quoting issues\n        v_text := kv.value #>> '{}';\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' = '   || quote_literal(v_text);\n      END IF;\n    END IF;\n  END LOOP;\n\n  -- Validate order_by\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name   = 'projects'\n      AND column_name  = _order_by\n  ) THEN\n    RAISE EXCEPTION 'unknown order_by column'\n      USING DETAIL = jsonb_build_object('column', _order_by);\n  END IF;\n\n  -- Clamp direction\n  IF dir NOT IN ('asc', 'desc') THEN\n    dir := 'asc';\n  END IF;\n\n  -- Always return full row to match RETURNS SETOF public.projects\n  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where\n         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;\n\n  IF _limit IS NOT NULL THEN\n    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);\n  END IF;\n\n  IF _offset IS NOT NULL THEN\n    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);\n  END IF;\n\n  RETURN QUERY EXECUTE sqltxt;\nEND;\n$$",
          "calls": "1",
          "mean_time_ms": "115.277807",
          "max_time_ms": "115.277807",
          "total_time_ms": "115.277807",
          "rows": "0",
          "Query": "-- =======================\n-- START PATCH: filter_projects hotfix\n-- =======================\n\nCREATE OR REPLACE FUNCTION public.filter_projects(\n  _filters jsonb DEFAULT '{}'::jsonb,\n  _select_cols text[] DEFAULT NULL::text[],\n  _order_by text DEFAULT 'id'::text,\n  _direction text DEFAULT 'asc'::text,\n  _limit integer DEFAULT NULL::integer,\n  _offset integer DEFAULT NULL::integer\n) RETURNS SETOF public.projects\nLANGUAGE plpgsql STABLE\nSET search_path TO 'public', 'pg_temp'\nAS $$\nDECLARE\n  _project_id      uuid;\n  _organization_id uuid;\n  _where           text := 'deleted_at IS NULL';\n  kv               record;\n  sqltxt           text;\n  dir              text := lower(coalesce(_direction, 'asc'));\n  v_text           text;\nBEGIN\n  -- Normalize filters to an object\n  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN\n    _filters := '{}'::jsonb;\n  END IF;\n\n  -- Safe casts (avoid \"\" -> uuid crash)\n  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;\n  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;\n\n  -- Access check (RLS still applies)\n  PERFORM check_access('select', 'projects', _project_id, _organization_id);\n\n  -- Build WHERE from filters (ignore special keys)\n  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP\n    IF kv.key NOT IN ('project_id', 'organization_id') THEN\n\n      -- JSON null\n      IF kv.value = 'null'::jsonb THEN\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' IS NULL';\n\n      ELSIF jsonb_typeof(kv.value) = 'object' THEN\n        IF (kv.value ? '$gte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' >= '  || quote_literal(kv.value->>'$gte');\n        END IF;\n\n        IF (kv.value ? '$lte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' <= '  || quote_literal(kv.value->>'$lte');\n        END IF;\n\n        IF (kv.value ? '$ilike') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' ILIKE ' || quote_literal(kv.value->>'$ilike');\n        END IF;\n\n        IF (kv.value ? '$in') THEN\n          -- col::text = ANY(text[])\n          _where := _where\n            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('\n            || 'ARRAY(SELECT jsonb_array_elements_text('\n            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';\n        END IF;\n\n      ELSE\n        -- Primitive value: use #>> '{}' to avoid JSON quoting issues\n        v_text := kv.value #>> '{}';\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' = '   || quote_literal(v_text);\n      END IF;\n    END IF;\n  END LOOP;\n\n  -- Validate order_by\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name   = 'projects'\n      AND column_name  = _order_by\n  ) THEN\n    RAISE EXCEPTION 'unknown order_by column'\n      USING DETAIL = jsonb_build_object('column', _order_by);\n  END IF;\n\n  -- Clamp direction\n  IF dir NOT IN ('asc', 'desc') THEN\n    dir := 'asc';\n  END IF;\n\n  -- Always return full row to match RETURNS SETOF public.projects\n  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where\n         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;\n\n  IF _limit IS NOT NULL THEN\n    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);\n  END IF;\n\n  IF _offset IS NOT NULL THEN\n    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);\n  END IF;\n\n  RETURN QUERY EXECUTE sqltxt;\nEND;\n$$",
          "Fingerprint": "b4425b85"
        },
        {
          "query": "COPY auth.audit_log_entries (instance_id, id, payload, created_at, ip_address) FROM stdin",
          "calls": "1",
          "mean_time_ms": "111.033599",
          "max_time_ms": "111.033599",
          "total_time_ms": "111.033599",
          "rows": "34",
          "Query": "COPY auth.audit_log_entries (instance_id, id, payload, created_at, ip_address) FROM stdin",
          "Fingerprint": "f285a55e"
        },
        {
          "query": "COPY storage.buckets (id, name, owner, created_at, updated_at, public, avif_autodetection, file_size_limit, allowed_mime_types, owner_id) FROM stdin",
          "calls": "1",
          "mean_time_ms": "106.702244",
          "max_time_ms": "106.702244",
          "total_time_ms": "106.702244",
          "rows": "2",
          "Query": "COPY storage.buckets (id, name, owner, created_at, updated_at, public, avif_autodetection, file_size_limit, allowed_mime_types, owner_id) FROM stdin",
          "Fingerprint": "af783faf"
        }
      ],
      "frequent": [
        {
          "query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "calls": "12281",
          "total_time_ms": "1230.18216",
          "rows": "12281",
          "Query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "Fingerprint": "dacc823a"
        },
        {
          "query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "calls": "12281",
          "total_time_ms": "1230.18216",
          "mean_time_ms": "0.100169543196808",
          "rows": "12281",
          "Query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "Fingerprint": "dacc823a"
        },
        {
          "query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "calls": "2848",
          "total_time_ms": "1301.024127",
          "rows": "2848",
          "Query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "Fingerprint": "0c4f8f7c"
        },
        {
          "query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "calls": "2848",
          "total_time_ms": "1301.024127",
          "mean_time_ms": "0.456820269311797",
          "rows": "2848",
          "Query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "Fingerprint": "0c4f8f7c"
        },
        {
          "query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
          "calls": "2388",
          "total_time_ms": "167.845012000001",
          "rows": "2388",
          "Query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
          "Fingerprint": "7174daf9"
        },
        {
          "query": "SET client_min_messages TO WARNING",
          "calls": "1983",
          "total_time_ms": "11.741692",
          "rows": "0",
          "Query": "SET client_min_messages TO WARNING",
          "Fingerprint": "d2883c6f"
        },
        {
          "query": "SET client_encoding = 'UTF8'",
          "calls": "1983",
          "total_time_ms": "17.447639",
          "rows": "0",
          "Query": "SET client_encoding = 'UTF8'",
          "Fingerprint": "2684e31e"
        },
        {
          "query": "BEGIN ISOLATION LEVEL READ COMMITTED READ ONLY",
          "calls": "1756",
          "total_time_ms": "19.396537",
          "rows": "0",
          "Query": "BEGIN ISOLATION LEVEL READ COMMITTED READ ONLY",
          "Fingerprint": "3c5b6168"
        },
        {
          "query": "SHOW transaction_read_only",
          "calls": "1644",
          "total_time_ms": "40.2912989999999",
          "rows": "0",
          "Query": "SHOW transaction_read_only",
          "Fingerprint": "e52c5054"
        },
        {
          "query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "calls": "1397",
          "total_time_ms": "1715.286118",
          "rows": "46811",
          "Query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "Fingerprint": "ee3d52f8"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "calls": "1397",
          "total_time_ms": "34323.32903",
          "rows": "311820",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "Fingerprint": "5eac5f98"
        },
        {
          "query": "WITH\nrole_setting AS (\n  SELECT setdatabase as database,\n         unnest(setconfig) as setting\n  FROM pg_catalog.pg_db_role_setting\n  WHERE setrole = CURRENT_USER::regrole::oid\n    AND setdatabase IN ($2, (SELECT oid FROM pg_catalog.pg_database WHERE datname = CURRENT_CATALOG))\n),\nkv_settings AS (\n  SELECT database,\n         substr(setting, $3, strpos(setting, $4) - $5) as k,\n         substr(setting, strpos(setting, $6) + $7) as v\n  FROM role_setting\n  \n)\nSELECT DISTINCT ON (key)\n       replace(k, $8, $9) AS key,\n       v AS value\nFROM kv_settings\nWHERE k = ANY($1) AND v IS NOT NULL\nORDER BY key, database DESC NULLS LAST",
          "calls": "1397",
          "total_time_ms": "92.493663",
          "rows": "0",
          "Query": "WITH\nrole_setting AS (\n  SELECT setdatabase as database,\n         unnest(setconfig) as setting\n  FROM pg_catalog.pg_db_role_setting\n  WHERE setrole = CURRENT_USER::regrole::oid\n    AND setdatabase IN ($2, (SELECT oid FROM pg_catalog.pg_database WHERE datname = CURRENT_CATALOG))\n),\nkv_settings AS (\n  SELECT database,\n         substr(setting, $3, strpos(setting, $4) - $5) as k,\n         substr(setting, strpos(setting, $6) + $7) as v\n  FROM role_setting\n  \n)\nSELECT DISTINCT ON (key)\n       replace(k, $8, $9) AS key,\n       v AS value\nFROM kv_settings\nWHERE k = ANY($1) AND v IS NOT NULL\nORDER BY key, database DESC NULLS LAST",
          "Fingerprint": "3a2c1e7e"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "calls": "1397",
          "total_time_ms": "33851.555228",
          "rows": "167758",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "Fingerprint": "2eb78329"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "calls": "1397",
          "total_time_ms": "571.449586",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "Fingerprint": "c5bdd355"
        },
        {
          "query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "calls": "1397",
          "total_time_ms": "2836.51774799999",
          "rows": "2794",
          "Query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "Fingerprint": "06396590"
        },
        {
          "query": "SELECT current_setting($1)::integer, current_setting($2), version()",
          "calls": "1397",
          "total_time_ms": "15.246181",
          "rows": "1397",
          "Query": "SELECT current_setting($1)::integer, current_setting($2), version()",
          "Fingerprint": "120b789e"
        },
        {
          "query": "COMMIT",
          "calls": "1397",
          "total_time_ms": "1.737483",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "calls": "1397",
          "total_time_ms": "2365.774295",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "Fingerprint": "b9ce39db"
        },
        {
          "query": "set local schema ''",
          "calls": "1397",
          "total_time_ms": "8.34740599999999",
          "rows": "0",
          "Query": "set local schema ''",
          "Fingerprint": "50e59e1c"
        },
        {
          "query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "calls": "1397",
          "total_time_ms": "667.382252000001",
          "rows": "0",
          "Query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "Fingerprint": "5d91a149"
        },
        {
          "query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "calls": "1397",
          "total_time_ms": "13353.197756",
          "rows": "64172",
          "Query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "Fingerprint": "d0298bd6"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "calls": "1397",
          "total_time_ms": "34323.32903",
          "mean_time_ms": "24.5693121188261",
          "rows": "311820",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "Fingerprint": "5eac5f98"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "calls": "1397",
          "total_time_ms": "33851.555228",
          "mean_time_ms": "24.2316071782391",
          "rows": "167758",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "Fingerprint": "2eb78329"
        },
        {
          "query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "calls": "1397",
          "total_time_ms": "13353.197756",
          "mean_time_ms": "9.55848085612025",
          "rows": "64172",
          "Query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "Fingerprint": "d0298bd6"
        },
        {
          "query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "calls": "1397",
          "total_time_ms": "2836.51774799999",
          "mean_time_ms": "2.03043503793844",
          "rows": "2794",
          "Query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "Fingerprint": "06396590"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "calls": "1397",
          "total_time_ms": "2365.774295",
          "mean_time_ms": "1.69346764137437",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "Fingerprint": "b9ce39db"
        },
        {
          "query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "calls": "1397",
          "total_time_ms": "1715.286118",
          "mean_time_ms": "1.22783544595562",
          "rows": "46811",
          "Query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "Fingerprint": "ee3d52f8"
        },
        {
          "query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "calls": "1397",
          "total_time_ms": "667.382252000001",
          "mean_time_ms": "0.477725305654975",
          "rows": "0",
          "Query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "Fingerprint": "5d91a149"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "calls": "1397",
          "total_time_ms": "571.449586",
          "mean_time_ms": "0.409054821760916",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "Fingerprint": "c5bdd355"
        },
        {
          "query": "SELECT name FROM pg_timezone_names",
          "calls": "1396",
          "total_time_ms": "103693.647862",
          "rows": "1666824",
          "Query": "SELECT name FROM pg_timezone_names",
          "Fingerprint": "f174234e"
        },
        {
          "query": "SELECT name FROM pg_timezone_names",
          "calls": "1396",
          "total_time_ms": "103693.647862",
          "mean_time_ms": "74.2791173796561",
          "rows": "1666824",
          "Query": "SELECT name FROM pg_timezone_names",
          "Fingerprint": "f174234e"
        },
        {
          "query": "SET idle_session_timeout='58s'",
          "calls": "1057",
          "total_time_ms": "3.192387",
          "rows": "0",
          "Query": "SET idle_session_timeout='58s'",
          "Fingerprint": "9469d6d2"
        },
        {
          "query": "SET statement_timeout='58s'",
          "calls": "1057",
          "total_time_ms": "15.915253",
          "rows": "0",
          "Query": "SET statement_timeout='58s'",
          "Fingerprint": "caa62bbc"
        },
        {
          "query": "PREPARE dumpEnumType(pg_catalog.oid) AS\nSELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder",
          "calls": "740",
          "total_time_ms": "13.1952",
          "rows": "4063",
          "Query": "PREPARE dumpEnumType(pg_catalog.oid) AS\nSELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder",
          "Fingerprint": "7c26b364"
        },
        {
          "query": "SELECT sessions.aal, sessions.created_at, sessions.factor_id, sessions.id, sessions.ip, sessions.not_after, sessions.oauth_client_id, sessions.refresh_token_counter, sessions.refresh_token_hmac_key, sessions.refreshed_at, sessions.scopes, sessions.tag, sessions.updated_at, sessions.user_agent, sessions.user_id FROM sessions AS sessions WHERE id = $1 LIMIT $2",
          "calls": "609",
          "total_time_ms": "108.247794",
          "rows": "609",
          "Query": "SELECT sessions.aal, sessions.created_at, sessions.factor_id, sessions.id, sessions.ip, sessions.not_after, sessions.oauth_client_id, sessions.refresh_token_counter, sessions.refresh_token_hmac_key, sessions.refreshed_at, sessions.scopes, sessions.tag, sessions.updated_at, sessions.user_agent, sessions.user_id FROM sessions AS sessions WHERE id = $1 LIMIT $2",
          "Fingerprint": "57f49ab9"
        },
        {
          "query": "SELECT mfa_amr_claims.authentication_method, mfa_amr_claims.created_at, mfa_amr_claims.id, mfa_amr_claims.session_id, mfa_amr_claims.updated_at FROM mfa_amr_claims AS mfa_amr_claims WHERE session_id = $1",
          "calls": "609",
          "total_time_ms": "32.246395",
          "rows": "609",
          "Query": "SELECT mfa_amr_claims.authentication_method, mfa_amr_claims.created_at, mfa_amr_claims.id, mfa_amr_claims.session_id, mfa_amr_claims.updated_at FROM mfa_amr_claims AS mfa_amr_claims WHERE session_id = $1",
          "Fingerprint": "a87b5d71"
        },
        {
          "query": "SELECT mfa_factors.created_at, mfa_factors.factor_type, mfa_factors.friendly_name, mfa_factors.id, mfa_factors.last_challenged_at, mfa_factors.last_webauthn_challenge_data, mfa_factors.phone, mfa_factors.secret, mfa_factors.status, mfa_factors.updated_at, mfa_factors.user_id, mfa_factors.web_authn_aaguid, mfa_factors.web_authn_credential FROM mfa_factors AS mfa_factors WHERE user_id = $1",
          "calls": "605",
          "total_time_ms": "7.48317799999999",
          "rows": "0",
          "Query": "SELECT mfa_factors.created_at, mfa_factors.factor_type, mfa_factors.friendly_name, mfa_factors.id, mfa_factors.last_challenged_at, mfa_factors.last_webauthn_challenge_data, mfa_factors.phone, mfa_factors.secret, mfa_factors.status, mfa_factors.updated_at, mfa_factors.user_id, mfa_factors.web_authn_aaguid, mfa_factors.web_authn_credential FROM mfa_factors AS mfa_factors WHERE user_id = $1",
          "Fingerprint": "dacebddc"
        },
        {
          "query": "SELECT identities.created_at, identities.email, identities.id, identities.identity_data, identities.last_sign_in_at, identities.provider, identities.provider_id, identities.updated_at, identities.user_id FROM identities AS identities WHERE user_id = $1",
          "calls": "605",
          "total_time_ms": "75.081424",
          "rows": "605",
          "Query": "SELECT identities.created_at, identities.email, identities.id, identities.identity_data, identities.last_sign_in_at, identities.provider, identities.provider_id, identities.updated_at, identities.user_id FROM identities AS identities WHERE user_id = $1",
          "Fingerprint": "85b8dd01"
        },
        {
          "query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and id = $2 LIMIT $3",
          "calls": "560",
          "total_time_ms": "74.639599",
          "rows": "551",
          "Query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and id = $2 LIMIT $3",
          "Fingerprint": "35e8447e"
        },
        {
          "query": "select setting from pg_config where name = $1",
          "calls": "548",
          "total_time_ms": "101.908625",
          "rows": "548",
          "Query": "select setting from pg_config where name = $1",
          "Fingerprint": "4fe9ed11"
        },
        {
          "query": "BEGIN ISOLATION LEVEL READ COMMITTED READ WRITE",
          "calls": "490",
          "total_time_ms": "7.89980099999999",
          "rows": "0",
          "Query": "BEGIN ISOLATION LEVEL READ COMMITTED READ WRITE",
          "Fingerprint": "3e989d19"
        },
        {
          "query": "COMMIT",
          "calls": "488",
          "total_time_ms": "0.664983",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "475",
          "total_time_ms": "1203.426561",
          "rows": "475",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "475",
          "total_time_ms": "1203.426561",
          "mean_time_ms": "2.53352960210526",
          "rows": "475",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "SET statement_timeout='58s'",
          "calls": "393",
          "total_time_ms": "6.13669699999999",
          "rows": "0",
          "Query": "SET statement_timeout='58s'",
          "Fingerprint": "caa62bbc"
        },
        {
          "query": "SET idle_session_timeout='58s'",
          "calls": "393",
          "total_time_ms": "2.087518",
          "rows": "0",
          "Query": "SET idle_session_timeout='58s'",
          "Fingerprint": "9469d6d2"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "391",
          "total_time_ms": "416.396113",
          "rows": "391",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "169ad58d"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "391",
          "total_time_ms": "416.396113",
          "mean_time_ms": "1.06495169565218",
          "rows": "391",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "169ad58d"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "362",
          "total_time_ms": "342.799267",
          "rows": "362",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "840a08d4"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "362",
          "total_time_ms": "342.799267",
          "mean_time_ms": "0.946959301104972",
          "rows": "362",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "840a08d4"
        },
        {
          "query": "COMMIT",
          "calls": "300",
          "total_time_ms": "0.348386",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "298",
          "total_time_ms": "410.95613",
          "rows": "298",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "fef63b48"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "298",
          "total_time_ms": "410.95613",
          "mean_time_ms": "1.37904741610738",
          "rows": "298",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "fef63b48"
        },
        {
          "query": "BEGIN",
          "calls": "292",
          "total_time_ms": "0.683945",
          "rows": "0",
          "Query": "BEGIN",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "SELECT set_config($2, $1, $3)",
          "calls": "292",
          "total_time_ms": "34.603603",
          "rows": "292",
          "Query": "SELECT set_config($2, $1, $3)",
          "Fingerprint": "372553e8"
        },
        {
          "query": "SELECT\n          set_config('role', $1, true),\n          set_config('request.jwt.claim.role', $2, true),\n          set_config('request.jwt', $3, true),\n          set_config('request.jwt.claim.sub', $4, true),\n          set_config('request.jwt.claims', $5, true),\n          set_config('request.headers', $6, true),\n          set_config('request.method', $7, true),\n          set_config('request.path', $8, true),\n          set_config('storage.operation', $9, true)",
          "calls": "290",
          "total_time_ms": "39.868987",
          "rows": "290",
          "Query": "SELECT\n          set_config('role', $1, true),\n          set_config('request.jwt.claim.role', $2, true),\n          set_config('request.jwt', $3, true),\n          set_config('request.jwt.claim.sub', $4, true),\n          set_config('request.jwt.claims', $5, true),\n          set_config('request.headers', $6, true),\n          set_config('request.method', $7, true),\n          set_config('request.path', $8, true),\n          set_config('storage.operation', $9, true)",
          "Fingerprint": "88c09e41"
        },
        {
          "query": "ABORT",
          "calls": "263",
          "total_time_ms": "0.356416",
          "rows": "0",
          "Query": "ABORT",
          "Fingerprint": "a52bcaf9"
        },
        {
          "query": "SELECT pg_catalog.format_type($1::pg_catalog.oid, $2)",
          "calls": "238",
          "total_time_ms": "3.276142",
          "rows": "238",
          "Query": "SELECT pg_catalog.format_type($1::pg_catalog.oid, $2)",
          "Fingerprint": "5f21d07e"
        },
        {
          "query": "set pg_stat_statements.track = none",
          "calls": "224",
          "total_time_ms": "0.504548",
          "rows": "0",
          "Query": "set pg_stat_statements.track = none",
          "Fingerprint": "564e7202"
        },
        {
          "query": "begin",
          "calls": "170",
          "total_time_ms": "0.167079",
          "rows": "0",
          "Query": "begin",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "commit",
          "calls": "168",
          "total_time_ms": "0.166121",
          "rows": "0",
          "Query": "commit",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "select exists(select $1 from auth.users)",
          "calls": "165",
          "total_time_ms": "30.342953",
          "rows": "165",
          "Query": "select exists(select $1 from auth.users)",
          "Fingerprint": "a6403a8d"
        },
        {
          "query": "deallocate $1",
          "calls": "149",
          "total_time_ms": "0.377356",
          "rows": "0",
          "Query": "deallocate $1",
          "Fingerprint": "67c106f6"
        },
        {
          "query": "BEGIN",
          "calls": "147",
          "total_time_ms": "0.193195",
          "rows": "0",
          "Query": "BEGIN",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "COMMIT",
          "calls": "143",
          "total_time_ms": "0.204349",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "SELECT * FROM pgbouncer.get_auth($1)",
          "calls": "133",
          "total_time_ms": "313.882881",
          "rows": "133",
          "Query": "SELECT * FROM pgbouncer.get_auth($1)",
          "Fingerprint": "6e8f1775"
        },
        {
          "query": "SELECT * FROM pgbouncer.get_auth($1)",
          "calls": "133",
          "total_time_ms": "313.882881",
          "mean_time_ms": "2.36002166165414",
          "rows": "133",
          "Query": "SELECT * FROM pgbouncer.get_auth($1)",
          "Fingerprint": "6e8f1775"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "113",
          "total_time_ms": "5259.748893",
          "rows": "113",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "5a244b78"
        },
        {
          "query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "calls": "113",
          "total_time_ms": "472.05049",
          "rows": "1017",
          "Query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "Fingerprint": "83726034"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "113",
          "total_time_ms": "5259.748893",
          "mean_time_ms": "46.546450380531",
          "rows": "113",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "5a244b78"
        },
        {
          "query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "calls": "113",
          "total_time_ms": "472.05049",
          "mean_time_ms": "4.17743796460177",
          "rows": "1017",
          "Query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "Fingerprint": "83726034"
        },
        {
          "query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "calls": "104",
          "total_time_ms": "2117.180412",
          "rows": "103",
          "Query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "Fingerprint": "de72792d"
        },
        {
          "query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "calls": "104",
          "total_time_ms": "2117.180412",
          "mean_time_ms": "20.3575039615385",
          "rows": "103",
          "Query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "Fingerprint": "de72792d"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "total_time_ms": "9967.864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "total_time_ms": "9967.864957",
          "mean_time_ms": "99.67864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "mean_time_ms": "99.67864957",
          "max_time_ms": "316.835546",
          "total_time_ms": "9967.864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "select\n      s.oid as \"id\",\n      w.fdwname as \"name\",\n      s.srvname as \"server_name\",\n      s.srvoptions as \"server_options\",\n      c.proname as \"handler\",\n      (\n        select jsonb_agg(\n          jsonb_build_object(\n            $1, c.oid::bigint,\n            $2, relnamespace::regnamespace::text,\n            $3, c.relname,\n            $4, (\n              select jsonb_agg(\n                jsonb_build_object(\n                  $5, a.attname,\n                  $6, pg_catalog.format_type(a.atttypid, a.atttypmod)\n                )\n              )\n              from pg_catalog.pg_attribute a\n              where a.attrelid = c.oid and a.attnum > $7 and not a.attisdropped\n            ),\n            $8, t.ftoptions\n          )\n        )\n        from pg_catalog.pg_class c\n        join pg_catalog.pg_foreign_table t on c.oid = t.ftrelid\n        where c.oid = any (select t.ftrelid from pg_catalog.pg_foreign_table t where t.ftserver = s.oid)\n      ) as \"tables\"\n    from pg_catalog.pg_foreign_server s\n    join pg_catalog.pg_foreign_data_wrapper w on s.srvfdw = w.oid\n    join pg_catalog.pg_proc c on w.fdwhandler = c.oid",
          "calls": "97",
          "total_time_ms": "2.233936",
          "rows": "0",
          "Query": "select\n      s.oid as \"id\",\n      w.fdwname as \"name\",\n      s.srvname as \"server_name\",\n      s.srvoptions as \"server_options\",\n      c.proname as \"handler\",\n      (\n        select jsonb_agg(\n          jsonb_build_object(\n            $1, c.oid::bigint,\n            $2, relnamespace::regnamespace::text,\n            $3, c.relname,\n            $4, (\n              select jsonb_agg(\n                jsonb_build_object(\n                  $5, a.attname,\n                  $6, pg_catalog.format_type(a.atttypid, a.atttypmod)\n                )\n              )\n              from pg_catalog.pg_attribute a\n              where a.attrelid = c.oid and a.attnum > $7 and not a.attisdropped\n            ),\n            $8, t.ftoptions\n          )\n        )\n        from pg_catalog.pg_class c\n        join pg_catalog.pg_foreign_table t on c.oid = t.ftrelid\n        where c.oid = any (select t.ftrelid from pg_catalog.pg_foreign_table t where t.ftserver = s.oid)\n      ) as \"tables\"\n    from pg_catalog.pg_foreign_server s\n    join pg_catalog.pg_foreign_data_wrapper w on s.srvfdw = w.oid\n    join pg_catalog.pg_proc c on w.fdwhandler = c.oid",
          "Fingerprint": "8e6d3b19"
        },
        {
          "query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "calls": "92",
          "total_time_ms": "396.812123",
          "rows": "92",
          "Query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "Fingerprint": "24390c08"
        },
        {
          "query": "select set_config('search_path', $1, true), set_config('role', $2, true), set_config('request.jwt.claims', $3, true), set_config('request.method', $4, true), set_config('request.path', $5, true), set_config('request.headers', $6, true), set_config('request.cookies', $7, true)",
          "calls": "92",
          "total_time_ms": "12.934942",
          "rows": "92",
          "Query": "select set_config('search_path', $1, true), set_config('role', $2, true), set_config('request.jwt.claims', $3, true), set_config('request.method', $4, true), set_config('request.path', $5, true), set_config('request.headers', $6, true), set_config('request.cookies', $7, true)",
          "Fingerprint": "2a976cc9"
        },
        {
          "query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "calls": "92",
          "total_time_ms": "396.812123",
          "mean_time_ms": "4.31317525",
          "rows": "92",
          "Query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "Fingerprint": "24390c08"
        },
        {
          "query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "88",
          "total_time_ms": "1485.024353",
          "rows": "88",
          "Query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "6eaa5bc4"
        },
        {
          "query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "88",
          "total_time_ms": "1485.024353",
          "mean_time_ms": "16.8752767386364",
          "rows": "88",
          "Query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "6eaa5bc4"
        },
        {
          "query": "SELECT pg_catalog.set_config($1, $2, $3)",
          "calls": "83",
          "total_time_ms": "0.904006",
          "rows": "83",
          "Query": "SELECT pg_catalog.set_config($1, $2, $3)",
          "Fingerprint": "f5e5553f"
        },
        {
          "query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "calls": "80",
          "total_time_ms": "6978.442858",
          "rows": "26106",
          "Query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "Fingerprint": "62d7ef17"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom materialized_views",
          "calls": "80",
          "total_time_ms": "23.678557",
          "rows": "68",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom materialized_views",
          "Fingerprint": "5fdd6c91"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "total_time_ms": "14684.666536",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "calls": "80",
          "total_time_ms": "2106.986161",
          "rows": "26088",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "Fingerprint": "dbb85dbe"
        },
        {
          "query": "with foreign_tables as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom foreign_tables",
          "calls": "80",
          "total_time_ms": "17.288298",
          "rows": "0",
          "Query": "with foreign_tables as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom foreign_tables",
          "Fingerprint": "4ab2deba"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "calls": "80",
          "total_time_ms": "1873.557554",
          "rows": "83576",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "Fingerprint": "b7f8e58a"
        },
        {
          "query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "calls": "80",
          "total_time_ms": "6176.415442",
          "rows": "114718",
          "Query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "Fingerprint": "5b79696f"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "calls": "80",
          "total_time_ms": "590.210851",
          "rows": "5984",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "Fingerprint": "03495dc3"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "calls": "80",
          "total_time_ms": "417.70789",
          "rows": "10019",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "Fingerprint": "63fbfa7d"
        },
        {
          "query": "-- Adapted from information_schema.schemata\nselect\n  n.oid::int8 as id,\n  n.nspname as name,\n  u.rolname as owner\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  \n  and n.nspname IN ($1,$2)\n  and not pg_catalog.starts_with(n.nspname, $3)\n  and (\n    pg_has_role(n.nspowner, $4)\n    or has_schema_privilege(n.oid, $5)\n  )\n  and not pg_catalog.starts_with(n.nspname, $6)\n  and not pg_catalog.starts_with(n.nspname, $7)",
          "calls": "80",
          "total_time_ms": "16.45004",
          "rows": "160",
          "Query": "-- Adapted from information_schema.schemata\nselect\n  n.oid::int8 as id,\n  n.nspname as name,\n  u.rolname as owner\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  \n  and n.nspname IN ($1,$2)\n  and not pg_catalog.starts_with(n.nspname, $3)\n  and (\n    pg_has_role(n.nspowner, $4)\n    or has_schema_privilege(n.oid, $5)\n  )\n  and not pg_catalog.starts_with(n.nspname, $6)\n  and not pg_catalog.starts_with(n.nspname, $7)",
          "Fingerprint": "6e38ce8d"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "total_time_ms": "14684.666536",
          "mean_time_ms": "183.5583317",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "calls": "80",
          "total_time_ms": "6978.442858",
          "mean_time_ms": "87.230535725",
          "rows": "26106",
          "Query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "Fingerprint": "62d7ef17"
        },
        {
          "query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "calls": "80",
          "total_time_ms": "6176.415442",
          "mean_time_ms": "77.205193025",
          "rows": "114718",
          "Query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "Fingerprint": "5b79696f"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "calls": "80",
          "total_time_ms": "2106.986161",
          "mean_time_ms": "26.3373270125",
          "rows": "26088",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "Fingerprint": "dbb85dbe"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "calls": "80",
          "total_time_ms": "1873.557554",
          "mean_time_ms": "23.419469425",
          "rows": "83576",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "Fingerprint": "b7f8e58a"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "calls": "80",
          "total_time_ms": "590.210851",
          "mean_time_ms": "7.3776356375",
          "rows": "5984",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "Fingerprint": "03495dc3"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "calls": "80",
          "total_time_ms": "417.70789",
          "mean_time_ms": "5.221348625",
          "rows": "10019",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "Fingerprint": "63fbfa7d"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "mean_time_ms": "183.5583317",
          "max_time_ms": "562.106136",
          "total_time_ms": "14684.666536",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "SELECT oid FROM pg_catalog.pg_namespace n\nWHERE n.nspname OPERATOR(pg_catalog.~) $1 COLLATE pg_catalog.default",
          "calls": "72",
          "total_time_ms": "2.960007",
          "rows": "72",
          "Query": "SELECT oid FROM pg_catalog.pg_namespace n\nWHERE n.nspname OPERATOR(pg_catalog.~) $1 COLLATE pg_catalog.default",
          "Fingerprint": "7c8009f7"
        },
        {
          "query": "LOCK TABLE \"realtime\".\"schema_migrations\" IN SHARE UPDATE EXCLUSIVE MODE",
          "calls": "71",
          "total_time_ms": "1.127289",
          "rows": "0",
          "Query": "LOCK TABLE \"realtime\".\"schema_migrations\" IN SHARE UPDATE EXCLUSIVE MODE",
          "Fingerprint": "deecdf8c"
        },
        {
          "query": "SELECT s0.\"version\" FROM \"realtime\".\"schema_migrations\" AS s0",
          "calls": "70",
          "total_time_ms": "3.596576",
          "rows": "2284",
          "Query": "SELECT s0.\"version\" FROM \"realtime\".\"schema_migrations\" AS s0",
          "Fingerprint": "aed88797"
        },
        {
          "query": "UPDATE \"users\" AS users SET \"last_sign_in_at\" = $1, \"updated_at\" = $2 WHERE users.id = $3",
          "calls": "69",
          "total_time_ms": "44.248527",
          "rows": "69",
          "Query": "UPDATE \"users\" AS users SET \"last_sign_in_at\" = $1, \"updated_at\" = $2 WHERE users.id = $3",
          "Fingerprint": "c94cfe49"
        },
        {
          "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "calls": "69",
          "total_time_ms": "396.493198",
          "rows": "69",
          "Query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "Fingerprint": "9d6d3db1"
        },
        {
          "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "calls": "69",
          "total_time_ms": "396.493198",
          "mean_time_ms": "5.74627823188406",
          "rows": "69",
          "Query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "Fingerprint": "9d6d3db1"
        },
        {
          "query": "INSERT INTO \"realtime\".\"schema_migrations\" (\"version\",\"inserted_at\") VALUES ($1,$2)",
          "calls": "67",
          "total_time_ms": "8.465681",
          "rows": "67",
          "Query": "INSERT INTO \"realtime\".\"schema_migrations\" (\"version\",\"inserted_at\") VALUES ($1,$2)",
          "Fingerprint": "7bfa5972"
        },
        {
          "query": "insert into schema_migrations (version) values ($1)",
          "calls": "65",
          "total_time_ms": "1.325092",
          "rows": "65",
          "Query": "insert into schema_migrations (version) values ($1)",
          "Fingerprint": "81bd7952"
        },
        {
          "query": "SELECT EXISTS (SELECT schema_migrations.* FROM schema_migrations AS schema_migrations WHERE version = $1)",
          "calls": "65",
          "total_time_ms": "1.322896",
          "rows": "65",
          "Query": "SELECT EXISTS (SELECT schema_migrations.* FROM schema_migrations AS schema_migrations WHERE version = $1)",
          "Fingerprint": "b97dc1f8"
        },
        {
          "query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and LOWER(email) = $2 and aud = $3 and is_sso_user = $4 LIMIT $5",
          "calls": "65",
          "total_time_ms": "17.461435",
          "rows": "54",
          "Query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and LOWER(email) = $2 and aud = $3 and is_sso_user = $4 LIMIT $5",
          "Fingerprint": "7121590d"
        },
        {
          "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "calls": "60",
          "total_time_ms": "267.54152",
          "rows": "60",
          "Query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "Fingerprint": "9ddfc8bb"
        },
        {
          "query": "INSERT INTO mfa_amr_claims(id, session_id, created_at, updated_at, authentication_method) values ($1, $2, $3, $4, $5)\n\t\t\tON CONFLICT ON CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey\n\t\t\tDO UPDATE SET updated_at = $6",
          "calls": "60",
          "total_time_ms": "68.695646",
          "rows": "60",
          "Query": "INSERT INTO mfa_amr_claims(id, session_id, created_at, updated_at, authentication_method) values ($1, $2, $3, $4, $5)\n\t\t\tON CONFLICT ON CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey\n\t\t\tDO UPDATE SET updated_at = $6",
          "Fingerprint": "b3c191e7"
        },
        {
          "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "calls": "60",
          "total_time_ms": "267.54152",
          "mean_time_ms": "4.45902533333333",
          "rows": "60",
          "Query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "Fingerprint": "9ddfc8bb"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "total_time_ms": "29046.709733",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "total_time_ms": "29046.709733",
          "mean_time_ms": "518.691245232143",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "mean_time_ms": "518.691245232143",
          "max_time_ms": "1137.156924",
          "total_time_ms": "29046.709733",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "total_time_ms": "40384.84643",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "total_time_ms": "40384.84643",
          "mean_time_ms": "734.269935090909",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "mean_time_ms": "734.269935090909",
          "max_time_ms": "1384.405776",
          "total_time_ms": "40384.84643",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "total_time_ms": "9479.365463",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "SELECT word FROM pg_get_keywords()",
          "calls": "54",
          "total_time_ms": "25.665143",
          "rows": "26514",
          "Query": "SELECT word FROM pg_get_keywords()",
          "Fingerprint": "93722fc9"
        },
        {
          "query": "select pid, query, query_start from pg_stat_activity where state = $1 and datname = $2",
          "calls": "54",
          "total_time_ms": "28.544478",
          "rows": "149",
          "Query": "select pid, query, query_start from pg_stat_activity where state = $1 and datname = $2",
          "Fingerprint": "09f3a758"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "total_time_ms": "9479.365463",
          "mean_time_ms": "175.54380487037",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "mean_time_ms": "175.54380487037",
          "max_time_ms": "292.478765",
          "total_time_ms": "9479.365463",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "calls": "50",
          "total_time_ms": "896.677722",
          "rows": "38",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "Fingerprint": "a7b5eaa1"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "total_time_ms": "32448.44921",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "INSERT INTO migrations (\"id\", \"name\", \"hash\") VALUES ($1,$2,$3)",
          "calls": "50",
          "total_time_ms": "4.90032",
          "rows": "50",
          "Query": "INSERT INTO migrations (\"id\", \"name\", \"hash\") VALUES ($1,$2,$3)",
          "Fingerprint": "08deba80"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "total_time_ms": "32448.44921",
          "mean_time_ms": "648.9689842",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "calls": "50",
          "total_time_ms": "896.677722",
          "mean_time_ms": "17.93355444",
          "rows": "38",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "Fingerprint": "a7b5eaa1"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "mean_time_ms": "648.9689842",
          "max_time_ms": "1199.324807",
          "total_time_ms": "32448.44921",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "49",
          "total_time_ms": "69.16763",
          "rows": "49",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "calls": "48",
          "total_time_ms": "1039.996381",
          "rows": "0",
          "Query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "Fingerprint": "b05429e3"
        },
        {
          "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "calls": "48",
          "total_time_ms": "1039.996381",
          "mean_time_ms": "21.6665912708333",
          "rows": "0",
          "Query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "Fingerprint": "b05429e3"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "calls": "46",
          "total_time_ms": "596.622214",
          "rows": "1236",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "Fingerprint": "2d4e922a"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "calls": "46",
          "total_time_ms": "596.622214",
          "mean_time_ms": "12.9700481304348",
          "rows": "1236",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "Fingerprint": "2d4e922a"
        },
        {
          "query": "COMMIT",
          "calls": "44",
          "total_time_ms": "0.033668",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "START TRANSACTION",
          "calls": "44",
          "total_time_ms": "0.027186",
          "rows": "0",
          "Query": "START TRANSACTION",
          "Fingerprint": "cd946f1b"
        },
        {
          "query": "SELECT\n  p.oid :: int8 AS id,\n  p.pubname AS name,\n  p.pubowner::regrole::text AS owner,\n  p.pubinsert AS publish_insert,\n  p.pubupdate AS publish_update,\n  p.pubdelete AS publish_delete,\n  p.pubtruncate AS publish_truncate,\n  CASE\n    WHEN p.puballtables THEN $1\n    ELSE pr.tables\n  END AS tables\nFROM\n  pg_catalog.pg_publication AS p\n  LEFT JOIN LATERAL (\n    SELECT\n      COALESCE(\n        array_agg(\n          json_build_object(\n            $2,\n            c.oid :: int8,\n            $3,\n            c.relname,\n            $4,\n            nc.nspname\n          )\n        ),\n        $5\n      ) AS tables\n    FROM\n      pg_catalog.pg_publication_rel AS pr\n      JOIN pg_class AS c ON pr.prrelid = c.oid\n      join pg_namespace as nc on c.relnamespace = nc.oid\n    WHERE\n      pr.prpubid = p.oid\n  ) AS pr ON $6 = $7\nWHERE\n  $8",
          "calls": "43",
          "total_time_ms": "24.366404",
          "rows": "43",
          "Query": "SELECT\n  p.oid :: int8 AS id,\n  p.pubname AS name,\n  p.pubowner::regrole::text AS owner,\n  p.pubinsert AS publish_insert,\n  p.pubupdate AS publish_update,\n  p.pubdelete AS publish_delete,\n  p.pubtruncate AS publish_truncate,\n  CASE\n    WHEN p.puballtables THEN $1\n    ELSE pr.tables\n  END AS tables\nFROM\n  pg_catalog.pg_publication AS p\n  LEFT JOIN LATERAL (\n    SELECT\n      COALESCE(\n        array_agg(\n          json_build_object(\n            $2,\n            c.oid :: int8,\n            $3,\n            c.relname,\n            $4,\n            nc.nspname\n          )\n        ),\n        $5\n      ) AS tables\n    FROM\n      pg_catalog.pg_publication_rel AS pr\n      JOIN pg_class AS c ON pr.prrelid = c.oid\n      join pg_namespace as nc on c.relnamespace = nc.oid\n    WHERE\n      pr.prpubid = p.oid\n  ) AS pr ON $6 = $7\nWHERE\n  $8",
          "Fingerprint": "2e2e4cdd"
        },
        {
          "query": "SET idle_in_transaction_session_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.401828",
          "rows": "0",
          "Query": "SET idle_in_transaction_session_timeout = 0",
          "Fingerprint": "419d6119"
        },
        {
          "query": "SET transaction_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.344597",
          "rows": "0",
          "Query": "SET transaction_timeout = 0",
          "Fingerprint": "c9aafa99"
        },
        {
          "query": "SET statement_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.957163",
          "rows": "0",
          "Query": "SET statement_timeout = 0",
          "Fingerprint": "27ded464"
        },
        {
          "query": "SET row_security = off",
          "calls": "41",
          "total_time_ms": "0.250875",
          "rows": "0",
          "Query": "SET row_security = off",
          "Fingerprint": "fb6611bc"
        },
        {
          "query": "with foreign_tables as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  obj_description(c.oid) as comment,\n  fs.srvname as foreign_server_name,\n  fdw.fdwname as foreign_data_wrapper_name,\n  handler.proname as foreign_data_wrapper_handler\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  inner join pg_foreign_table ft on ft.ftrelid = c.oid\n  inner join pg_foreign_server fs on fs.oid = ft.ftserver\n  inner join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw\n  inner join pg_proc handler on handler.oid = fdw.fdwhandler\nwhere\n  c.relkind = $1\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $2 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $3\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $4 THEN CASE\n      WHEN bt.typelem <> $5 :: oid\n      AND bt.typlen = $6 THEN $7\n      WHEN nbt.nspname = $8 THEN format_type(t.typbasetype, $9)\n      ELSE $10\n    END\n    ELSE CASE\n      WHEN t.typelem <> $11 :: oid\n      AND t.typlen = $12 THEN $13\n      WHEN nt.nspname = $14 THEN format_type(a.atttypid, $15)\n      ELSE $16\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($17, $18) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $19 THEN $20\n    WHEN $21 THEN $22\n    ELSE $23\n  END AS identity_generation,\n  a.attgenerated IN ($24) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $25 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($26, $27)\n    OR c.relkind IN ($28, $29) AND pg_column_is_updatable(c.oid, a.attnum, $30)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $31\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$32] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $33 AND cardinality(conkey) = $34\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$35] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $36),\n        $37,\n        length(pg_get_constraintdef(pg_constraint.oid, $38)) - $39\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $40 AND cardinality(conkey) = $41\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $42\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($43, $44, $45, $46, $47))\n  AND (\n    pg_has_role(c.relowner, $48)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $49\n    )\n  )\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = foreign_tables.id)\n    FROM\n      columns\n  ),\n  $50\n) AS columns\nfrom foreign_tables where schema IN ($51)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:17:01.330Z",
          "calls": "41",
          "total_time_ms": "0.858437",
          "rows": "0",
          "Query": "with foreign_tables as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  obj_description(c.oid) as comment,\n  fs.srvname as foreign_server_name,\n  fdw.fdwname as foreign_data_wrapper_name,\n  handler.proname as foreign_data_wrapper_handler\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  inner join pg_foreign_table ft on ft.ftrelid = c.oid\n  inner join pg_foreign_server fs on fs.oid = ft.ftserver\n  inner join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw\n  inner join pg_proc handler on handler.oid = fdw.fdwhandler\nwhere\n  c.relkind = $1\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $2 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $3\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $4 THEN CASE\n      WHEN bt.typelem <> $5 :: oid\n      AND bt.typlen = $6 THEN $7\n      WHEN nbt.nspname = $8 THEN format_type(t.typbasetype, $9)\n      ELSE $10\n    END\n    ELSE CASE\n      WHEN t.typelem <> $11 :: oid\n      AND t.typlen = $12 THEN $13\n      WHEN nt.nspname = $14 THEN format_type(a.atttypid, $15)\n      ELSE $16\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($17, $18) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $19 THEN $20\n    WHEN $21 THEN $22\n    ELSE $23\n  END AS identity_generation,\n  a.attgenerated IN ($24) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $25 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($26, $27)\n    OR c.relkind IN ($28, $29) AND pg_column_is_updatable(c.oid, a.attnum, $30)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $31\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$32] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $33 AND cardinality(conkey) = $34\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$35] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $36),\n        $37,\n        length(pg_get_constraintdef(pg_constraint.oid, $38)) - $39\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $40 AND cardinality(conkey) = $41\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $42\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($43, $44, $45, $46, $47))\n  AND (\n    pg_has_role(c.relowner, $48)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $49\n    )\n  )\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = foreign_tables.id)\n    FROM\n      columns\n  ),\n  $50\n) AS columns\nfrom foreign_tables where schema IN ($51)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:17:01.330Z",
          "Fingerprint": "805f0060"
        },
        {
          "query": "SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = $1 THEN $2::\"char\" ELSE $3::\"char\" END, c.relowner) AS acldefault, CASE WHEN c.relkind = $4 THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE $5 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, $6 AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,$7),$8) AS reloptions, CASE WHEN $9 = ANY (c.reloptions) THEN $10::text WHEN $11 = ANY (c.reloptions) THEN $12::text ELSE $13 END AS checkoption, am.amname, (d.deptype = $14) IS TRUE AS is_identity_sequence, c.relispartition AS ispartition \nFROM pg_class c\nLEFT JOIN pg_depend d ON (c.relkind = $15 AND d.classid = $16::regclass AND d.objid = c.oid AND d.objsubid = $17 AND d.refclassid = $18::regclass AND d.deptype IN ($19, $20))\nLEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)\nLEFT JOIN pg_am am ON (c.relam = am.oid)\nLEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = $21 AND c.relkind <> $22)\nWHERE c.relkind IN ($23, $24, $25, $26, $27, $28, $29)\nORDER BY c.oid",
          "calls": "36",
          "total_time_ms": "3448.801096",
          "mean_time_ms": "95.8000304444444",
          "rows": "14824",
          "Query": "SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = $1 THEN $2::\"char\" ELSE $3::\"char\" END, c.relowner) AS acldefault, CASE WHEN c.relkind = $4 THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE $5 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, $6 AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,$7),$8) AS reloptions, CASE WHEN $9 = ANY (c.reloptions) THEN $10::text WHEN $11 = ANY (c.reloptions) THEN $12::text ELSE $13 END AS checkoption, am.amname, (d.deptype = $14) IS TRUE AS is_identity_sequence, c.relispartition AS ispartition \nFROM pg_class c\nLEFT JOIN pg_depend d ON (c.relkind = $15 AND d.classid = $16::regclass AND d.objid = c.oid AND d.objsubid = $17 AND d.refclassid = $18::regclass AND d.deptype IN ($19, $20))\nLEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)\nLEFT JOIN pg_am am ON (c.relam = am.oid)\nLEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = $21 AND c.relkind <> $22)\nWHERE c.relkind IN ($23, $24, $25, $26, $27, $28, $29)\nORDER BY c.oid",
          "Fingerprint": "43860e47"
        },
        {
          "query": "SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid",
          "calls": "36",
          "total_time_ms": "644.090406",
          "mean_time_ms": "17.8914001666667",
          "rows": "189526",
          "Query": "SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid",
          "Fingerprint": "189d6e81"
        },
        {
          "query": "SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, $1) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $2) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $3) AS indstatvals, i.indnullsnotdistinct FROM unnest($4::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ($5,$6,$7)) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = $8) AND i.indisready ORDER BY i.indrelid, indexname",
          "calls": "36",
          "total_time_ms": "544.603807",
          "mean_time_ms": "15.1278835277778",
          "rows": "10108",
          "Query": "SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, $1) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $2) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $3) AS indstatvals, i.indnullsnotdistinct FROM unnest($4::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ($5,$6,$7)) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = $8) AND i.indisready ORDER BY i.indrelid, indexname",
          "Fingerprint": "8c28798a"
        },
        {
          "query": "SELECT\na.attrelid,\na.attnum,\na.attname,\na.attstattarget,\na.attstorage,\nt.typstorage,\na.attnotnull,\na.atthasdef,\na.attisdropped,\na.attlen,\na.attalign,\na.attislocal,\npg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,\narray_to_string(a.attoptions, $1) AS attoptions,\nCASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE $2 END AS attcollation,\npg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || $3 || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), $4) AS attfdwoptions,\na.attcompression AS attcompression,\na.attidentity,\nCASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE $5 END AS attmissingval,\na.attgenerated\nFROM unnest($6::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)\nWHERE a.attnum > $7::pg_catalog.int2\nORDER BY a.attrelid, a.attnum",
          "calls": "36",
          "total_time_ms": "477.764626",
          "mean_time_ms": "13.2712396111111",
          "rows": "53780",
          "Query": "SELECT\na.attrelid,\na.attnum,\na.attname,\na.attstattarget,\na.attstorage,\nt.typstorage,\na.attnotnull,\na.atthasdef,\na.attisdropped,\na.attlen,\na.attalign,\na.attislocal,\npg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,\narray_to_string(a.attoptions, $1) AS attoptions,\nCASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE $2 END AS attcollation,\npg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || $3 || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), $4) AS attfdwoptions,\na.attcompression AS attcompression,\na.attidentity,\nCASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE $5 END AS attmissingval,\na.attgenerated\nFROM unnest($6::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)\nWHERE a.attnum > $7::pg_catalog.int2\nORDER BY a.attrelid, a.attnum",
          "Fingerprint": "8a143ec8"
        },
        {
          "query": "SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault($1, p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = $2::regclass AND pip.objsubid = $3) WHERE p.prokind <> $4\n  AND NOT EXISTS (SELECT $5 FROM pg_depend WHERE classid = $6::regclass AND objid = p.oid AND deptype = $7)\n  AND (\n  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = $8)\n  OR EXISTS (SELECT $9 FROM pg_cast\n  WHERE pg_cast.oid > $10 \n  AND p.oid = pg_cast.castfunc)\n  OR EXISTS (SELECT $11 FROM pg_transform\n  WHERE pg_transform.oid > $12 AND \n  (p.oid = pg_transform.trffromsql\n  OR p.oid = pg_transform.trftosql))\n  OR p.proacl IS DISTINCT FROM pip.initprivs)",
          "calls": "36",
          "total_time_ms": "396.306517",
          "mean_time_ms": "11.0085143611111",
          "rows": "16637",
          "Query": "SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault($1, p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = $2::regclass AND pip.objsubid = $3) WHERE p.prokind <> $4\n  AND NOT EXISTS (SELECT $5 FROM pg_depend WHERE classid = $6::regclass AND objid = p.oid AND deptype = $7)\n  AND (\n  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = $8)\n  OR EXISTS (SELECT $9 FROM pg_cast\n  WHERE pg_cast.oid > $10 \n  AND p.oid = pg_cast.castfunc)\n  OR EXISTS (SELECT $11 FROM pg_transform\n  WHERE pg_transform.oid > $12 AND \n  (p.oid = pg_transform.trffromsql\n  OR p.oid = pg_transform.trftosql))\n  OR p.proacl IS DISTINCT FROM pip.initprivs)",
          "Fingerprint": "21a0331a"
        },
        {
          "query": "SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != $1 AND deptype != $2\nUNION ALL\nSELECT $3::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ($4, $5, $6) AND classid = $7::regclass AND objid = o.oid AND NOT (refclassid = $8::regclass AND amopfamily = refobjid)\nUNION ALL\nSELECT $9::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ($10, $11, $12) AND classid = $13::regclass AND objid = p.oid AND NOT (refclassid = $14::regclass AND amprocfamily = refobjid)\nORDER BY 1,2",
          "calls": "36",
          "total_time_ms": "394.801907",
          "mean_time_ms": "10.9667196388889",
          "rows": "274216",
          "Query": "SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != $1 AND deptype != $2\nUNION ALL\nSELECT $3::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ($4, $5, $6) AND classid = $7::regclass AND objid = o.oid AND NOT (refclassid = $8::regclass AND amopfamily = refobjid)\nUNION ALL\nSELECT $9::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ($10, $11, $12) AND classid = $13::regclass AND objid = p.oid AND NOT (refclassid = $14::regclass AND amprocfamily = refobjid)\nORDER BY 1,2",
          "Fingerprint": "72852126"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"_filters\", \"_order_by\", \"_direction\" FROM json_to_record(pgrst_payload.json_data) AS _(\"_filters\" jsonb, \"_order_by\" text, \"_direction\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"filter_projects\"(\"_filters\" := pgrst_body.\"_filters\", \"_order_by\" := pgrst_body.\"_order_by\", \"_direction\" := pgrst_body.\"_direction\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"projects\".* FROM \"pgrst_source\" AS \"projects\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "36",
          "total_time_ms": "393.437611",
          "mean_time_ms": "10.9288225277778",
          "rows": "36",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"_filters\", \"_order_by\", \"_direction\" FROM json_to_record(pgrst_payload.json_data) AS _(\"_filters\" jsonb, \"_order_by\" text, \"_direction\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"filter_projects\"(\"_filters\" := pgrst_body.\"_filters\", \"_order_by\" := pgrst_body.\"_order_by\", \"_direction\" := pgrst_body.\"_direction\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"projects\".* FROM \"pgrst_source\" AS \"projects\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "0bad5e6b"
        },
        {
          "query": "SELECT tableoid, oid, typname, typnamespace, typacl, acldefault($1, typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = $2 THEN $3::\"char\" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[$4] = $5 AND typelem != $6 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type",
          "calls": "36",
          "total_time_ms": "383.257885",
          "mean_time_ms": "10.6460523611111",
          "rows": "38148",
          "Query": "SELECT tableoid, oid, typname, typnamespace, typacl, acldefault($1, typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = $2 THEN $3::\"char\" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[$4] = $5 AND typelem != $6 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type",
          "Fingerprint": "7fd9aab0"
        },
        {
          "query": "SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation",
          "calls": "36",
          "total_time_ms": "303.222024",
          "mean_time_ms": "8.422834",
          "rows": "29340",
          "Query": "SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation",
          "Fingerprint": "fb4316d3"
        },
        {
          "query": "SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc\nFROM unnest($1::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)\nORDER BY a.adrelid, a.adnum",
          "calls": "36",
          "total_time_ms": "230.075726",
          "mean_time_ms": "6.39099238888889",
          "rows": "10081",
          "Query": "SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc\nFROM unnest($1::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)\nORDER BY a.adrelid, a.adnum",
          "Fingerprint": "d4507d78"
        },
        {
          "query": "SELECT \n  con.oid as id, \n  con.conname as constraint_name, \n  con.confdeltype as deletion_action,\n  con.confupdtype as update_action,\n  rel.oid as source_id,\n  nsp.nspname as source_schema, \n  rel.relname as source_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.conkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = rel.oid\n  ) source_columns, \n  frel.oid as target_id,\n  fnsp.nspname as target_schema, \n  frel.relname as target_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.confkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = frel.oid\n  ) target_columns \nFROM \n  pg_constraint con \n  INNER JOIN pg_class rel ON rel.oid = con.conrelid \n  INNER JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace \n  INNER JOIN pg_class frel ON frel.oid = con.confrelid \n  INNER JOIN pg_namespace fnsp ON fnsp.oid = frel.relnamespace \nWHERE \n  con.contype = $1\n  AND nsp.nspname = $2\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T05:13:26.471Z",
          "calls": "34",
          "total_time_ms": "350.834465",
          "mean_time_ms": "10.3186607352941",
          "rows": "3900",
          "Query": "SELECT \n  con.oid as id, \n  con.conname as constraint_name, \n  con.confdeltype as deletion_action,\n  con.confupdtype as update_action,\n  rel.oid as source_id,\n  nsp.nspname as source_schema, \n  rel.relname as source_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.conkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = rel.oid\n  ) source_columns, \n  frel.oid as target_id,\n  fnsp.nspname as target_schema, \n  frel.relname as target_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.confkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = frel.oid\n  ) target_columns \nFROM \n  pg_constraint con \n  INNER JOIN pg_class rel ON rel.oid = con.conrelid \n  INNER JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace \n  INNER JOIN pg_class frel ON frel.oid = con.confrelid \n  INNER JOIN pg_namespace fnsp ON fnsp.oid = frel.relnamespace \nWHERE \n  con.contype = $1\n  AND nsp.nspname = $2\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T05:13:26.471Z",
          "Fingerprint": "d62b169a"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "calls": "30",
          "total_time_ms": "3255.608133",
          "mean_time_ms": "108.5202711",
          "rows": "30",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "Fingerprint": "393cf5c5"
        },
        {
          "query": "select * from storage.search($1,$2,$3,$4,$5,$6,$7,$8)",
          "calls": "30",
          "total_time_ms": "263.756364",
          "mean_time_ms": "8.7918788",
          "rows": "330",
          "Query": "select * from storage.search($1,$2,$3,$4,$5,$6,$7,$8)",
          "Fingerprint": "4855f2f1"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "calls": "30",
          "mean_time_ms": "108.5202711",
          "max_time_ms": "205.438253",
          "total_time_ms": "3255.608133",
          "rows": "30",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "Fingerprint": "393cf5c5"
        },
        {
          "query": "SELECT\n  pol.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS table,\n  c.oid :: int8 AS table_id,\n  pol.polname AS name,\n  CASE\n    WHEN pol.polpermissive THEN $1 :: text\n    ELSE $2 :: text\n  END AS action,\n  CASE\n    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(\n      string_to_array($4 :: text, $5 :: text) :: name []\n    )\n    ELSE array_to_json(\n      ARRAY(\n        SELECT\n          pg_roles.rolname\n        FROM\n          pg_roles\n        WHERE\n          pg_roles.oid = ANY (pol.polroles)\n        ORDER BY\n          pg_roles.rolname\n      )\n    )\n  END AS roles,\n  CASE\n    pol.polcmd\n    WHEN $6 :: \"char\" THEN $7 :: text\n    WHEN $8 :: \"char\" THEN $9 :: text\n    WHEN $10 :: \"char\" THEN $11 :: text\n    WHEN $12 :: \"char\" THEN $13 :: text\n    WHEN $14 :: \"char\" THEN $15 :: text\n    ELSE $16 :: text\n  END AS command,\n  pg_get_expr(pol.polqual, pol.polrelid) AS definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check\nFROM\n  pg_policy pol\n  JOIN pg_class c ON c.oid = pol.polrelid\n  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname NOT IN ($17,$18,$19)",
          "calls": "24",
          "total_time_ms": "664.760387",
          "mean_time_ms": "27.6983494583333",
          "rows": "9760",
          "Query": "SELECT\n  pol.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS table,\n  c.oid :: int8 AS table_id,\n  pol.polname AS name,\n  CASE\n    WHEN pol.polpermissive THEN $1 :: text\n    ELSE $2 :: text\n  END AS action,\n  CASE\n    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(\n      string_to_array($4 :: text, $5 :: text) :: name []\n    )\n    ELSE array_to_json(\n      ARRAY(\n        SELECT\n          pg_roles.rolname\n        FROM\n          pg_roles\n        WHERE\n          pg_roles.oid = ANY (pol.polroles)\n        ORDER BY\n          pg_roles.rolname\n      )\n    )\n  END AS roles,\n  CASE\n    pol.polcmd\n    WHEN $6 :: \"char\" THEN $7 :: text\n    WHEN $8 :: \"char\" THEN $9 :: text\n    WHEN $10 :: \"char\" THEN $11 :: text\n    WHEN $12 :: \"char\" THEN $13 :: text\n    WHEN $14 :: \"char\" THEN $15 :: text\n    ELSE $16 :: text\n  END AS command,\n  pg_get_expr(pol.polqual, pol.polrelid) AS definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check\nFROM\n  pg_policy pol\n  JOIN pg_class c ON c.oid = pol.polrelid\n  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname NOT IN ($17,$18,$19)",
          "Fingerprint": "2bc926bd"
        },
        {
          "query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "calls": "22",
          "total_time_ms": "4059.943647",
          "mean_time_ms": "184.542893045455",
          "rows": "4573",
          "Query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "Fingerprint": "ac49b202"
        },
        {
          "query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "calls": "22",
          "mean_time_ms": "184.542893045455",
          "max_time_ms": "547.889806",
          "total_time_ms": "4059.943647",
          "rows": "4573",
          "Query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "Fingerprint": "ac49b202"
        },
        {
          "query": "SELECT\n  pg_t.oid AS id,\n  pg_t.tgrelid AS table_id,\n  CASE\n    WHEN pg_t.tgenabled = $1 THEN $2\n    WHEN pg_t.tgenabled = $3 THEN $4\n    WHEN pg_t.tgenabled = $5 THEN $6\n    WHEN pg_t.tgenabled = $7 THEN $8\n    END AS enabled_mode,\n  (\n    STRING_TO_ARRAY(\n      ENCODE(pg_t.tgargs, $9), $10\n    )\n  )[:pg_t.tgnargs] AS function_args,\n  is_t.trigger_name AS name,\n  is_t.event_object_table AS table,\n  is_t.event_object_schema AS schema,\n  is_t.action_condition AS condition,\n  is_t.action_orientation AS orientation,\n  is_t.action_timing AS activation,\n  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,\n  pg_p.proname AS function_name,\n  pg_n.nspname AS function_schema\nFROM\n  pg_trigger AS pg_t\nJOIN\n  pg_class AS pg_c\nON pg_t.tgrelid = pg_c.oid\nJOIN pg_namespace AS table_ns\nON pg_c.relnamespace = table_ns.oid\nJOIN information_schema.triggers AS is_t\nON is_t.trigger_name = pg_t.tgname\nAND pg_c.relname = is_t.event_object_table\nAND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace\nJOIN pg_proc AS pg_p\nON pg_t.tgfoid = pg_p.oid\nJOIN pg_namespace AS pg_n\nON pg_p.pronamespace = pg_n.oid\nWHERE\n  table_ns.nspname NOT IN ($11,$12,$13)\n  \n  \n  \nGROUP BY\n  pg_t.oid,\n  pg_t.tgrelid,\n  pg_t.tgenabled,\n  pg_t.tgargs,\n  pg_t.tgnargs,\n  is_t.trigger_name,\n  is_t.event_object_table,\n  is_t.event_object_schema,\n  is_t.action_condition,\n  is_t.action_orientation,\n  is_t.action_timing,\n  pg_p.proname,\n  pg_n.nspname",
          "calls": "17",
          "total_time_ms": "310.477875",
          "mean_time_ms": "18.2634044117647",
          "rows": "2872",
          "Query": "SELECT\n  pg_t.oid AS id,\n  pg_t.tgrelid AS table_id,\n  CASE\n    WHEN pg_t.tgenabled = $1 THEN $2\n    WHEN pg_t.tgenabled = $3 THEN $4\n    WHEN pg_t.tgenabled = $5 THEN $6\n    WHEN pg_t.tgenabled = $7 THEN $8\n    END AS enabled_mode,\n  (\n    STRING_TO_ARRAY(\n      ENCODE(pg_t.tgargs, $9), $10\n    )\n  )[:pg_t.tgnargs] AS function_args,\n  is_t.trigger_name AS name,\n  is_t.event_object_table AS table,\n  is_t.event_object_schema AS schema,\n  is_t.action_condition AS condition,\n  is_t.action_orientation AS orientation,\n  is_t.action_timing AS activation,\n  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,\n  pg_p.proname AS function_name,\n  pg_n.nspname AS function_schema\nFROM\n  pg_trigger AS pg_t\nJOIN\n  pg_class AS pg_c\nON pg_t.tgrelid = pg_c.oid\nJOIN pg_namespace AS table_ns\nON pg_c.relnamespace = table_ns.oid\nJOIN information_schema.triggers AS is_t\nON is_t.trigger_name = pg_t.tgname\nAND pg_c.relname = is_t.event_object_table\nAND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace\nJOIN pg_proc AS pg_p\nON pg_t.tgfoid = pg_p.oid\nJOIN pg_namespace AS pg_n\nON pg_p.pronamespace = pg_n.oid\nWHERE\n  table_ns.nspname NOT IN ($11,$12,$13)\n  \n  \n  \nGROUP BY\n  pg_t.oid,\n  pg_t.tgrelid,\n  pg_t.tgenabled,\n  pg_t.tgargs,\n  pg_t.tgnargs,\n  is_t.trigger_name,\n  is_t.event_object_table,\n  is_t.event_object_schema,\n  is_t.action_condition,\n  is_t.action_orientation,\n  is_t.action_timing,\n  pg_p.proname,\n  pg_n.nspname",
          "Fingerprint": "fa5418aa"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "13",
          "total_time_ms": "469.941505",
          "mean_time_ms": "36.1493465384615",
          "rows": "532",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "335d3082"
        },
        {
          "query": "INSERT INTO \"users\" (\"aud\", \"banned_until\", \"confirmation_sent_at\", \"confirmation_token\", \"created_at\", \"deleted_at\", \"email\", \"email_change\", \"email_change_confirm_status\", \"email_change_sent_at\", \"email_change_token_current\", \"email_change_token_new\", \"email_confirmed_at\", \"encrypted_password\", \"id\", \"instance_id\", \"invited_at\", \"is_anonymous\", \"is_sso_user\", \"last_sign_in_at\", \"phone\", \"phone_change\", \"phone_change_sent_at\", \"phone_change_token\", \"phone_confirmed_at\", \"raw_app_meta_data\", \"raw_user_meta_data\", \"reauthentication_sent_at\", \"reauthentication_token\", \"recovery_sent_at\", \"recovery_token\", \"role\", \"updated_at\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)",
          "calls": "7",
          "total_time_ms": "370.288915",
          "mean_time_ms": "52.8984164285714",
          "rows": "7",
          "Query": "INSERT INTO \"users\" (\"aud\", \"banned_until\", \"confirmation_sent_at\", \"confirmation_token\", \"created_at\", \"deleted_at\", \"email\", \"email_change\", \"email_change_confirm_status\", \"email_change_sent_at\", \"email_change_token_current\", \"email_change_token_new\", \"email_confirmed_at\", \"encrypted_password\", \"id\", \"instance_id\", \"invited_at\", \"is_anonymous\", \"is_sso_user\", \"last_sign_in_at\", \"phone\", \"phone_change\", \"phone_change_sent_at\", \"phone_change_token\", \"phone_confirmed_at\", \"raw_app_meta_data\", \"raw_user_meta_data\", \"reauthentication_sent_at\", \"reauthentication_token\", \"recovery_sent_at\", \"recovery_token\", \"role\", \"updated_at\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)",
          "Fingerprint": "28bfbb4f"
        },
        {
          "query": "delete from public.profiles where id in ($1)",
          "calls": "6",
          "total_time_ms": "308.323666",
          "mean_time_ms": "51.3872776666667",
          "rows": "6",
          "Query": "delete from public.profiles where id in ($1)",
          "Fingerprint": "8fff047e"
        },
        {
          "query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "calls": "5",
          "total_time_ms": "783.325132",
          "mean_time_ms": "156.6650264",
          "rows": "5",
          "Query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "Fingerprint": "ad2f00c3"
        },
        {
          "query": "SELECT concat(schemaname, $1, tablename, $2, policyname) as policy\n    FROM   pg_policies",
          "calls": "5",
          "total_time_ms": "215.448357",
          "mean_time_ms": "43.0896714",
          "rows": "1777",
          "Query": "SELECT concat(schemaname, $1, tablename, $2, policyname) as policy\n    FROM   pg_policies",
          "Fingerprint": "46133688"
        },
        {
          "query": "SELECT labelfile, spcmapfile, lsn FROM pg_backup_stop($1)",
          "calls": "5",
          "total_time_ms": "204.326571",
          "mean_time_ms": "40.8653142",
          "rows": "5",
          "Query": "SELECT labelfile, spcmapfile, lsn FROM pg_backup_stop($1)",
          "Fingerprint": "11e57483"
        },
        {
          "query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "calls": "5",
          "mean_time_ms": "156.6650264",
          "max_time_ms": "178.818857",
          "total_time_ms": "783.325132",
          "rows": "5",
          "Query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "Fingerprint": "ad2f00c3"
        },
        {
          "query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
          "calls": "4",
          "total_time_ms": "323.330854",
          "mean_time_ms": "80.8327135",
          "rows": "0",
          "Query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
          "Fingerprint": "92e79eb0"
        },
        {
          "query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "calls": "2",
          "total_time_ms": "273.3887",
          "mean_time_ms": "136.69435",
          "rows": "902",
          "Query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "069b33dd"
        },
        {
          "query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "calls": "2",
          "total_time_ms": "220.062577",
          "mean_time_ms": "110.0312885",
          "rows": "0",
          "Query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "Fingerprint": "0f1f0b6b"
        },
        {
          "query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "207.808953",
          "mean_time_ms": "103.9044765",
          "rows": "0",
          "Query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "Fingerprint": "c6431895"
        },
        {
          "query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "206.381392",
          "mean_time_ms": "103.190696",
          "rows": "0",
          "Query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3607e581"
        },
        {
          "query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "206.062412",
          "mean_time_ms": "103.031206",
          "rows": "0",
          "Query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "393ce475"
        },
        {
          "query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "205.673718",
          "mean_time_ms": "102.836859",
          "rows": "0",
          "Query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3fea036f"
        },
        {
          "query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "205.463539",
          "mean_time_ms": "102.7317695",
          "rows": "0",
          "Query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "e68eeac4"
        },
        {
          "query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "204.001209",
          "mean_time_ms": "102.0006045",
          "rows": "0",
          "Query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0ecbf6a3"
        },
        {
          "query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "203.976468",
          "mean_time_ms": "101.988234",
          "rows": "0",
          "Query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a70a9671"
        },
        {
          "query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.699628",
          "mean_time_ms": "101.349814",
          "rows": "0",
          "Query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "fbbe9f07"
        },
        {
          "query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.517924",
          "mean_time_ms": "101.258962",
          "rows": "0",
          "Query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "985defa9"
        },
        {
          "query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.514213",
          "mean_time_ms": "101.2571065",
          "rows": "0",
          "Query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0cdfc356"
        },
        {
          "query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.451113",
          "mean_time_ms": "101.2255565",
          "rows": "0",
          "Query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9d63facb"
        },
        {
          "query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.02539",
          "mean_time_ms": "101.012695",
          "rows": "0",
          "Query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "af8cfe10"
        },
        {
          "query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.014789",
          "mean_time_ms": "101.0073945",
          "rows": "0",
          "Query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "4aa64b10"
        },
        {
          "query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.994657",
          "mean_time_ms": "100.9973285",
          "rows": "0",
          "Query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ab6ea55e"
        },
        {
          "query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.979829",
          "mean_time_ms": "100.9899145",
          "rows": "0",
          "Query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ee687845"
        },
        {
          "query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.977313",
          "mean_time_ms": "100.9886565",
          "rows": "0",
          "Query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "61246560"
        },
        {
          "query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.95722",
          "mean_time_ms": "100.97861",
          "rows": "0",
          "Query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "725b8f3c"
        },
        {
          "query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.852303",
          "mean_time_ms": "100.9261515",
          "rows": "0",
          "Query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b9c2a293"
        },
        {
          "query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.743704",
          "mean_time_ms": "100.871852",
          "rows": "0",
          "Query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "63153467"
        },
        {
          "query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.709249",
          "mean_time_ms": "100.8546245",
          "rows": "0",
          "Query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a27fced0"
        },
        {
          "query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.368563",
          "mean_time_ms": "100.6842815",
          "rows": "0",
          "Query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "11df5844"
        },
        {
          "query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.250924",
          "mean_time_ms": "100.625462",
          "rows": "2",
          "Query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "Fingerprint": "c8e5bf36"
        },
        {
          "query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.235425",
          "mean_time_ms": "100.6177125",
          "rows": "0",
          "Query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "Fingerprint": "254f4411"
        },
        {
          "query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.062897",
          "mean_time_ms": "100.5314485",
          "rows": "0",
          "Query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b24724cf"
        },
        {
          "query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.595134",
          "mean_time_ms": "100.297567",
          "rows": "0",
          "Query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "762656ca"
        },
        {
          "query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.491872",
          "mean_time_ms": "100.245936",
          "rows": "0",
          "Query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "d828f6ba"
        },
        {
          "query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.426622",
          "mean_time_ms": "100.213311",
          "rows": "0",
          "Query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9bf1c2fe"
        },
        {
          "query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.351478",
          "mean_time_ms": "100.175739",
          "rows": "0",
          "Query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dadb92a9"
        },
        {
          "query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.275125",
          "mean_time_ms": "100.1375625",
          "rows": "0",
          "Query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "Fingerprint": "cc50e652"
        },
        {
          "query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "199.807887",
          "mean_time_ms": "99.9039435",
          "rows": "0",
          "Query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "06813e78"
        },
        {
          "query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "199.698604",
          "mean_time_ms": "99.849302",
          "rows": "0",
          "Query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6c04fcb5"
        },
        {
          "query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "calls": "2",
          "mean_time_ms": "136.69435",
          "max_time_ms": "257.34823",
          "total_time_ms": "273.3887",
          "rows": "902",
          "Query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "069b33dd"
        },
        {
          "query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "calls": "2",
          "mean_time_ms": "110.0312885",
          "max_time_ms": "219.722141",
          "total_time_ms": "220.062577",
          "rows": "0",
          "Query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "Fingerprint": "0f1f0b6b"
        },
        {
          "query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.9044765",
          "max_time_ms": "104.666803",
          "total_time_ms": "207.808953",
          "rows": "0",
          "Query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "Fingerprint": "c6431895"
        },
        {
          "query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.190696",
          "max_time_ms": "107.763366",
          "total_time_ms": "206.381392",
          "rows": "0",
          "Query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3607e581"
        },
        {
          "query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.031206",
          "max_time_ms": "103.208161",
          "total_time_ms": "206.062412",
          "rows": "0",
          "Query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "393ce475"
        },
        {
          "query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.836859",
          "max_time_ms": "110.852408",
          "total_time_ms": "205.673718",
          "rows": "0",
          "Query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3fea036f"
        },
        {
          "query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.7317695",
          "max_time_ms": "111.358102",
          "total_time_ms": "205.463539",
          "rows": "0",
          "Query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "e68eeac4"
        },
        {
          "query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.0006045",
          "max_time_ms": "103.951377",
          "total_time_ms": "204.001209",
          "rows": "0",
          "Query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0ecbf6a3"
        },
        {
          "query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.988234",
          "max_time_ms": "108.352564",
          "total_time_ms": "203.976468",
          "rows": "0",
          "Query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a70a9671"
        },
        {
          "query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.349814",
          "max_time_ms": "104.02735",
          "total_time_ms": "202.699628",
          "rows": "0",
          "Query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "fbbe9f07"
        },
        {
          "query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.258962",
          "max_time_ms": "103.113763",
          "total_time_ms": "202.517924",
          "rows": "0",
          "Query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "985defa9"
        },
        {
          "query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.2571065",
          "max_time_ms": "103.900791",
          "total_time_ms": "202.514213",
          "rows": "0",
          "Query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0cdfc356"
        },
        {
          "query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.2255565",
          "max_time_ms": "103.772709",
          "total_time_ms": "202.451113",
          "rows": "0",
          "Query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9d63facb"
        },
        {
          "query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.012695",
          "max_time_ms": "103.267842",
          "total_time_ms": "202.02539",
          "rows": "0",
          "Query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "af8cfe10"
        },
        {
          "query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.0073945",
          "max_time_ms": "103.32245",
          "total_time_ms": "202.014789",
          "rows": "0",
          "Query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "4aa64b10"
        },
        {
          "query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9973285",
          "max_time_ms": "102.47602",
          "total_time_ms": "201.994657",
          "rows": "0",
          "Query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ab6ea55e"
        },
        {
          "query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9899145",
          "max_time_ms": "103.205074",
          "total_time_ms": "201.979829",
          "rows": "0",
          "Query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ee687845"
        },
        {
          "query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9886565",
          "max_time_ms": "103.240863",
          "total_time_ms": "201.977313",
          "rows": "0",
          "Query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "61246560"
        },
        {
          "query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.97861",
          "max_time_ms": "103.969483",
          "total_time_ms": "201.95722",
          "rows": "0",
          "Query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "725b8f3c"
        },
        {
          "query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9261515",
          "max_time_ms": "103.91475",
          "total_time_ms": "201.852303",
          "rows": "0",
          "Query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b9c2a293"
        },
        {
          "query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.871852",
          "max_time_ms": "103.079578",
          "total_time_ms": "201.743704",
          "rows": "0",
          "Query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "63153467"
        },
        {
          "query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.8546245",
          "max_time_ms": "103.134612",
          "total_time_ms": "201.709249",
          "rows": "0",
          "Query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a27fced0"
        },
        {
          "query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.6842815",
          "max_time_ms": "103.245174",
          "total_time_ms": "201.368563",
          "rows": "0",
          "Query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "11df5844"
        },
        {
          "query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.625462",
          "max_time_ms": "102.487678",
          "total_time_ms": "201.250924",
          "rows": "2",
          "Query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "Fingerprint": "c8e5bf36"
        },
        {
          "query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.6177125",
          "max_time_ms": "103.226005",
          "total_time_ms": "201.235425",
          "rows": "0",
          "Query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "Fingerprint": "254f4411"
        },
        {
          "query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.5314485",
          "max_time_ms": "103.15837",
          "total_time_ms": "201.062897",
          "rows": "0",
          "Query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b24724cf"
        },
        {
          "query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.297567",
          "max_time_ms": "103.2202",
          "total_time_ms": "200.595134",
          "rows": "0",
          "Query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "762656ca"
        },
        {
          "query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.245936",
          "max_time_ms": "104.799331",
          "total_time_ms": "200.491872",
          "rows": "0",
          "Query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "d828f6ba"
        },
        {
          "query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.213311",
          "max_time_ms": "102.488242",
          "total_time_ms": "200.426622",
          "rows": "0",
          "Query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9bf1c2fe"
        },
        {
          "query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.175739",
          "max_time_ms": "103.10024",
          "total_time_ms": "200.351478",
          "rows": "0",
          "Query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dadb92a9"
        },
        {
          "query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.1375625",
          "max_time_ms": "103.138458",
          "total_time_ms": "200.275125",
          "rows": "0",
          "Query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "Fingerprint": "cc50e652"
        },
        {
          "query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.9039435",
          "max_time_ms": "104.654816",
          "total_time_ms": "199.807887",
          "rows": "0",
          "Query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "06813e78"
        },
        {
          "query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.849302",
          "max_time_ms": "104.678428",
          "total_time_ms": "199.698604",
          "rows": "0",
          "Query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6c04fcb5"
        },
        {
          "query": "COPY public.tack_rates (id, project_id, rate, material_type, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.832495",
          "max_time_ms": "101.546485",
          "total_time_ms": "199.66499",
          "rows": "0",
          "Query": "COPY public.tack_rates (id, project_id, rate, material_type, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b0803b87"
        },
        {
          "query": "COPY public.audit_log (id, table_name, action, row_id, before_data, after_data, changed_by, changed_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.7842675",
          "max_time_ms": "103.065844",
          "total_time_ms": "199.568535",
          "rows": "0",
          "Query": "COPY public.audit_log (id, table_name, action, row_id, before_data, after_data, changed_by, changed_at, deleted_at) FROM stdin",
          "Fingerprint": "704b2583"
        },
        {
          "query": "COPY public.equipment_maintenance (id, equipment_id, maintenance_date, type, description, performed_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.463506",
          "max_time_ms": "103.164462",
          "total_time_ms": "198.927012",
          "rows": "0",
          "Query": "COPY public.equipment_maintenance (id, equipment_id, maintenance_date, type, description, performed_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6e8cab3d"
        },
        {
          "query": "COPY realtime.subscription (id, subscription_id, entity, filters, claims, created_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.4489215",
          "max_time_ms": "100.152143",
          "total_time_ms": "198.897843",
          "rows": "0",
          "Query": "COPY realtime.subscription (id, subscription_id, entity, filters, claims, created_at) FROM stdin",
          "Fingerprint": "b4bc70d0"
        },
        {
          "query": "COPY public.safety_incidents (id, project_id, incident_date, description, reported_by, severity, resolved, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.3453095",
          "max_time_ms": "103.06347",
          "total_time_ms": "198.690619",
          "rows": "0",
          "Query": "COPY public.safety_incidents (id, project_id, incident_date, description, reported_by, severity, resolved, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dd094ff1"
        },
        {
          "query": "COPY public.user_projects (id, user_id, project_id, role, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.1600695",
          "max_time_ms": "103.175814",
          "total_time_ms": "198.320139",
          "rows": "0",
          "Query": "COPY public.user_projects (id, user_id, project_id, role, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6494210b"
        },
        {
          "query": "COPY auth.saml_relay_states (id, sso_provider_id, request_id, for_email, redirect_to, created_at, updated_at, flow_state_id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.1385155",
          "max_time_ms": "99.562381",
          "total_time_ms": "198.277031",
          "rows": "0",
          "Query": "COPY auth.saml_relay_states (id, sso_provider_id, request_id, for_email, redirect_to, created_at, updated_at, flow_state_id) FROM stdin",
          "Fingerprint": "ea71b0bd"
        },
        {
          "query": "COPY public.task_dependencies (id, task_id, depends_on_task_id, created_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.132069",
          "max_time_ms": "102.400731",
          "total_time_ms": "198.264138",
          "rows": "0",
          "Query": "COPY public.task_dependencies (id, task_id, depends_on_task_id, created_at, deleted_at) FROM stdin",
          "Fingerprint": "084a3cc5"
        },
        {
          "query": "COPY public.avatars (id, url, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.115221",
          "max_time_ms": "103.966743",
          "total_time_ms": "198.230442",
          "rows": "0",
          "Query": "COPY public.avatars (id, url, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "10445d5c"
        },
        {
          "query": "COPY auth.mfa_factors (id, user_id, friendly_name, factor_type, status, created_at, updated_at, secret, phone, last_challenged_at, web_authn_credential, web_authn_aaguid) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.090762",
          "max_time_ms": "99.429246",
          "total_time_ms": "198.181524",
          "rows": "0",
          "Query": "COPY auth.mfa_factors (id, user_id, friendly_name, factor_type, status, created_at, updated_at, secret, phone, last_challenged_at, web_authn_credential, web_authn_aaguid) FROM stdin",
          "Fingerprint": "cec579ea"
        },
        {
          "query": "COPY public.materials (id, organization_id, name, description, unit, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0780935",
          "max_time_ms": "99.630832",
          "total_time_ms": "198.156187",
          "rows": "0",
          "Query": "COPY public.materials (id, organization_id, name, description, unit, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "8aa4d8bf"
        },
        {
          "query": "COPY public.vendor_documents (id, vendor_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0703345",
          "max_time_ms": "99.378792",
          "total_time_ms": "198.140669",
          "rows": "0",
          "Query": "COPY public.vendor_documents (id, vendor_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "581b0829"
        },
        {
          "query": "COPY public.accounts_receivable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0671665",
          "max_time_ms": "103.27019",
          "total_time_ms": "198.134333",
          "rows": "0",
          "Query": "COPY public.accounts_receivable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "1ecde75f"
        },
        {
          "query": "COPY public.daily_logs (id, project_id, date, weather, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.035697",
          "max_time_ms": "99.361033",
          "total_time_ms": "198.071394",
          "rows": "0",
          "Query": "COPY public.daily_logs (id, project_id, date, weather, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "5c027ac6"
        },
        {
          "query": "COPY auth.identities (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0258625",
          "max_time_ms": "99.488222",
          "total_time_ms": "198.051725",
          "rows": "0",
          "Query": "COPY auth.identities (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, id) FROM stdin",
          "Fingerprint": "58196849"
        },
        {
          "query": "COPY auth.flow_state (id, user_id, auth_code, code_challenge_method, code_challenge, provider_type, provider_access_token, provider_refresh_token, created_at, updated_at, authentication_method, auth_code_issued_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0232145",
          "max_time_ms": "103.023291",
          "total_time_ms": "198.046429",
          "rows": "0",
          "Query": "COPY auth.flow_state (id, user_id, auth_code, code_challenge_method, code_challenge, provider_type, provider_access_token, provider_refresh_token, created_at, updated_at, authentication_method, auth_code_issued_at) FROM stdin",
          "Fingerprint": "5fc5c63b"
        },
        {
          "query": "COPY auth.mfa_amr_claims (session_id, created_at, updated_at, authentication_method, id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.008733",
          "max_time_ms": "103.181295",
          "total_time_ms": "198.017466",
          "rows": "0",
          "Query": "COPY auth.mfa_amr_claims (session_id, created_at, updated_at, authentication_method, id) FROM stdin",
          "Fingerprint": "7760a2e4"
        },
        {
          "query": "COPY public.organization_projects (id, organization_id, project_id, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.003132",
          "max_time_ms": "99.318153",
          "total_time_ms": "198.006264",
          "rows": "0",
          "Query": "COPY public.organization_projects (id, organization_id, project_id, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3059abb3"
        },
        {
          "query": "COPY auth.refresh_tokens (instance_id, id, token, user_id, revoked, created_at, updated_at, parent, session_id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.947378",
          "max_time_ms": "99.36111",
          "total_time_ms": "197.894756",
          "rows": "0",
          "Query": "COPY auth.refresh_tokens (instance_id, id, token, user_id, revoked, created_at, updated_at, parent, session_id) FROM stdin",
          "Fingerprint": "5780d9c8"
        },
        {
          "query": "COPY public.labor_records (id, line_item_id, worker_count, hours_worked, work_date, work_type, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.9292225",
          "max_time_ms": "99.371704",
          "total_time_ms": "197.858445",
          "rows": "0",
          "Query": "COPY public.labor_records (id, line_item_id, worker_count, hours_worked, work_date, work_type, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "456f60d1"
        },
        {
          "query": "COPY public.material_inventory (id, material_id, organization_id, quantity, last_updated, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.928901",
          "max_time_ms": "102.343097",
          "total_time_ms": "197.857802",
          "rows": "0",
          "Query": "COPY public.material_inventory (id, material_id, organization_id, quantity, last_updated, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6ac46892"
        },
        {
          "query": "COPY auth.sso_providers (id, resource_id, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.885203",
          "max_time_ms": "99.914739",
          "total_time_ms": "197.770406",
          "rows": "0",
          "Query": "COPY auth.sso_providers (id, resource_id, created_at, updated_at) FROM stdin",
          "Fingerprint": "e3bc4723"
        },
        {
          "query": "COPY public.vendors (id, organization_id, name, status, contact_email, contact_phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7803365",
          "max_time_ms": "103.249249",
          "total_time_ms": "197.560673",
          "rows": "0",
          "Query": "COPY public.vendors (id, organization_id, name, status, contact_email, contact_phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "24075ca8"
        },
        {
          "query": "COPY public.change_orders (id, project_id, number, description, status, amount, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7662585",
          "max_time_ms": "98.798355",
          "total_time_ms": "197.532517",
          "rows": "0",
          "Query": "COPY public.change_orders (id, project_id, number, description, status, amount, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "5882c02d"
        },
        {
          "query": "COPY public.photos (id, project_id, url, caption, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7259615",
          "max_time_ms": "98.798059",
          "total_time_ms": "197.451923",
          "rows": "0",
          "Query": "COPY public.photos (id, project_id, url, caption, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "99b591f2"
        },
        {
          "query": "COPY public.bid_packages (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.715568",
          "max_time_ms": "98.786265",
          "total_time_ms": "197.431136",
          "rows": "0",
          "Query": "COPY public.bid_packages (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "33db00f2"
        },
        {
          "query": "COPY public.bim_models (id, project_id, name, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7117465",
          "max_time_ms": "103.064154",
          "total_time_ms": "197.423493",
          "rows": "0",
          "Query": "COPY public.bim_models (id, project_id, name, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "7cbd4961"
        },
        {
          "query": "COPY public.commitments (id, project_id, vendor_id, type, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7070115",
          "max_time_ms": "103.115353",
          "total_time_ms": "197.414023",
          "rows": "0",
          "Query": "COPY public.commitments (id, project_id, vendor_id, type, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "95986b7c"
        },
        {
          "query": "COPY public.material_receipts (id, material_order_id, received_date, quantity, received_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7029815",
          "max_time_ms": "98.706456",
          "total_time_ms": "197.405963",
          "rows": "0",
          "Query": "COPY public.material_receipts (id, material_order_id, received_date, quantity, received_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a41d9dfa"
        },
        {
          "query": "COPY public.crew_members (id, crew_id, profile_id, role, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6990605",
          "max_time_ms": "98.739759",
          "total_time_ms": "197.398121",
          "rows": "0",
          "Query": "COPY public.crew_members (id, crew_id, profile_id, role, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "c052cb3d"
        },
        {
          "query": "COPY public.drawing_versions (id, document_id, version, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.683518",
          "max_time_ms": "103.134743",
          "total_time_ms": "197.367036",
          "rows": "0",
          "Query": "COPY public.drawing_versions (id, document_id, version, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0b26fcaa"
        },
        {
          "query": "COPY public.dashboard_configs (id, profile_id, config, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6810585",
          "max_time_ms": "98.724536",
          "total_time_ms": "197.362117",
          "rows": "0",
          "Query": "COPY public.dashboard_configs (id, profile_id, config, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "1cd42ea2"
        },
        {
          "query": "COPY public.training_records (id, employee_id, training_type, completion_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.663368",
          "max_time_ms": "98.676634",
          "total_time_ms": "197.326736",
          "rows": "0",
          "Query": "COPY public.training_records (id, employee_id, training_type, completion_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "58dd9afa"
        },
        {
          "query": "COPY public.certifications (id, employee_id, certification_type, issue_date, expiry_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6559805",
          "max_time_ms": "103.158594",
          "total_time_ms": "197.311961",
          "rows": "0",
          "Query": "COPY public.certifications (id, employee_id, certification_type, issue_date, expiry_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "278a4a8b"
        },
        {
          "query": "COPY auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, invited_at, confirmation_token, confirmation_sent_at, recovery_token, recovery_sent_at, email_change_token_new, email_change, email_change_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, is_super_admin, created_at, updated_at, phone, phone_confirmed_at, phone_change, phone_change_token, phone_change_sent_at, email_change_token_current, email_change_confirm_status, banned_until, reauthentication_token, reauthentication_sent_at, is_sso_user, deleted_at, is_anonymous) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6528365",
          "max_time_ms": "102.373345",
          "total_time_ms": "197.305673",
          "rows": "0",
          "Query": "COPY auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, invited_at, confirmation_token, confirmation_sent_at, recovery_token, recovery_sent_at, email_change_token_new, email_change, email_change_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, is_super_admin, created_at, updated_at, phone, phone_confirmed_at, phone_change, phone_change_token, phone_change_sent_at, email_change_token_current, email_change_confirm_status, banned_until, reauthentication_token, reauthentication_sent_at, is_sso_user, deleted_at, is_anonymous) FROM stdin",
          "Fingerprint": "43fa7093"
        },
        {
          "query": "COPY auth.saml_providers (id, sso_provider_id, entity_id, metadata_xml, metadata_url, attribute_mapping, created_at, updated_at, name_id_format) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.617569",
          "max_time_ms": "98.653057",
          "total_time_ms": "197.235138",
          "rows": "0",
          "Query": "COPY auth.saml_providers (id, sso_provider_id, entity_id, metadata_xml, metadata_url, attribute_mapping, created_at, updated_at, name_id_format) FROM stdin",
          "Fingerprint": "66acf199"
        },
        {
          "query": "COPY public.audit_logs (id, project_id, action, performed_by, performed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6151865",
          "max_time_ms": "100.978198",
          "total_time_ms": "197.230373",
          "rows": "0",
          "Query": "COPY public.audit_logs (id, project_id, action, performed_by, performed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a3eec967"
        },
        {
          "query": "COPY public.job_titles (id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.60715",
          "max_time_ms": "98.828301",
          "total_time_ms": "197.2143",
          "rows": "0",
          "Query": "COPY public.job_titles (id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0327482d"
        },
        {
          "query": "COPY public.project_inspectors (project_id, profile_id, assigned_by, assigned_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3914115",
          "max_time_ms": "100.102467",
          "total_time_ms": "196.782823",
          "rows": "0",
          "Query": "COPY public.project_inspectors (project_id, profile_id, assigned_by, assigned_at, deleted_at) FROM stdin",
          "Fingerprint": "49a305d5"
        },
        {
          "query": "COPY public.projects (id, organization_id, name, description, status, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.381776",
          "max_time_ms": "98.711193",
          "total_time_ms": "196.763552",
          "rows": "0",
          "Query": "COPY public.projects (id, organization_id, name, description, status, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "87734e8e"
        },
        {
          "query": "COPY public.integration_tokens (id, profile_id, service_name, token, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3527905",
          "max_time_ms": "102.481523",
          "total_time_ms": "196.705581",
          "rows": "0",
          "Query": "COPY public.integration_tokens (id, profile_id, service_name, token, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "abb0fc43"
        },
        {
          "query": "COPY auth.one_time_tokens (id, user_id, token_type, token_hash, relates_to, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3484635",
          "max_time_ms": "98.649517",
          "total_time_ms": "196.696927",
          "rows": "0",
          "Query": "COPY auth.one_time_tokens (id, user_id, token_type, token_hash, relates_to, created_at, updated_at) FROM stdin",
          "Fingerprint": "0a6c105b"
        },
        {
          "query": "COPY public.progress_billings (id, project_id, billing_number, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3037135",
          "max_time_ms": "101.629248",
          "total_time_ms": "196.607427",
          "rows": "0",
          "Query": "COPY public.progress_billings (id, project_id, billing_number, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9f3aca0f"
        },
        {
          "query": "COPY public.task_status_logs (task_id, status, changed_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.2796635",
          "max_time_ms": "98.631252",
          "total_time_ms": "196.559327",
          "rows": "0",
          "Query": "COPY public.task_status_logs (task_id, status, changed_at, deleted_at) FROM stdin",
          "Fingerprint": "9b0f587c"
        },
        {
          "query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "calls": "1",
          "total_time_ms": "420.238451",
          "mean_time_ms": "420.238451",
          "rows": "0",
          "Query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "Fingerprint": "d77f9421"
        },
        {
          "query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "calls": "1",
          "total_time_ms": "405.91149",
          "mean_time_ms": "405.91149",
          "rows": "496",
          "Query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "96cb168f"
        },
        {
          "query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "calls": "1",
          "total_time_ms": "381.49694",
          "mean_time_ms": "381.49694",
          "rows": "112",
          "Query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "Fingerprint": "ad99e1e0"
        },
        {
          "query": "DROP SCHEMA IF EXISTS public CASCADE",
          "calls": "1",
          "total_time_ms": "354.783696",
          "mean_time_ms": "354.783696",
          "rows": "0",
          "Query": "DROP SCHEMA IF EXISTS public CASCADE",
          "Fingerprint": "2124d21d"
        },
        {
          "query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "calls": "1",
          "total_time_ms": "274.966629",
          "mean_time_ms": "274.966629",
          "rows": "387",
          "Query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "Fingerprint": "fa35e7f9"
        },
        {
          "query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "calls": "1",
          "total_time_ms": "269.306295",
          "mean_time_ms": "269.306295",
          "rows": "0",
          "Query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "Fingerprint": "bfd231e0"
        },
        {
          "query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "calls": "1",
          "mean_time_ms": "420.238451",
          "max_time_ms": "420.238451",
          "total_time_ms": "420.238451",
          "rows": "0",
          "Query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "Fingerprint": "d77f9421"
        },
        {
          "query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "calls": "1",
          "mean_time_ms": "405.91149",
          "max_time_ms": "405.91149",
          "total_time_ms": "405.91149",
          "rows": "496",
          "Query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "96cb168f"
        },
        {
          "query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "calls": "1",
          "mean_time_ms": "381.49694",
          "max_time_ms": "381.49694",
          "total_time_ms": "381.49694",
          "rows": "112",
          "Query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "Fingerprint": "ad99e1e0"
        },
        {
          "query": "DROP SCHEMA IF EXISTS public CASCADE",
          "calls": "1",
          "mean_time_ms": "354.783696",
          "max_time_ms": "354.783696",
          "total_time_ms": "354.783696",
          "rows": "0",
          "Query": "DROP SCHEMA IF EXISTS public CASCADE",
          "Fingerprint": "2124d21d"
        },
        {
          "query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "calls": "1",
          "mean_time_ms": "274.966629",
          "max_time_ms": "274.966629",
          "total_time_ms": "274.966629",
          "rows": "387",
          "Query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "Fingerprint": "fa35e7f9"
        },
        {
          "query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "calls": "1",
          "mean_time_ms": "269.306295",
          "max_time_ms": "269.306295",
          "total_time_ms": "269.306295",
          "rows": "0",
          "Query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "Fingerprint": "bfd231e0"
        },
        {
          "query": "-- QUERY 3: RLS policies + table grants + routine grants (single JSON output)\nWITH tbl AS (\n  SELECT\n    c.oid                                 AS table_oid,\n    n.nspname                             AS schema_name,\n    c.relname                             AS table_name,\n    c.relrowsecurity                      AS rls_enabled,\n    c.relforcerowsecurity                 AS rls_forced\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $1\n    AND n.nspname IN ($2, $3)\n),\npol AS (\n  SELECT\n    schemaname,\n    tablename,\n    jsonb_agg(\n      jsonb_build_object(\n        $4, policyname,\n        $5, permissive,\n        $6, roles,\n        $7, cmd,\n        $8, qual,\n        $9, with_check\n      )\n      ORDER BY policyname\n    ) AS policies\n  FROM pg_policies\n  WHERE schemaname IN ($10, $11)\n  GROUP BY schemaname, tablename\n),\ntable_grants AS (\n  SELECT\n    table_schema,\n    table_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $12, grantee,\n        $13, privilege_type,\n        $14, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_table_grants\n  WHERE table_schema IN ($15, $16)\n  GROUP BY table_schema, table_name\n),\nroutine_grants AS (\n  SELECT\n    routine_schema,\n    routine_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $17, grantee,\n        $18, privilege_type,\n        $19, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_routine_grants\n  WHERE routine_schema IN ($20, $21)\n  GROUP BY routine_schema, routine_name\n)\nSELECT jsonb_build_object(\n  $22, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $23, t.schema_name,\n        $24, t.table_name,\n        $25, t.rls_enabled,\n        $26, t.rls_forced,\n        $27, COALESCE(p.policies, $28::jsonb),\n        $29, COALESCE(g.grants, $30::jsonb)\n      )\n      ORDER BY t.schema_name, t.table_name\n    )\n    FROM tbl t\n    LEFT JOIN pol p\n      ON p.schemaname = t.schema_name AND p.tablename = t.table_name\n    LEFT JOIN table_grants g\n      ON g.table_schema = t.schema_name AND g.table_name = t.table_name\n  ),\n  $31, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $32, rg.routine_schema,\n        $33, rg.routine_name,\n        $34, rg.grants\n      )\n      ORDER BY rg.routine_schema, rg.routine_name\n    )\n    FROM routine_grants rg\n  )\n) AS security_dump",
          "calls": "1",
          "mean_time_ms": "197.888901",
          "max_time_ms": "197.888901",
          "total_time_ms": "197.888901",
          "rows": "1",
          "Query": "-- QUERY 3: RLS policies + table grants + routine grants (single JSON output)\nWITH tbl AS (\n  SELECT\n    c.oid                                 AS table_oid,\n    n.nspname                             AS schema_name,\n    c.relname                             AS table_name,\n    c.relrowsecurity                      AS rls_enabled,\n    c.relforcerowsecurity                 AS rls_forced\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $1\n    AND n.nspname IN ($2, $3)\n),\npol AS (\n  SELECT\n    schemaname,\n    tablename,\n    jsonb_agg(\n      jsonb_build_object(\n        $4, policyname,\n        $5, permissive,\n        $6, roles,\n        $7, cmd,\n        $8, qual,\n        $9, with_check\n      )\n      ORDER BY policyname\n    ) AS policies\n  FROM pg_policies\n  WHERE schemaname IN ($10, $11)\n  GROUP BY schemaname, tablename\n),\ntable_grants AS (\n  SELECT\n    table_schema,\n    table_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $12, grantee,\n        $13, privilege_type,\n        $14, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_table_grants\n  WHERE table_schema IN ($15, $16)\n  GROUP BY table_schema, table_name\n),\nroutine_grants AS (\n  SELECT\n    routine_schema,\n    routine_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $17, grantee,\n        $18, privilege_type,\n        $19, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_routine_grants\n  WHERE routine_schema IN ($20, $21)\n  GROUP BY routine_schema, routine_name\n)\nSELECT jsonb_build_object(\n  $22, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $23, t.schema_name,\n        $24, t.table_name,\n        $25, t.rls_enabled,\n        $26, t.rls_forced,\n        $27, COALESCE(p.policies, $28::jsonb),\n        $29, COALESCE(g.grants, $30::jsonb)\n      )\n      ORDER BY t.schema_name, t.table_name\n    )\n    FROM tbl t\n    LEFT JOIN pol p\n      ON p.schemaname = t.schema_name AND p.tablename = t.table_name\n    LEFT JOIN table_grants g\n      ON g.table_schema = t.schema_name AND g.table_name = t.table_name\n  ),\n  $31, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $32, rg.routine_schema,\n        $33, rg.routine_name,\n        $34, rg.grants\n      )\n      ORDER BY rg.routine_schema, rg.routine_name\n    )\n    FROM routine_grants rg\n  )\n) AS security_dump",
          "Fingerprint": "0a80504f"
        },
        {
          "query": "-- Org Dashboard foundations (service areas, member rates, project invites)\n\n-- [REF: org_dashboard_foundations START]\n\nCREATE TABLE IF NOT EXISTS public.organization_service_areas (\n    id uuid DEFAULT gen_random_uuid() NOT NULL,\n    organization_id uuid NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,\n    service_area_text text NOT NULL,\n    created_at timestamp with time zone DEFAULT now() NOT NULL,\n    updated_at timestamp with time zone DEFAULT now() NOT NULL,\n    CONSTRAINT organization_service_areas_pkey PRIMARY KEY (id)\n)",
          "calls": "1",
          "mean_time_ms": "189.125765",
          "max_time_ms": "189.125765",
          "total_time_ms": "189.125765",
          "rows": "0",
          "Query": "-- Org Dashboard foundations (service areas, member rates, project invites)\n\n-- [REF: org_dashboard_foundations START]\n\nCREATE TABLE IF NOT EXISTS public.organization_service_areas (\n    id uuid DEFAULT gen_random_uuid() NOT NULL,\n    organization_id uuid NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,\n    service_area_text text NOT NULL,\n    created_at timestamp with time zone DEFAULT now() NOT NULL,\n    updated_at timestamp with time zone DEFAULT now() NOT NULL,\n    CONSTRAINT organization_service_areas_pkey PRIMARY KEY (id)\n)",
          "Fingerprint": "08d5b208"
        },
        {
          "query": "with jwt as (\n  select\n    set_config($1, $2, $3) as a,\n    set_config($4, $5, $6) as b,\n    set_config(\n      $7,\n      format($8, $9),\n      $10\n    ) as c\n),\ncheck_auth as (\n  select auth.uid() as uid\n  from jwt\n),\np as (\n  select public.rpc_org_dashboard_payload(\n    $11::uuid,\n    $12,\n    $13\n  ) as payload\n  from check_auth\n)\nselect\n  (select uid from check_auth) as uid,\n  (select payload from p) as payload",
          "calls": "1",
          "mean_time_ms": "139.849526",
          "max_time_ms": "139.849526",
          "total_time_ms": "139.849526",
          "rows": "1",
          "Query": "with jwt as (\n  select\n    set_config($1, $2, $3) as a,\n    set_config($4, $5, $6) as b,\n    set_config(\n      $7,\n      format($8, $9),\n      $10\n    ) as c\n),\ncheck_auth as (\n  select auth.uid() as uid\n  from jwt\n),\np as (\n  select public.rpc_org_dashboard_payload(\n    $11::uuid,\n    $12,\n    $13\n  ) as payload\n  from check_auth\n)\nselect\n  (select uid from check_auth) as uid,\n  (select payload from p) as payload",
          "Fingerprint": "c71951cc"
        },
        {
          "query": "-- Safe org-scoped profile list for UI pickers\n\nCREATE OR REPLACE FUNCTION public.get_my_org_profiles_minimal()\nRETURNS TABLE (\n  id uuid,\n  email text,\n  full_name text,\n  avatar_url text\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  v_user_id uuid;\n  v_org_id uuid;\nBEGIN\n  v_user_id := auth.uid();\n  IF v_user_id IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  SELECT organization_id\n    INTO v_org_id\n  FROM public.profiles\n  WHERE id = v_user_id;\n\n  IF v_org_id IS NULL THEN\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  SELECT p.id, p.email, p.full_name, p.avatar_url\n  FROM public.profiles p\n  WHERE p.organization_id = v_org_id;\nEND;\n$$",
          "calls": "1",
          "mean_time_ms": "135.089398",
          "max_time_ms": "135.089398",
          "total_time_ms": "135.089398",
          "rows": "0",
          "Query": "-- Safe org-scoped profile list for UI pickers\n\nCREATE OR REPLACE FUNCTION public.get_my_org_profiles_minimal()\nRETURNS TABLE (\n  id uuid,\n  email text,\n  full_name text,\n  avatar_url text\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  v_user_id uuid;\n  v_org_id uuid;\nBEGIN\n  v_user_id := auth.uid();\n  IF v_user_id IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  SELECT organization_id\n    INTO v_org_id\n  FROM public.profiles\n  WHERE id = v_user_id;\n\n  IF v_org_id IS NULL THEN\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  SELECT p.id, p.email, p.full_name, p.avatar_url\n  FROM public.profiles p\n  WHERE p.organization_id = v_org_id;\nEND;\n$$",
          "Fingerprint": "9ba4385f"
        },
        {
          "query": "-- Public-safe RPCs for onboarding job titles\n\ncreate or replace function public.get_job_titles_public()\nreturns setof public.job_titles\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\nbegin\n  return query\n  select *\n  from public.job_titles\n  where deleted_at is null\n  order by name asc;\nend;\n$$",
          "calls": "1",
          "mean_time_ms": "117.711826",
          "max_time_ms": "117.711826",
          "total_time_ms": "117.711826",
          "rows": "0",
          "Query": "-- Public-safe RPCs for onboarding job titles\n\ncreate or replace function public.get_job_titles_public()\nreturns setof public.job_titles\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\nbegin\n  return query\n  select *\n  from public.job_titles\n  where deleted_at is null\n  order by name asc;\nend;\n$$",
          "Fingerprint": "08882903"
        },
        {
          "query": "-- =======================\n-- START PATCH: filter_projects hotfix\n-- =======================\n\nCREATE OR REPLACE FUNCTION public.filter_projects(\n  _filters jsonb DEFAULT '{}'::jsonb,\n  _select_cols text[] DEFAULT NULL::text[],\n  _order_by text DEFAULT 'id'::text,\n  _direction text DEFAULT 'asc'::text,\n  _limit integer DEFAULT NULL::integer,\n  _offset integer DEFAULT NULL::integer\n) RETURNS SETOF public.projects\nLANGUAGE plpgsql STABLE\nSET search_path TO 'public', 'pg_temp'\nAS $$\nDECLARE\n  _project_id      uuid;\n  _organization_id uuid;\n  _where           text := 'deleted_at IS NULL';\n  kv               record;\n  sqltxt           text;\n  dir              text := lower(coalesce(_direction, 'asc'));\n  v_text           text;\nBEGIN\n  -- Normalize filters to an object\n  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN\n    _filters := '{}'::jsonb;\n  END IF;\n\n  -- Safe casts (avoid \"\" -> uuid crash)\n  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;\n  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;\n\n  -- Access check (RLS still applies)\n  PERFORM check_access('select', 'projects', _project_id, _organization_id);\n\n  -- Build WHERE from filters (ignore special keys)\n  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP\n    IF kv.key NOT IN ('project_id', 'organization_id') THEN\n\n      -- JSON null\n      IF kv.value = 'null'::jsonb THEN\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' IS NULL';\n\n      ELSIF jsonb_typeof(kv.value) = 'object' THEN\n        IF (kv.value ? '$gte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' >= '  || quote_literal(kv.value->>'$gte');\n        END IF;\n\n        IF (kv.value ? '$lte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' <= '  || quote_literal(kv.value->>'$lte');\n        END IF;\n\n        IF (kv.value ? '$ilike') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' ILIKE ' || quote_literal(kv.value->>'$ilike');\n        END IF;\n\n        IF (kv.value ? '$in') THEN\n          -- col::text = ANY(text[])\n          _where := _where\n            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('\n            || 'ARRAY(SELECT jsonb_array_elements_text('\n            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';\n        END IF;\n\n      ELSE\n        -- Primitive value: use #>> '{}' to avoid JSON quoting issues\n        v_text := kv.value #>> '{}';\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' = '   || quote_literal(v_text);\n      END IF;\n    END IF;\n  END LOOP;\n\n  -- Validate order_by\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name   = 'projects'\n      AND column_name  = _order_by\n  ) THEN\n    RAISE EXCEPTION 'unknown order_by column'\n      USING DETAIL = jsonb_build_object('column', _order_by);\n  END IF;\n\n  -- Clamp direction\n  IF dir NOT IN ('asc', 'desc') THEN\n    dir := 'asc';\n  END IF;\n\n  -- Always return full row to match RETURNS SETOF public.projects\n  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where\n         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;\n\n  IF _limit IS NOT NULL THEN\n    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);\n  END IF;\n\n  IF _offset IS NOT NULL THEN\n    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);\n  END IF;\n\n  RETURN QUERY EXECUTE sqltxt;\nEND;\n$$",
          "calls": "1",
          "mean_time_ms": "115.277807",
          "max_time_ms": "115.277807",
          "total_time_ms": "115.277807",
          "rows": "0",
          "Query": "-- =======================\n-- START PATCH: filter_projects hotfix\n-- =======================\n\nCREATE OR REPLACE FUNCTION public.filter_projects(\n  _filters jsonb DEFAULT '{}'::jsonb,\n  _select_cols text[] DEFAULT NULL::text[],\n  _order_by text DEFAULT 'id'::text,\n  _direction text DEFAULT 'asc'::text,\n  _limit integer DEFAULT NULL::integer,\n  _offset integer DEFAULT NULL::integer\n) RETURNS SETOF public.projects\nLANGUAGE plpgsql STABLE\nSET search_path TO 'public', 'pg_temp'\nAS $$\nDECLARE\n  _project_id      uuid;\n  _organization_id uuid;\n  _where           text := 'deleted_at IS NULL';\n  kv               record;\n  sqltxt           text;\n  dir              text := lower(coalesce(_direction, 'asc'));\n  v_text           text;\nBEGIN\n  -- Normalize filters to an object\n  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN\n    _filters := '{}'::jsonb;\n  END IF;\n\n  -- Safe casts (avoid \"\" -> uuid crash)\n  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;\n  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;\n\n  -- Access check (RLS still applies)\n  PERFORM check_access('select', 'projects', _project_id, _organization_id);\n\n  -- Build WHERE from filters (ignore special keys)\n  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP\n    IF kv.key NOT IN ('project_id', 'organization_id') THEN\n\n      -- JSON null\n      IF kv.value = 'null'::jsonb THEN\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' IS NULL';\n\n      ELSIF jsonb_typeof(kv.value) = 'object' THEN\n        IF (kv.value ? '$gte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' >= '  || quote_literal(kv.value->>'$gte');\n        END IF;\n\n        IF (kv.value ? '$lte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' <= '  || quote_literal(kv.value->>'$lte');\n        END IF;\n\n        IF (kv.value ? '$ilike') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' ILIKE ' || quote_literal(kv.value->>'$ilike');\n        END IF;\n\n        IF (kv.value ? '$in') THEN\n          -- col::text = ANY(text[])\n          _where := _where\n            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('\n            || 'ARRAY(SELECT jsonb_array_elements_text('\n            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';\n        END IF;\n\n      ELSE\n        -- Primitive value: use #>> '{}' to avoid JSON quoting issues\n        v_text := kv.value #>> '{}';\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' = '   || quote_literal(v_text);\n      END IF;\n    END IF;\n  END LOOP;\n\n  -- Validate order_by\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name   = 'projects'\n      AND column_name  = _order_by\n  ) THEN\n    RAISE EXCEPTION 'unknown order_by column'\n      USING DETAIL = jsonb_build_object('column', _order_by);\n  END IF;\n\n  -- Clamp direction\n  IF dir NOT IN ('asc', 'desc') THEN\n    dir := 'asc';\n  END IF;\n\n  -- Always return full row to match RETURNS SETOF public.projects\n  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where\n         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;\n\n  IF _limit IS NOT NULL THEN\n    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);\n  END IF;\n\n  IF _offset IS NOT NULL THEN\n    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);\n  END IF;\n\n  RETURN QUERY EXECUTE sqltxt;\nEND;\n$$",
          "Fingerprint": "b4425b85"
        },
        {
          "query": "COPY auth.audit_log_entries (instance_id, id, payload, created_at, ip_address) FROM stdin",
          "calls": "1",
          "mean_time_ms": "111.033599",
          "max_time_ms": "111.033599",
          "total_time_ms": "111.033599",
          "rows": "34",
          "Query": "COPY auth.audit_log_entries (instance_id, id, payload, created_at, ip_address) FROM stdin",
          "Fingerprint": "f285a55e"
        },
        {
          "query": "COPY storage.buckets (id, name, owner, created_at, updated_at, public, avif_autodetection, file_size_limit, allowed_mime_types, owner_id) FROM stdin",
          "calls": "1",
          "mean_time_ms": "106.702244",
          "max_time_ms": "106.702244",
          "total_time_ms": "106.702244",
          "rows": "2",
          "Query": "COPY storage.buckets (id, name, owner, created_at, updated_at, public, avif_autodetection, file_size_limit, allowed_mime_types, owner_id) FROM stdin",
          "Fingerprint": "af783faf"
        }
      ],
      "timeConsuming": [
        {
          "query": "SELECT name FROM pg_timezone_names",
          "calls": "1396",
          "total_time_ms": "103693.647862",
          "rows": "1666824",
          "Query": "SELECT name FROM pg_timezone_names",
          "Fingerprint": "f174234e"
        },
        {
          "query": "SELECT name FROM pg_timezone_names",
          "calls": "1396",
          "total_time_ms": "103693.647862",
          "mean_time_ms": "74.2791173796561",
          "rows": "1666824",
          "Query": "SELECT name FROM pg_timezone_names",
          "Fingerprint": "f174234e"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "total_time_ms": "40384.84643",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "total_time_ms": "40384.84643",
          "mean_time_ms": "734.269935090909",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "calls": "55",
          "mean_time_ms": "734.269935090909",
          "max_time_ms": "1384.405776",
          "total_time_ms": "40384.84643",
          "rows": "3969",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
          "Fingerprint": "1560ef1e"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "calls": "1397",
          "total_time_ms": "34323.32903",
          "rows": "311820",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "Fingerprint": "5eac5f98"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "calls": "1397",
          "total_time_ms": "34323.32903",
          "mean_time_ms": "24.5693121188261",
          "rows": "311820",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
          "Fingerprint": "5eac5f98"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "calls": "1397",
          "total_time_ms": "33851.555228",
          "rows": "167758",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "Fingerprint": "2eb78329"
        },
        {
          "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "calls": "1397",
          "total_time_ms": "33851.555228",
          "mean_time_ms": "24.2316071782391",
          "rows": "167758",
          "Query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
          "Fingerprint": "2eb78329"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "total_time_ms": "32448.44921",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "total_time_ms": "32448.44921",
          "mean_time_ms": "648.9689842",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "calls": "50",
          "mean_time_ms": "648.9689842",
          "max_time_ms": "1199.324807",
          "total_time_ms": "32448.44921",
          "rows": "3347",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4) AND\n  \n  \n  c.relkind = $5\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $6 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $7\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $8 THEN CASE\n      WHEN bt.typelem <> $9 :: oid\n      AND bt.typlen = $10 THEN $11\n      WHEN nbt.nspname = $12 THEN format_type(t.typbasetype, $13)\n      ELSE $14\n    END\n    ELSE CASE\n      WHEN t.typelem <> $15 :: oid\n      AND t.typlen = $16 THEN $17\n      WHEN nt.nspname = $18 THEN format_type(a.atttypid, $19)\n      ELSE $20\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($21, $22) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $23 THEN $24\n    WHEN $25 THEN $26\n    ELSE $27\n  END AS identity_generation,\n  a.attgenerated IN ($28) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $29 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($30, $31)\n    OR c.relkind IN ($32, $33) AND pg_column_is_updatable(c.oid, a.attnum, $34)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $35\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $37 AND cardinality(conkey) = $38\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$39] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $40),\n        $41,\n        length(pg_get_constraintdef(pg_constraint.oid, $42)) - $43\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $44 AND cardinality(conkey) = $45\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($46) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $47\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($48, $49, $50, $51, $52))\n  AND (\n    pg_has_role(c.relowner, $53)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $54\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = views.id)\n    FROM\n      columns\n  ),\n  $55\n) AS columns\nfrom views",
          "Fingerprint": "6c807ceb"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "total_time_ms": "29046.709733",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "total_time_ms": "29046.709733",
          "mean_time_ms": "518.691245232143",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "calls": "56",
          "mean_time_ms": "518.691245232143",
          "max_time_ms": "1137.156924",
          "total_time_ms": "29046.709733",
          "rows": "27529",
          "Query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:23:07.129Z",
          "Fingerprint": "ea30b511"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "total_time_ms": "14684.666536",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "total_time_ms": "14684.666536",
          "mean_time_ms": "183.5583317",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "80",
          "mean_time_ms": "183.5583317",
          "max_time_ms": "562.106136",
          "total_time_ms": "14684.666536",
          "rows": "7692",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16,$17) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($18,$19) OR nta.nspname IN ($20,$21) AND\n      \n      c.contype = $22\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($23,$24) AND\n  \n  \n  c.relkind IN ($25, $26)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $27)\n    OR has_table_privilege(\n      c.oid,\n      $28\n    )\n    OR has_any_column_privilege(c.oid, $29)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "a0a04cc6"
        },
        {
          "query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "calls": "1397",
          "total_time_ms": "13353.197756",
          "rows": "64172",
          "Query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "Fingerprint": "d0298bd6"
        },
        {
          "query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "calls": "1397",
          "total_time_ms": "13353.197756",
          "mean_time_ms": "9.55848085612025",
          "rows": "64172",
          "Query": "with recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $3) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $4\n  where contype IN ($5, $6)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $7) as contype,\n    conname,\n    array_length(confkey, $8) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $9\n  where contype=$10\n),\nviews as (\n  select\n    c.oid          as view_id,\n    c.relnamespace as view_schema_id,\n    n.nspname      as view_schema,\n    c.relname      as view_name,\n    r.ev_action    as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) and c.relnamespace = ANY($1::regnamespace[] || $2::regnamespace[])\n),\ntransform_json as (\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- `<>` in pg_node_tree is the same as `null` in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: `(<> ...`, too. This is the case for coldefexprs, when the first column does not have a default value.\n         $13              , $14\n      -- `,` is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all `,` that might be part of column names.\n      ), $15               , $16\n      -- The same applies for `{` and `}`, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $17            , $18\n      ), $19            , $20\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $21   , $22\n      ), $23        , $24\n      ), $25   , $26\n      ), $27   , $28\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $29               , $30\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $31              , $32\n      ), $33              , $34\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $35       , $36              , $37\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $38           , $39\n      ), $40           , $41\n      -- This reverses the \"node list protection\" from above.\n      ), $42              , $43\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $44              , $45\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $46               , $47\n      ), $48               , $49\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $50             , $51\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    json_array_elements(view_definition->$52->$53) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema_id, view_schema, view_name,\n    (entry->>$54)::int as view_column,\n    (entry->>$55)::oid as resorigtbl,\n    (entry->>$56)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $57,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema_id = ANY ($1::regnamespace[])\n  union all\n  select\n    view.view_id,\n    view.view_schema_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  array_agg(row(col.attname, view_columns) order by pks_fks.ord) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname, rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $58)",
          "Fingerprint": "d0298bd6"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "total_time_ms": "9967.864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "total_time_ms": "9967.864957",
          "mean_time_ms": "99.67864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "calls": "100",
          "mean_time_ms": "99.67864957",
          "max_time_ms": "316.835546",
          "total_time_ms": "9967.864957",
          "rows": "7800",
          "Query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
          "Fingerprint": "9a8bab38"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "total_time_ms": "9479.365463",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "total_time_ms": "9479.365463",
          "mean_time_ms": "175.54380487037",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "calls": "54",
          "mean_time_ms": "175.54380487037",
          "max_time_ms": "292.478765",
          "total_time_ms": "9479.365463",
          "rows": "11508",
          "Query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
          "Fingerprint": "5641247e"
        },
        {
          "query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "calls": "80",
          "total_time_ms": "6978.442858",
          "rows": "26106",
          "Query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "Fingerprint": "62d7ef17"
        },
        {
          "query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "calls": "80",
          "total_time_ms": "6978.442858",
          "mean_time_ms": "87.230535725",
          "rows": "26106",
          "Query": "-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    p.*,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n    join pg_namespace n on p.pronamespace = n.oid\n  where\n    n.nspname IN ($5,$6) AND\n    \n    \n    \n    p.prokind = $7\n)\nselect\n  f.oid::int8 as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $8 then $9\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $10 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $11) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype::int8 as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid::int8, $12) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.proretset then nullif(f.prorows, $13)\n    else $14\n  end as prorows,\n  case\n    when f.provolatile = $15 then $16\n    when f.provolatile = $17 then $18\n    when f.provolatile = $19 then $20\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $21))[$22] as param,\n          (string_to_array(unnest(proconfig), $23))[$24] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $25, t2.mode,\n        $26, name,\n        $27, type_id,\n        $28, has_default\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $29 then $30\n            when t1.mode = $31 then $32\n            when t1.mode = $33 then $34\n            when t1.mode = $35 then $36\n            else $37\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid",
          "Fingerprint": "62d7ef17"
        },
        {
          "query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "calls": "80",
          "total_time_ms": "6176.415442",
          "rows": "114718",
          "Query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "Fingerprint": "5b79696f"
        },
        {
          "query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "calls": "80",
          "total_time_ms": "6176.415442",
          "mean_time_ms": "77.205193025",
          "rows": "114718",
          "Query": "-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $1 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $2\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $3 THEN CASE\n      WHEN bt.typelem <> $4 :: oid\n      AND bt.typlen = $5 THEN $6\n      WHEN nbt.nspname = $7 THEN format_type(t.typbasetype, $8)\n      ELSE $9\n    END\n    ELSE CASE\n      WHEN t.typelem <> $10 :: oid\n      AND t.typlen = $11 THEN $12\n      WHEN nt.nspname = $13 THEN format_type(a.atttypid, $14)\n      ELSE $15\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($16, $17) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $18 THEN $19\n    WHEN $20 THEN $21\n    ELSE $22\n  END AS identity_generation,\n  a.attgenerated IN ($23) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $24 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($25, $26)\n    OR c.relkind IN ($27, $28) AND pg_column_is_updatable(c.oid, a.attnum, $29)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $30\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$31] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $32 AND cardinality(conkey) = $33\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$34] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $35),\n        $36,\n        length(pg_get_constraintdef(pg_constraint.oid, $37)) - $38\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $39 AND cardinality(conkey) = $40\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($41,$42) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $43\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($44, $45, $46, $47, $48))\n  AND (\n    pg_has_role(c.relowner, $49)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $50\n    )\n  )",
          "Fingerprint": "5b79696f"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "113",
          "total_time_ms": "5259.748893",
          "rows": "113",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "5a244b78"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "113",
          "total_time_ms": "5259.748893",
          "mean_time_ms": "46.546450380531",
          "rows": "113",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"fn_list_tables_and_columns\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "5a244b78"
        },
        {
          "query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "calls": "22",
          "total_time_ms": "4059.943647",
          "mean_time_ms": "184.542893045455",
          "rows": "4573",
          "Query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "Fingerprint": "ac49b202"
        },
        {
          "query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "calls": "22",
          "mean_time_ms": "184.542893045455",
          "max_time_ms": "547.889806",
          "total_time_ms": "4059.943647",
          "rows": "4573",
          "Query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:16:21.723Z",
          "Fingerprint": "ac49b202"
        },
        {
          "query": "SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = $1 THEN $2::\"char\" ELSE $3::\"char\" END, c.relowner) AS acldefault, CASE WHEN c.relkind = $4 THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE $5 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, $6 AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,$7),$8) AS reloptions, CASE WHEN $9 = ANY (c.reloptions) THEN $10::text WHEN $11 = ANY (c.reloptions) THEN $12::text ELSE $13 END AS checkoption, am.amname, (d.deptype = $14) IS TRUE AS is_identity_sequence, c.relispartition AS ispartition \nFROM pg_class c\nLEFT JOIN pg_depend d ON (c.relkind = $15 AND d.classid = $16::regclass AND d.objid = c.oid AND d.objsubid = $17 AND d.refclassid = $18::regclass AND d.deptype IN ($19, $20))\nLEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)\nLEFT JOIN pg_am am ON (c.relam = am.oid)\nLEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = $21 AND c.relkind <> $22)\nWHERE c.relkind IN ($23, $24, $25, $26, $27, $28, $29)\nORDER BY c.oid",
          "calls": "36",
          "total_time_ms": "3448.801096",
          "mean_time_ms": "95.8000304444444",
          "rows": "14824",
          "Query": "SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = $1 THEN $2::\"char\" ELSE $3::\"char\" END, c.relowner) AS acldefault, CASE WHEN c.relkind = $4 THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE $5 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, $6 AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,$7),$8) AS reloptions, CASE WHEN $9 = ANY (c.reloptions) THEN $10::text WHEN $11 = ANY (c.reloptions) THEN $12::text ELSE $13 END AS checkoption, am.amname, (d.deptype = $14) IS TRUE AS is_identity_sequence, c.relispartition AS ispartition \nFROM pg_class c\nLEFT JOIN pg_depend d ON (c.relkind = $15 AND d.classid = $16::regclass AND d.objid = c.oid AND d.objsubid = $17 AND d.refclassid = $18::regclass AND d.deptype IN ($19, $20))\nLEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)\nLEFT JOIN pg_am am ON (c.relam = am.oid)\nLEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = $21 AND c.relkind <> $22)\nWHERE c.relkind IN ($23, $24, $25, $26, $27, $28, $29)\nORDER BY c.oid",
          "Fingerprint": "43860e47"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "calls": "30",
          "total_time_ms": "3255.608133",
          "mean_time_ms": "108.5202711",
          "rows": "30",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "Fingerprint": "393cf5c5"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "calls": "30",
          "mean_time_ms": "108.5202711",
          "max_time_ms": "205.438253",
          "total_time_ms": "3255.608133",
          "rows": "30",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
          "Fingerprint": "393cf5c5"
        },
        {
          "query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "calls": "1397",
          "total_time_ms": "2836.51774799999",
          "rows": "2794",
          "Query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "Fingerprint": "06396590"
        },
        {
          "query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "calls": "1397",
          "total_time_ms": "2836.51774799999",
          "mean_time_ms": "2.03043503793844",
          "rows": "2794",
          "Query": "with\nrole_setting as (\n  select r.rolname, unnest(r.rolconfig) as setting\n  from pg_auth_members m\n  join pg_roles r on r.oid = m.roleid\n  where member = current_user::regrole::oid\n),\nkv_settings AS (\n  SELECT\n    rolname,\n    substr(setting, $1, strpos(setting, $2) - $3) as key,\n    lower(substr(setting, strpos(setting, $4) + $5)) as value\n  FROM role_setting\n),\niso_setting AS (\n  SELECT rolname, value\n  FROM kv_settings\n  WHERE key = $6\n)\nselect\n  kv.rolname,\n  i.value as iso_lvl,\n  coalesce(array_agg(row(kv.key, kv.value)) filter (where key <> $7), $8) as role_settings\nfrom kv_settings kv\njoin pg_settings ps on ps.name = kv.key and (ps.context = $9 or has_parameter_privilege(current_user::regrole::oid, ps.name, $10))\nleft join iso_setting i on i.rolname = kv.rolname\ngroup by kv.rolname, i.value",
          "Fingerprint": "06396590"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "calls": "1397",
          "total_time_ms": "2365.774295",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "Fingerprint": "b9ce39db"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "calls": "1397",
          "total_time_ms": "2365.774295",
          "mean_time_ms": "1.69346764137437",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($1,$2,$3,$4,$5)\n),\ncomputed_rels as (\n  select\n    (parse_ident(p.pronamespace::regnamespace::text))[$6] as schema,\n    p.proname::text                  as name,\n    arg_schema.nspname::text         as rel_table_schema,\n    arg_name.typname::text           as rel_table_name,\n    ret_schema.nspname::text         as rel_ftable_schema,\n    ret_name.typname::text           as rel_ftable_name,\n    not p.proretset or p.prorows = $7 as single_row\n  from pg_proc p\n    join pg_type      arg_name   on arg_name.oid = p.proargtypes[$8]\n    join pg_namespace arg_schema on arg_schema.oid = arg_name.typnamespace\n    join pg_type      ret_name   on ret_name.oid = p.prorettype\n    join pg_namespace ret_schema on ret_schema.oid = ret_name.typnamespace\n  where\n    p.pronargs = $9\n    and p.proargtypes[$10] in (select reltype from all_relations)\n    and p.prorettype in (select reltype from all_relations)\n)\nselect\n  *,\n  row(rel_table_schema, rel_table_name) = row(rel_ftable_schema, rel_ftable_name) as is_self\nfrom computed_rels",
          "Fingerprint": "b9ce39db"
        },
        {
          "query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "calls": "104",
          "total_time_ms": "2117.180412",
          "rows": "103",
          "Query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "Fingerprint": "de72792d"
        },
        {
          "query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "calls": "104",
          "total_time_ms": "2117.180412",
          "mean_time_ms": "20.3575039615385",
          "rows": "103",
          "Query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
          "Fingerprint": "de72792d"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "calls": "80",
          "total_time_ms": "2106.986161",
          "rows": "26088",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "Fingerprint": "dbb85dbe"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "calls": "80",
          "total_time_ms": "2106.986161",
          "mean_time_ms": "26.3373270125",
          "rows": "26088",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L820\nwith recursive\npks_fks as (\n  -- pk + fk referencing col\n  select\n    contype::text as contype,\n    conname,\n    array_length(conkey, $1) as ncol,\n    conrelid as resorigtbl,\n    col as resorigcol,\n    ord\n  from pg_constraint\n  left join lateral unnest(conkey) with ordinality as _(col, ord) on $2\n  where contype IN ($3, $4)\n  union\n  -- fk referenced col\n  select\n    concat(contype, $5) as contype,\n    conname,\n    array_length(confkey, $6) as ncol,\n    confrelid,\n    col,\n    ord\n  from pg_constraint\n  left join lateral unnest(confkey) with ordinality as _(col, ord) on $7\n  where contype=$8\n  and connamespace::regnamespace::text IN ($9,$10)\n),\nviews as (\n  select\n    c.oid       as view_id,\n    n.nspname   as view_schema,\n    c.relname   as view_name,\n    r.ev_action as view_definition\n  from pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  join pg_rewrite r on r.ev_class = c.oid\n  where c.relkind in ($11, $12) \n    and n.nspname IN ($13,$14)\n),\ntransform_json as (\n  select\n    view_id, view_schema, view_name,\n    -- the following formatting is without indentation on purpose\n    -- to allow simple diffs, with less whitespace noise\n    replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      regexp_replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n      replace(\n        view_definition::text,\n      -- This conversion to json is heavily optimized for performance.\n      -- The general idea is to use as few regexp_replace() calls as possible.\n      -- Simple replace() is a lot faster, so we jump through some hoops\n      -- to be able to use regexp_replace() only once.\n      -- This has been tested against a huge schema with 250+ different views.\n      -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n      -- -----------------------------------------------\n      -- pattern           | replacement         | flags\n      -- -----------------------------------------------\n      -- <> in pg_node_tree is the same as null in JSON, but due to very poor performance of json_typeof\n      -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n      -- when the targetList is null.\n      -- We'll need to put it first, to make the node protection below work for node lists that start with\n      -- null: (<> ..., too. This is the case for coldefexprs, when the first column does not have a default value.\n         $15              , $16\n      -- , is not part of the pg_node_tree format, but used in the regex.\n      -- This removes all , that might be part of column names.\n      ), $17               , $18\n      -- The same applies for { and }, although those are used a lot in pg_node_tree.\n      -- We remove the escaped ones, which might be part of column names again.\n      ), $19            , $20\n      ), $21            , $22\n      -- The fields we need are formatted as json manually to protect them from the regex.\n      ), $23   , $24\n      ), $25        , $26\n      ), $27   , $28\n      ), $29   , $30\n      -- Make the regex also match the node type, e.g. `{QUERY ...`, to remove it in one pass.\n      ), $31               , $32\n      -- Protect node lists, which start with `({` or `((` from the greedy regex.\n      -- The extra `{` is removed again later.\n      ), $33              , $34\n      ), $35              , $36\n      -- This regex removes all unused fields to avoid the need to format all of them correctly.\n      -- This leads to a smaller json result as well.\n      -- Removal stops at `,` for used fields (see above) and `}` for the end of the current node.\n      -- Nesting can't be parsed correctly with a regex, so we stop at `{` as well and\n      -- add an empty key for the followig node.\n      ), $37       , $38              , $39\n      -- For performance, the regex also added those empty keys when hitting a `,` or `}`.\n      -- Those are removed next.\n      ), $40           , $41\n      ), $42           , $43\n      -- This reverses the \"node list protection\" from above.\n      ), $44              , $45\n      -- Every key above has been added with a `,` so far. The first key in an object doesn't need it.\n      ), $46              , $47\n      -- pg_node_tree has `()` around lists, but JSON uses `[]`\n      ), $48               , $49\n      ), $50               , $51\n      -- pg_node_tree has ` ` between list items, but JSON uses `,`\n      ), $52             , $53\n    )::json as view_definition\n  from views\n),\ntarget_entries as(\n  select\n    view_id, view_schema, view_name,\n    json_array_elements(view_definition->$54->$55) as entry\n  from transform_json\n),\nresults as(\n  select\n    view_id, view_schema, view_name,\n    (entry->>$56)::int as view_column,\n    (entry->>$57)::oid as resorigtbl,\n    (entry->>$58)::int as resorigcol\n  from target_entries\n),\n-- CYCLE detection according to PG docs: https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CYCLE\n-- Can be replaced with CYCLE clause once PG v13 is EOL.\nrecursion(view_id, view_schema, view_name, view_column, resorigtbl, resorigcol, is_cycle, path) as(\n  select\n    r.*,\n    $59,\n    ARRAY[resorigtbl]\n  from results r\n  where view_schema IN ($60,$61)\n  union all\n  select\n    view.view_id,\n    view.view_schema,\n    view.view_name,\n    view.view_column,\n    tab.resorigtbl,\n    tab.resorigcol,\n    tab.resorigtbl = ANY(path),\n    path || tab.resorigtbl\n  from recursion view\n  join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n  where not is_cycle\n),\nrepeated_references as(\n  select\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol,\n    array_agg(attname) as view_columns\n  from recursion\n  join pg_attribute vcol on vcol.attrelid = view_id and vcol.attnum = view_column\n  group by\n    view_id,\n    view_schema,\n    view_name,\n    resorigtbl,\n    resorigcol\n)\nselect\n  sch.nspname as table_schema,\n  tbl.relname as table_name,\n  rep.view_schema,\n  rep.view_name,\n  pks_fks.conname as constraint_name,\n  pks_fks.contype as constraint_type,\n  jsonb_agg(\n    jsonb_build_object($62, col.attname, $63, view_columns) order by pks_fks.ord\n  ) as column_dependencies\nfrom repeated_references rep\njoin pks_fks using (resorigtbl, resorigcol)\njoin pg_class tbl on tbl.oid = rep.resorigtbl\njoin pg_attribute col on col.attrelid = tbl.oid and col.attnum = rep.resorigcol\njoin pg_namespace sch on sch.oid = tbl.relnamespace\ngroup by sch.nspname, tbl.relname,  rep.view_schema, rep.view_name, pks_fks.conname, pks_fks.contype, pks_fks.ncol\n-- make sure we only return key for which all columns are referenced in the view - no partial PKs or FKs\nhaving ncol = array_length(array_agg(row(col.attname, view_columns) order by pks_fks.ord), $64)",
          "Fingerprint": "dbb85dbe"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "calls": "80",
          "total_time_ms": "1873.557554",
          "rows": "83576",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "Fingerprint": "b7f8e58a"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "calls": "80",
          "total_time_ms": "1873.557554",
          "mean_time_ms": "23.419469425",
          "rows": "83576",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind in ($10, $11, $12, $13, $14)\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )",
          "Fingerprint": "b7f8e58a"
        },
        {
          "query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "calls": "1397",
          "total_time_ms": "1715.286118",
          "rows": "46811",
          "Query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "Fingerprint": "ee3d52f8"
        },
        {
          "query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "calls": "1397",
          "total_time_ms": "1715.286118",
          "mean_time_ms": "1.22783544595562",
          "rows": "46811",
          "Query": "WITH\npks_uniques_cols AS (\n  SELECT\n    conrelid,\n    array_agg(key order by key) as cols\n  FROM pg_constraint,\n  LATERAL unnest(conkey) AS _(key)\n  WHERE\n    contype IN ($1, $2)\n    AND connamespace <> $3::regnamespace\n  GROUP BY oid, conrelid\n)\nSELECT\n  ns1.nspname AS table_schema,\n  tab.relname AS table_name,\n  ns2.nspname AS foreign_table_schema,\n  other.relname AS foreign_table_name,\n  traint.conrelid = traint.confrelid AS is_self,\n  traint.conname  AS constraint_name,\n  column_info.cols_and_fcols,\n  (column_info.cols IN (SELECT cols FROM pks_uniques_cols WHERE conrelid = traint.conrelid)) AS one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    array_agg(row(cols.attname, refs.attname) order by ord) AS cols_and_fcols,\n    array_agg(cols.attnum order by cols.attnum) AS cols\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n) AS column_info ON $4\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nWHERE traint.contype = $5\nAND traint.conparentid = $6\nORDER BY traint.conrelid, traint.conname",
          "Fingerprint": "ee3d52f8"
        },
        {
          "query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "88",
          "total_time_ms": "1485.024353",
          "rows": "88",
          "Query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "6eaa5bc4"
        },
        {
          "query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "88",
          "total_time_ms": "1485.024353",
          "mean_time_ms": "16.8752767386364",
          "rows": "88",
          "Query": "WITH pgrst_source AS (SELECT pgrst_call.pgrst_scalar FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_organization_id\", \"p_members_page\", \"p_page_size\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_organization_id\" uuid, \"p_members_page\" integer, \"p_page_size\" integer) LIMIT $4) pgrst_body , LATERAL (SELECT \"public\".\"rpc_org_dashboard_payload\"(\"p_organization_id\" := pgrst_body.\"p_organization_id\", \"p_members_page\" := pgrst_body.\"p_members_page\", \"p_page_size\" := pgrst_body.\"p_page_size\") pgrst_scalar) pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t.pgrst_scalar)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"rpc_org_dashboard_payload\".* FROM \"pgrst_source\" AS \"rpc_org_dashboard_payload\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "6eaa5bc4"
        },
        {
          "query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "calls": "2848",
          "total_time_ms": "1301.024127",
          "rows": "2848",
          "Query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "Fingerprint": "0c4f8f7c"
        },
        {
          "query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "calls": "2848",
          "total_time_ms": "1301.024127",
          "mean_time_ms": "0.456820269311797",
          "rows": "2848",
          "Query": "SELECT pg_catalog.pg_get_viewdef($1::pg_catalog.oid) AS viewdef",
          "Fingerprint": "0c4f8f7c"
        },
        {
          "query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "calls": "12281",
          "total_time_ms": "1230.18216",
          "rows": "12281",
          "Query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "Fingerprint": "dacc823a"
        },
        {
          "query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "calls": "12281",
          "total_time_ms": "1230.18216",
          "mean_time_ms": "0.100169543196808",
          "rows": "12281",
          "Query": "PREPARE dumpFunc(pg_catalog.oid) AS\nSELECT\nproretset,\nprosrc,\nprobin,\nprovolatile,\nproisstrict,\nprosecdef,\nlanname,\nproconfig,\nprocost,\nprorows,\npg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\npg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\npg_catalog.pg_get_function_result(p.oid) AS funcresult,\nproleakproof,\narray_to_string(protrftypes, $2) AS protrftypes,\nproparallel,\nprokind,\nprosupport,\npg_get_function_sqlbody(p.oid) AS prosqlbody\nFROM pg_catalog.pg_proc p, pg_catalog.pg_language l\nWHERE p.oid = $1 AND l.oid = p.prolang",
          "Fingerprint": "dacc823a"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "475",
          "total_time_ms": "1203.426561",
          "rows": "475",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "475",
          "total_time_ms": "1203.426561",
          "mean_time_ms": "2.53352960210526",
          "rows": "475",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "calls": "48",
          "total_time_ms": "1039.996381",
          "rows": "0",
          "Query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "Fingerprint": "b05429e3"
        },
        {
          "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "calls": "48",
          "total_time_ms": "1039.996381",
          "mean_time_ms": "21.6665912708333",
          "rows": "0",
          "Query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
          "Fingerprint": "b05429e3"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "calls": "50",
          "total_time_ms": "896.677722",
          "rows": "38",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "Fingerprint": "a7b5eaa1"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "calls": "50",
          "total_time_ms": "896.677722",
          "mean_time_ms": "17.93355444",
          "rows": "38",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1) AND\n  \n  \n  c.relkind = $2\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $3 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $4\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $5 THEN CASE\n      WHEN bt.typelem <> $6 :: oid\n      AND bt.typlen = $7 THEN $8\n      WHEN nbt.nspname = $9 THEN format_type(t.typbasetype, $10)\n      ELSE $11\n    END\n    ELSE CASE\n      WHEN t.typelem <> $12 :: oid\n      AND t.typlen = $13 THEN $14\n      WHEN nt.nspname = $15 THEN format_type(a.atttypid, $16)\n      ELSE $17\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($18, $19) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $20 THEN $21\n    WHEN $22 THEN $23\n    ELSE $24\n  END AS identity_generation,\n  a.attgenerated IN ($25) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $26 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($27, $28)\n    OR c.relkind IN ($29, $30) AND pg_column_is_updatable(c.oid, a.attnum, $31)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $32\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$33] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $34 AND cardinality(conkey) = $35\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$36] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $37),\n        $38,\n        length(pg_get_constraintdef(pg_constraint.oid, $39)) - $40\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $41 AND cardinality(conkey) = $42\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($43) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $44\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($45, $46, $47, $48, $49))\n  AND (\n    pg_has_role(c.relowner, $50)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $51\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = materialized_views.id)\n    FROM\n      columns\n  ),\n  $52\n) AS columns\nfrom materialized_views",
          "Fingerprint": "a7b5eaa1"
        },
        {
          "query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "calls": "5",
          "total_time_ms": "783.325132",
          "mean_time_ms": "156.6650264",
          "rows": "5",
          "Query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "Fingerprint": "ad2f00c3"
        },
        {
          "query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "calls": "5",
          "mean_time_ms": "156.6650264",
          "max_time_ms": "178.818857",
          "total_time_ms": "783.325132",
          "rows": "5",
          "Query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
          "Fingerprint": "ad2f00c3"
        },
        {
          "query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "calls": "1397",
          "total_time_ms": "667.382252000001",
          "rows": "0",
          "Query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "Fingerprint": "5d91a149"
        },
        {
          "query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "calls": "1397",
          "total_time_ms": "667.382252000001",
          "mean_time_ms": "0.477725305654975",
          "rows": "0",
          "Query": "SELECT\n  c.castsource::regtype::text,\n  c.casttarget::regtype::text,\n  c.castfunc::regproc::text\nFROM\n  pg_catalog.pg_cast c\nJOIN pg_catalog.pg_type src_t\n  ON c.castsource::oid = src_t.oid\nJOIN pg_catalog.pg_type dst_t\n  ON c.casttarget::oid = dst_t.oid\nWHERE\n  c.castcontext = $1\n  AND c.castmethod = $2\n  AND has_function_privilege(c.castfunc, $3)\n  AND ((src_t.typtype = $4 AND c.casttarget IN ($5::regtype::oid , $6::regtype::oid))\n   OR (dst_t.typtype = $7 AND c.castsource IN ($8::regtype::oid , $9::regtype::oid)))",
          "Fingerprint": "5d91a149"
        },
        {
          "query": "SELECT\n  pol.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS table,\n  c.oid :: int8 AS table_id,\n  pol.polname AS name,\n  CASE\n    WHEN pol.polpermissive THEN $1 :: text\n    ELSE $2 :: text\n  END AS action,\n  CASE\n    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(\n      string_to_array($4 :: text, $5 :: text) :: name []\n    )\n    ELSE array_to_json(\n      ARRAY(\n        SELECT\n          pg_roles.rolname\n        FROM\n          pg_roles\n        WHERE\n          pg_roles.oid = ANY (pol.polroles)\n        ORDER BY\n          pg_roles.rolname\n      )\n    )\n  END AS roles,\n  CASE\n    pol.polcmd\n    WHEN $6 :: \"char\" THEN $7 :: text\n    WHEN $8 :: \"char\" THEN $9 :: text\n    WHEN $10 :: \"char\" THEN $11 :: text\n    WHEN $12 :: \"char\" THEN $13 :: text\n    WHEN $14 :: \"char\" THEN $15 :: text\n    ELSE $16 :: text\n  END AS command,\n  pg_get_expr(pol.polqual, pol.polrelid) AS definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check\nFROM\n  pg_policy pol\n  JOIN pg_class c ON c.oid = pol.polrelid\n  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname NOT IN ($17,$18,$19)",
          "calls": "24",
          "total_time_ms": "664.760387",
          "mean_time_ms": "27.6983494583333",
          "rows": "9760",
          "Query": "SELECT\n  pol.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS table,\n  c.oid :: int8 AS table_id,\n  pol.polname AS name,\n  CASE\n    WHEN pol.polpermissive THEN $1 :: text\n    ELSE $2 :: text\n  END AS action,\n  CASE\n    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(\n      string_to_array($4 :: text, $5 :: text) :: name []\n    )\n    ELSE array_to_json(\n      ARRAY(\n        SELECT\n          pg_roles.rolname\n        FROM\n          pg_roles\n        WHERE\n          pg_roles.oid = ANY (pol.polroles)\n        ORDER BY\n          pg_roles.rolname\n      )\n    )\n  END AS roles,\n  CASE\n    pol.polcmd\n    WHEN $6 :: \"char\" THEN $7 :: text\n    WHEN $8 :: \"char\" THEN $9 :: text\n    WHEN $10 :: \"char\" THEN $11 :: text\n    WHEN $12 :: \"char\" THEN $13 :: text\n    WHEN $14 :: \"char\" THEN $15 :: text\n    ELSE $16 :: text\n  END AS command,\n  pg_get_expr(pol.polqual, pol.polrelid) AS definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check\nFROM\n  pg_policy pol\n  JOIN pg_class c ON c.oid = pol.polrelid\n  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname NOT IN ($17,$18,$19)",
          "Fingerprint": "2bc926bd"
        },
        {
          "query": "SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid",
          "calls": "36",
          "total_time_ms": "644.090406",
          "mean_time_ms": "17.8914001666667",
          "rows": "189526",
          "Query": "SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid",
          "Fingerprint": "189d6e81"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "calls": "46",
          "total_time_ms": "596.622214",
          "rows": "1236",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "Fingerprint": "2d4e922a"
        },
        {
          "query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "calls": "46",
          "total_time_ms": "596.622214",
          "mean_time_ms": "12.9700481304348",
          "rows": "1236",
          "Query": "select\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, $1) as format,\n  coalesce(t_enums.enums, $2) as enums,\n  coalesce(t_attributes.attributes, $3) as attributes,\n  obj_description (t.oid, $4) as comment,\n  nullif(t.typrelid::int8, $5) as type_relation_id\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object($6, a.attname, $7, a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = $8 and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\n  where\n      (\n        t.typrelid = $9\n        or (\n          select\n            c.relkind = $10\n          from\n            pg_class c\n          where\n            c.oid = t.typrelid\n        )\n      )\n      and not exists (\n                 select\n                 from\n                   pg_type el\n                 where\n                   el.oid = t.typelem\n                   and el.typarray = t.oid\n               )\n      and n.nspname NOT IN ($11,$12,$13)",
          "Fingerprint": "2d4e922a"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "calls": "80",
          "total_time_ms": "590.210851",
          "rows": "5984",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "Fingerprint": "03495dc3"
        },
        {
          "query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "calls": "80",
          "total_time_ms": "590.210851",
          "mean_time_ms": "7.3776356375",
          "rows": "5984",
          "Query": "with views as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  -- See definition of information_schema.views\n  (pg_relation_is_updatable(c.oid, $1) & $2) = $3 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($4,$5) AND\n  \n  \n  c.relkind = $6\n\n\n)\n  \nselect\n  *\n  \nfrom views",
          "Fingerprint": "03495dc3"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "calls": "1397",
          "total_time_ms": "571.449586",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "Fingerprint": "c5bdd355"
        },
        {
          "query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "calls": "1397",
          "total_time_ms": "571.449586",
          "mean_time_ms": "0.409054821760916",
          "rows": "0",
          "Query": "with\nall_relations as (\n  select reltype\n  from pg_class\n  where relkind in ($2,$3,$4,$5,$6)\n  union\n  select oid\n  from pg_type\n  where typname = $7\n),\nmedia_types as (\n    SELECT\n      t.oid,\n      lower(t.typname) as typname,\n      t.typnamespace,\n      case t.typname\n        when $8 then $9\n        else t.typname\n      end as resolved_media_type\n    FROM pg_type t\n    JOIN pg_type b ON t.typbasetype = b.oid\n    WHERE\n      t.typbasetype <> $10 and\n      (t.typname ~* $11 or t.typname = $12)\n)\nselect\n  proc_schema.nspname           as handler_schema,\n  proc.proname                  as handler_name,\n  arg_schema.nspname::text      as target_schema,\n  arg_name.typname::text        as target_name,\n  media_types.typname           as media_type,\n  media_types.resolved_media_type\nfrom media_types\n  join pg_proc      proc         on proc.prorettype = media_types.oid\n  join pg_namespace proc_schema  on proc_schema.oid = proc.pronamespace\n  join pg_aggregate agg          on agg.aggfnoid = proc.oid\n  join pg_type      arg_name     on arg_name.oid = proc.proargtypes[$13]\n  join pg_namespace arg_schema   on arg_schema.oid = arg_name.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and\n  proc.pronargs = $14 and\n  arg_name.oid in (select reltype from all_relations)\nunion\nselect\n    typ_sch.nspname as handler_schema,\n    mtype.typname   as handler_name,\n    pro_sch.nspname as target_schema,\n    proname         as target_name,\n    mtype.typname   as media_type,\n    mtype.resolved_media_type\nfrom pg_proc proc\n  join pg_namespace pro_sch on pro_sch.oid = proc.pronamespace\n  join media_types mtype on proc.prorettype = mtype.oid\n  join pg_namespace typ_sch     on typ_sch.oid = mtype.typnamespace\nwhere\n  proc.pronamespace = ANY($1::regnamespace[]) and NOT proretset\n  and prokind = $15",
          "Fingerprint": "c5bdd355"
        },
        {
          "query": "SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, $1) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $2) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $3) AS indstatvals, i.indnullsnotdistinct FROM unnest($4::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ($5,$6,$7)) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = $8) AND i.indisready ORDER BY i.indrelid, indexname",
          "calls": "36",
          "total_time_ms": "544.603807",
          "mean_time_ms": "15.1278835277778",
          "rows": "10108",
          "Query": "SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, $1) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $2) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= $3) AS indstatvals, i.indnullsnotdistinct FROM unnest($4::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ($5,$6,$7)) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = $8) AND i.indisready ORDER BY i.indrelid, indexname",
          "Fingerprint": "8c28798a"
        },
        {
          "query": "SELECT\na.attrelid,\na.attnum,\na.attname,\na.attstattarget,\na.attstorage,\nt.typstorage,\na.attnotnull,\na.atthasdef,\na.attisdropped,\na.attlen,\na.attalign,\na.attislocal,\npg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,\narray_to_string(a.attoptions, $1) AS attoptions,\nCASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE $2 END AS attcollation,\npg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || $3 || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), $4) AS attfdwoptions,\na.attcompression AS attcompression,\na.attidentity,\nCASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE $5 END AS attmissingval,\na.attgenerated\nFROM unnest($6::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)\nWHERE a.attnum > $7::pg_catalog.int2\nORDER BY a.attrelid, a.attnum",
          "calls": "36",
          "total_time_ms": "477.764626",
          "mean_time_ms": "13.2712396111111",
          "rows": "53780",
          "Query": "SELECT\na.attrelid,\na.attnum,\na.attname,\na.attstattarget,\na.attstorage,\nt.typstorage,\na.attnotnull,\na.atthasdef,\na.attisdropped,\na.attlen,\na.attalign,\na.attislocal,\npg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,\narray_to_string(a.attoptions, $1) AS attoptions,\nCASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE $2 END AS attcollation,\npg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || $3 || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), $4) AS attfdwoptions,\na.attcompression AS attcompression,\na.attidentity,\nCASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE $5 END AS attmissingval,\na.attgenerated\nFROM unnest($6::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)\nWHERE a.attnum > $7::pg_catalog.int2\nORDER BY a.attrelid, a.attnum",
          "Fingerprint": "8a143ec8"
        },
        {
          "query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "calls": "113",
          "total_time_ms": "472.05049",
          "rows": "1017",
          "Query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "Fingerprint": "83726034"
        },
        {
          "query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "calls": "113",
          "total_time_ms": "472.05049",
          "mean_time_ms": "4.17743796460177",
          "rows": "1017",
          "Query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T01:59:40.011Z",
          "Fingerprint": "83726034"
        },
        {
          "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "calls": "13",
          "total_time_ms": "469.941505",
          "mean_time_ms": "36.1493465384615",
          "rows": "532",
          "Query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
          "Fingerprint": "335d3082"
        },
        {
          "query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "calls": "1",
          "total_time_ms": "420.238451",
          "mean_time_ms": "420.238451",
          "rows": "0",
          "Query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "Fingerprint": "d77f9421"
        },
        {
          "query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "calls": "1",
          "mean_time_ms": "420.238451",
          "max_time_ms": "420.238451",
          "total_time_ms": "420.238451",
          "rows": "0",
          "Query": "ALTER TABLE public.avatars ADD COLUMN is_preset bool\n    DEFAULT 'false'\n    NOT NULL",
          "Fingerprint": "d77f9421"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "calls": "80",
          "total_time_ms": "417.70789",
          "rows": "10019",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "Fingerprint": "63fbfa7d"
        },
        {
          "query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "calls": "80",
          "total_time_ms": "417.70789",
          "mean_time_ms": "5.221348625",
          "rows": "10019",
          "Query": "-- Adapted from\n-- https://github.com/PostgREST/postgrest/blob/f9f0f79fa914ac00c11fbf7f4c558e14821e67e2/src/PostgREST/SchemaCache.hs#L722\nWITH\npks_uniques_cols AS (\n  SELECT\n    connamespace,\n    conrelid,\n    jsonb_agg(column_info.cols) as cols\n  FROM pg_constraint\n  JOIN lateral (\n    SELECT array_agg(cols.attname order by cols.attnum) as cols\n    FROM ( select unnest(conkey) as col) _\n    JOIN pg_attribute cols on cols.attrelid = conrelid and cols.attnum = col\n  ) column_info ON $1\n  WHERE\n    contype IN ($2, $3) and\n    connamespace::regnamespace::text <> $4\n    and connamespace::regnamespace::text IN ($5,$6)\n  GROUP BY connamespace, conrelid\n)\nSELECT\n  traint.conname AS foreign_key_name,\n  ns1.nspname AS schema,\n  tab.relname AS relation,\n  column_info.cols AS columns,\n  ns2.nspname AS referenced_schema,\n  other.relname AS referenced_relation,\n  column_info.refs AS referenced_columns,\n  (column_info.cols IN (SELECT * FROM jsonb_array_elements(pks_uqs.cols))) AS is_one_to_one\nFROM pg_constraint traint\nJOIN LATERAL (\n  SELECT\n    jsonb_agg(cols.attname order by ord) AS cols,\n    jsonb_agg(refs.attname order by ord) AS refs\n  FROM unnest(traint.conkey, traint.confkey) WITH ORDINALITY AS _(col, ref, ord)\n  JOIN pg_attribute cols ON cols.attrelid = traint.conrelid AND cols.attnum = col\n  JOIN pg_attribute refs ON refs.attrelid = traint.confrelid AND refs.attnum = ref\n  WHERE traint.connamespace::regnamespace::text IN ($7,$8)\n) AS column_info ON $9\nJOIN pg_namespace ns1 ON ns1.oid = traint.connamespace\nJOIN pg_class tab ON tab.oid = traint.conrelid\nJOIN pg_class other ON other.oid = traint.confrelid\nJOIN pg_namespace ns2 ON ns2.oid = other.relnamespace\nLEFT JOIN pks_uniques_cols pks_uqs ON pks_uqs.connamespace = traint.connamespace AND pks_uqs.conrelid = traint.conrelid\nWHERE traint.contype = $10\nAND traint.conparentid = $11\nand ns1.nspname IN ($12,$13)",
          "Fingerprint": "63fbfa7d"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "391",
          "total_time_ms": "416.396113",
          "rows": "391",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "169ad58d"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "391",
          "total_time_ms": "416.396113",
          "mean_time_ms": "1.06495169565218",
          "rows": "391",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_job_titles_public\"() pgrst_call) SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT \"job_titles\".* FROM \"pgrst_source\" AS \"job_titles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "169ad58d"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "298",
          "total_time_ms": "410.95613",
          "rows": "298",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "fef63b48"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "298",
          "total_time_ms": "410.95613",
          "mean_time_ms": "1.37904741610738",
          "rows": "298",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_query\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_query\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_organizations_public\"(\"p_query\" := pgrst_body.\"p_query\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"record\".* FROM \"pgrst_source\" AS \"record\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "fef63b48"
        },
        {
          "query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "calls": "1",
          "total_time_ms": "405.91149",
          "mean_time_ms": "405.91149",
          "rows": "496",
          "Query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "96cb168f"
        },
        {
          "query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "calls": "1",
          "mean_time_ms": "405.91149",
          "max_time_ms": "405.91149",
          "total_time_ms": "405.91149",
          "rows": "496",
          "Query": "COPY  ( select n.nspname as schema, p.proname as function, pg_get_functiondef ( p.oid ) as definition from pg_proc p join pg_namespace n on n.oid = p.pronamespace where n.nspname not in ( 'pg_catalog' , 'information_schema' ) order by n.nspname, p.proname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "96cb168f"
        },
        {
          "query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "calls": "92",
          "total_time_ms": "396.812123",
          "rows": "92",
          "Query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "Fingerprint": "24390c08"
        },
        {
          "query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "calls": "92",
          "total_time_ms": "396.812123",
          "mean_time_ms": "4.31317525",
          "rows": "92",
          "Query": "SELECT pg_catalog.obj_description($1::regnamespace, $2)",
          "Fingerprint": "24390c08"
        },
        {
          "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "calls": "69",
          "total_time_ms": "396.493198",
          "rows": "69",
          "Query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "Fingerprint": "9d6d3db1"
        },
        {
          "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "calls": "69",
          "total_time_ms": "396.493198",
          "mean_time_ms": "5.74627823188406",
          "rows": "69",
          "Query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
          "Fingerprint": "9d6d3db1"
        },
        {
          "query": "SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault($1, p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = $2::regclass AND pip.objsubid = $3) WHERE p.prokind <> $4\n  AND NOT EXISTS (SELECT $5 FROM pg_depend WHERE classid = $6::regclass AND objid = p.oid AND deptype = $7)\n  AND (\n  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = $8)\n  OR EXISTS (SELECT $9 FROM pg_cast\n  WHERE pg_cast.oid > $10 \n  AND p.oid = pg_cast.castfunc)\n  OR EXISTS (SELECT $11 FROM pg_transform\n  WHERE pg_transform.oid > $12 AND \n  (p.oid = pg_transform.trffromsql\n  OR p.oid = pg_transform.trftosql))\n  OR p.proacl IS DISTINCT FROM pip.initprivs)",
          "calls": "36",
          "total_time_ms": "396.306517",
          "mean_time_ms": "11.0085143611111",
          "rows": "16637",
          "Query": "SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault($1, p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = $2::regclass AND pip.objsubid = $3) WHERE p.prokind <> $4\n  AND NOT EXISTS (SELECT $5 FROM pg_depend WHERE classid = $6::regclass AND objid = p.oid AND deptype = $7)\n  AND (\n  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = $8)\n  OR EXISTS (SELECT $9 FROM pg_cast\n  WHERE pg_cast.oid > $10 \n  AND p.oid = pg_cast.castfunc)\n  OR EXISTS (SELECT $11 FROM pg_transform\n  WHERE pg_transform.oid > $12 AND \n  (p.oid = pg_transform.trffromsql\n  OR p.oid = pg_transform.trftosql))\n  OR p.proacl IS DISTINCT FROM pip.initprivs)",
          "Fingerprint": "21a0331a"
        },
        {
          "query": "SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != $1 AND deptype != $2\nUNION ALL\nSELECT $3::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ($4, $5, $6) AND classid = $7::regclass AND objid = o.oid AND NOT (refclassid = $8::regclass AND amopfamily = refobjid)\nUNION ALL\nSELECT $9::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ($10, $11, $12) AND classid = $13::regclass AND objid = p.oid AND NOT (refclassid = $14::regclass AND amprocfamily = refobjid)\nORDER BY 1,2",
          "calls": "36",
          "total_time_ms": "394.801907",
          "mean_time_ms": "10.9667196388889",
          "rows": "274216",
          "Query": "SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != $1 AND deptype != $2\nUNION ALL\nSELECT $3::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ($4, $5, $6) AND classid = $7::regclass AND objid = o.oid AND NOT (refclassid = $8::regclass AND amopfamily = refobjid)\nUNION ALL\nSELECT $9::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ($10, $11, $12) AND classid = $13::regclass AND objid = p.oid AND NOT (refclassid = $14::regclass AND amprocfamily = refobjid)\nORDER BY 1,2",
          "Fingerprint": "72852126"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"_filters\", \"_order_by\", \"_direction\" FROM json_to_record(pgrst_payload.json_data) AS _(\"_filters\" jsonb, \"_order_by\" text, \"_direction\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"filter_projects\"(\"_filters\" := pgrst_body.\"_filters\", \"_order_by\" := pgrst_body.\"_order_by\", \"_direction\" := pgrst_body.\"_direction\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"projects\".* FROM \"pgrst_source\" AS \"projects\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "36",
          "total_time_ms": "393.437611",
          "mean_time_ms": "10.9288225277778",
          "rows": "36",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"_filters\", \"_order_by\", \"_direction\" FROM json_to_record(pgrst_payload.json_data) AS _(\"_filters\" jsonb, \"_order_by\" text, \"_direction\" text) LIMIT $4) pgrst_body , LATERAL \"public\".\"filter_projects\"(\"_filters\" := pgrst_body.\"_filters\", \"_order_by\" := pgrst_body.\"_order_by\", \"_direction\" := pgrst_body.\"_direction\") pgrst_call) SELECT $5::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"projects\".* FROM \"pgrst_source\" AS \"projects\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "0bad5e6b"
        },
        {
          "query": "SELECT tableoid, oid, typname, typnamespace, typacl, acldefault($1, typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = $2 THEN $3::\"char\" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[$4] = $5 AND typelem != $6 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type",
          "calls": "36",
          "total_time_ms": "383.257885",
          "mean_time_ms": "10.6460523611111",
          "rows": "38148",
          "Query": "SELECT tableoid, oid, typname, typnamespace, typacl, acldefault($1, typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = $2 THEN $3::\"char\" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[$4] = $5 AND typelem != $6 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type",
          "Fingerprint": "7fd9aab0"
        },
        {
          "query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "calls": "1",
          "total_time_ms": "381.49694",
          "mean_time_ms": "381.49694",
          "rows": "112",
          "Query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "Fingerprint": "ad99e1e0"
        },
        {
          "query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "calls": "1",
          "mean_time_ms": "381.49694",
          "max_time_ms": "381.49694",
          "total_time_ms": "381.49694",
          "rows": "112",
          "Query": "-- QUERY 1: Tables + columns + constraints + indexes + triggers + RLS flags + size\nWITH tables AS (\n  SELECT\n    c.oid                                         AS table_oid,\n    n.nspname                                     AS schema_name,\n    c.relname                                     AS table_name,\n    c.reltuples                                   AS approx_rows,\n    c.relrowsecurity                              AS rls_enabled,\n    c.relforcerowsecurity                         AS rls_forced,\n    pg_total_relation_size(c.oid)                 AS total_bytes,\n    pg_relation_size(c.oid)                       AS table_bytes,\n    pg_indexes_size(c.oid)                        AS index_bytes,\n    obj_description(c.oid, $1)            AS table_comment\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $2 -- ordinary tables\n    AND n.nspname IN ($3, $4)\n)\nSELECT\n  t.schema_name,\n  t.table_name,\n  t.table_comment,\n  t.rls_enabled,\n  t.rls_forced,\n  t.approx_rows,\n  t.total_bytes,\n  t.table_bytes,\n  t.index_bytes,\n\n  -- columns\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $5, a.attnum,\n        $6, a.attname,\n        $7, pg_catalog.format_type(a.atttypid, a.atttypmod),\n        $8, a.attnotnull,\n        $9, pg_get_expr(ad.adbin, ad.adrelid),\n        $10, a.attidentity,\n        $11, a.attgenerated\n      )\n      ORDER BY a.attnum\n    )\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef ad\n      ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum\n    WHERE a.attrelid = t.table_oid\n      AND a.attnum > $12\n      AND NOT a.attisdropped\n  ) AS columns,\n\n  -- constraints (pk/uk/fk/check)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $13, con.conname,\n        $14, con.contype,\n        $15, pg_get_constraintdef(con.oid, $16)\n      )\n      ORDER BY con.conname\n    )\n    FROM pg_constraint con\n    WHERE con.conrelid = t.table_oid\n  ) AS constraints,\n\n  -- indexes\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $17, i.relname,\n        $18, pg_get_indexdef(i.oid)\n      )\n      ORDER BY i.relname\n    )\n    FROM pg_index ix\n    JOIN pg_class i ON i.oid = ix.indexrelid\n    WHERE ix.indrelid = t.table_oid\n  ) AS indexes,\n\n  -- triggers (excluding internal)\n  (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $19, tg.tgname,\n        $20, tg.tgenabled,\n        $21, pg_get_triggerdef(tg.oid, $22)\n      )\n      ORDER BY tg.tgname\n    )\n    FROM pg_trigger tg\n    WHERE tg.tgrelid = t.table_oid\n      AND NOT tg.tgisinternal\n  ) AS triggers\n\nFROM tables t\nORDER BY t.schema_name, t.table_name",
          "Fingerprint": "ad99e1e0"
        },
        {
          "query": "INSERT INTO \"users\" (\"aud\", \"banned_until\", \"confirmation_sent_at\", \"confirmation_token\", \"created_at\", \"deleted_at\", \"email\", \"email_change\", \"email_change_confirm_status\", \"email_change_sent_at\", \"email_change_token_current\", \"email_change_token_new\", \"email_confirmed_at\", \"encrypted_password\", \"id\", \"instance_id\", \"invited_at\", \"is_anonymous\", \"is_sso_user\", \"last_sign_in_at\", \"phone\", \"phone_change\", \"phone_change_sent_at\", \"phone_change_token\", \"phone_confirmed_at\", \"raw_app_meta_data\", \"raw_user_meta_data\", \"reauthentication_sent_at\", \"reauthentication_token\", \"recovery_sent_at\", \"recovery_token\", \"role\", \"updated_at\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)",
          "calls": "7",
          "total_time_ms": "370.288915",
          "mean_time_ms": "52.8984164285714",
          "rows": "7",
          "Query": "INSERT INTO \"users\" (\"aud\", \"banned_until\", \"confirmation_sent_at\", \"confirmation_token\", \"created_at\", \"deleted_at\", \"email\", \"email_change\", \"email_change_confirm_status\", \"email_change_sent_at\", \"email_change_token_current\", \"email_change_token_new\", \"email_confirmed_at\", \"encrypted_password\", \"id\", \"instance_id\", \"invited_at\", \"is_anonymous\", \"is_sso_user\", \"last_sign_in_at\", \"phone\", \"phone_change\", \"phone_change_sent_at\", \"phone_change_token\", \"phone_confirmed_at\", \"raw_app_meta_data\", \"raw_user_meta_data\", \"reauthentication_sent_at\", \"reauthentication_token\", \"recovery_sent_at\", \"recovery_token\", \"role\", \"updated_at\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)",
          "Fingerprint": "28bfbb4f"
        },
        {
          "query": "DROP SCHEMA IF EXISTS public CASCADE",
          "calls": "1",
          "total_time_ms": "354.783696",
          "mean_time_ms": "354.783696",
          "rows": "0",
          "Query": "DROP SCHEMA IF EXISTS public CASCADE",
          "Fingerprint": "2124d21d"
        },
        {
          "query": "DROP SCHEMA IF EXISTS public CASCADE",
          "calls": "1",
          "mean_time_ms": "354.783696",
          "max_time_ms": "354.783696",
          "total_time_ms": "354.783696",
          "rows": "0",
          "Query": "DROP SCHEMA IF EXISTS public CASCADE",
          "Fingerprint": "2124d21d"
        },
        {
          "query": "SELECT \n  con.oid as id, \n  con.conname as constraint_name, \n  con.confdeltype as deletion_action,\n  con.confupdtype as update_action,\n  rel.oid as source_id,\n  nsp.nspname as source_schema, \n  rel.relname as source_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.conkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = rel.oid\n  ) source_columns, \n  frel.oid as target_id,\n  fnsp.nspname as target_schema, \n  frel.relname as target_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.confkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = frel.oid\n  ) target_columns \nFROM \n  pg_constraint con \n  INNER JOIN pg_class rel ON rel.oid = con.conrelid \n  INNER JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace \n  INNER JOIN pg_class frel ON frel.oid = con.confrelid \n  INNER JOIN pg_namespace fnsp ON fnsp.oid = frel.relnamespace \nWHERE \n  con.contype = $1\n  AND nsp.nspname = $2\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T05:13:26.471Z",
          "calls": "34",
          "total_time_ms": "350.834465",
          "mean_time_ms": "10.3186607352941",
          "rows": "3900",
          "Query": "SELECT \n  con.oid as id, \n  con.conname as constraint_name, \n  con.confdeltype as deletion_action,\n  con.confupdtype as update_action,\n  rel.oid as source_id,\n  nsp.nspname as source_schema, \n  rel.relname as source_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.conkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = rel.oid\n  ) source_columns, \n  frel.oid as target_id,\n  fnsp.nspname as target_schema, \n  frel.relname as target_table, \n  (\n    SELECT \n      array_agg(\n        att.attname \n        ORDER BY \n          un.ord\n      ) \n    FROM \n      unnest(con.confkey) WITH ORDINALITY un (attnum, ord) \n      INNER JOIN pg_attribute att ON att.attnum = un.attnum \n    WHERE \n      att.attrelid = frel.oid\n  ) target_columns \nFROM \n  pg_constraint con \n  INNER JOIN pg_class rel ON rel.oid = con.conrelid \n  INNER JOIN pg_namespace nsp ON nsp.oid = rel.relnamespace \n  INNER JOIN pg_class frel ON frel.oid = con.confrelid \n  INNER JOIN pg_namespace fnsp ON fnsp.oid = frel.relnamespace \nWHERE \n  con.contype = $1\n  AND nsp.nspname = $2\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T05:13:26.471Z",
          "Fingerprint": "d62b169a"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "362",
          "total_time_ms": "342.799267",
          "rows": "362",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "840a08d4"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "calls": "362",
          "total_time_ms": "342.799267",
          "mean_time_ms": "0.946959301104972",
          "rows": "362",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT \"p_avatar_id\" FROM json_to_record(pgrst_payload.json_data) AS _(\"p_avatar_id\" uuid) LIMIT $4) pgrst_body , LATERAL \"public\".\"get_avatar_by_id_public\"(\"p_avatar_id\" := pgrst_body.\"p_avatar_id\") pgrst_call) SELECT $5::bigint AS total_result_set, $6 AS page_total, coalesce(json_agg(_postgrest_t)->$7, $8) AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM (SELECT \"avatars\".* FROM \"pgrst_source\" AS \"avatars\"   LIMIT $2 OFFSET $3) _postgrest_t",
          "Fingerprint": "840a08d4"
        },
        {
          "query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
          "calls": "4",
          "total_time_ms": "323.330854",
          "mean_time_ms": "80.8327135",
          "rows": "0",
          "Query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
          "Fingerprint": "92e79eb0"
        },
        {
          "query": "SELECT * FROM pgbouncer.get_auth($1)",
          "calls": "133",
          "total_time_ms": "313.882881",
          "rows": "133",
          "Query": "SELECT * FROM pgbouncer.get_auth($1)",
          "Fingerprint": "6e8f1775"
        },
        {
          "query": "SELECT * FROM pgbouncer.get_auth($1)",
          "calls": "133",
          "total_time_ms": "313.882881",
          "mean_time_ms": "2.36002166165414",
          "rows": "133",
          "Query": "SELECT * FROM pgbouncer.get_auth($1)",
          "Fingerprint": "6e8f1775"
        },
        {
          "query": "SELECT\n  pg_t.oid AS id,\n  pg_t.tgrelid AS table_id,\n  CASE\n    WHEN pg_t.tgenabled = $1 THEN $2\n    WHEN pg_t.tgenabled = $3 THEN $4\n    WHEN pg_t.tgenabled = $5 THEN $6\n    WHEN pg_t.tgenabled = $7 THEN $8\n    END AS enabled_mode,\n  (\n    STRING_TO_ARRAY(\n      ENCODE(pg_t.tgargs, $9), $10\n    )\n  )[:pg_t.tgnargs] AS function_args,\n  is_t.trigger_name AS name,\n  is_t.event_object_table AS table,\n  is_t.event_object_schema AS schema,\n  is_t.action_condition AS condition,\n  is_t.action_orientation AS orientation,\n  is_t.action_timing AS activation,\n  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,\n  pg_p.proname AS function_name,\n  pg_n.nspname AS function_schema\nFROM\n  pg_trigger AS pg_t\nJOIN\n  pg_class AS pg_c\nON pg_t.tgrelid = pg_c.oid\nJOIN pg_namespace AS table_ns\nON pg_c.relnamespace = table_ns.oid\nJOIN information_schema.triggers AS is_t\nON is_t.trigger_name = pg_t.tgname\nAND pg_c.relname = is_t.event_object_table\nAND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace\nJOIN pg_proc AS pg_p\nON pg_t.tgfoid = pg_p.oid\nJOIN pg_namespace AS pg_n\nON pg_p.pronamespace = pg_n.oid\nWHERE\n  table_ns.nspname NOT IN ($11,$12,$13)\n  \n  \n  \nGROUP BY\n  pg_t.oid,\n  pg_t.tgrelid,\n  pg_t.tgenabled,\n  pg_t.tgargs,\n  pg_t.tgnargs,\n  is_t.trigger_name,\n  is_t.event_object_table,\n  is_t.event_object_schema,\n  is_t.action_condition,\n  is_t.action_orientation,\n  is_t.action_timing,\n  pg_p.proname,\n  pg_n.nspname",
          "calls": "17",
          "total_time_ms": "310.477875",
          "mean_time_ms": "18.2634044117647",
          "rows": "2872",
          "Query": "SELECT\n  pg_t.oid AS id,\n  pg_t.tgrelid AS table_id,\n  CASE\n    WHEN pg_t.tgenabled = $1 THEN $2\n    WHEN pg_t.tgenabled = $3 THEN $4\n    WHEN pg_t.tgenabled = $5 THEN $6\n    WHEN pg_t.tgenabled = $7 THEN $8\n    END AS enabled_mode,\n  (\n    STRING_TO_ARRAY(\n      ENCODE(pg_t.tgargs, $9), $10\n    )\n  )[:pg_t.tgnargs] AS function_args,\n  is_t.trigger_name AS name,\n  is_t.event_object_table AS table,\n  is_t.event_object_schema AS schema,\n  is_t.action_condition AS condition,\n  is_t.action_orientation AS orientation,\n  is_t.action_timing AS activation,\n  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,\n  pg_p.proname AS function_name,\n  pg_n.nspname AS function_schema\nFROM\n  pg_trigger AS pg_t\nJOIN\n  pg_class AS pg_c\nON pg_t.tgrelid = pg_c.oid\nJOIN pg_namespace AS table_ns\nON pg_c.relnamespace = table_ns.oid\nJOIN information_schema.triggers AS is_t\nON is_t.trigger_name = pg_t.tgname\nAND pg_c.relname = is_t.event_object_table\nAND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace\nJOIN pg_proc AS pg_p\nON pg_t.tgfoid = pg_p.oid\nJOIN pg_namespace AS pg_n\nON pg_p.pronamespace = pg_n.oid\nWHERE\n  table_ns.nspname NOT IN ($11,$12,$13)\n  \n  \n  \nGROUP BY\n  pg_t.oid,\n  pg_t.tgrelid,\n  pg_t.tgenabled,\n  pg_t.tgargs,\n  pg_t.tgnargs,\n  is_t.trigger_name,\n  is_t.event_object_table,\n  is_t.event_object_schema,\n  is_t.action_condition,\n  is_t.action_orientation,\n  is_t.action_timing,\n  pg_p.proname,\n  pg_n.nspname",
          "Fingerprint": "fa5418aa"
        },
        {
          "query": "delete from public.profiles where id in ($1)",
          "calls": "6",
          "total_time_ms": "308.323666",
          "mean_time_ms": "51.3872776666667",
          "rows": "6",
          "Query": "delete from public.profiles where id in ($1)",
          "Fingerprint": "8fff047e"
        },
        {
          "query": "SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation",
          "calls": "36",
          "total_time_ms": "303.222024",
          "mean_time_ms": "8.422834",
          "rows": "29340",
          "Query": "SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation",
          "Fingerprint": "fb4316d3"
        },
        {
          "query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "calls": "1",
          "total_time_ms": "274.966629",
          "mean_time_ms": "274.966629",
          "rows": "387",
          "Query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "Fingerprint": "fa35e7f9"
        },
        {
          "query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "calls": "1",
          "mean_time_ms": "274.966629",
          "max_time_ms": "274.966629",
          "total_time_ms": "274.966629",
          "rows": "387",
          "Query": "-- QUERY 2: RPCs / Functions (definitions + args + return type + security + volatility)\nSELECT\n  n.nspname                                                      AS schema_name,\n  p.proname                                                      AS function_name,\n  p.oid                                                          AS function_oid,\n  pg_get_userbyid(p.proowner)                                    AS owner,\n  p.prosecdef                                                    AS security_definer,\n  p.provolatile                                                  AS volatility,      -- i=immutable, s=stable, v=volatile\n  pg_get_function_identity_arguments(p.oid)                      AS identity_args,\n  pg_get_function_arguments(p.oid)                               AS full_args,\n  pg_catalog.format_type(p.prorettype, $1)                     AS return_type,\n  pg_get_functiondef(p.oid)                                      AS definition\nFROM pg_proc p\nJOIN pg_namespace n ON n.oid = p.pronamespace\nWHERE n.nspname IN ($2, $3)\n  AND p.prokind = $4 -- function (not procedure/aggregate/window)\n  AND p.proname NOT LIKE $5\nORDER BY n.nspname, p.proname, identity_args",
          "Fingerprint": "fa35e7f9"
        },
        {
          "query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "calls": "2",
          "total_time_ms": "273.3887",
          "mean_time_ms": "136.69435",
          "rows": "902",
          "Query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "069b33dd"
        },
        {
          "query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "calls": "2",
          "mean_time_ms": "136.69435",
          "max_time_ms": "257.34823",
          "total_time_ms": "273.3887",
          "rows": "902",
          "Query": "COPY  ( select schemaname as schema, tablename as table, policyname as policy, permissive, roles, cmd as command, qual as using, with_check as check from pg_policies order by schemaname, tablename, policyname ) TO STDOUT WITH CSV HEADER",
          "Fingerprint": "069b33dd"
        },
        {
          "query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "calls": "1",
          "total_time_ms": "269.306295",
          "mean_time_ms": "269.306295",
          "rows": "0",
          "Query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "Fingerprint": "bfd231e0"
        },
        {
          "query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "calls": "1",
          "mean_time_ms": "269.306295",
          "max_time_ms": "269.306295",
          "total_time_ms": "269.306295",
          "rows": "0",
          "Query": "ALTER TABLE public.organizations\n    ADD COLUMN IF NOT EXISTS mission_statement text,\n    ADD COLUMN IF NOT EXISTS headquarters text,\n    ADD COLUMN IF NOT EXISTS logo_url text",
          "Fingerprint": "bfd231e0"
        },
        {
          "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "calls": "60",
          "total_time_ms": "267.54152",
          "rows": "60",
          "Query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "Fingerprint": "9ddfc8bb"
        },
        {
          "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "calls": "60",
          "total_time_ms": "267.54152",
          "mean_time_ms": "4.45902533333333",
          "rows": "60",
          "Query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
          "Fingerprint": "9ddfc8bb"
        },
        {
          "query": "select * from storage.search($1,$2,$3,$4,$5,$6,$7,$8)",
          "calls": "30",
          "total_time_ms": "263.756364",
          "mean_time_ms": "8.7918788",
          "rows": "330",
          "Query": "select * from storage.search($1,$2,$3,$4,$5,$6,$7,$8)",
          "Fingerprint": "4855f2f1"
        },
        {
          "query": "SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc\nFROM unnest($1::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)\nORDER BY a.adrelid, a.adnum",
          "calls": "36",
          "total_time_ms": "230.075726",
          "mean_time_ms": "6.39099238888889",
          "rows": "10081",
          "Query": "SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc\nFROM unnest($1::pg_catalog.oid[]) AS src(tbloid)\nJOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)\nORDER BY a.adrelid, a.adnum",
          "Fingerprint": "d4507d78"
        },
        {
          "query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "calls": "2",
          "total_time_ms": "220.062577",
          "mean_time_ms": "110.0312885",
          "rows": "0",
          "Query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "Fingerprint": "0f1f0b6b"
        },
        {
          "query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "calls": "2",
          "mean_time_ms": "110.0312885",
          "max_time_ms": "219.722141",
          "total_time_ms": "220.062577",
          "rows": "0",
          "Query": "CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents\r\n    LANGUAGE plpgsql\r\n    SET search_path TO 'public', 'pg_temp'\r\n    AS $$\r\n      DECLARE\r\n        _old_row public.documents;\r\n        _new_row public.documents;\r\n        -- Map only known columns; keys not in the table are ignored safely\r\n        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));\r\n      BEGIN\r\n        -- Fetch row (RLS decides visibility)\r\n        SELECT * INTO _old_row FROM public.documents WHERE id = _id;\r\n        IF _old_row IS NULL THEN\r\n          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);\r\n        END IF;\r\n\r\n        -- Authorization gate with existing row scope (prevents privilege escalation)\r\n        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);\r\n\r\n        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here\r\n        UPDATE public.documents\r\n           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()\r\n         WHERE id = _id\r\n         RETURNING * INTO _new_row;\r\n\r\n        RETURN NEXT _new_row;\r\n      END;\r\n      $$",
          "Fingerprint": "0f1f0b6b"
        },
        {
          "query": "SELECT concat(schemaname, $1, tablename, $2, policyname) as policy\n    FROM   pg_policies",
          "calls": "5",
          "total_time_ms": "215.448357",
          "mean_time_ms": "43.0896714",
          "rows": "1777",
          "Query": "SELECT concat(schemaname, $1, tablename, $2, policyname) as policy\n    FROM   pg_policies",
          "Fingerprint": "46133688"
        },
        {
          "query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "207.808953",
          "mean_time_ms": "103.9044765",
          "rows": "0",
          "Query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "Fingerprint": "c6431895"
        },
        {
          "query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.9044765",
          "max_time_ms": "104.666803",
          "total_time_ms": "207.808953",
          "rows": "0",
          "Query": "COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin",
          "Fingerprint": "c6431895"
        },
        {
          "query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "206.381392",
          "mean_time_ms": "103.190696",
          "rows": "0",
          "Query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3607e581"
        },
        {
          "query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.190696",
          "max_time_ms": "107.763366",
          "total_time_ms": "206.381392",
          "rows": "0",
          "Query": "COPY public.crews (id, project_id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3607e581"
        },
        {
          "query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "206.062412",
          "mean_time_ms": "103.031206",
          "rows": "0",
          "Query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "393ce475"
        },
        {
          "query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "103.031206",
          "max_time_ms": "103.208161",
          "total_time_ms": "206.062412",
          "rows": "0",
          "Query": "COPY public.bid_vendors (id, bid_package_id, vendor_id, invited_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "393ce475"
        },
        {
          "query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "205.673718",
          "mean_time_ms": "102.836859",
          "rows": "0",
          "Query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3fea036f"
        },
        {
          "query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.836859",
          "max_time_ms": "110.852408",
          "total_time_ms": "205.673718",
          "rows": "0",
          "Query": "COPY public.hr_documents (id, employee_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3fea036f"
        },
        {
          "query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "205.463539",
          "mean_time_ms": "102.7317695",
          "rows": "0",
          "Query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "e68eeac4"
        },
        {
          "query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.7317695",
          "max_time_ms": "111.358102",
          "total_time_ms": "205.463539",
          "rows": "0",
          "Query": "COPY public.general_ledger (id, project_id, entry_date, description, debit, credit, balance, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "e68eeac4"
        },
        {
          "query": "SELECT labelfile, spcmapfile, lsn FROM pg_backup_stop($1)",
          "calls": "5",
          "total_time_ms": "204.326571",
          "mean_time_ms": "40.8653142",
          "rows": "5",
          "Query": "SELECT labelfile, spcmapfile, lsn FROM pg_backup_stop($1)",
          "Fingerprint": "11e57483"
        },
        {
          "query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "204.001209",
          "mean_time_ms": "102.0006045",
          "rows": "0",
          "Query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0ecbf6a3"
        },
        {
          "query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "102.0006045",
          "max_time_ms": "103.951377",
          "total_time_ms": "204.001209",
          "rows": "0",
          "Query": "COPY public.estimate_line_items (id, estimate_id, cost_code_id, name, unit_measure, quantity, unit_price, total_cost, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0ecbf6a3"
        },
        {
          "query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "203.976468",
          "mean_time_ms": "101.988234",
          "rows": "0",
          "Query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a70a9671"
        },
        {
          "query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.988234",
          "max_time_ms": "108.352564",
          "total_time_ms": "203.976468",
          "rows": "0",
          "Query": "COPY public.inspections (id, project_id, name, inspection_type, date, status, result, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a70a9671"
        },
        {
          "query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.699628",
          "mean_time_ms": "101.349814",
          "rows": "0",
          "Query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "fbbe9f07"
        },
        {
          "query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.349814",
          "max_time_ms": "104.02735",
          "total_time_ms": "202.699628",
          "rows": "0",
          "Query": "COPY public.reports (id, project_id, report_type, generated_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "fbbe9f07"
        },
        {
          "query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.517924",
          "mean_time_ms": "101.258962",
          "rows": "0",
          "Query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "985defa9"
        },
        {
          "query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.258962",
          "max_time_ms": "103.113763",
          "total_time_ms": "202.517924",
          "rows": "0",
          "Query": "COPY public.equipment_assignments (id, equipment_id, project_id, assigned_to, assigned_date, released_date, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "985defa9"
        },
        {
          "query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.514213",
          "mean_time_ms": "101.2571065",
          "rows": "0",
          "Query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0cdfc356"
        },
        {
          "query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.2571065",
          "max_time_ms": "103.900791",
          "total_time_ms": "202.514213",
          "rows": "0",
          "Query": "COPY public.bids (id, bid_package_id, vendor_id, amount, submitted_at, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0cdfc356"
        },
        {
          "query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.451113",
          "mean_time_ms": "101.2255565",
          "rows": "0",
          "Query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9d63facb"
        },
        {
          "query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.2255565",
          "max_time_ms": "103.772709",
          "total_time_ms": "202.451113",
          "rows": "0",
          "Query": "COPY public.accounts_payable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9d63facb"
        },
        {
          "query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.02539",
          "mean_time_ms": "101.012695",
          "rows": "0",
          "Query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "af8cfe10"
        },
        {
          "query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.012695",
          "max_time_ms": "103.267842",
          "total_time_ms": "202.02539",
          "rows": "0",
          "Query": "COPY public.vendor_contacts (id, vendor_id, name, email, phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "af8cfe10"
        },
        {
          "query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "202.014789",
          "mean_time_ms": "101.0073945",
          "rows": "0",
          "Query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "4aa64b10"
        },
        {
          "query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "101.0073945",
          "max_time_ms": "103.32245",
          "total_time_ms": "202.014789",
          "rows": "0",
          "Query": "COPY public.cost_codes (id, code, description, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "4aa64b10"
        },
        {
          "query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.994657",
          "mean_time_ms": "100.9973285",
          "rows": "0",
          "Query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ab6ea55e"
        },
        {
          "query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9973285",
          "max_time_ms": "102.47602",
          "total_time_ms": "201.994657",
          "rows": "0",
          "Query": "COPY public.sensor_data (id, project_id, data, collected_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ab6ea55e"
        },
        {
          "query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.979829",
          "mean_time_ms": "100.9899145",
          "rows": "0",
          "Query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ee687845"
        },
        {
          "query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9899145",
          "max_time_ms": "103.205074",
          "total_time_ms": "201.979829",
          "rows": "0",
          "Query": "COPY public.workflows (id, entity_schema, entity_table, entity_id, workflow_name, current_state, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "ee687845"
        },
        {
          "query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.977313",
          "mean_time_ms": "100.9886565",
          "rows": "0",
          "Query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "61246560"
        },
        {
          "query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9886565",
          "max_time_ms": "103.240863",
          "total_time_ms": "201.977313",
          "rows": "0",
          "Query": "COPY public.rfis (id, project_id, subject, status, question, answer, submitted_by, reviewed_by, submitted_at, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "61246560"
        },
        {
          "query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.95722",
          "mean_time_ms": "100.97861",
          "rows": "0",
          "Query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "725b8f3c"
        },
        {
          "query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.97861",
          "max_time_ms": "103.969483",
          "total_time_ms": "201.95722",
          "rows": "0",
          "Query": "COPY public.activity_logs (id, profile_id, activity_type, activity_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "725b8f3c"
        },
        {
          "query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.852303",
          "mean_time_ms": "100.9261515",
          "rows": "0",
          "Query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b9c2a293"
        },
        {
          "query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.9261515",
          "max_time_ms": "103.91475",
          "total_time_ms": "201.852303",
          "rows": "0",
          "Query": "COPY public.line_item_templates (id, name, formula, variables, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b9c2a293"
        },
        {
          "query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.743704",
          "mean_time_ms": "100.871852",
          "rows": "0",
          "Query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "63153467"
        },
        {
          "query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.871852",
          "max_time_ms": "103.079578",
          "total_time_ms": "201.743704",
          "rows": "0",
          "Query": "COPY public.wbs (id, project_id, name, location, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "63153467"
        },
        {
          "query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.709249",
          "mean_time_ms": "100.8546245",
          "rows": "0",
          "Query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a27fced0"
        },
        {
          "query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.8546245",
          "max_time_ms": "103.134612",
          "total_time_ms": "201.709249",
          "rows": "0",
          "Query": "COPY public.crew_assignments (id, crew_id, profile_id, assigned_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a27fced0"
        },
        {
          "query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.368563",
          "mean_time_ms": "100.6842815",
          "rows": "0",
          "Query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "11df5844"
        },
        {
          "query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.6842815",
          "max_time_ms": "103.245174",
          "total_time_ms": "201.368563",
          "rows": "0",
          "Query": "COPY public.meeting_minutes (id, project_id, meeting_date, notes, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "11df5844"
        },
        {
          "query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.250924",
          "mean_time_ms": "100.625462",
          "rows": "2",
          "Query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "Fingerprint": "c8e5bf36"
        },
        {
          "query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.625462",
          "max_time_ms": "102.487678",
          "total_time_ms": "201.250924",
          "rows": "2",
          "Query": "COPY public.profiles (id, email, full_name, phone, job_title_id, organization_id, avatar_url, created_at, updated_at, role, deleted_at) FROM stdin",
          "Fingerprint": "c8e5bf36"
        },
        {
          "query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.235425",
          "mean_time_ms": "100.6177125",
          "rows": "0",
          "Query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "Fingerprint": "254f4411"
        },
        {
          "query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.6177125",
          "max_time_ms": "103.226005",
          "total_time_ms": "201.235425",
          "rows": "0",
          "Query": "COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin",
          "Fingerprint": "254f4411"
        },
        {
          "query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "201.062897",
          "mean_time_ms": "100.5314485",
          "rows": "0",
          "Query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b24724cf"
        },
        {
          "query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.5314485",
          "max_time_ms": "103.15837",
          "total_time_ms": "201.062897",
          "rows": "0",
          "Query": "COPY public.vendor_qualifications (id, vendor_id, qualification_type, status, reviewed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b24724cf"
        },
        {
          "query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.595134",
          "mean_time_ms": "100.297567",
          "rows": "0",
          "Query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "762656ca"
        },
        {
          "query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.297567",
          "max_time_ms": "103.2202",
          "total_time_ms": "200.595134",
          "rows": "0",
          "Query": "COPY public.line_item_entries (id, line_item_id, date, quantity_completed, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "762656ca"
        },
        {
          "query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.491872",
          "mean_time_ms": "100.245936",
          "rows": "0",
          "Query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "d828f6ba"
        },
        {
          "query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.245936",
          "max_time_ms": "104.799331",
          "total_time_ms": "200.491872",
          "rows": "0",
          "Query": "COPY public.maps (id, wbs_id, project_id, name, description, coordinates, scope, order_num, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "d828f6ba"
        },
        {
          "query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.426622",
          "mean_time_ms": "100.213311",
          "rows": "0",
          "Query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9bf1c2fe"
        },
        {
          "query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.213311",
          "max_time_ms": "102.488242",
          "total_time_ms": "200.426622",
          "rows": "0",
          "Query": "COPY public.estimates (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9bf1c2fe"
        },
        {
          "query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.351478",
          "mean_time_ms": "100.175739",
          "rows": "0",
          "Query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dadb92a9"
        },
        {
          "query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.175739",
          "max_time_ms": "103.10024",
          "total_time_ms": "200.351478",
          "rows": "0",
          "Query": "COPY public.compliance_checks (id, project_id, check_date, description, result, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dadb92a9"
        },
        {
          "query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "calls": "2",
          "total_time_ms": "200.275125",
          "mean_time_ms": "100.1375625",
          "rows": "0",
          "Query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "Fingerprint": "cc50e652"
        },
        {
          "query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "calls": "2",
          "mean_time_ms": "100.1375625",
          "max_time_ms": "103.138458",
          "total_time_ms": "200.275125",
          "rows": "0",
          "Query": "COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin",
          "Fingerprint": "cc50e652"
        },
        {
          "query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "199.807887",
          "mean_time_ms": "99.9039435",
          "rows": "0",
          "Query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "06813e78"
        },
        {
          "query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.9039435",
          "max_time_ms": "104.654816",
          "total_time_ms": "199.807887",
          "rows": "0",
          "Query": "COPY public.subcontractor_agreements (id, subcontract_id, agreement_url, signed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "06813e78"
        },
        {
          "query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "total_time_ms": "199.698604",
          "mean_time_ms": "99.849302",
          "rows": "0",
          "Query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6c04fcb5"
        },
        {
          "query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.849302",
          "max_time_ms": "104.678428",
          "total_time_ms": "199.698604",
          "rows": "0",
          "Query": "COPY public.financial_documents (id, project_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6c04fcb5"
        },
        {
          "query": "COPY public.tack_rates (id, project_id, rate, material_type, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.832495",
          "max_time_ms": "101.546485",
          "total_time_ms": "199.66499",
          "rows": "0",
          "Query": "COPY public.tack_rates (id, project_id, rate, material_type, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "b0803b87"
        },
        {
          "query": "COPY public.audit_log (id, table_name, action, row_id, before_data, after_data, changed_by, changed_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.7842675",
          "max_time_ms": "103.065844",
          "total_time_ms": "199.568535",
          "rows": "0",
          "Query": "COPY public.audit_log (id, table_name, action, row_id, before_data, after_data, changed_by, changed_at, deleted_at) FROM stdin",
          "Fingerprint": "704b2583"
        },
        {
          "query": "COPY public.equipment_maintenance (id, equipment_id, maintenance_date, type, description, performed_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.463506",
          "max_time_ms": "103.164462",
          "total_time_ms": "198.927012",
          "rows": "0",
          "Query": "COPY public.equipment_maintenance (id, equipment_id, maintenance_date, type, description, performed_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6e8cab3d"
        },
        {
          "query": "COPY realtime.subscription (id, subscription_id, entity, filters, claims, created_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.4489215",
          "max_time_ms": "100.152143",
          "total_time_ms": "198.897843",
          "rows": "0",
          "Query": "COPY realtime.subscription (id, subscription_id, entity, filters, claims, created_at) FROM stdin",
          "Fingerprint": "b4bc70d0"
        },
        {
          "query": "COPY public.safety_incidents (id, project_id, incident_date, description, reported_by, severity, resolved, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.3453095",
          "max_time_ms": "103.06347",
          "total_time_ms": "198.690619",
          "rows": "0",
          "Query": "COPY public.safety_incidents (id, project_id, incident_date, description, reported_by, severity, resolved, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "dd094ff1"
        },
        {
          "query": "COPY public.user_projects (id, user_id, project_id, role, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.1600695",
          "max_time_ms": "103.175814",
          "total_time_ms": "198.320139",
          "rows": "0",
          "Query": "COPY public.user_projects (id, user_id, project_id, role, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6494210b"
        },
        {
          "query": "COPY auth.saml_relay_states (id, sso_provider_id, request_id, for_email, redirect_to, created_at, updated_at, flow_state_id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.1385155",
          "max_time_ms": "99.562381",
          "total_time_ms": "198.277031",
          "rows": "0",
          "Query": "COPY auth.saml_relay_states (id, sso_provider_id, request_id, for_email, redirect_to, created_at, updated_at, flow_state_id) FROM stdin",
          "Fingerprint": "ea71b0bd"
        },
        {
          "query": "COPY public.task_dependencies (id, task_id, depends_on_task_id, created_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.132069",
          "max_time_ms": "102.400731",
          "total_time_ms": "198.264138",
          "rows": "0",
          "Query": "COPY public.task_dependencies (id, task_id, depends_on_task_id, created_at, deleted_at) FROM stdin",
          "Fingerprint": "084a3cc5"
        },
        {
          "query": "COPY public.avatars (id, url, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.115221",
          "max_time_ms": "103.966743",
          "total_time_ms": "198.230442",
          "rows": "0",
          "Query": "COPY public.avatars (id, url, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "10445d5c"
        },
        {
          "query": "COPY auth.mfa_factors (id, user_id, friendly_name, factor_type, status, created_at, updated_at, secret, phone, last_challenged_at, web_authn_credential, web_authn_aaguid) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.090762",
          "max_time_ms": "99.429246",
          "total_time_ms": "198.181524",
          "rows": "0",
          "Query": "COPY auth.mfa_factors (id, user_id, friendly_name, factor_type, status, created_at, updated_at, secret, phone, last_challenged_at, web_authn_credential, web_authn_aaguid) FROM stdin",
          "Fingerprint": "cec579ea"
        },
        {
          "query": "COPY public.materials (id, organization_id, name, description, unit, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0780935",
          "max_time_ms": "99.630832",
          "total_time_ms": "198.156187",
          "rows": "0",
          "Query": "COPY public.materials (id, organization_id, name, description, unit, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "8aa4d8bf"
        },
        {
          "query": "COPY public.vendor_documents (id, vendor_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0703345",
          "max_time_ms": "99.378792",
          "total_time_ms": "198.140669",
          "rows": "0",
          "Query": "COPY public.vendor_documents (id, vendor_id, document_type, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "581b0829"
        },
        {
          "query": "COPY public.accounts_receivable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0671665",
          "max_time_ms": "103.27019",
          "total_time_ms": "198.134333",
          "rows": "0",
          "Query": "COPY public.accounts_receivable (id, project_id, amount_due, due_date, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "1ecde75f"
        },
        {
          "query": "COPY public.daily_logs (id, project_id, date, weather, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.035697",
          "max_time_ms": "99.361033",
          "total_time_ms": "198.071394",
          "rows": "0",
          "Query": "COPY public.daily_logs (id, project_id, date, weather, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "5c027ac6"
        },
        {
          "query": "COPY auth.identities (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0258625",
          "max_time_ms": "99.488222",
          "total_time_ms": "198.051725",
          "rows": "0",
          "Query": "COPY auth.identities (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, id) FROM stdin",
          "Fingerprint": "58196849"
        },
        {
          "query": "COPY auth.flow_state (id, user_id, auth_code, code_challenge_method, code_challenge, provider_type, provider_access_token, provider_refresh_token, created_at, updated_at, authentication_method, auth_code_issued_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.0232145",
          "max_time_ms": "103.023291",
          "total_time_ms": "198.046429",
          "rows": "0",
          "Query": "COPY auth.flow_state (id, user_id, auth_code, code_challenge_method, code_challenge, provider_type, provider_access_token, provider_refresh_token, created_at, updated_at, authentication_method, auth_code_issued_at) FROM stdin",
          "Fingerprint": "5fc5c63b"
        },
        {
          "query": "COPY auth.mfa_amr_claims (session_id, created_at, updated_at, authentication_method, id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.008733",
          "max_time_ms": "103.181295",
          "total_time_ms": "198.017466",
          "rows": "0",
          "Query": "COPY auth.mfa_amr_claims (session_id, created_at, updated_at, authentication_method, id) FROM stdin",
          "Fingerprint": "7760a2e4"
        },
        {
          "query": "COPY public.organization_projects (id, organization_id, project_id, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "99.003132",
          "max_time_ms": "99.318153",
          "total_time_ms": "198.006264",
          "rows": "0",
          "Query": "COPY public.organization_projects (id, organization_id, project_id, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "3059abb3"
        },
        {
          "query": "COPY auth.refresh_tokens (instance_id, id, token, user_id, revoked, created_at, updated_at, parent, session_id) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.947378",
          "max_time_ms": "99.36111",
          "total_time_ms": "197.894756",
          "rows": "0",
          "Query": "COPY auth.refresh_tokens (instance_id, id, token, user_id, revoked, created_at, updated_at, parent, session_id) FROM stdin",
          "Fingerprint": "5780d9c8"
        },
        {
          "query": "-- QUERY 3: RLS policies + table grants + routine grants (single JSON output)\nWITH tbl AS (\n  SELECT\n    c.oid                                 AS table_oid,\n    n.nspname                             AS schema_name,\n    c.relname                             AS table_name,\n    c.relrowsecurity                      AS rls_enabled,\n    c.relforcerowsecurity                 AS rls_forced\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $1\n    AND n.nspname IN ($2, $3)\n),\npol AS (\n  SELECT\n    schemaname,\n    tablename,\n    jsonb_agg(\n      jsonb_build_object(\n        $4, policyname,\n        $5, permissive,\n        $6, roles,\n        $7, cmd,\n        $8, qual,\n        $9, with_check\n      )\n      ORDER BY policyname\n    ) AS policies\n  FROM pg_policies\n  WHERE schemaname IN ($10, $11)\n  GROUP BY schemaname, tablename\n),\ntable_grants AS (\n  SELECT\n    table_schema,\n    table_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $12, grantee,\n        $13, privilege_type,\n        $14, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_table_grants\n  WHERE table_schema IN ($15, $16)\n  GROUP BY table_schema, table_name\n),\nroutine_grants AS (\n  SELECT\n    routine_schema,\n    routine_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $17, grantee,\n        $18, privilege_type,\n        $19, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_routine_grants\n  WHERE routine_schema IN ($20, $21)\n  GROUP BY routine_schema, routine_name\n)\nSELECT jsonb_build_object(\n  $22, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $23, t.schema_name,\n        $24, t.table_name,\n        $25, t.rls_enabled,\n        $26, t.rls_forced,\n        $27, COALESCE(p.policies, $28::jsonb),\n        $29, COALESCE(g.grants, $30::jsonb)\n      )\n      ORDER BY t.schema_name, t.table_name\n    )\n    FROM tbl t\n    LEFT JOIN pol p\n      ON p.schemaname = t.schema_name AND p.tablename = t.table_name\n    LEFT JOIN table_grants g\n      ON g.table_schema = t.schema_name AND g.table_name = t.table_name\n  ),\n  $31, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $32, rg.routine_schema,\n        $33, rg.routine_name,\n        $34, rg.grants\n      )\n      ORDER BY rg.routine_schema, rg.routine_name\n    )\n    FROM routine_grants rg\n  )\n) AS security_dump",
          "calls": "1",
          "mean_time_ms": "197.888901",
          "max_time_ms": "197.888901",
          "total_time_ms": "197.888901",
          "rows": "1",
          "Query": "-- QUERY 3: RLS policies + table grants + routine grants (single JSON output)\nWITH tbl AS (\n  SELECT\n    c.oid                                 AS table_oid,\n    n.nspname                             AS schema_name,\n    c.relname                             AS table_name,\n    c.relrowsecurity                      AS rls_enabled,\n    c.relforcerowsecurity                 AS rls_forced\n  FROM pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\n  WHERE c.relkind = $1\n    AND n.nspname IN ($2, $3)\n),\npol AS (\n  SELECT\n    schemaname,\n    tablename,\n    jsonb_agg(\n      jsonb_build_object(\n        $4, policyname,\n        $5, permissive,\n        $6, roles,\n        $7, cmd,\n        $8, qual,\n        $9, with_check\n      )\n      ORDER BY policyname\n    ) AS policies\n  FROM pg_policies\n  WHERE schemaname IN ($10, $11)\n  GROUP BY schemaname, tablename\n),\ntable_grants AS (\n  SELECT\n    table_schema,\n    table_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $12, grantee,\n        $13, privilege_type,\n        $14, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_table_grants\n  WHERE table_schema IN ($15, $16)\n  GROUP BY table_schema, table_name\n),\nroutine_grants AS (\n  SELECT\n    routine_schema,\n    routine_name,\n    jsonb_agg(\n      jsonb_build_object(\n        $17, grantee,\n        $18, privilege_type,\n        $19, is_grantable\n      )\n      ORDER BY grantee, privilege_type\n    ) AS grants\n  FROM information_schema.role_routine_grants\n  WHERE routine_schema IN ($20, $21)\n  GROUP BY routine_schema, routine_name\n)\nSELECT jsonb_build_object(\n  $22, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $23, t.schema_name,\n        $24, t.table_name,\n        $25, t.rls_enabled,\n        $26, t.rls_forced,\n        $27, COALESCE(p.policies, $28::jsonb),\n        $29, COALESCE(g.grants, $30::jsonb)\n      )\n      ORDER BY t.schema_name, t.table_name\n    )\n    FROM tbl t\n    LEFT JOIN pol p\n      ON p.schemaname = t.schema_name AND p.tablename = t.table_name\n    LEFT JOIN table_grants g\n      ON g.table_schema = t.schema_name AND g.table_name = t.table_name\n  ),\n  $31, (\n    SELECT jsonb_agg(\n      jsonb_build_object(\n        $32, rg.routine_schema,\n        $33, rg.routine_name,\n        $34, rg.grants\n      )\n      ORDER BY rg.routine_schema, rg.routine_name\n    )\n    FROM routine_grants rg\n  )\n) AS security_dump",
          "Fingerprint": "0a80504f"
        },
        {
          "query": "COPY public.labor_records (id, line_item_id, worker_count, hours_worked, work_date, work_type, notes, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.9292225",
          "max_time_ms": "99.371704",
          "total_time_ms": "197.858445",
          "rows": "0",
          "Query": "COPY public.labor_records (id, line_item_id, worker_count, hours_worked, work_date, work_type, notes, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "456f60d1"
        },
        {
          "query": "COPY public.material_inventory (id, material_id, organization_id, quantity, last_updated, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.928901",
          "max_time_ms": "102.343097",
          "total_time_ms": "197.857802",
          "rows": "0",
          "Query": "COPY public.material_inventory (id, material_id, organization_id, quantity, last_updated, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "6ac46892"
        },
        {
          "query": "COPY auth.sso_providers (id, resource_id, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.885203",
          "max_time_ms": "99.914739",
          "total_time_ms": "197.770406",
          "rows": "0",
          "Query": "COPY auth.sso_providers (id, resource_id, created_at, updated_at) FROM stdin",
          "Fingerprint": "e3bc4723"
        },
        {
          "query": "COPY public.vendors (id, organization_id, name, status, contact_email, contact_phone, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7803365",
          "max_time_ms": "103.249249",
          "total_time_ms": "197.560673",
          "rows": "0",
          "Query": "COPY public.vendors (id, organization_id, name, status, contact_email, contact_phone, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "24075ca8"
        },
        {
          "query": "COPY public.change_orders (id, project_id, number, description, status, amount, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7662585",
          "max_time_ms": "98.798355",
          "total_time_ms": "197.532517",
          "rows": "0",
          "Query": "COPY public.change_orders (id, project_id, number, description, status, amount, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "5882c02d"
        },
        {
          "query": "COPY public.photos (id, project_id, url, caption, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7259615",
          "max_time_ms": "98.798059",
          "total_time_ms": "197.451923",
          "rows": "0",
          "Query": "COPY public.photos (id, project_id, url, caption, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "99b591f2"
        },
        {
          "query": "COPY public.bid_packages (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.715568",
          "max_time_ms": "98.786265",
          "total_time_ms": "197.431136",
          "rows": "0",
          "Query": "COPY public.bid_packages (id, project_id, name, status, created_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "33db00f2"
        },
        {
          "query": "COPY public.bim_models (id, project_id, name, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7117465",
          "max_time_ms": "103.064154",
          "total_time_ms": "197.423493",
          "rows": "0",
          "Query": "COPY public.bim_models (id, project_id, name, url, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "7cbd4961"
        },
        {
          "query": "COPY public.commitments (id, project_id, vendor_id, type, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7070115",
          "max_time_ms": "103.115353",
          "total_time_ms": "197.414023",
          "rows": "0",
          "Query": "COPY public.commitments (id, project_id, vendor_id, type, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "95986b7c"
        },
        {
          "query": "COPY public.material_receipts (id, material_order_id, received_date, quantity, received_by, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.7029815",
          "max_time_ms": "98.706456",
          "total_time_ms": "197.405963",
          "rows": "0",
          "Query": "COPY public.material_receipts (id, material_order_id, received_date, quantity, received_by, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a41d9dfa"
        },
        {
          "query": "COPY public.crew_members (id, crew_id, profile_id, role, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6990605",
          "max_time_ms": "98.739759",
          "total_time_ms": "197.398121",
          "rows": "0",
          "Query": "COPY public.crew_members (id, crew_id, profile_id, role, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "c052cb3d"
        },
        {
          "query": "COPY public.drawing_versions (id, document_id, version, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.683518",
          "max_time_ms": "103.134743",
          "total_time_ms": "197.367036",
          "rows": "0",
          "Query": "COPY public.drawing_versions (id, document_id, version, uploaded_by, uploaded_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0b26fcaa"
        },
        {
          "query": "COPY public.dashboard_configs (id, profile_id, config, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6810585",
          "max_time_ms": "98.724536",
          "total_time_ms": "197.362117",
          "rows": "0",
          "Query": "COPY public.dashboard_configs (id, profile_id, config, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "1cd42ea2"
        },
        {
          "query": "COPY public.training_records (id, employee_id, training_type, completion_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.663368",
          "max_time_ms": "98.676634",
          "total_time_ms": "197.326736",
          "rows": "0",
          "Query": "COPY public.training_records (id, employee_id, training_type, completion_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "58dd9afa"
        },
        {
          "query": "COPY public.certifications (id, employee_id, certification_type, issue_date, expiry_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6559805",
          "max_time_ms": "103.158594",
          "total_time_ms": "197.311961",
          "rows": "0",
          "Query": "COPY public.certifications (id, employee_id, certification_type, issue_date, expiry_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "278a4a8b"
        },
        {
          "query": "COPY auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, invited_at, confirmation_token, confirmation_sent_at, recovery_token, recovery_sent_at, email_change_token_new, email_change, email_change_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, is_super_admin, created_at, updated_at, phone, phone_confirmed_at, phone_change, phone_change_token, phone_change_sent_at, email_change_token_current, email_change_confirm_status, banned_until, reauthentication_token, reauthentication_sent_at, is_sso_user, deleted_at, is_anonymous) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6528365",
          "max_time_ms": "102.373345",
          "total_time_ms": "197.305673",
          "rows": "0",
          "Query": "COPY auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, invited_at, confirmation_token, confirmation_sent_at, recovery_token, recovery_sent_at, email_change_token_new, email_change, email_change_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, is_super_admin, created_at, updated_at, phone, phone_confirmed_at, phone_change, phone_change_token, phone_change_sent_at, email_change_token_current, email_change_confirm_status, banned_until, reauthentication_token, reauthentication_sent_at, is_sso_user, deleted_at, is_anonymous) FROM stdin",
          "Fingerprint": "43fa7093"
        },
        {
          "query": "COPY auth.saml_providers (id, sso_provider_id, entity_id, metadata_xml, metadata_url, attribute_mapping, created_at, updated_at, name_id_format) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.617569",
          "max_time_ms": "98.653057",
          "total_time_ms": "197.235138",
          "rows": "0",
          "Query": "COPY auth.saml_providers (id, sso_provider_id, entity_id, metadata_xml, metadata_url, attribute_mapping, created_at, updated_at, name_id_format) FROM stdin",
          "Fingerprint": "66acf199"
        },
        {
          "query": "COPY public.audit_logs (id, project_id, action, performed_by, performed_at, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.6151865",
          "max_time_ms": "100.978198",
          "total_time_ms": "197.230373",
          "rows": "0",
          "Query": "COPY public.audit_logs (id, project_id, action, performed_by, performed_at, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "a3eec967"
        },
        {
          "query": "COPY public.job_titles (id, name, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.60715",
          "max_time_ms": "98.828301",
          "total_time_ms": "197.2143",
          "rows": "0",
          "Query": "COPY public.job_titles (id, name, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "0327482d"
        },
        {
          "query": "COPY public.project_inspectors (project_id, profile_id, assigned_by, assigned_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3914115",
          "max_time_ms": "100.102467",
          "total_time_ms": "196.782823",
          "rows": "0",
          "Query": "COPY public.project_inspectors (project_id, profile_id, assigned_by, assigned_at, deleted_at) FROM stdin",
          "Fingerprint": "49a305d5"
        },
        {
          "query": "COPY public.projects (id, organization_id, name, description, status, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.381776",
          "max_time_ms": "98.711193",
          "total_time_ms": "196.763552",
          "rows": "0",
          "Query": "COPY public.projects (id, organization_id, name, description, status, start_date, end_date, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "87734e8e"
        },
        {
          "query": "COPY public.integration_tokens (id, profile_id, service_name, token, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3527905",
          "max_time_ms": "102.481523",
          "total_time_ms": "196.705581",
          "rows": "0",
          "Query": "COPY public.integration_tokens (id, profile_id, service_name, token, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "abb0fc43"
        },
        {
          "query": "COPY auth.one_time_tokens (id, user_id, token_type, token_hash, relates_to, created_at, updated_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3484635",
          "max_time_ms": "98.649517",
          "total_time_ms": "196.696927",
          "rows": "0",
          "Query": "COPY auth.one_time_tokens (id, user_id, token_type, token_hash, relates_to, created_at, updated_at) FROM stdin",
          "Fingerprint": "0a6c105b"
        },
        {
          "query": "COPY public.progress_billings (id, project_id, billing_number, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.3037135",
          "max_time_ms": "101.629248",
          "total_time_ms": "196.607427",
          "rows": "0",
          "Query": "COPY public.progress_billings (id, project_id, billing_number, amount, status, created_at, updated_at, deleted_at) FROM stdin",
          "Fingerprint": "9f3aca0f"
        },
        {
          "query": "COPY public.task_status_logs (task_id, status, changed_at, deleted_at) FROM stdin",
          "calls": "2",
          "mean_time_ms": "98.2796635",
          "max_time_ms": "98.631252",
          "total_time_ms": "196.559327",
          "rows": "0",
          "Query": "COPY public.task_status_logs (task_id, status, changed_at, deleted_at) FROM stdin",
          "Fingerprint": "9b0f587c"
        },
        {
          "query": "-- Org Dashboard foundations (service areas, member rates, project invites)\n\n-- [REF: org_dashboard_foundations START]\n\nCREATE TABLE IF NOT EXISTS public.organization_service_areas (\n    id uuid DEFAULT gen_random_uuid() NOT NULL,\n    organization_id uuid NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,\n    service_area_text text NOT NULL,\n    created_at timestamp with time zone DEFAULT now() NOT NULL,\n    updated_at timestamp with time zone DEFAULT now() NOT NULL,\n    CONSTRAINT organization_service_areas_pkey PRIMARY KEY (id)\n)",
          "calls": "1",
          "mean_time_ms": "189.125765",
          "max_time_ms": "189.125765",
          "total_time_ms": "189.125765",
          "rows": "0",
          "Query": "-- Org Dashboard foundations (service areas, member rates, project invites)\n\n-- [REF: org_dashboard_foundations START]\n\nCREATE TABLE IF NOT EXISTS public.organization_service_areas (\n    id uuid DEFAULT gen_random_uuid() NOT NULL,\n    organization_id uuid NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,\n    service_area_text text NOT NULL,\n    created_at timestamp with time zone DEFAULT now() NOT NULL,\n    updated_at timestamp with time zone DEFAULT now() NOT NULL,\n    CONSTRAINT organization_service_areas_pkey PRIMARY KEY (id)\n)",
          "Fingerprint": "08d5b208"
        },
        {
          "query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
          "calls": "2388",
          "total_time_ms": "167.845012000001",
          "rows": "2388",
          "Query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
          "Fingerprint": "7174daf9"
        },
        {
          "query": "with jwt as (\n  select\n    set_config($1, $2, $3) as a,\n    set_config($4, $5, $6) as b,\n    set_config(\n      $7,\n      format($8, $9),\n      $10\n    ) as c\n),\ncheck_auth as (\n  select auth.uid() as uid\n  from jwt\n),\np as (\n  select public.rpc_org_dashboard_payload(\n    $11::uuid,\n    $12,\n    $13\n  ) as payload\n  from check_auth\n)\nselect\n  (select uid from check_auth) as uid,\n  (select payload from p) as payload",
          "calls": "1",
          "mean_time_ms": "139.849526",
          "max_time_ms": "139.849526",
          "total_time_ms": "139.849526",
          "rows": "1",
          "Query": "with jwt as (\n  select\n    set_config($1, $2, $3) as a,\n    set_config($4, $5, $6) as b,\n    set_config(\n      $7,\n      format($8, $9),\n      $10\n    ) as c\n),\ncheck_auth as (\n  select auth.uid() as uid\n  from jwt\n),\np as (\n  select public.rpc_org_dashboard_payload(\n    $11::uuid,\n    $12,\n    $13\n  ) as payload\n  from check_auth\n)\nselect\n  (select uid from check_auth) as uid,\n  (select payload from p) as payload",
          "Fingerprint": "c71951cc"
        },
        {
          "query": "-- Safe org-scoped profile list for UI pickers\n\nCREATE OR REPLACE FUNCTION public.get_my_org_profiles_minimal()\nRETURNS TABLE (\n  id uuid,\n  email text,\n  full_name text,\n  avatar_url text\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  v_user_id uuid;\n  v_org_id uuid;\nBEGIN\n  v_user_id := auth.uid();\n  IF v_user_id IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  SELECT organization_id\n    INTO v_org_id\n  FROM public.profiles\n  WHERE id = v_user_id;\n\n  IF v_org_id IS NULL THEN\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  SELECT p.id, p.email, p.full_name, p.avatar_url\n  FROM public.profiles p\n  WHERE p.organization_id = v_org_id;\nEND;\n$$",
          "calls": "1",
          "mean_time_ms": "135.089398",
          "max_time_ms": "135.089398",
          "total_time_ms": "135.089398",
          "rows": "0",
          "Query": "-- Safe org-scoped profile list for UI pickers\n\nCREATE OR REPLACE FUNCTION public.get_my_org_profiles_minimal()\nRETURNS TABLE (\n  id uuid,\n  email text,\n  full_name text,\n  avatar_url text\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  v_user_id uuid;\n  v_org_id uuid;\nBEGIN\n  v_user_id := auth.uid();\n  IF v_user_id IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  SELECT organization_id\n    INTO v_org_id\n  FROM public.profiles\n  WHERE id = v_user_id;\n\n  IF v_org_id IS NULL THEN\n    RETURN;\n  END IF;\n\n  RETURN QUERY\n  SELECT p.id, p.email, p.full_name, p.avatar_url\n  FROM public.profiles p\n  WHERE p.organization_id = v_org_id;\nEND;\n$$",
          "Fingerprint": "9ba4385f"
        },
        {
          "query": "-- Public-safe RPCs for onboarding job titles\n\ncreate or replace function public.get_job_titles_public()\nreturns setof public.job_titles\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\nbegin\n  return query\n  select *\n  from public.job_titles\n  where deleted_at is null\n  order by name asc;\nend;\n$$",
          "calls": "1",
          "mean_time_ms": "117.711826",
          "max_time_ms": "117.711826",
          "total_time_ms": "117.711826",
          "rows": "0",
          "Query": "-- Public-safe RPCs for onboarding job titles\n\ncreate or replace function public.get_job_titles_public()\nreturns setof public.job_titles\nlanguage plpgsql\nsecurity definer\nset search_path = public\nas $$\nbegin\n  return query\n  select *\n  from public.job_titles\n  where deleted_at is null\n  order by name asc;\nend;\n$$",
          "Fingerprint": "08882903"
        },
        {
          "query": "-- =======================\n-- START PATCH: filter_projects hotfix\n-- =======================\n\nCREATE OR REPLACE FUNCTION public.filter_projects(\n  _filters jsonb DEFAULT '{}'::jsonb,\n  _select_cols text[] DEFAULT NULL::text[],\n  _order_by text DEFAULT 'id'::text,\n  _direction text DEFAULT 'asc'::text,\n  _limit integer DEFAULT NULL::integer,\n  _offset integer DEFAULT NULL::integer\n) RETURNS SETOF public.projects\nLANGUAGE plpgsql STABLE\nSET search_path TO 'public', 'pg_temp'\nAS $$\nDECLARE\n  _project_id      uuid;\n  _organization_id uuid;\n  _where           text := 'deleted_at IS NULL';\n  kv               record;\n  sqltxt           text;\n  dir              text := lower(coalesce(_direction, 'asc'));\n  v_text           text;\nBEGIN\n  -- Normalize filters to an object\n  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN\n    _filters := '{}'::jsonb;\n  END IF;\n\n  -- Safe casts (avoid \"\" -> uuid crash)\n  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;\n  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;\n\n  -- Access check (RLS still applies)\n  PERFORM check_access('select', 'projects', _project_id, _organization_id);\n\n  -- Build WHERE from filters (ignore special keys)\n  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP\n    IF kv.key NOT IN ('project_id', 'organization_id') THEN\n\n      -- JSON null\n      IF kv.value = 'null'::jsonb THEN\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' IS NULL';\n\n      ELSIF jsonb_typeof(kv.value) = 'object' THEN\n        IF (kv.value ? '$gte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' >= '  || quote_literal(kv.value->>'$gte');\n        END IF;\n\n        IF (kv.value ? '$lte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' <= '  || quote_literal(kv.value->>'$lte');\n        END IF;\n\n        IF (kv.value ? '$ilike') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' ILIKE ' || quote_literal(kv.value->>'$ilike');\n        END IF;\n\n        IF (kv.value ? '$in') THEN\n          -- col::text = ANY(text[])\n          _where := _where\n            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('\n            || 'ARRAY(SELECT jsonb_array_elements_text('\n            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';\n        END IF;\n\n      ELSE\n        -- Primitive value: use #>> '{}' to avoid JSON quoting issues\n        v_text := kv.value #>> '{}';\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' = '   || quote_literal(v_text);\n      END IF;\n    END IF;\n  END LOOP;\n\n  -- Validate order_by\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name   = 'projects'\n      AND column_name  = _order_by\n  ) THEN\n    RAISE EXCEPTION 'unknown order_by column'\n      USING DETAIL = jsonb_build_object('column', _order_by);\n  END IF;\n\n  -- Clamp direction\n  IF dir NOT IN ('asc', 'desc') THEN\n    dir := 'asc';\n  END IF;\n\n  -- Always return full row to match RETURNS SETOF public.projects\n  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where\n         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;\n\n  IF _limit IS NOT NULL THEN\n    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);\n  END IF;\n\n  IF _offset IS NOT NULL THEN\n    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);\n  END IF;\n\n  RETURN QUERY EXECUTE sqltxt;\nEND;\n$$",
          "calls": "1",
          "mean_time_ms": "115.277807",
          "max_time_ms": "115.277807",
          "total_time_ms": "115.277807",
          "rows": "0",
          "Query": "-- =======================\n-- START PATCH: filter_projects hotfix\n-- =======================\n\nCREATE OR REPLACE FUNCTION public.filter_projects(\n  _filters jsonb DEFAULT '{}'::jsonb,\n  _select_cols text[] DEFAULT NULL::text[],\n  _order_by text DEFAULT 'id'::text,\n  _direction text DEFAULT 'asc'::text,\n  _limit integer DEFAULT NULL::integer,\n  _offset integer DEFAULT NULL::integer\n) RETURNS SETOF public.projects\nLANGUAGE plpgsql STABLE\nSET search_path TO 'public', 'pg_temp'\nAS $$\nDECLARE\n  _project_id      uuid;\n  _organization_id uuid;\n  _where           text := 'deleted_at IS NULL';\n  kv               record;\n  sqltxt           text;\n  dir              text := lower(coalesce(_direction, 'asc'));\n  v_text           text;\nBEGIN\n  -- Normalize filters to an object\n  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN\n    _filters := '{}'::jsonb;\n  END IF;\n\n  -- Safe casts (avoid \"\" -> uuid crash)\n  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;\n  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;\n\n  -- Access check (RLS still applies)\n  PERFORM check_access('select', 'projects', _project_id, _organization_id);\n\n  -- Build WHERE from filters (ignore special keys)\n  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP\n    IF kv.key NOT IN ('project_id', 'organization_id') THEN\n\n      -- JSON null\n      IF kv.value = 'null'::jsonb THEN\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' IS NULL';\n\n      ELSIF jsonb_typeof(kv.value) = 'object' THEN\n        IF (kv.value ? '$gte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' >= '  || quote_literal(kv.value->>'$gte');\n        END IF;\n\n        IF (kv.value ? '$lte') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' <= '  || quote_literal(kv.value->>'$lte');\n        END IF;\n\n        IF (kv.value ? '$ilike') THEN\n          _where := _where\n            || ' AND ' || quote_ident(kv.key)\n            || ' ILIKE ' || quote_literal(kv.value->>'$ilike');\n        END IF;\n\n        IF (kv.value ? '$in') THEN\n          -- col::text = ANY(text[])\n          _where := _where\n            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('\n            || 'ARRAY(SELECT jsonb_array_elements_text('\n            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';\n        END IF;\n\n      ELSE\n        -- Primitive value: use #>> '{}' to avoid JSON quoting issues\n        v_text := kv.value #>> '{}';\n        _where := _where\n          || ' AND ' || quote_ident(kv.key)\n          || ' = '   || quote_literal(v_text);\n      END IF;\n    END IF;\n  END LOOP;\n\n  -- Validate order_by\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name   = 'projects'\n      AND column_name  = _order_by\n  ) THEN\n    RAISE EXCEPTION 'unknown order_by column'\n      USING DETAIL = jsonb_build_object('column', _order_by);\n  END IF;\n\n  -- Clamp direction\n  IF dir NOT IN ('asc', 'desc') THEN\n    dir := 'asc';\n  END IF;\n\n  -- Always return full row to match RETURNS SETOF public.projects\n  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where\n         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;\n\n  IF _limit IS NOT NULL THEN\n    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);\n  END IF;\n\n  IF _offset IS NOT NULL THEN\n    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);\n  END IF;\n\n  RETURN QUERY EXECUTE sqltxt;\nEND;\n$$",
          "Fingerprint": "b4425b85"
        },
        {
          "query": "COPY auth.audit_log_entries (instance_id, id, payload, created_at, ip_address) FROM stdin",
          "calls": "1",
          "mean_time_ms": "111.033599",
          "max_time_ms": "111.033599",
          "total_time_ms": "111.033599",
          "rows": "34",
          "Query": "COPY auth.audit_log_entries (instance_id, id, payload, created_at, ip_address) FROM stdin",
          "Fingerprint": "f285a55e"
        },
        {
          "query": "SELECT sessions.aal, sessions.created_at, sessions.factor_id, sessions.id, sessions.ip, sessions.not_after, sessions.oauth_client_id, sessions.refresh_token_counter, sessions.refresh_token_hmac_key, sessions.refreshed_at, sessions.scopes, sessions.tag, sessions.updated_at, sessions.user_agent, sessions.user_id FROM sessions AS sessions WHERE id = $1 LIMIT $2",
          "calls": "609",
          "total_time_ms": "108.247794",
          "rows": "609",
          "Query": "SELECT sessions.aal, sessions.created_at, sessions.factor_id, sessions.id, sessions.ip, sessions.not_after, sessions.oauth_client_id, sessions.refresh_token_counter, sessions.refresh_token_hmac_key, sessions.refreshed_at, sessions.scopes, sessions.tag, sessions.updated_at, sessions.user_agent, sessions.user_id FROM sessions AS sessions WHERE id = $1 LIMIT $2",
          "Fingerprint": "57f49ab9"
        },
        {
          "query": "COPY storage.buckets (id, name, owner, created_at, updated_at, public, avif_autodetection, file_size_limit, allowed_mime_types, owner_id) FROM stdin",
          "calls": "1",
          "mean_time_ms": "106.702244",
          "max_time_ms": "106.702244",
          "total_time_ms": "106.702244",
          "rows": "2",
          "Query": "COPY storage.buckets (id, name, owner, created_at, updated_at, public, avif_autodetection, file_size_limit, allowed_mime_types, owner_id) FROM stdin",
          "Fingerprint": "af783faf"
        },
        {
          "query": "select setting from pg_config where name = $1",
          "calls": "548",
          "total_time_ms": "101.908625",
          "rows": "548",
          "Query": "select setting from pg_config where name = $1",
          "Fingerprint": "4fe9ed11"
        },
        {
          "query": "WITH\nrole_setting AS (\n  SELECT setdatabase as database,\n         unnest(setconfig) as setting\n  FROM pg_catalog.pg_db_role_setting\n  WHERE setrole = CURRENT_USER::regrole::oid\n    AND setdatabase IN ($2, (SELECT oid FROM pg_catalog.pg_database WHERE datname = CURRENT_CATALOG))\n),\nkv_settings AS (\n  SELECT database,\n         substr(setting, $3, strpos(setting, $4) - $5) as k,\n         substr(setting, strpos(setting, $6) + $7) as v\n  FROM role_setting\n  \n)\nSELECT DISTINCT ON (key)\n       replace(k, $8, $9) AS key,\n       v AS value\nFROM kv_settings\nWHERE k = ANY($1) AND v IS NOT NULL\nORDER BY key, database DESC NULLS LAST",
          "calls": "1397",
          "total_time_ms": "92.493663",
          "rows": "0",
          "Query": "WITH\nrole_setting AS (\n  SELECT setdatabase as database,\n         unnest(setconfig) as setting\n  FROM pg_catalog.pg_db_role_setting\n  WHERE setrole = CURRENT_USER::regrole::oid\n    AND setdatabase IN ($2, (SELECT oid FROM pg_catalog.pg_database WHERE datname = CURRENT_CATALOG))\n),\nkv_settings AS (\n  SELECT database,\n         substr(setting, $3, strpos(setting, $4) - $5) as k,\n         substr(setting, strpos(setting, $6) + $7) as v\n  FROM role_setting\n  \n)\nSELECT DISTINCT ON (key)\n       replace(k, $8, $9) AS key,\n       v AS value\nFROM kv_settings\nWHERE k = ANY($1) AND v IS NOT NULL\nORDER BY key, database DESC NULLS LAST",
          "Fingerprint": "3a2c1e7e"
        },
        {
          "query": "SELECT identities.created_at, identities.email, identities.id, identities.identity_data, identities.last_sign_in_at, identities.provider, identities.provider_id, identities.updated_at, identities.user_id FROM identities AS identities WHERE user_id = $1",
          "calls": "605",
          "total_time_ms": "75.081424",
          "rows": "605",
          "Query": "SELECT identities.created_at, identities.email, identities.id, identities.identity_data, identities.last_sign_in_at, identities.provider, identities.provider_id, identities.updated_at, identities.user_id FROM identities AS identities WHERE user_id = $1",
          "Fingerprint": "85b8dd01"
        },
        {
          "query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and id = $2 LIMIT $3",
          "calls": "560",
          "total_time_ms": "74.639599",
          "rows": "551",
          "Query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and id = $2 LIMIT $3",
          "Fingerprint": "35e8447e"
        },
        {
          "query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "calls": "49",
          "total_time_ms": "69.16763",
          "rows": "49",
          "Query": "WITH pgrst_source AS (SELECT \"pgrst_call\".* FROM \"public\".\"get_my_profile\"() pgrst_call) SELECT $3::bigint AS total_result_set, $4 AS page_total, coalesce(json_agg(_postgrest_t)->$5, $6) AS body, nullif(current_setting($7, $8), $9) AS response_headers, nullif(current_setting($10, $11), $12) AS response_status, $13 AS response_inserted FROM (SELECT \"profiles\".* FROM \"pgrst_source\" AS \"profiles\"   LIMIT $1 OFFSET $2) _postgrest_t",
          "Fingerprint": "1b25acd9"
        },
        {
          "query": "INSERT INTO mfa_amr_claims(id, session_id, created_at, updated_at, authentication_method) values ($1, $2, $3, $4, $5)\n\t\t\tON CONFLICT ON CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey\n\t\t\tDO UPDATE SET updated_at = $6",
          "calls": "60",
          "total_time_ms": "68.695646",
          "rows": "60",
          "Query": "INSERT INTO mfa_amr_claims(id, session_id, created_at, updated_at, authentication_method) values ($1, $2, $3, $4, $5)\n\t\t\tON CONFLICT ON CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey\n\t\t\tDO UPDATE SET updated_at = $6",
          "Fingerprint": "b3c191e7"
        },
        {
          "query": "UPDATE \"users\" AS users SET \"last_sign_in_at\" = $1, \"updated_at\" = $2 WHERE users.id = $3",
          "calls": "69",
          "total_time_ms": "44.248527",
          "rows": "69",
          "Query": "UPDATE \"users\" AS users SET \"last_sign_in_at\" = $1, \"updated_at\" = $2 WHERE users.id = $3",
          "Fingerprint": "c94cfe49"
        },
        {
          "query": "SHOW transaction_read_only",
          "calls": "1644",
          "total_time_ms": "40.2912989999999",
          "rows": "0",
          "Query": "SHOW transaction_read_only",
          "Fingerprint": "e52c5054"
        },
        {
          "query": "SELECT\n          set_config('role', $1, true),\n          set_config('request.jwt.claim.role', $2, true),\n          set_config('request.jwt', $3, true),\n          set_config('request.jwt.claim.sub', $4, true),\n          set_config('request.jwt.claims', $5, true),\n          set_config('request.headers', $6, true),\n          set_config('request.method', $7, true),\n          set_config('request.path', $8, true),\n          set_config('storage.operation', $9, true)",
          "calls": "290",
          "total_time_ms": "39.868987",
          "rows": "290",
          "Query": "SELECT\n          set_config('role', $1, true),\n          set_config('request.jwt.claim.role', $2, true),\n          set_config('request.jwt', $3, true),\n          set_config('request.jwt.claim.sub', $4, true),\n          set_config('request.jwt.claims', $5, true),\n          set_config('request.headers', $6, true),\n          set_config('request.method', $7, true),\n          set_config('request.path', $8, true),\n          set_config('storage.operation', $9, true)",
          "Fingerprint": "88c09e41"
        },
        {
          "query": "SELECT set_config($2, $1, $3)",
          "calls": "292",
          "total_time_ms": "34.603603",
          "rows": "292",
          "Query": "SELECT set_config($2, $1, $3)",
          "Fingerprint": "372553e8"
        },
        {
          "query": "SELECT mfa_amr_claims.authentication_method, mfa_amr_claims.created_at, mfa_amr_claims.id, mfa_amr_claims.session_id, mfa_amr_claims.updated_at FROM mfa_amr_claims AS mfa_amr_claims WHERE session_id = $1",
          "calls": "609",
          "total_time_ms": "32.246395",
          "rows": "609",
          "Query": "SELECT mfa_amr_claims.authentication_method, mfa_amr_claims.created_at, mfa_amr_claims.id, mfa_amr_claims.session_id, mfa_amr_claims.updated_at FROM mfa_amr_claims AS mfa_amr_claims WHERE session_id = $1",
          "Fingerprint": "a87b5d71"
        },
        {
          "query": "select exists(select $1 from auth.users)",
          "calls": "165",
          "total_time_ms": "30.342953",
          "rows": "165",
          "Query": "select exists(select $1 from auth.users)",
          "Fingerprint": "a6403a8d"
        },
        {
          "query": "select pid, query, query_start from pg_stat_activity where state = $1 and datname = $2",
          "calls": "54",
          "total_time_ms": "28.544478",
          "rows": "149",
          "Query": "select pid, query, query_start from pg_stat_activity where state = $1 and datname = $2",
          "Fingerprint": "09f3a758"
        },
        {
          "query": "SELECT word FROM pg_get_keywords()",
          "calls": "54",
          "total_time_ms": "25.665143",
          "rows": "26514",
          "Query": "SELECT word FROM pg_get_keywords()",
          "Fingerprint": "93722fc9"
        },
        {
          "query": "SELECT\n  p.oid :: int8 AS id,\n  p.pubname AS name,\n  p.pubowner::regrole::text AS owner,\n  p.pubinsert AS publish_insert,\n  p.pubupdate AS publish_update,\n  p.pubdelete AS publish_delete,\n  p.pubtruncate AS publish_truncate,\n  CASE\n    WHEN p.puballtables THEN $1\n    ELSE pr.tables\n  END AS tables\nFROM\n  pg_catalog.pg_publication AS p\n  LEFT JOIN LATERAL (\n    SELECT\n      COALESCE(\n        array_agg(\n          json_build_object(\n            $2,\n            c.oid :: int8,\n            $3,\n            c.relname,\n            $4,\n            nc.nspname\n          )\n        ),\n        $5\n      ) AS tables\n    FROM\n      pg_catalog.pg_publication_rel AS pr\n      JOIN pg_class AS c ON pr.prrelid = c.oid\n      join pg_namespace as nc on c.relnamespace = nc.oid\n    WHERE\n      pr.prpubid = p.oid\n  ) AS pr ON $6 = $7\nWHERE\n  $8",
          "calls": "43",
          "total_time_ms": "24.366404",
          "rows": "43",
          "Query": "SELECT\n  p.oid :: int8 AS id,\n  p.pubname AS name,\n  p.pubowner::regrole::text AS owner,\n  p.pubinsert AS publish_insert,\n  p.pubupdate AS publish_update,\n  p.pubdelete AS publish_delete,\n  p.pubtruncate AS publish_truncate,\n  CASE\n    WHEN p.puballtables THEN $1\n    ELSE pr.tables\n  END AS tables\nFROM\n  pg_catalog.pg_publication AS p\n  LEFT JOIN LATERAL (\n    SELECT\n      COALESCE(\n        array_agg(\n          json_build_object(\n            $2,\n            c.oid :: int8,\n            $3,\n            c.relname,\n            $4,\n            nc.nspname\n          )\n        ),\n        $5\n      ) AS tables\n    FROM\n      pg_catalog.pg_publication_rel AS pr\n      JOIN pg_class AS c ON pr.prrelid = c.oid\n      join pg_namespace as nc on c.relnamespace = nc.oid\n    WHERE\n      pr.prpubid = p.oid\n  ) AS pr ON $6 = $7\nWHERE\n  $8",
          "Fingerprint": "2e2e4cdd"
        },
        {
          "query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom materialized_views",
          "calls": "80",
          "total_time_ms": "23.678557",
          "rows": "68",
          "Query": "with materialized_views as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom materialized_views",
          "Fingerprint": "5fdd6c91"
        },
        {
          "query": "BEGIN ISOLATION LEVEL READ COMMITTED READ ONLY",
          "calls": "1756",
          "total_time_ms": "19.396537",
          "rows": "0",
          "Query": "BEGIN ISOLATION LEVEL READ COMMITTED READ ONLY",
          "Fingerprint": "3c5b6168"
        },
        {
          "query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and LOWER(email) = $2 and aud = $3 and is_sso_user = $4 LIMIT $5",
          "calls": "65",
          "total_time_ms": "17.461435",
          "rows": "54",
          "Query": "SELECT users.aud, users.banned_until, users.confirmation_sent_at, users.confirmation_token, users.confirmed_at, users.created_at, users.deleted_at, users.email, users.email_change, users.email_change_confirm_status, users.email_change_sent_at, users.email_change_token_current, users.email_change_token_new, users.email_confirmed_at, users.encrypted_password, users.id, users.instance_id, users.invited_at, users.is_anonymous, users.is_sso_user, users.last_sign_in_at, users.phone, users.phone_change, users.phone_change_sent_at, users.phone_change_token, users.phone_confirmed_at, users.raw_app_meta_data, users.raw_user_meta_data, users.reauthentication_sent_at, users.reauthentication_token, users.recovery_sent_at, users.recovery_token, users.role, users.updated_at FROM users AS users WHERE instance_id = $1 and LOWER(email) = $2 and aud = $3 and is_sso_user = $4 LIMIT $5",
          "Fingerprint": "7121590d"
        },
        {
          "query": "SET client_encoding = 'UTF8'",
          "calls": "1983",
          "total_time_ms": "17.447639",
          "rows": "0",
          "Query": "SET client_encoding = 'UTF8'",
          "Fingerprint": "2684e31e"
        },
        {
          "query": "with foreign_tables as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom foreign_tables",
          "calls": "80",
          "total_time_ms": "17.288298",
          "rows": "0",
          "Query": "with foreign_tables as (\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname IN ($1,$2) AND\n  \n  \n  c.relkind = $3\n\n\n)\n  \nselect\n  *\n  \nfrom foreign_tables",
          "Fingerprint": "4ab2deba"
        },
        {
          "query": "-- Adapted from information_schema.schemata\nselect\n  n.oid::int8 as id,\n  n.nspname as name,\n  u.rolname as owner\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  \n  and n.nspname IN ($1,$2)\n  and not pg_catalog.starts_with(n.nspname, $3)\n  and (\n    pg_has_role(n.nspowner, $4)\n    or has_schema_privilege(n.oid, $5)\n  )\n  and not pg_catalog.starts_with(n.nspname, $6)\n  and not pg_catalog.starts_with(n.nspname, $7)",
          "calls": "80",
          "total_time_ms": "16.45004",
          "rows": "160",
          "Query": "-- Adapted from information_schema.schemata\nselect\n  n.oid::int8 as id,\n  n.nspname as name,\n  u.rolname as owner\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  \n  and n.nspname IN ($1,$2)\n  and not pg_catalog.starts_with(n.nspname, $3)\n  and (\n    pg_has_role(n.nspowner, $4)\n    or has_schema_privilege(n.oid, $5)\n  )\n  and not pg_catalog.starts_with(n.nspname, $6)\n  and not pg_catalog.starts_with(n.nspname, $7)",
          "Fingerprint": "6e38ce8d"
        },
        {
          "query": "SET statement_timeout='58s'",
          "calls": "1057",
          "total_time_ms": "15.915253",
          "rows": "0",
          "Query": "SET statement_timeout='58s'",
          "Fingerprint": "caa62bbc"
        },
        {
          "query": "SELECT current_setting($1)::integer, current_setting($2), version()",
          "calls": "1397",
          "total_time_ms": "15.246181",
          "rows": "1397",
          "Query": "SELECT current_setting($1)::integer, current_setting($2), version()",
          "Fingerprint": "120b789e"
        },
        {
          "query": "PREPARE dumpEnumType(pg_catalog.oid) AS\nSELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder",
          "calls": "740",
          "total_time_ms": "13.1952",
          "rows": "4063",
          "Query": "PREPARE dumpEnumType(pg_catalog.oid) AS\nSELECT oid, enumlabel FROM pg_catalog.pg_enum WHERE enumtypid = $1 ORDER BY enumsortorder",
          "Fingerprint": "7c26b364"
        },
        {
          "query": "select set_config('search_path', $1, true), set_config('role', $2, true), set_config('request.jwt.claims', $3, true), set_config('request.method', $4, true), set_config('request.path', $5, true), set_config('request.headers', $6, true), set_config('request.cookies', $7, true)",
          "calls": "92",
          "total_time_ms": "12.934942",
          "rows": "92",
          "Query": "select set_config('search_path', $1, true), set_config('role', $2, true), set_config('request.jwt.claims', $3, true), set_config('request.method', $4, true), set_config('request.path', $5, true), set_config('request.headers', $6, true), set_config('request.cookies', $7, true)",
          "Fingerprint": "2a976cc9"
        },
        {
          "query": "SET client_min_messages TO WARNING",
          "calls": "1983",
          "total_time_ms": "11.741692",
          "rows": "0",
          "Query": "SET client_min_messages TO WARNING",
          "Fingerprint": "d2883c6f"
        },
        {
          "query": "INSERT INTO \"realtime\".\"schema_migrations\" (\"version\",\"inserted_at\") VALUES ($1,$2)",
          "calls": "67",
          "total_time_ms": "8.465681",
          "rows": "67",
          "Query": "INSERT INTO \"realtime\".\"schema_migrations\" (\"version\",\"inserted_at\") VALUES ($1,$2)",
          "Fingerprint": "7bfa5972"
        },
        {
          "query": "set local schema ''",
          "calls": "1397",
          "total_time_ms": "8.34740599999999",
          "rows": "0",
          "Query": "set local schema ''",
          "Fingerprint": "50e59e1c"
        },
        {
          "query": "BEGIN ISOLATION LEVEL READ COMMITTED READ WRITE",
          "calls": "490",
          "total_time_ms": "7.89980099999999",
          "rows": "0",
          "Query": "BEGIN ISOLATION LEVEL READ COMMITTED READ WRITE",
          "Fingerprint": "3e989d19"
        },
        {
          "query": "SELECT mfa_factors.created_at, mfa_factors.factor_type, mfa_factors.friendly_name, mfa_factors.id, mfa_factors.last_challenged_at, mfa_factors.last_webauthn_challenge_data, mfa_factors.phone, mfa_factors.secret, mfa_factors.status, mfa_factors.updated_at, mfa_factors.user_id, mfa_factors.web_authn_aaguid, mfa_factors.web_authn_credential FROM mfa_factors AS mfa_factors WHERE user_id = $1",
          "calls": "605",
          "total_time_ms": "7.48317799999999",
          "rows": "0",
          "Query": "SELECT mfa_factors.created_at, mfa_factors.factor_type, mfa_factors.friendly_name, mfa_factors.id, mfa_factors.last_challenged_at, mfa_factors.last_webauthn_challenge_data, mfa_factors.phone, mfa_factors.secret, mfa_factors.status, mfa_factors.updated_at, mfa_factors.user_id, mfa_factors.web_authn_aaguid, mfa_factors.web_authn_credential FROM mfa_factors AS mfa_factors WHERE user_id = $1",
          "Fingerprint": "dacebddc"
        },
        {
          "query": "SET statement_timeout='58s'",
          "calls": "393",
          "total_time_ms": "6.13669699999999",
          "rows": "0",
          "Query": "SET statement_timeout='58s'",
          "Fingerprint": "caa62bbc"
        },
        {
          "query": "INSERT INTO migrations (\"id\", \"name\", \"hash\") VALUES ($1,$2,$3)",
          "calls": "50",
          "total_time_ms": "4.90032",
          "rows": "50",
          "Query": "INSERT INTO migrations (\"id\", \"name\", \"hash\") VALUES ($1,$2,$3)",
          "Fingerprint": "08deba80"
        },
        {
          "query": "SELECT s0.\"version\" FROM \"realtime\".\"schema_migrations\" AS s0",
          "calls": "70",
          "total_time_ms": "3.596576",
          "rows": "2284",
          "Query": "SELECT s0.\"version\" FROM \"realtime\".\"schema_migrations\" AS s0",
          "Fingerprint": "aed88797"
        },
        {
          "query": "SELECT pg_catalog.format_type($1::pg_catalog.oid, $2)",
          "calls": "238",
          "total_time_ms": "3.276142",
          "rows": "238",
          "Query": "SELECT pg_catalog.format_type($1::pg_catalog.oid, $2)",
          "Fingerprint": "5f21d07e"
        },
        {
          "query": "SET idle_session_timeout='58s'",
          "calls": "1057",
          "total_time_ms": "3.192387",
          "rows": "0",
          "Query": "SET idle_session_timeout='58s'",
          "Fingerprint": "9469d6d2"
        },
        {
          "query": "SELECT oid FROM pg_catalog.pg_namespace n\nWHERE n.nspname OPERATOR(pg_catalog.~) $1 COLLATE pg_catalog.default",
          "calls": "72",
          "total_time_ms": "2.960007",
          "rows": "72",
          "Query": "SELECT oid FROM pg_catalog.pg_namespace n\nWHERE n.nspname OPERATOR(pg_catalog.~) $1 COLLATE pg_catalog.default",
          "Fingerprint": "7c8009f7"
        },
        {
          "query": "select\n      s.oid as \"id\",\n      w.fdwname as \"name\",\n      s.srvname as \"server_name\",\n      s.srvoptions as \"server_options\",\n      c.proname as \"handler\",\n      (\n        select jsonb_agg(\n          jsonb_build_object(\n            $1, c.oid::bigint,\n            $2, relnamespace::regnamespace::text,\n            $3, c.relname,\n            $4, (\n              select jsonb_agg(\n                jsonb_build_object(\n                  $5, a.attname,\n                  $6, pg_catalog.format_type(a.atttypid, a.atttypmod)\n                )\n              )\n              from pg_catalog.pg_attribute a\n              where a.attrelid = c.oid and a.attnum > $7 and not a.attisdropped\n            ),\n            $8, t.ftoptions\n          )\n        )\n        from pg_catalog.pg_class c\n        join pg_catalog.pg_foreign_table t on c.oid = t.ftrelid\n        where c.oid = any (select t.ftrelid from pg_catalog.pg_foreign_table t where t.ftserver = s.oid)\n      ) as \"tables\"\n    from pg_catalog.pg_foreign_server s\n    join pg_catalog.pg_foreign_data_wrapper w on s.srvfdw = w.oid\n    join pg_catalog.pg_proc c on w.fdwhandler = c.oid",
          "calls": "97",
          "total_time_ms": "2.233936",
          "rows": "0",
          "Query": "select\n      s.oid as \"id\",\n      w.fdwname as \"name\",\n      s.srvname as \"server_name\",\n      s.srvoptions as \"server_options\",\n      c.proname as \"handler\",\n      (\n        select jsonb_agg(\n          jsonb_build_object(\n            $1, c.oid::bigint,\n            $2, relnamespace::regnamespace::text,\n            $3, c.relname,\n            $4, (\n              select jsonb_agg(\n                jsonb_build_object(\n                  $5, a.attname,\n                  $6, pg_catalog.format_type(a.atttypid, a.atttypmod)\n                )\n              )\n              from pg_catalog.pg_attribute a\n              where a.attrelid = c.oid and a.attnum > $7 and not a.attisdropped\n            ),\n            $8, t.ftoptions\n          )\n        )\n        from pg_catalog.pg_class c\n        join pg_catalog.pg_foreign_table t on c.oid = t.ftrelid\n        where c.oid = any (select t.ftrelid from pg_catalog.pg_foreign_table t where t.ftserver = s.oid)\n      ) as \"tables\"\n    from pg_catalog.pg_foreign_server s\n    join pg_catalog.pg_foreign_data_wrapper w on s.srvfdw = w.oid\n    join pg_catalog.pg_proc c on w.fdwhandler = c.oid",
          "Fingerprint": "8e6d3b19"
        },
        {
          "query": "SET idle_session_timeout='58s'",
          "calls": "393",
          "total_time_ms": "2.087518",
          "rows": "0",
          "Query": "SET idle_session_timeout='58s'",
          "Fingerprint": "9469d6d2"
        },
        {
          "query": "COMMIT",
          "calls": "1397",
          "total_time_ms": "1.737483",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "insert into schema_migrations (version) values ($1)",
          "calls": "65",
          "total_time_ms": "1.325092",
          "rows": "65",
          "Query": "insert into schema_migrations (version) values ($1)",
          "Fingerprint": "81bd7952"
        },
        {
          "query": "SELECT EXISTS (SELECT schema_migrations.* FROM schema_migrations AS schema_migrations WHERE version = $1)",
          "calls": "65",
          "total_time_ms": "1.322896",
          "rows": "65",
          "Query": "SELECT EXISTS (SELECT schema_migrations.* FROM schema_migrations AS schema_migrations WHERE version = $1)",
          "Fingerprint": "b97dc1f8"
        },
        {
          "query": "LOCK TABLE \"realtime\".\"schema_migrations\" IN SHARE UPDATE EXCLUSIVE MODE",
          "calls": "71",
          "total_time_ms": "1.127289",
          "rows": "0",
          "Query": "LOCK TABLE \"realtime\".\"schema_migrations\" IN SHARE UPDATE EXCLUSIVE MODE",
          "Fingerprint": "deecdf8c"
        },
        {
          "query": "SET statement_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.957163",
          "rows": "0",
          "Query": "SET statement_timeout = 0",
          "Fingerprint": "27ded464"
        },
        {
          "query": "SELECT pg_catalog.set_config($1, $2, $3)",
          "calls": "83",
          "total_time_ms": "0.904006",
          "rows": "83",
          "Query": "SELECT pg_catalog.set_config($1, $2, $3)",
          "Fingerprint": "f5e5553f"
        },
        {
          "query": "with foreign_tables as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  obj_description(c.oid) as comment,\n  fs.srvname as foreign_server_name,\n  fdw.fdwname as foreign_data_wrapper_name,\n  handler.proname as foreign_data_wrapper_handler\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  inner join pg_foreign_table ft on ft.ftrelid = c.oid\n  inner join pg_foreign_server fs on fs.oid = ft.ftserver\n  inner join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw\n  inner join pg_proc handler on handler.oid = fdw.fdwhandler\nwhere\n  c.relkind = $1\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $2 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $3\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $4 THEN CASE\n      WHEN bt.typelem <> $5 :: oid\n      AND bt.typlen = $6 THEN $7\n      WHEN nbt.nspname = $8 THEN format_type(t.typbasetype, $9)\n      ELSE $10\n    END\n    ELSE CASE\n      WHEN t.typelem <> $11 :: oid\n      AND t.typlen = $12 THEN $13\n      WHEN nt.nspname = $14 THEN format_type(a.atttypid, $15)\n      ELSE $16\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($17, $18) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $19 THEN $20\n    WHEN $21 THEN $22\n    ELSE $23\n  END AS identity_generation,\n  a.attgenerated IN ($24) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $25 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($26, $27)\n    OR c.relkind IN ($28, $29) AND pg_column_is_updatable(c.oid, a.attnum, $30)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $31\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$32] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $33 AND cardinality(conkey) = $34\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$35] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $36),\n        $37,\n        length(pg_get_constraintdef(pg_constraint.oid, $38)) - $39\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $40 AND cardinality(conkey) = $41\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $42\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($43, $44, $45, $46, $47))\n  AND (\n    pg_has_role(c.relowner, $48)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $49\n    )\n  )\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = foreign_tables.id)\n    FROM\n      columns\n  ),\n  $50\n) AS columns\nfrom foreign_tables where schema IN ($51)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:17:01.330Z",
          "calls": "41",
          "total_time_ms": "0.858437",
          "rows": "0",
          "Query": "with foreign_tables as (\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  obj_description(c.oid) as comment,\n  fs.srvname as foreign_server_name,\n  fdw.fdwname as foreign_data_wrapper_name,\n  handler.proname as foreign_data_wrapper_handler\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  inner join pg_foreign_table ft on ft.ftrelid = c.oid\n  inner join pg_foreign_server fs on fs.oid = ft.ftserver\n  inner join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw\n  inner join pg_proc handler on handler.oid = fdw.fdwhandler\nwhere\n  c.relkind = $1\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $2 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $3\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $4 THEN CASE\n      WHEN bt.typelem <> $5 :: oid\n      AND bt.typlen = $6 THEN $7\n      WHEN nbt.nspname = $8 THEN format_type(t.typbasetype, $9)\n      ELSE $10\n    END\n    ELSE CASE\n      WHEN t.typelem <> $11 :: oid\n      AND t.typlen = $12 THEN $13\n      WHEN nt.nspname = $14 THEN format_type(a.atttypid, $15)\n      ELSE $16\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($17, $18) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $19 THEN $20\n    WHEN $21 THEN $22\n    ELSE $23\n  END AS identity_generation,\n  a.attgenerated IN ($24) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $25 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($26, $27)\n    OR c.relkind IN ($28, $29) AND pg_column_is_updatable(c.oid, a.attnum, $30)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $31\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$32] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $33 AND cardinality(conkey) = $34\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$35] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $36),\n        $37,\n        length(pg_get_constraintdef(pg_constraint.oid, $38)) - $39\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $40 AND cardinality(conkey) = $41\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $42\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($43, $44, $45, $46, $47))\n  AND (\n    pg_has_role(c.relowner, $48)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $49\n    )\n  )\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = foreign_tables.id)\n    FROM\n      columns\n  ),\n  $50\n) AS columns\nfrom foreign_tables where schema IN ($51)\n\n-- source: dashboard\n-- user: 8075c1a2-da12-4dce-901d-1b970a3e0101\n-- date: 2026-02-01T06:17:01.330Z",
          "Fingerprint": "805f0060"
        },
        {
          "query": "BEGIN",
          "calls": "292",
          "total_time_ms": "0.683945",
          "rows": "0",
          "Query": "BEGIN",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "COMMIT",
          "calls": "488",
          "total_time_ms": "0.664983",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "set pg_stat_statements.track = none",
          "calls": "224",
          "total_time_ms": "0.504548",
          "rows": "0",
          "Query": "set pg_stat_statements.track = none",
          "Fingerprint": "564e7202"
        },
        {
          "query": "SET idle_in_transaction_session_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.401828",
          "rows": "0",
          "Query": "SET idle_in_transaction_session_timeout = 0",
          "Fingerprint": "419d6119"
        },
        {
          "query": "deallocate $1",
          "calls": "149",
          "total_time_ms": "0.377356",
          "rows": "0",
          "Query": "deallocate $1",
          "Fingerprint": "67c106f6"
        },
        {
          "query": "ABORT",
          "calls": "263",
          "total_time_ms": "0.356416",
          "rows": "0",
          "Query": "ABORT",
          "Fingerprint": "a52bcaf9"
        },
        {
          "query": "COMMIT",
          "calls": "300",
          "total_time_ms": "0.348386",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "SET transaction_timeout = 0",
          "calls": "41",
          "total_time_ms": "0.344597",
          "rows": "0",
          "Query": "SET transaction_timeout = 0",
          "Fingerprint": "c9aafa99"
        },
        {
          "query": "SET row_security = off",
          "calls": "41",
          "total_time_ms": "0.250875",
          "rows": "0",
          "Query": "SET row_security = off",
          "Fingerprint": "fb6611bc"
        },
        {
          "query": "COMMIT",
          "calls": "143",
          "total_time_ms": "0.204349",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "BEGIN",
          "calls": "147",
          "total_time_ms": "0.193195",
          "rows": "0",
          "Query": "BEGIN",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "begin",
          "calls": "170",
          "total_time_ms": "0.167079",
          "rows": "0",
          "Query": "begin",
          "Fingerprint": "68348a7e"
        },
        {
          "query": "commit",
          "calls": "168",
          "total_time_ms": "0.166121",
          "rows": "0",
          "Query": "commit",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "COMMIT",
          "calls": "44",
          "total_time_ms": "0.033668",
          "rows": "0",
          "Query": "COMMIT",
          "Fingerprint": "334bd0fc"
        },
        {
          "query": "START TRANSACTION",
          "calls": "44",
          "total_time_ms": "0.027186",
          "rows": "0",
          "Query": "START TRANSACTION",
          "Fingerprint": "cd946f1b"
        }
      ]
    },
    "rpc": {
      "items": [
        {
          "key": "auth.email",
          "function": "email",
          "schema": "auth",
          "roles": "supabase_auth_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "auth.jwt",
          "function": "jwt",
          "schema": "auth",
          "roles": "supabase_auth_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "auth.role",
          "function": "role",
          "schema": "auth",
          "roles": "supabase_auth_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "auth.uid",
          "function": "uid",
          "schema": "auth",
          "roles": "supabase_auth_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.armor",
          "function": "armor",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.armor",
          "function": "armor",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.crypt",
          "function": "crypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.dearmor",
          "function": "dearmor",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.decrypt",
          "function": "decrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.decrypt_iv",
          "function": "decrypt_iv",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.digest",
          "function": "digest",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.digest",
          "function": "digest",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.encrypt",
          "function": "encrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.encrypt_iv",
          "function": "encrypt_iv",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.gen_random_bytes",
          "function": "gen_random_bytes",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.gen_random_uuid",
          "function": "gen_random_uuid",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.gen_salt",
          "function": "gen_salt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.gen_salt",
          "function": "gen_salt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.grant_pg_cron_access",
          "function": "grant_pg_cron_access",
          "schema": "extensions",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.grant_pg_graphql_access",
          "function": "grant_pg_graphql_access",
          "schema": "extensions",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.grant_pg_net_access",
          "function": "grant_pg_net_access",
          "schema": "extensions",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.hmac",
          "function": "hmac",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.hmac",
          "function": "hmac",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pg_stat_statements",
          "function": "pg_stat_statements",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pg_stat_statements_info",
          "function": "pg_stat_statements_info",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pg_stat_statements_reset",
          "function": "pg_stat_statements_reset",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_armor_headers",
          "function": "pgp_armor_headers",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_key_id",
          "function": "pgp_key_id",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_decrypt",
          "function": "pgp_pub_decrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_decrypt",
          "function": "pgp_pub_decrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_decrypt",
          "function": "pgp_pub_decrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_decrypt_bytea",
          "function": "pgp_pub_decrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_decrypt_bytea",
          "function": "pgp_pub_decrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_decrypt_bytea",
          "function": "pgp_pub_decrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_encrypt",
          "function": "pgp_pub_encrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_encrypt",
          "function": "pgp_pub_encrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_encrypt_bytea",
          "function": "pgp_pub_encrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_pub_encrypt_bytea",
          "function": "pgp_pub_encrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_sym_decrypt",
          "function": "pgp_sym_decrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_sym_decrypt",
          "function": "pgp_sym_decrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_sym_decrypt_bytea",
          "function": "pgp_sym_decrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_sym_decrypt_bytea",
          "function": "pgp_sym_decrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_sym_encrypt",
          "function": "pgp_sym_encrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_sym_encrypt",
          "function": "pgp_sym_encrypt",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_sym_encrypt_bytea",
          "function": "pgp_sym_encrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgp_sym_encrypt_bytea",
          "function": "pgp_sym_encrypt_bytea",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgrst_ddl_watch",
          "function": "pgrst_ddl_watch",
          "schema": "extensions",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.pgrst_drop_watch",
          "function": "pgrst_drop_watch",
          "schema": "extensions",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.set_graphql_placeholder",
          "function": "set_graphql_placeholder",
          "schema": "extensions",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_generate_v1",
          "function": "uuid_generate_v1",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_generate_v1mc",
          "function": "uuid_generate_v1mc",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_generate_v3",
          "function": "uuid_generate_v3",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_generate_v4",
          "function": "uuid_generate_v4",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_generate_v5",
          "function": "uuid_generate_v5",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_nil",
          "function": "uuid_nil",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_ns_dns",
          "function": "uuid_ns_dns",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_ns_oid",
          "function": "uuid_ns_oid",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_ns_url",
          "function": "uuid_ns_url",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "extensions.uuid_ns_x500",
          "function": "uuid_ns_x500",
          "schema": "extensions",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "graphql._internal_resolve",
          "function": "_internal_resolve",
          "schema": "graphql",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "graphql.comment_directive",
          "function": "comment_directive",
          "schema": "graphql",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "graphql.exception",
          "function": "exception",
          "schema": "graphql",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "graphql.get_schema_version",
          "function": "get_schema_version",
          "schema": "graphql",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "graphql.increment_schema_version",
          "function": "increment_schema_version",
          "schema": "graphql",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "graphql.resolve",
          "function": "resolve",
          "schema": "graphql",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "graphql_public.graphql",
          "function": "graphql",
          "schema": "graphql_public",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "pgbouncer.get_auth",
          "function": "get_auth",
          "schema": "pgbouncer",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.advance_workflow",
          "function": "advance_workflow",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.check_access",
          "function": "check_access",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.check_access_bool",
          "function": "check_access_bool",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.complete_my_profile",
          "function": "complete_my_profile",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.count_unread_notifications",
          "function": "count_unread_notifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.create_my_organization",
          "function": "create_my_organization",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_accounts_payable",
          "function": "delete_accounts_payable",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_accounts_receivable",
          "function": "delete_accounts_receivable",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_activity_logs",
          "function": "delete_activity_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_asphalt_types",
          "function": "delete_asphalt_types",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_audit_logs",
          "function": "delete_audit_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_avatars",
          "function": "delete_avatars",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_bid_packages",
          "function": "delete_bid_packages",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_bid_vendors",
          "function": "delete_bid_vendors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_bids",
          "function": "delete_bids",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_bim_models",
          "function": "delete_bim_models",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_certifications",
          "function": "delete_certifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_change_orders",
          "function": "delete_change_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_commitments",
          "function": "delete_commitments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_compliance_checks",
          "function": "delete_compliance_checks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_compliance_tracking",
          "function": "delete_compliance_tracking",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_cost_codes",
          "function": "delete_cost_codes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_crew_assignments",
          "function": "delete_crew_assignments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_crew_members",
          "function": "delete_crew_members",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_crews",
          "function": "delete_crews",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_daily_logs",
          "function": "delete_daily_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_dashboard_configs",
          "function": "delete_dashboard_configs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_document_references",
          "function": "delete_document_references",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_documents",
          "function": "delete_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_drawing_versions",
          "function": "delete_drawing_versions",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_dump_trucks",
          "function": "delete_dump_trucks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_employees",
          "function": "delete_employees",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_equipment",
          "function": "delete_equipment",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_equipment_assignments",
          "function": "delete_equipment_assignments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_equipment_maintenance",
          "function": "delete_equipment_maintenance",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_equipment_usage",
          "function": "delete_equipment_usage",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_estimate_line_items",
          "function": "delete_estimate_line_items",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_estimates",
          "function": "delete_estimates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_financial_documents",
          "function": "delete_financial_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_general_ledger",
          "function": "delete_general_ledger",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_hr_documents",
          "function": "delete_hr_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_inspections",
          "function": "delete_inspections",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_integration_tokens",
          "function": "delete_integration_tokens",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_inventory_transactions",
          "function": "delete_inventory_transactions",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_issues",
          "function": "delete_issues",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_job_titles",
          "function": "delete_job_titles",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_labor_records",
          "function": "delete_labor_records",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_line_item_entries",
          "function": "delete_line_item_entries",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_line_item_templates",
          "function": "delete_line_item_templates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_line_items",
          "function": "delete_line_items",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_maps",
          "function": "delete_maps",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_material_inventory",
          "function": "delete_material_inventory",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_material_orders",
          "function": "delete_material_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_material_receipts",
          "function": "delete_material_receipts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_materials",
          "function": "delete_materials",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_meeting_minutes",
          "function": "delete_meeting_minutes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_notifications",
          "function": "delete_notifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_organization_members",
          "function": "delete_organization_members",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_organization_projects",
          "function": "delete_organization_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_organizations",
          "function": "delete_organizations",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_payments",
          "function": "delete_payments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_payroll",
          "function": "delete_payroll",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_photos",
          "function": "delete_photos",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_prequalifications",
          "function": "delete_prequalifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_procurement_workflows",
          "function": "delete_procurement_workflows",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_profiles",
          "function": "delete_profiles",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_progress_billings",
          "function": "delete_progress_billings",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_project_inspectors",
          "function": "delete_project_inspectors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_projects",
          "function": "delete_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_punch_lists",
          "function": "delete_punch_lists",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_purchase_orders",
          "function": "delete_purchase_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_quality_reviews",
          "function": "delete_quality_reviews",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_regulatory_documents",
          "function": "delete_regulatory_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_reports",
          "function": "delete_reports",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_rfis",
          "function": "delete_rfis",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_safety_incidents",
          "function": "delete_safety_incidents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_sensor_data",
          "function": "delete_sensor_data",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_subcontractor_agreements",
          "function": "delete_subcontractor_agreements",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_subcontracts",
          "function": "delete_subcontracts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_submittals",
          "function": "delete_submittals",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_tack_rates",
          "function": "delete_tack_rates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_task_dependencies",
          "function": "delete_task_dependencies",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_task_status_logs",
          "function": "delete_task_status_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_tasks",
          "function": "delete_tasks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_training_records",
          "function": "delete_training_records",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_user_projects",
          "function": "delete_user_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_vendor_bid_packages",
          "function": "delete_vendor_bid_packages",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_vendor_contacts",
          "function": "delete_vendor_contacts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_vendor_documents",
          "function": "delete_vendor_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_vendor_qualifications",
          "function": "delete_vendor_qualifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_vendors",
          "function": "delete_vendors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_wbs",
          "function": "delete_wbs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.delete_workflows",
          "function": "delete_workflows",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.ensure_fk_indexes_for_schema",
          "function": "ensure_fk_indexes_for_schema",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.ensure_soft_delete_cols",
          "function": "ensure_soft_delete_cols",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_accounts_payable",
          "function": "filter_accounts_payable",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_accounts_receivable",
          "function": "filter_accounts_receivable",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_activity_logs",
          "function": "filter_activity_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_asphalt_types",
          "function": "filter_asphalt_types",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_audit_logs",
          "function": "filter_audit_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_avatars",
          "function": "filter_avatars",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_bid_packages",
          "function": "filter_bid_packages",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_bid_vendors",
          "function": "filter_bid_vendors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_bids",
          "function": "filter_bids",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_bim_models",
          "function": "filter_bim_models",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_certifications",
          "function": "filter_certifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_change_orders",
          "function": "filter_change_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_commitments",
          "function": "filter_commitments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_compliance_checks",
          "function": "filter_compliance_checks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_compliance_tracking",
          "function": "filter_compliance_tracking",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_cost_codes",
          "function": "filter_cost_codes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_crew_assignments",
          "function": "filter_crew_assignments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_crew_members",
          "function": "filter_crew_members",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_crews",
          "function": "filter_crews",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_daily_logs",
          "function": "filter_daily_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_dashboard_configs",
          "function": "filter_dashboard_configs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_document_references",
          "function": "filter_document_references",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_documents",
          "function": "filter_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_drawing_versions",
          "function": "filter_drawing_versions",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_dump_trucks",
          "function": "filter_dump_trucks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_employees",
          "function": "filter_employees",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_equipment",
          "function": "filter_equipment",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_equipment_assignments",
          "function": "filter_equipment_assignments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_equipment_maintenance",
          "function": "filter_equipment_maintenance",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_equipment_usage",
          "function": "filter_equipment_usage",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_estimate_line_items",
          "function": "filter_estimate_line_items",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_estimates",
          "function": "filter_estimates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_financial_documents",
          "function": "filter_financial_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_general_ledger",
          "function": "filter_general_ledger",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_hr_documents",
          "function": "filter_hr_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_inspections",
          "function": "filter_inspections",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_integration_tokens",
          "function": "filter_integration_tokens",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_inventory_transactions",
          "function": "filter_inventory_transactions",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_issues",
          "function": "filter_issues",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_job_titles",
          "function": "filter_job_titles",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_labor_records",
          "function": "filter_labor_records",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_line_item_entries",
          "function": "filter_line_item_entries",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_line_item_templates",
          "function": "filter_line_item_templates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_line_items",
          "function": "filter_line_items",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_maps",
          "function": "filter_maps",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_material_inventory",
          "function": "filter_material_inventory",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_material_orders",
          "function": "filter_material_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_material_receipts",
          "function": "filter_material_receipts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_materials",
          "function": "filter_materials",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_meeting_minutes",
          "function": "filter_meeting_minutes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_notifications",
          "function": "filter_notifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_organization_members",
          "function": "filter_organization_members",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_organization_projects",
          "function": "filter_organization_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_organizations",
          "function": "filter_organizations",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_payments",
          "function": "filter_payments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_payroll",
          "function": "filter_payroll",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_photos",
          "function": "filter_photos",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_prequalifications",
          "function": "filter_prequalifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_procurement_workflows",
          "function": "filter_procurement_workflows",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_profiles",
          "function": "filter_profiles",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_progress_billings",
          "function": "filter_progress_billings",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_project_inspectors",
          "function": "filter_project_inspectors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_projects",
          "function": "filter_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_punch_lists",
          "function": "filter_punch_lists",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_purchase_orders",
          "function": "filter_purchase_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_quality_reviews",
          "function": "filter_quality_reviews",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_regulatory_documents",
          "function": "filter_regulatory_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_reports",
          "function": "filter_reports",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_rfis",
          "function": "filter_rfis",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_safety_incidents",
          "function": "filter_safety_incidents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_sensor_data",
          "function": "filter_sensor_data",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_subcontractor_agreements",
          "function": "filter_subcontractor_agreements",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_subcontracts",
          "function": "filter_subcontracts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_submittals",
          "function": "filter_submittals",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_tack_rates",
          "function": "filter_tack_rates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_task_dependencies",
          "function": "filter_task_dependencies",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_task_status_logs",
          "function": "filter_task_status_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_tasks",
          "function": "filter_tasks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_training_records",
          "function": "filter_training_records",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_user_projects",
          "function": "filter_user_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_vendor_bid_packages",
          "function": "filter_vendor_bid_packages",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_vendor_contacts",
          "function": "filter_vendor_contacts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_vendor_documents",
          "function": "filter_vendor_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_vendor_qualifications",
          "function": "filter_vendor_qualifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_vendors",
          "function": "filter_vendors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_wbs",
          "function": "filter_wbs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.filter_workflows",
          "function": "filter_workflows",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_cashflow_curve",
          "function": "fn_cashflow_curve",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_eqp_7d_avg_hours",
          "function": "fn_eqp_7d_avg_hours",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_find_rpc_dupes",
          "function": "fn_find_rpc_dupes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_inventory_balance",
          "function": "fn_inventory_balance",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_list_tables_and_columns",
          "function": "fn_list_tables_and_columns",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_materials_on_hand",
          "function": "fn_materials_on_hand",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_task_cycle_time",
          "function": "fn_task_cycle_time",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_top5_cost_codes",
          "function": "fn_top5_cost_codes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_weekly_receipt_perf",
          "function": "fn_weekly_receipt_perf",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.fn_worst10_crews_by_incidents",
          "function": "fn_worst10_crews_by_incidents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.get_avatar_by_id_public",
          "function": "get_avatar_by_id_public",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.get_job_titles_public",
          "function": "get_job_titles_public",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.get_my_org_profiles_minimal",
          "function": "get_my_org_profiles_minimal",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.get_my_profile",
          "function": "get_my_profile",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.get_organizations_public",
          "function": "get_organizations_public",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.get_preset_avatars_public",
          "function": "get_preset_avatars_public",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.handle_auth_user_profile_sync",
          "function": "handle_auth_user_profile_sync",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_accounts_payable",
          "function": "insert_accounts_payable",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_accounts_receivable",
          "function": "insert_accounts_receivable",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_activity_logs",
          "function": "insert_activity_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_asphalt_types",
          "function": "insert_asphalt_types",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_audit_logs",
          "function": "insert_audit_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_avatars",
          "function": "insert_avatars",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_bid_packages",
          "function": "insert_bid_packages",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_bid_vendors",
          "function": "insert_bid_vendors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_bids",
          "function": "insert_bids",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_bim_models",
          "function": "insert_bim_models",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_certifications",
          "function": "insert_certifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_change_orders",
          "function": "insert_change_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_commitments",
          "function": "insert_commitments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_compliance_checks",
          "function": "insert_compliance_checks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_compliance_tracking",
          "function": "insert_compliance_tracking",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_cost_codes",
          "function": "insert_cost_codes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_crew_assignments",
          "function": "insert_crew_assignments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_crew_members",
          "function": "insert_crew_members",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_crews",
          "function": "insert_crews",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_daily_logs",
          "function": "insert_daily_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_dashboard_configs",
          "function": "insert_dashboard_configs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_document_references",
          "function": "insert_document_references",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_documents",
          "function": "insert_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_drawing_versions",
          "function": "insert_drawing_versions",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_dump_trucks",
          "function": "insert_dump_trucks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_employees",
          "function": "insert_employees",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_equipment",
          "function": "insert_equipment",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_equipment_assignments",
          "function": "insert_equipment_assignments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_equipment_maintenance",
          "function": "insert_equipment_maintenance",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_equipment_usage",
          "function": "insert_equipment_usage",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_estimate_line_items",
          "function": "insert_estimate_line_items",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_estimates",
          "function": "insert_estimates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_financial_documents",
          "function": "insert_financial_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_general_ledger",
          "function": "insert_general_ledger",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_hr_documents",
          "function": "insert_hr_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_inspections",
          "function": "insert_inspections",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_integration_tokens",
          "function": "insert_integration_tokens",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_inventory_transactions",
          "function": "insert_inventory_transactions",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_issues",
          "function": "insert_issues",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_job_title_public",
          "function": "insert_job_title_public",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_job_titles",
          "function": "insert_job_titles",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_labor_records",
          "function": "insert_labor_records",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_line_item_entries",
          "function": "insert_line_item_entries",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_line_item_templates",
          "function": "insert_line_item_templates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_line_items",
          "function": "insert_line_items",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_maps",
          "function": "insert_maps",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_material_inventory",
          "function": "insert_material_inventory",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_material_orders",
          "function": "insert_material_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_material_receipts",
          "function": "insert_material_receipts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_materials",
          "function": "insert_materials",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_meeting_minutes",
          "function": "insert_meeting_minutes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_notifications",
          "function": "insert_notifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_organization_members",
          "function": "insert_organization_members",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_organization_projects",
          "function": "insert_organization_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_organizations",
          "function": "insert_organizations",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_payments",
          "function": "insert_payments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_payroll",
          "function": "insert_payroll",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_photos",
          "function": "insert_photos",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_prequalifications",
          "function": "insert_prequalifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_procurement_workflows",
          "function": "insert_procurement_workflows",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_profiles",
          "function": "insert_profiles",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_progress_billings",
          "function": "insert_progress_billings",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_project_inspectors",
          "function": "insert_project_inspectors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_projects",
          "function": "insert_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_punch_lists",
          "function": "insert_punch_lists",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_purchase_orders",
          "function": "insert_purchase_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_quality_reviews",
          "function": "insert_quality_reviews",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_regulatory_documents",
          "function": "insert_regulatory_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_reports",
          "function": "insert_reports",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_rfis",
          "function": "insert_rfis",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_safety_incidents",
          "function": "insert_safety_incidents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_sensor_data",
          "function": "insert_sensor_data",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_subcontractor_agreements",
          "function": "insert_subcontractor_agreements",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_subcontracts",
          "function": "insert_subcontracts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_submittals",
          "function": "insert_submittals",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_tack_rates",
          "function": "insert_tack_rates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_task_dependencies",
          "function": "insert_task_dependencies",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_task_status_logs",
          "function": "insert_task_status_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_tasks",
          "function": "insert_tasks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_training_records",
          "function": "insert_training_records",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_user_projects",
          "function": "insert_user_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_vendor_bid_packages",
          "function": "insert_vendor_bid_packages",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_vendor_contacts",
          "function": "insert_vendor_contacts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_vendor_documents",
          "function": "insert_vendor_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_vendor_qualifications",
          "function": "insert_vendor_qualifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_vendors",
          "function": "insert_vendors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_wbs",
          "function": "insert_wbs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.insert_workflows",
          "function": "insert_workflows",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.notify_new_bid",
          "function": "notify_new_bid",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.on_create_function_pin_search_path",
          "function": "on_create_function_pin_search_path",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.on_ddl_ensure_fk_indexes",
          "function": "on_ddl_ensure_fk_indexes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.rank_equipment_usage",
          "function": "rank_equipment_usage",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.refresh_project_cost_summary",
          "function": "refresh_project_cost_summary",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.rpc_org_dashboard_payload",
          "function": "rpc_org_dashboard_payload",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.set_org_member_role",
          "function": "set_org_member_role",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.set_updated_at",
          "function": "set_updated_at",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.touch_created_at",
          "function": "touch_created_at",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_accounts_payable",
          "function": "update_accounts_payable",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_accounts_receivable",
          "function": "update_accounts_receivable",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_activity_logs",
          "function": "update_activity_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_asphalt_types",
          "function": "update_asphalt_types",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_audit_logs",
          "function": "update_audit_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_avatars",
          "function": "update_avatars",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_bid_packages",
          "function": "update_bid_packages",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_bid_vendors",
          "function": "update_bid_vendors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_bids",
          "function": "update_bids",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_bim_models",
          "function": "update_bim_models",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_certifications",
          "function": "update_certifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_change_orders",
          "function": "update_change_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_commitments",
          "function": "update_commitments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_compliance_checks",
          "function": "update_compliance_checks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_compliance_tracking",
          "function": "update_compliance_tracking",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_cost_codes",
          "function": "update_cost_codes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_crew_assignments",
          "function": "update_crew_assignments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_crew_members",
          "function": "update_crew_members",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_crews",
          "function": "update_crews",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_daily_logs",
          "function": "update_daily_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_dashboard_configs",
          "function": "update_dashboard_configs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_document_references",
          "function": "update_document_references",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_documents",
          "function": "update_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_drawing_versions",
          "function": "update_drawing_versions",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_dump_trucks",
          "function": "update_dump_trucks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_employees",
          "function": "update_employees",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_equipment",
          "function": "update_equipment",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_equipment_assignments",
          "function": "update_equipment_assignments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_equipment_maintenance",
          "function": "update_equipment_maintenance",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_equipment_usage",
          "function": "update_equipment_usage",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_estimate_line_items",
          "function": "update_estimate_line_items",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_estimates",
          "function": "update_estimates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_financial_documents",
          "function": "update_financial_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_general_ledger",
          "function": "update_general_ledger",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_hr_documents",
          "function": "update_hr_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_inspections",
          "function": "update_inspections",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_integration_tokens",
          "function": "update_integration_tokens",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_inventory_transactions",
          "function": "update_inventory_transactions",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_issues",
          "function": "update_issues",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_job_titles",
          "function": "update_job_titles",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_labor_records",
          "function": "update_labor_records",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_line_item_entries",
          "function": "update_line_item_entries",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_line_item_templates",
          "function": "update_line_item_templates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_line_items",
          "function": "update_line_items",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_maps",
          "function": "update_maps",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_material_inventory",
          "function": "update_material_inventory",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_material_orders",
          "function": "update_material_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_material_receipts",
          "function": "update_material_receipts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_materials",
          "function": "update_materials",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_meeting_minutes",
          "function": "update_meeting_minutes",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_notifications",
          "function": "update_notifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_organization_members",
          "function": "update_organization_members",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_organization_projects",
          "function": "update_organization_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_organizations",
          "function": "update_organizations",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_payments",
          "function": "update_payments",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_payroll",
          "function": "update_payroll",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_photos",
          "function": "update_photos",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_prequalifications",
          "function": "update_prequalifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_procurement_workflows",
          "function": "update_procurement_workflows",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_profiles",
          "function": "update_profiles",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_progress_billings",
          "function": "update_progress_billings",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_project_inspectors",
          "function": "update_project_inspectors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_projects",
          "function": "update_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_punch_lists",
          "function": "update_punch_lists",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_purchase_orders",
          "function": "update_purchase_orders",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_quality_reviews",
          "function": "update_quality_reviews",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_regulatory_documents",
          "function": "update_regulatory_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_reports",
          "function": "update_reports",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_rfis",
          "function": "update_rfis",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_safety_incidents",
          "function": "update_safety_incidents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_sensor_data",
          "function": "update_sensor_data",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_subcontractor_agreements",
          "function": "update_subcontractor_agreements",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_subcontracts",
          "function": "update_subcontracts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_submittals",
          "function": "update_submittals",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_tack_rates",
          "function": "update_tack_rates",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_task_dependencies",
          "function": "update_task_dependencies",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_task_status_logs",
          "function": "update_task_status_logs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_tasks",
          "function": "update_tasks",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_training_records",
          "function": "update_training_records",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_user_projects",
          "function": "update_user_projects",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_vendor_bid_packages",
          "function": "update_vendor_bid_packages",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_vendor_contacts",
          "function": "update_vendor_contacts",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_vendor_documents",
          "function": "update_vendor_documents",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_vendor_qualifications",
          "function": "update_vendor_qualifications",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_vendors",
          "function": "update_vendors",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_wbs",
          "function": "update_wbs",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "public.update_workflows",
          "function": "update_workflows",
          "schema": "public",
          "roles": "postgres",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.apply_rls",
          "function": "apply_rls",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.broadcast_changes",
          "function": "broadcast_changes",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.build_prepared_statement_sql",
          "function": "build_prepared_statement_sql",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.cast",
          "function": "cast",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.check_equality_op",
          "function": "check_equality_op",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.is_visible_through_filters",
          "function": "is_visible_through_filters",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.list_changes",
          "function": "list_changes",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.quote_wal2json",
          "function": "quote_wal2json",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.send",
          "function": "send",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.subscription_check_filters",
          "function": "subscription_check_filters",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.to_regrole",
          "function": "to_regrole",
          "schema": "realtime",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "realtime.topic",
          "function": "topic",
          "schema": "realtime",
          "roles": "supabase_realtime_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.add_prefixes",
          "function": "add_prefixes",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.can_insert_object",
          "function": "can_insert_object",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.delete_leaf_prefixes",
          "function": "delete_leaf_prefixes",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.delete_prefix",
          "function": "delete_prefix",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.delete_prefix_hierarchy_trigger",
          "function": "delete_prefix_hierarchy_trigger",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.enforce_bucket_name_length",
          "function": "enforce_bucket_name_length",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.extension",
          "function": "extension",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.filename",
          "function": "filename",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.foldername",
          "function": "foldername",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.get_level",
          "function": "get_level",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.get_prefix",
          "function": "get_prefix",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.get_prefixes",
          "function": "get_prefixes",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.get_size_by_bucket",
          "function": "get_size_by_bucket",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.list_multipart_uploads_with_delimiter",
          "function": "list_multipart_uploads_with_delimiter",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.list_objects_with_delimiter",
          "function": "list_objects_with_delimiter",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.lock_top_prefixes",
          "function": "lock_top_prefixes",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.objects_delete_cleanup",
          "function": "objects_delete_cleanup",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.objects_insert_prefix_trigger",
          "function": "objects_insert_prefix_trigger",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.objects_update_cleanup",
          "function": "objects_update_cleanup",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.objects_update_level_trigger",
          "function": "objects_update_level_trigger",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.objects_update_prefix_trigger",
          "function": "objects_update_prefix_trigger",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.operation",
          "function": "operation",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.prefixes_delete_cleanup",
          "function": "prefixes_delete_cleanup",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.prefixes_insert_trigger",
          "function": "prefixes_insert_trigger",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.search",
          "function": "search",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.search_legacy_v1",
          "function": "search_legacy_v1",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.search_v1_optimised",
          "function": "search_v1_optimised",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.search_v2",
          "function": "search_v2",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "storage.update_updated_at_column",
          "function": "update_updated_at_column",
          "schema": "storage",
          "roles": "supabase_storage_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "vault._crypto_aead_det_decrypt",
          "function": "_crypto_aead_det_decrypt",
          "schema": "vault",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "vault._crypto_aead_det_encrypt",
          "function": "_crypto_aead_det_encrypt",
          "schema": "vault",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "vault._crypto_aead_det_noncegen",
          "function": "_crypto_aead_det_noncegen",
          "schema": "vault",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "vault.create_secret",
          "function": "create_secret",
          "schema": "vault",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        },
        {
          "key": "vault.update_secret",
          "function": "update_secret",
          "schema": "vault",
          "roles": "supabase_admin",
          "writeLike": true,
          "risk": "P2"
        }
      ]
    },
    "policies": {
      "policyCounts": {
        "public.accounts_payable": 5,
        "public.accounts_receivable": 5,
        "public.activity_logs": 5,
        "public.asphalt_types": 5,
        "public.audit_log": 5,
        "public.audit_logs": 5,
        "public.avatars": 5,
        "public.bid_packages": 5,
        "public.bid_vendors": 5,
        "public.bids": 5,
        "public.bim_models": 5,
        "public.certifications": 5,
        "public.change_orders": 5,
        "public.commitments": 5,
        "public.compliance_checks": 5,
        "public.compliance_tracking": 5,
        "public.cost_codes": 5,
        "public.crew_assignments": 5,
        "public.crew_members": 5,
        "public.crews": 5,
        "public.daily_logs": 5,
        "public.dashboard_configs": 5,
        "public.document_references": 5,
        "public.documents": 5,
        "public.drawing_versions": 5,
        "public.dump_trucks": 5,
        "public.employees": 5,
        "public.equipment": 5,
        "public.equipment_assignments": 5,
        "public.equipment_maintenance": 5,
        "public.equipment_usage": 5,
        "public.estimate_line_items": 5,
        "public.estimates": 5,
        "public.financial_documents": 5,
        "public.general_ledger": 5,
        "public.hr_documents": 5,
        "public.inspections": 5,
        "public.integration_tokens": 5,
        "public.inventory_transactions": 5,
        "public.issues": 5,
        "public.job_titles": 5,
        "public.labor_records": 5,
        "public.line_item_entries": 5,
        "public.line_item_templates": 5,
        "public.line_items": 5,
        "public.maps": 5,
        "public.material_inventory": 5,
        "public.material_orders": 5,
        "public.material_receipts": 5,
        "public.materials": 5,
        "public.meeting_minutes": 5,
        "public.notifications": 5,
        "public.organization_member_rates": 1,
        "public.organization_members": 5,
        "public.organization_projects": 5,
        "public.organization_service_areas": 1,
        "public.organizations": 5,
        "public.payments": 5,
        "public.payroll": 5,
        "public.photos": 5,
        "public.prequalifications": 5,
        "public.procurement_workflows": 5,
        "public.profiles": 9,
        "public.progress_billings": 5,
        "public.project_inspectors": 5,
        "public.project_invites": 1,
        "public.project_service_areas": 1,
        "public.projects": 5,
        "public.punch_lists": 5,
        "public.purchase_orders": 5,
        "public.quality_reviews": 5,
        "public.regulatory_documents": 5,
        "public.reports": 5,
        "public.rfis": 5,
        "public.safety_incidents": 5,
        "public.sensor_data": 5,
        "public.subcontractor_agreements": 5,
        "public.subcontracts": 5,
        "public.submittals": 5,
        "public.tack_rates": 5,
        "public.task_dependencies": 5,
        "public.task_status_logs": 5,
        "public.tasks": 5,
        "public.training_records": 5,
        "public.user_projects": 5,
        "public.vendor_bid_packages": 5,
        "public.vendor_contacts": 5,
        "public.vendor_documents": 5,
        "public.vendor_qualifications": 5,
        "public.vendors": 5,
        "public.wbs": 5,
        "public.workflows": 5,
        "storage.objects": 3
      },
      "zeroPolicy": [
        "auth.audit_log_entries",
        "auth.flow_state",
        "auth.identities",
        "auth.instances",
        "auth.mfa_amr_claims",
        "auth.mfa_challenges",
        "auth.mfa_factors",
        "auth.oauth_authorizations",
        "auth.oauth_client_states",
        "auth.oauth_clients",
        "auth.oauth_consents",
        "auth.one_time_tokens",
        "auth.refresh_tokens",
        "auth.saml_providers",
        "auth.saml_relay_states",
        "auth.schema_migrations",
        "auth.sessions",
        "auth.sso_domains",
        "auth.sso_providers",
        "auth.users",
        "extensions.pg_stat_statements",
        "extensions.pg_stat_statements_info",
        "public.accounts_payable_active",
        "public.accounts_receivable_active",
        "public.activity_logs_active",
        "public.asphalt_types_active",
        "public.audit_log_active",
        "public.audit_logs_active",
        "public.avatars_active",
        "public.bid_packages_active",
        "public.bid_vendors_active",
        "public.bids_active",
        "public.bim_models_active",
        "public.certifications_active",
        "public.change_orders_active",
        "public.commitments_active",
        "public.compliance_checks_active",
        "public.compliance_tracking_active",
        "public.cost_codes_active",
        "public.crew_assignments_active",
        "public.crew_members_active",
        "public.crews_active",
        "public.daily_logs_active",
        "public.dashboard_configs_active",
        "public.document_references_active",
        "public.documents_active",
        "public.drawing_versions_active",
        "public.dump_trucks_active",
        "public.employees_active",
        "public.equipment_active",
        "public.equipment_assignments_active",
        "public.equipment_maintenance_active",
        "public.equipment_usage_active",
        "public.estimate_line_items_active",
        "public.estimates_active",
        "public.financial_documents_active",
        "public.general_ledger_active",
        "public.hr_documents_active",
        "public.inspections_active",
        "public.integration_tokens_active",
        "public.inventory_transactions_active",
        "public.issues_active",
        "public.job_titles_active",
        "public.labor_records_active",
        "public.line_item_entries_active",
        "public.line_item_templates_active",
        "public.line_items_active",
        "public.maps_active",
        "public.material_inventory_active",
        "public.material_orders_active",
        "public.material_receipts_active",
        "public.materials_active",
        "public.meeting_minutes_active",
        "public.notifications_active",
        "public.organization_members_active",
        "public.organization_projects_active",
        "public.organizations_active",
        "public.payments_active",
        "public.payroll_active",
        "public.photos_active",
        "public.prequalifications_active",
        "public.procurement_workflows_active",
        "public.profiles_active",
        "public.progress_billings_active",
        "public.project_inspectors_active",
        "public.projects_active",
        "public.punch_lists_active",
        "public.purchase_orders_active",
        "public.quality_reviews_active",
        "public.regulatory_documents_active",
        "public.reports_active",
        "public.rfis_active",
        "public.safety_incidents_active",
        "public.sensor_data_active",
        "public.subcontractor_agreements_active",
        "public.subcontracts_active",
        "public.submittals_active",
        "public.tack_rates_active",
        "public.task_dependencies_active",
        "public.task_status_logs_active",
        "public.tasks_active",
        "public.training_records_active",
        "public.user_projects_active",
        "public.vendor_bid_packages_active",
        "public.vendor_contacts_active",
        "public.vendor_documents_active",
        "public.vendor_qualifications_active",
        "public.vendors_active",
        "public.wbs_active",
        "public.workflows_active",
        "realtime.messages",
        "realtime.schema_migrations",
        "realtime.subscription",
        "storage.buckets",
        "storage.buckets_analytics",
        "storage.buckets_vectors",
        "storage.migrations",
        "storage.prefixes",
        "storage.s3_multipart_uploads",
        "storage.s3_multipart_uploads_parts",
        "storage.vector_indexes",
        "vault.decrypted_secrets",
        "vault.secrets"
      ]
    },
    "triggers": {
      "items": [
        {
          "trigger": "on_auth_user_profile_sync",
          "table": "users",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "accounts_payable",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "accounts_payable",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "accounts_receivable",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "accounts_receivable",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "activity_logs",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "activity_logs",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "asphalt_types",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "asphalt_types",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "audit_logs",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "audit_logs",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "avatars",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "avatars",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "bid_packages",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "bid_packages",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "bid_vendors",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "bid_vendors",
          "function": ""
        },
        {
          "trigger": "trg_notify_new_bid",
          "table": "bids",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "bids",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "bids",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "bim_models",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "bim_models",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "certifications",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "certifications",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "change_orders",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "change_orders",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "commitments",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "commitments",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "compliance_checks",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "compliance_checks",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "compliance_tracking",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "compliance_tracking",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "cost_codes",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "cost_codes",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "crew_assignments",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "crew_assignments",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "crew_members",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "crew_members",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "crews",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "crews",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "daily_logs",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "daily_logs",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "dashboard_configs",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "dashboard_configs",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "document_references",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "document_references",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "documents",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "documents",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "drawing_versions",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "drawing_versions",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "dump_trucks",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "dump_trucks",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "employees",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "employees",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "equipment",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "equipment",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "equipment_assignments",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "equipment_assignments",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "equipment_maintenance",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "equipment_maintenance",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "equipment_usage",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "equipment_usage",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "estimate_line_items",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "estimate_line_items",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "estimates",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "estimates",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "financial_documents",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "financial_documents",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "general_ledger",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "general_ledger",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "hr_documents",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "hr_documents",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "inspections",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "inspections",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "integration_tokens",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "integration_tokens",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "inventory_transactions",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "inventory_transactions",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "issues",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "issues",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "job_titles",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "job_titles",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "labor_records",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "labor_records",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "line_item_entries",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "line_item_entries",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "line_item_templates",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "line_item_templates",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "line_items",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "line_items",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "maps",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "maps",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "material_inventory",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "material_inventory",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "material_orders",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "material_orders",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "material_receipts",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "material_receipts",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "materials",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "materials",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "meeting_minutes",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "meeting_minutes",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "notifications",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "notifications",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "organization_members",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "organization_members",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "organization_projects",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "organization_projects",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "organizations",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "organizations",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "payments",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "payments",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "payroll",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "payroll",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "photos",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "photos",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "prequalifications",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "prequalifications",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "procurement_workflows",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "procurement_workflows",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "profiles",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "profiles",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "progress_billings",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "progress_billings",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "projects",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "projects",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "punch_lists",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "punch_lists",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "purchase_orders",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "purchase_orders",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "quality_reviews",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "quality_reviews",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "regulatory_documents",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "regulatory_documents",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "reports",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "reports",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "rfis",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "rfis",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "safety_incidents",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "safety_incidents",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "sensor_data",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "sensor_data",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "subcontractor_agreements",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "subcontractor_agreements",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "subcontracts",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "subcontracts",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "submittals",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "submittals",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "tack_rates",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "tack_rates",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "task_dependencies",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "tasks",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "tasks",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "training_records",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "training_records",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "user_projects",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "user_projects",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "vendor_bid_packages",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "vendor_bid_packages",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "vendor_contacts",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "vendor_contacts",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "vendor_documents",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "vendor_documents",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "vendor_qualifications",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "vendor_qualifications",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "vendors",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "vendors",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "wbs",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "wbs",
          "function": ""
        },
        {
          "trigger": "trg_set_updated_at",
          "table": "workflows",
          "function": ""
        },
        {
          "trigger": "trg_touch_created_at",
          "table": "workflows",
          "function": ""
        },
        {
          "trigger": "tr_check_filters",
          "table": "subscription",
          "function": ""
        },
        {
          "trigger": "enforce_bucket_name_length_trigger",
          "table": "buckets",
          "function": ""
        },
        {
          "trigger": "objects_delete_delete_prefix",
          "table": "objects",
          "function": ""
        },
        {
          "trigger": "objects_insert_create_prefix",
          "table": "objects",
          "function": ""
        },
        {
          "trigger": "objects_update_create_prefix",
          "table": "objects",
          "function": ""
        },
        {
          "trigger": "update_objects_updated_at",
          "table": "objects",
          "function": ""
        },
        {
          "trigger": "prefixes_create_hierarchy",
          "table": "prefixes",
          "function": ""
        },
        {
          "trigger": "prefixes_delete_hierarchy",
          "table": "prefixes",
          "function": ""
        }
      ]
    }
  },
  "recommendations": {
    "p0": [],
    "p1": [
      "Investigate top slowest/most time-consuming queries (EXPLAIN ANALYZE)."
    ],
    "p2": []
  }
}