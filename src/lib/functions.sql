--
-- PostgreSQL database dump
--

-- Dumped from database version 17.6
-- Dumped by pg_dump version 17.5

-- Started on 2026-02-21 02:30:21

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 54 (class 2615 OID 20818)
-- Name: public; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA public;


--
-- TOC entry 2289 (class 1247 OID 20820)
-- Name: certification_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.certification_type AS ENUM (
    'osha_10',
    'osha_30',
    'cpr',
    'first_aid',
    'equipment_card',
    'other'
);


--
-- TOC entry 2292 (class 1247 OID 20834)
-- Name: commitment_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.commitment_type AS ENUM (
    'subcontract',
    'purchase_order',
    'change_order'
);


--
-- TOC entry 2295 (class 1247 OID 20842)
-- Name: document_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.document_type AS ENUM (
    'drawing',
    'spec',
    'rfi',
    'submittal',
    'change_order',
    'other'
);


--
-- TOC entry 2298 (class 1247 OID 20856)
-- Name: equipment_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.equipment_type AS ENUM (
    'truck',
    'excavator',
    'grader',
    'roller',
    'loader',
    'misc'
);


--
-- TOC entry 2301 (class 1247 OID 20870)
-- Name: general_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.general_status AS ENUM (
    'draft',
    'pending',
    'approved',
    'rejected',
    'active',
    'inactive',
    'complete',
    'closed'
);


--
-- TOC entry 2304 (class 1247 OID 20888)
-- Name: issue_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.issue_type AS ENUM (
    'safety',
    'quality',
    'field',
    'equipment',
    'other'
);


--
-- TOC entry 2307 (class 1247 OID 20900)
-- Name: notification_category; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.notification_category AS ENUM (
    'bid_received',
    'approval_needed',
    'deadline_reminder',
    'task_assigned',
    'workflow_update',
    'general'
);


--
-- TOC entry 2310 (class 1247 OID 20914)
-- Name: org_role; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.org_role AS ENUM (
    'admin',
    'manager',
    'superintendent',
    'foreman',
    'worker',
    'viewer',
    'accountant',
    'hr',
    'estimator',
    'guest',
    'owner'
);


--
-- TOC entry 2313 (class 1247 OID 20936)
-- Name: project_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.project_status AS ENUM (
    'planned',
    'active',
    'complete',
    'archived',
    'on_hold',
    'canceled'
);


--
-- TOC entry 2316 (class 1247 OID 20950)
-- Name: task_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.task_status AS ENUM (
    'not_started',
    'in_progress',
    'completed',
    'blocked'
);


--
-- TOC entry 2319 (class 1247 OID 20960)
-- Name: unit_measure; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.unit_measure AS ENUM (
    'Feet (FT)',
    'Inches (IN)',
    'Linear Feet (LF)',
    'Mile (MI)',
    'Shoulder Mile (SMI)',
    'Square Feet (SF)',
    'Square Yard (SY)',
    'Acre (AC)',
    'Cubic Foot (CF)',
    'Cubic Yard (CY)',
    'Gallon (GAL)',
    'Pounds (LBS)',
    'TON',
    'Each (EA)',
    'Lump Sum (LS)',
    'Hour (HR)',
    'DAY',
    'Station (STA)',
    'MSF (1000SF)',
    'MLF (1000LF)',
    'Cubic Feet per Second (CFS)',
    'Pounds per Square Inch (PSI)',
    'Percent (%)',
    'Degrees (*)'
);


--
-- TOC entry 2322 (class 1247 OID 21010)
-- Name: user_role_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.user_role_type AS ENUM (
    'system_admin',
    'org_admin',
    'org_supervisor',
    'org_user',
    'org_viewer',
    'inspector',
    'auditor'
);


--
-- TOC entry 2325 (class 1247 OID 21026)
-- Name: workflow_name; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.workflow_name AS ENUM (
    'estimate_submission',
    'bid_submission',
    'bid_review',
    'contract_award',
    'task_execution',
    'inspection',
    'project_closeout'
);


SET default_table_access_method = heap;

--
-- TOC entry 345 (class 1259 OID 21041)
-- Name: workflows; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.workflows (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    entity_schema text NOT NULL,
    entity_table text NOT NULL,
    entity_id uuid NOT NULL,
    workflow_name public.workflow_name DEFAULT 'estimate_submission'::public.workflow_name NOT NULL,
    current_state text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.workflows FORCE ROW LEVEL SECURITY;


--
-- TOC entry 636 (class 1255 OID 21050)
-- Name: advance_workflow(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.advance_workflow(_id uuid, _new_state text) RETURNS public.workflows
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  UPDATE public.workflows
     SET current_state = _new_state,
         updated_at    = now()
   WHERE id = _id
   RETURNING *;
$$;


--
-- TOC entry 553 (class 1255 OID 21051)
-- Name: check_access(text, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_access(_action text, _resource text, _project_id uuid DEFAULT NULL::uuid, _organization_id uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  _role text;
  _org_id uuid;
BEGIN
  -- ðŸ” Load caller's role and org
  SELECT role, organization_id INTO _role, _org_id
  FROM public.profiles
  WHERE id = auth.uid();

  IF _role IS NULL THEN
    RAISE EXCEPTION 'Access denied: profile not found for user %', auth.uid();
  END IF;

  -- âœ… SYSTEM ADMIN â€” unrestricted access
  IF _role = 'system_admin' THEN
    RETURN;
  END IF;

  -- ðŸ”’ Always-denied resources for limited roles
  IF _role IN ('org_user', 'org_viewer', 'inspector', 'auditor') AND
     _resource IN ('organizations', 'organization_members', 'profiles', 'job_titles', 'integration_tokens') THEN
    RAISE EXCEPTION 'Access denied: role % cannot access resource %', _role, _resource;
  END IF;

  -- ðŸ¢ ORG-LEVEL CHECK
  IF _resource IN (
    'organizations', 'organization_members', 'profiles', 'job_titles', 'integration_tokens'
  ) THEN
    IF _organization_id IS NULL THEN
      RAISE EXCEPTION 'Access denied: _organization_id is required for org-level access to %', _resource;
    END IF;
    IF _organization_id != _org_id THEN
      RAISE EXCEPTION 'Access denied: you do not belong to organization %', _organization_id;
    END IF;
  END IF;

  -- ðŸ— PROJECT-LEVEL CHECK
  IF _project_id IS NOT NULL THEN
    PERFORM 1 FROM projects WHERE id = _project_id AND organization_id = _org_id;
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Access denied: project % not in your organization', _project_id;
    END IF;
  END IF;

  -- âœ… ORG ADMIN â€” full access within their org
  IF _role = 'org_admin' THEN
    RETURN;
  END IF;

  -- âœ… ORG SUPERVISOR â€” same as admin, minus org/user admin
  IF _role = 'org_supervisor' THEN
    IF _resource IN ('organizations', 'organization_members') THEN
      RAISE EXCEPTION 'Access denied: org_supervisor cannot manage organization metadata or users';
    END IF;
    RETURN;
  END IF;

  -- ðŸ”§ ORG USER â€” hybrid policy: mostly read, scoped write
  IF _role = 'org_user' THEN
    -- Denied for sensitive reads
    IF _action = 'select' AND _resource IN (
      'organizations', 'organization_members', 'profiles', 'job_titles', 'integration_tokens'
    ) THEN
      RAISE EXCEPTION 'Access denied: org_user cannot read %', _resource;
    END IF;

    -- Allowed writes (insert/update/delete)
    IF _action IN ('insert', 'update', 'delete') THEN
      IF _resource IN (
        'daily_logs', 'photos', 'documents', 'rfis', 'submittals',
        'inspections', 'line_item_entries', 'labor_records',
        'equipment_usage', 'issues', 'punch_lists', 'quality_reviews',
        'meeting_minutes'
      ) THEN
        RETURN;
      ELSE
        RAISE EXCEPTION 'Access denied: org_user cannot write to %', _resource;
      END IF;
    END IF;

    RETURN; -- For valid reads
  END IF;

  -- ðŸ” ORG VIEWER â€” read-only
  IF _role = 'org_viewer' THEN
    IF _action = 'select' THEN
      RETURN;
    ELSE
      RAISE EXCEPTION 'Access denied: org_viewer is read-only';
    END IF;
  END IF;

  -- ðŸ•µï¸ INSPECTOR â€” must be assigned to project, and only on select resources
  IF _role = 'inspector' THEN
    IF _action = 'select' THEN
      RETURN;
    ELSIF _action IN ('insert', 'update') AND _resource IN (
      'inspections', 'reports', 'documents', 'regulatory_documents'
    ) THEN
      IF NOT EXISTS (
        SELECT 1 FROM project_inspectors
        WHERE project_id = _project_id AND profile_id = auth.uid()
      ) THEN
        RAISE EXCEPTION 'Access denied: inspector not assigned to project %', _project_id;
      END IF;
      RETURN;
    ELSE
      RAISE EXCEPTION 'Access denied: inspector cannot % on %', _action, _resource;
    END IF;
  END IF;

  -- ðŸ§¾ AUDITOR â€” global read-only
  IF _role = 'auditor' THEN
    IF _action = 'select' THEN
      RETURN;
    ELSE
      RAISE EXCEPTION 'Access denied: auditor is read-only';
    END IF;
  END IF;

  -- ðŸš« Fallback catch-all
  RAISE EXCEPTION 'Access denied: unrecognized role % or unsupported action % on %', _role, _action, _resource;
END;
$$;


--
-- TOC entry 1063 (class 1255 OID 21052)
-- Name: check_access_bool(text, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_access_bool(_action text, _table text, _proj uuid, _org uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM check_access(_action, _table, _proj, _org);
  RETURN true;
EXCEPTION
  WHEN others THEN
    RETURN false;
END;
$$;


--
-- TOC entry 405 (class 1259 OID 21745)
-- Name: profiles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.profiles (
    id uuid NOT NULL,
    email text NOT NULL,
    full_name text,
    phone text,
    job_title_id uuid,
    organization_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    role public.user_role_type DEFAULT 'org_user'::public.user_role_type,
    deleted_at timestamp with time zone,
    profile_completed_at timestamp with time zone,
    avatar_id uuid,
    location text
);

ALTER TABLE ONLY public.profiles FORCE ROW LEVEL SECURITY;


--
-- TOC entry 551 (class 1255 OID 34379)
-- Name: complete_my_profile(text, text, uuid, uuid, public.user_role_type, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_my_profile(p_full_name text, p_phone text DEFAULT NULL::text, p_job_title_id uuid DEFAULT NULL::uuid, p_avatar_id uuid DEFAULT NULL::uuid, p_role public.user_role_type DEFAULT NULL::public.user_role_type, p_organization_id uuid DEFAULT NULL::uuid) RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles;
  v_role public.user_role_type;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  v_role := p_role;
  if v_role = 'system_admin' then
    raise exception 'system_admin role cannot be assigned via onboarding';
  end if;

  update public.profiles
  set
    full_name = nullif(btrim(p_full_name), ''),
    phone = nullif(btrim(p_phone), ''),
    job_title_id = p_job_title_id,
    avatar_id = p_avatar_id,
    role = case when v_role is not null then v_role else role end,
    organization_id = p_organization_id,
    profile_completed_at = coalesce(profile_completed_at, now()),
    updated_at = now()
  where id = v_user_id
  returning * into v_profile;

  return v_profile;
end;
$$;


--
-- TOC entry 874 (class 1255 OID 43223)
-- Name: complete_my_profile(text, uuid, uuid, uuid, text, public.user_role_type, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_my_profile(p_full_name text, p_avatar_id uuid DEFAULT NULL::uuid, p_job_title_id uuid DEFAULT NULL::uuid, p_organization_id uuid DEFAULT NULL::uuid, p_phone text DEFAULT NULL::text, p_role public.user_role_type DEFAULT NULL::public.user_role_type, p_location text DEFAULT NULL::text) RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
DECLARE
    updated_profile profiles;
BEGIN

    UPDATE profiles
    SET
        avatar_id = p_avatar_id,
        full_name = p_full_name,
        job_title_id = p_job_title_id,
        organization_id = p_organization_id,
        phone = p_phone,
        role = p_role,
        location = p_location,
        profile_completed_at = NOW(),
        updated_at = NOW()
    WHERE id = auth.uid()
    RETURNING * INTO updated_profile;

    RETURN updated_profile;
END;
$$;


--
-- TOC entry 836 (class 1255 OID 21053)
-- Name: count_unread_notifications(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.count_unread_notifications() RETURNS integer
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  select count(*)
    from public.notifications
   where user_id = auth.uid()
     and is_read = false
     and deleted_at is null;
$$;


--
-- TOC entry 784 (class 1255 OID 43245)
-- Name: create_my_organization(text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_my_organization(p_name text, p_description text DEFAULT NULL::text, p_mission_statement text DEFAULT NULL::text, p_headquarters text DEFAULT NULL::text, p_logo_url text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_org_id uuid;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  insert into public.organizations (
    name, description, mission_statement, headquarters, logo_url, created_at, updated_at
  )
  values (
    p_name,
    nullif(btrim(p_description), ''),
    nullif(btrim(p_mission_statement), ''),
    nullif(btrim(p_headquarters), ''),
    nullif(btrim(p_logo_url), ''),
    now(),
    now()
  )
  returning id into v_org_id;

  insert into public.organization_members (organization_id, profile_id, role, created_at, updated_at)
  values (v_org_id, v_user_id, 'org_admin', now(), now());

  update public.profiles
  set organization_id = v_org_id,
      updated_at = now()
  where id = v_user_id;

  return v_org_id;
end;
$$;


--
-- TOC entry 408 (class 1259 OID 21771)
-- Name: projects; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    name text NOT NULL,
    description text,
    status public.project_status,
    start_date date,
    end_date date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.projects FORCE ROW LEVEL SECURITY;


--
-- TOC entry 643 (class 1255 OID 27703)
-- Name: create_project_with_owner(jsonb, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_project_with_owner(_input jsonb, _role text DEFAULT 'project_manager'::text) RETURNS SETOF public.projects
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_name text := nullif(_input->>'name','');
  v_description text := nullif(_input->>'description','');
  v_status public.project_status := coalesce((_input->>'status')::public.project_status, 'planned');
  v_start_date date := nullif(_input->>'start_date','')::date;
  v_end_date date := nullif(_input->>'end_date','')::date;
  v_project public.projects;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_profile.role = 'system_admin' and nullif(_input->>'organization_id','') is not null then
    v_org_id := (_input->>'organization_id')::uuid;
  end if;

  if v_org_id is null then
    raise exception 'Organization is required to create a project';
  end if;

  if v_name is null then
    raise exception 'Project name is required';
  end if;

  insert into public.projects (
    name,
    description,
    status,
    start_date,
    end_date,
    organization_id
  ) values (
    v_name,
    v_description,
    v_status,
    v_start_date,
    v_end_date,
    v_org_id
  )
  returning * into v_project;

  insert into public.user_projects (
    user_id,
    project_id,
    role
  ) values (
    v_user_id,
    v_project.id,
    _role
  );

  return next v_project;
end;
$$;


--
-- TOC entry 709 (class 1255 OID 21054)
-- Name: delete_accounts_payable(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_accounts_payable(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.accounts_payable;
        BEGIN
          SELECT * INTO _row FROM public.accounts_payable WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','accounts_payable', _row.project_id, _row.organization_id);

          UPDATE public.accounts_payable
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 775 (class 1255 OID 21055)
-- Name: delete_accounts_receivable(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_accounts_receivable(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.accounts_receivable;
        BEGIN
          SELECT * INTO _row FROM public.accounts_receivable WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','accounts_receivable', _row.project_id, _row.organization_id);

          UPDATE public.accounts_receivable
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 651 (class 1255 OID 21056)
-- Name: delete_activity_logs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_activity_logs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.activity_logs;
        BEGIN
          SELECT * INTO _row FROM public.activity_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','activity_logs', _row.project_id, _row.organization_id);

          UPDATE public.activity_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1036 (class 1255 OID 21057)
-- Name: delete_asphalt_types(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_asphalt_types(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.asphalt_types;
        BEGIN
          SELECT * INTO _row FROM public.asphalt_types WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','asphalt_types', _row.project_id, _row.organization_id);

          UPDATE public.asphalt_types
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 875 (class 1255 OID 27713)
-- Name: delete_audit_log(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_audit_log(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.audit_log;
    BEGIN
      SELECT * INTO _row FROM public.audit_log WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('delete','audit_log', NULL, NULL);

      UPDATE public.audit_log
         SET deleted_at = now()
       WHERE id = _id;
    END;
    $$;


--
-- TOC entry 903 (class 1255 OID 21058)
-- Name: delete_audit_logs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_audit_logs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.audit_logs;
        BEGIN
          SELECT * INTO _row FROM public.audit_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','audit_logs', _row.project_id, _row.organization_id);

          UPDATE public.audit_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 855 (class 1255 OID 21059)
-- Name: delete_avatars(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_avatars(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.avatars;
        BEGIN
          SELECT * INTO _row FROM public.avatars WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','avatars', _row.project_id, _row.organization_id);

          UPDATE public.avatars
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 623 (class 1255 OID 21060)
-- Name: delete_bid_packages(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_bid_packages(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.bid_packages;
        BEGIN
          SELECT * INTO _row FROM public.bid_packages WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bid_packages', _row.project_id, _row.organization_id);

          UPDATE public.bid_packages
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 976 (class 1255 OID 21061)
-- Name: delete_bid_vendors(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_bid_vendors(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.bid_vendors;
        BEGIN
          SELECT * INTO _row FROM public.bid_vendors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bid_vendors', _row.project_id, _row.organization_id);

          UPDATE public.bid_vendors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1065 (class 1255 OID 21062)
-- Name: delete_bids(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_bids(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.bids;
        BEGIN
          SELECT * INTO _row FROM public.bids WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bids', _row.project_id, _row.organization_id);

          UPDATE public.bids
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 934 (class 1255 OID 21063)
-- Name: delete_bim_models(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_bim_models(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.bim_models;
        BEGIN
          SELECT * INTO _row FROM public.bim_models WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bim_models', _row.project_id, _row.organization_id);

          UPDATE public.bim_models
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 696 (class 1255 OID 21064)
-- Name: delete_certifications(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_certifications(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.certifications;
        BEGIN
          SELECT * INTO _row FROM public.certifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','certifications', _row.project_id, _row.organization_id);

          UPDATE public.certifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1045 (class 1255 OID 21065)
-- Name: delete_change_orders(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_change_orders(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.change_orders;
        BEGIN
          SELECT * INTO _row FROM public.change_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','change_orders', _row.project_id, _row.organization_id);

          UPDATE public.change_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 751 (class 1255 OID 21066)
-- Name: delete_commitments(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_commitments(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.commitments;
        BEGIN
          SELECT * INTO _row FROM public.commitments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','commitments', _row.project_id, _row.organization_id);

          UPDATE public.commitments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 897 (class 1255 OID 21067)
-- Name: delete_compliance_checks(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_compliance_checks(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.compliance_checks;
        BEGIN
          SELECT * INTO _row FROM public.compliance_checks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','compliance_checks', _row.project_id, _row.organization_id);

          UPDATE public.compliance_checks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 645 (class 1255 OID 21068)
-- Name: delete_compliance_tracking(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_compliance_tracking(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.compliance_tracking;
        BEGIN
          SELECT * INTO _row FROM public.compliance_tracking WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','compliance_tracking', _row.project_id, _row.organization_id);

          UPDATE public.compliance_tracking
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 728 (class 1255 OID 21069)
-- Name: delete_cost_codes(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_cost_codes(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.cost_codes;
        BEGIN
          SELECT * INTO _row FROM public.cost_codes WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','cost_codes', _row.project_id, _row.organization_id);

          UPDATE public.cost_codes
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 574 (class 1255 OID 21070)
-- Name: delete_crew_assignments(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_crew_assignments(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.crew_assignments;
        BEGIN
          SELECT * INTO _row FROM public.crew_assignments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crew_assignments', _row.project_id, _row.organization_id);

          UPDATE public.crew_assignments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 909 (class 1255 OID 21071)
-- Name: delete_crew_members(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_crew_members(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.crew_members;
        BEGIN
          SELECT * INTO _row FROM public.crew_members WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crew_members', _row.project_id, _row.organization_id);

          UPDATE public.crew_members
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1023 (class 1255 OID 21072)
-- Name: delete_crews(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_crews(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.crews;
        BEGIN
          SELECT * INTO _row FROM public.crews WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crews', _row.project_id, _row.organization_id);

          UPDATE public.crews
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 930 (class 1255 OID 21073)
-- Name: delete_daily_logs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_daily_logs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.daily_logs;
        BEGIN
          SELECT * INTO _row FROM public.daily_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','daily_logs', _row.project_id, _row.organization_id);

          UPDATE public.daily_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 979 (class 1255 OID 21074)
-- Name: delete_dashboard_configs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_dashboard_configs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.dashboard_configs;
        BEGIN
          SELECT * INTO _row FROM public.dashboard_configs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','dashboard_configs', _row.project_id, _row.organization_id);

          UPDATE public.dashboard_configs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1073 (class 1255 OID 21075)
-- Name: delete_document_references(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_document_references(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.document_references;
        BEGIN
          SELECT * INTO _row FROM public.document_references WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','document_references', _row.project_id, _row.organization_id);

          UPDATE public.document_references
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 935 (class 1255 OID 21076)
-- Name: delete_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.documents;
        BEGIN
          SELECT * INTO _row FROM public.documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','documents', _row.project_id, _row.organization_id);

          UPDATE public.documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 829 (class 1255 OID 21077)
-- Name: delete_drawing_versions(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_drawing_versions(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.drawing_versions;
        BEGIN
          SELECT * INTO _row FROM public.drawing_versions WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','drawing_versions', _row.project_id, _row.organization_id);

          UPDATE public.drawing_versions
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 763 (class 1255 OID 21078)
-- Name: delete_dump_trucks(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_dump_trucks(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.dump_trucks;
        BEGIN
          SELECT * INTO _row FROM public.dump_trucks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','dump_trucks', _row.project_id, _row.organization_id);

          UPDATE public.dump_trucks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 771 (class 1255 OID 21079)
-- Name: delete_employees(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_employees(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.employees;
        BEGIN
          SELECT * INTO _row FROM public.employees WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','employees', _row.project_id, _row.organization_id);

          UPDATE public.employees
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 580 (class 1255 OID 21080)
-- Name: delete_equipment(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_equipment(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.equipment;
        BEGIN
          SELECT * INTO _row FROM public.equipment WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment', _row.project_id, _row.organization_id);

          UPDATE public.equipment
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 581 (class 1255 OID 21081)
-- Name: delete_equipment_assignments(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_equipment_assignments(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.equipment_assignments;
        BEGIN
          SELECT * INTO _row FROM public.equipment_assignments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_assignments', _row.project_id, _row.organization_id);

          UPDATE public.equipment_assignments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 895 (class 1255 OID 21082)
-- Name: delete_equipment_maintenance(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_equipment_maintenance(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.equipment_maintenance;
        BEGIN
          SELECT * INTO _row FROM public.equipment_maintenance WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_maintenance', _row.project_id, _row.organization_id);

          UPDATE public.equipment_maintenance
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 919 (class 1255 OID 21083)
-- Name: delete_equipment_usage(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_equipment_usage(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.equipment_usage;
        BEGIN
          SELECT * INTO _row FROM public.equipment_usage WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_usage', _row.project_id, _row.organization_id);

          UPDATE public.equipment_usage
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 773 (class 1255 OID 21084)
-- Name: delete_estimate_line_items(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_estimate_line_items(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.estimate_line_items;
        BEGIN
          SELECT * INTO _row FROM public.estimate_line_items WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','estimate_line_items', _row.project_id, _row.organization_id);

          UPDATE public.estimate_line_items
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 663 (class 1255 OID 21085)
-- Name: delete_estimates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_estimates(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.estimates;
        BEGIN
          SELECT * INTO _row FROM public.estimates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','estimates', _row.project_id, _row.organization_id);

          UPDATE public.estimates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1064 (class 1255 OID 21086)
-- Name: delete_financial_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_financial_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.financial_documents;
        BEGIN
          SELECT * INTO _row FROM public.financial_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','financial_documents', _row.project_id, _row.organization_id);

          UPDATE public.financial_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 798 (class 1255 OID 21087)
-- Name: delete_general_ledger(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_general_ledger(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.general_ledger;
        BEGIN
          SELECT * INTO _row FROM public.general_ledger WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','general_ledger', _row.project_id, _row.organization_id);

          UPDATE public.general_ledger
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 988 (class 1255 OID 21088)
-- Name: delete_hr_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_hr_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.hr_documents;
        BEGIN
          SELECT * INTO _row FROM public.hr_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','hr_documents', _row.project_id, _row.organization_id);

          UPDATE public.hr_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1014 (class 1255 OID 21089)
-- Name: delete_inspections(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_inspections(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.inspections;
        BEGIN
          SELECT * INTO _row FROM public.inspections WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','inspections', _row.project_id, _row.organization_id);

          UPDATE public.inspections
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 955 (class 1255 OID 21090)
-- Name: delete_integration_tokens(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_integration_tokens(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.integration_tokens;
        BEGIN
          SELECT * INTO _row FROM public.integration_tokens WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','integration_tokens', _row.project_id, _row.organization_id);

          UPDATE public.integration_tokens
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 939 (class 1255 OID 21091)
-- Name: delete_inventory_transactions(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_inventory_transactions(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.inventory_transactions;
        BEGIN
          SELECT * INTO _row FROM public.inventory_transactions WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','inventory_transactions', _row.project_id, _row.organization_id);

          UPDATE public.inventory_transactions
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 785 (class 1255 OID 21092)
-- Name: delete_issues(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_issues(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.issues;
        BEGIN
          SELECT * INTO _row FROM public.issues WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','issues', _row.project_id, _row.organization_id);

          UPDATE public.issues
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 787 (class 1255 OID 21093)
-- Name: delete_job_titles(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_job_titles(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.job_titles;
        BEGIN
          SELECT * INTO _row FROM public.job_titles WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','job_titles', _row.project_id, _row.organization_id);

          UPDATE public.job_titles
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 707 (class 1255 OID 21094)
-- Name: delete_labor_records(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_labor_records(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.labor_records;
        BEGIN
          SELECT * INTO _row FROM public.labor_records WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','labor_records', _row.project_id, _row.organization_id);

          UPDATE public.labor_records
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 559 (class 1255 OID 21095)
-- Name: delete_line_item_entries(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_line_item_entries(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.line_item_entries;
        BEGIN
          SELECT * INTO _row FROM public.line_item_entries WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_item_entries', _row.project_id, _row.organization_id);

          UPDATE public.line_item_entries
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 899 (class 1255 OID 21096)
-- Name: delete_line_item_templates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_line_item_templates(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.line_item_templates;
        BEGIN
          SELECT * INTO _row FROM public.line_item_templates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_item_templates', _row.project_id, _row.organization_id);

          UPDATE public.line_item_templates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 833 (class 1255 OID 21097)
-- Name: delete_line_items(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_line_items(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.line_items;
        BEGIN
          SELECT * INTO _row FROM public.line_items WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_items', _row.project_id, _row.organization_id);

          UPDATE public.line_items
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 697 (class 1255 OID 21098)
-- Name: delete_maps(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_maps(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.maps;
        BEGIN
          SELECT * INTO _row FROM public.maps WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','maps', _row.project_id, _row.organization_id);

          UPDATE public.maps
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 545 (class 1255 OID 21099)
-- Name: delete_material_inventory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_material_inventory(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.material_inventory;
        BEGIN
          SELECT * INTO _row FROM public.material_inventory WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_inventory', _row.project_id, _row.organization_id);

          UPDATE public.material_inventory
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 740 (class 1255 OID 21100)
-- Name: delete_material_orders(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_material_orders(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.material_orders;
        BEGIN
          SELECT * INTO _row FROM public.material_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_orders', _row.project_id, _row.organization_id);

          UPDATE public.material_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 640 (class 1255 OID 21101)
-- Name: delete_material_receipts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_material_receipts(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.material_receipts;
        BEGIN
          SELECT * INTO _row FROM public.material_receipts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_receipts', _row.project_id, _row.organization_id);

          UPDATE public.material_receipts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1041 (class 1255 OID 21102)
-- Name: delete_materials(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_materials(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.materials;
        BEGIN
          SELECT * INTO _row FROM public.materials WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','materials', _row.project_id, _row.organization_id);

          UPDATE public.materials
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 830 (class 1255 OID 21103)
-- Name: delete_meeting_minutes(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_meeting_minutes(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.meeting_minutes;
        BEGIN
          SELECT * INTO _row FROM public.meeting_minutes WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','meeting_minutes', _row.project_id, _row.organization_id);

          UPDATE public.meeting_minutes
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 837 (class 1255 OID 21104)
-- Name: delete_notifications(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_notifications(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.notifications;
        BEGIN
          SELECT * INTO _row FROM public.notifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','notifications', _row.project_id, _row.organization_id);

          UPDATE public.notifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 699 (class 1255 OID 43257)
-- Name: delete_organization_invites(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_invites(_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _row public.organization_invites;
BEGIN
  SELECT * INTO _row FROM public.organization_invites WHERE id = _id;
  IF _row IS NULL THEN RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id); END IF;

  PERFORM check_access('delete','organization_invites', NULL, _row.organization_id);

  DELETE FROM public.organization_invites WHERE id = _id;
END;
$$;


--
-- TOC entry 761 (class 1255 OID 27717)
-- Name: delete_organization_member_rates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_member_rates(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.organization_member_rates;
      _organization_id uuid;
    BEGIN
      SELECT * INTO _row FROM public.organization_member_rates WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      SELECT organization_id INTO _organization_id
        FROM public.organization_members
       WHERE id = _row.membership_id;

      PERFORM check_access('delete','organization_member_rates', NULL, _organization_id);

      DELETE FROM public.organization_member_rates WHERE id = _id;
    END;
    $$;


--
-- TOC entry 1068 (class 1255 OID 21105)
-- Name: delete_organization_members(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_members(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.organization_members;
        BEGIN
          SELECT * INTO _row FROM public.organization_members WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','organization_members', _row.project_id, _row.organization_id);

          UPDATE public.organization_members
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 631 (class 1255 OID 21106)
-- Name: delete_organization_projects(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_projects(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.organization_projects;
        BEGIN
          SELECT * INTO _row FROM public.organization_projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','organization_projects', _row.project_id, _row.organization_id);

          UPDATE public.organization_projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 560 (class 1255 OID 27721)
-- Name: delete_organization_service_areas(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_service_areas(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.organization_service_areas;
    BEGIN
      SELECT * INTO _row FROM public.organization_service_areas WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('delete','organization_service_areas', NULL, _row.organization_id);

      DELETE FROM public.organization_service_areas WHERE id = _id;
    END;
    $$;


--
-- TOC entry 1001 (class 1255 OID 21107)
-- Name: delete_organizations(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organizations(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.organizations;
        BEGIN
          SELECT * INTO _row FROM public.organizations WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','organizations', _row.project_id, _row.organization_id);

          UPDATE public.organizations
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 622 (class 1255 OID 21108)
-- Name: delete_payments(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_payments(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.payments;
        BEGIN
          SELECT * INTO _row FROM public.payments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','payments', _row.project_id, _row.organization_id);

          UPDATE public.payments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 694 (class 1255 OID 21109)
-- Name: delete_payroll(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_payroll(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.payroll;
        BEGIN
          SELECT * INTO _row FROM public.payroll WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','payroll', _row.project_id, _row.organization_id);

          UPDATE public.payroll
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 575 (class 1255 OID 21110)
-- Name: delete_photos(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_photos(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.photos;
        BEGIN
          SELECT * INTO _row FROM public.photos WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','photos', _row.project_id, _row.organization_id);

          UPDATE public.photos
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 876 (class 1255 OID 21111)
-- Name: delete_prequalifications(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_prequalifications(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.prequalifications;
        BEGIN
          SELECT * INTO _row FROM public.prequalifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','prequalifications', _row.project_id, _row.organization_id);

          UPDATE public.prequalifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1077 (class 1255 OID 21112)
-- Name: delete_procurement_workflows(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_procurement_workflows(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.procurement_workflows;
        BEGIN
          SELECT * INTO _row FROM public.procurement_workflows WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','procurement_workflows', _row.project_id, _row.organization_id);

          UPDATE public.procurement_workflows
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1009 (class 1255 OID 21113)
-- Name: delete_profiles(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_profiles(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.profiles;
        BEGIN
          SELECT * INTO _row FROM public.profiles WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','profiles', _row.project_id, _row.organization_id);

          UPDATE public.profiles
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 842 (class 1255 OID 21114)
-- Name: delete_progress_billings(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_progress_billings(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.progress_billings;
        BEGIN
          SELECT * INTO _row FROM public.progress_billings WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','progress_billings', _row.project_id, _row.organization_id);

          UPDATE public.progress_billings
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 917 (class 1255 OID 21115)
-- Name: delete_project_inspectors(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_project_inspectors(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.project_inspectors;
        BEGIN
          SELECT * INTO _row FROM public.project_inspectors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','project_inspectors', _row.project_id, _row.organization_id);

          UPDATE public.project_inspectors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 884 (class 1255 OID 27725)
-- Name: delete_project_invites(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_project_invites(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.project_invites;
    BEGIN
      SELECT * INTO _row FROM public.project_invites WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('delete','project_invites', _row.project_id, NULL);

      DELETE FROM public.project_invites WHERE id = _id;
    END;
    $$;


--
-- TOC entry 817 (class 1255 OID 27729)
-- Name: delete_project_service_areas(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_project_service_areas(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.project_service_areas;
    BEGIN
      SELECT * INTO _row FROM public.project_service_areas WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('delete','project_service_areas', _row.project_id, NULL);

      DELETE FROM public.project_service_areas WHERE id = _id;
    END;
    $$;


--
-- TOC entry 1027 (class 1255 OID 21116)
-- Name: delete_projects(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_projects(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.projects;
        BEGIN
          SELECT * INTO _row FROM public.projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','projects', _row.project_id, _row.organization_id);

          UPDATE public.projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 654 (class 1255 OID 21117)
-- Name: delete_punch_lists(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_punch_lists(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.punch_lists;
        BEGIN
          SELECT * INTO _row FROM public.punch_lists WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','punch_lists', _row.project_id, _row.organization_id);

          UPDATE public.punch_lists
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 589 (class 1255 OID 21118)
-- Name: delete_purchase_orders(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_purchase_orders(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.purchase_orders;
        BEGIN
          SELECT * INTO _row FROM public.purchase_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','purchase_orders', _row.project_id, _row.organization_id);

          UPDATE public.purchase_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 656 (class 1255 OID 21119)
-- Name: delete_quality_reviews(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_quality_reviews(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.quality_reviews;
        BEGIN
          SELECT * INTO _row FROM public.quality_reviews WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','quality_reviews', _row.project_id, _row.organization_id);

          UPDATE public.quality_reviews
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 967 (class 1255 OID 21120)
-- Name: delete_regulatory_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_regulatory_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.regulatory_documents;
        BEGIN
          SELECT * INTO _row FROM public.regulatory_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','regulatory_documents', _row.project_id, _row.organization_id);

          UPDATE public.regulatory_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 902 (class 1255 OID 21121)
-- Name: delete_reports(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_reports(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.reports;
        BEGIN
          SELECT * INTO _row FROM public.reports WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','reports', _row.project_id, _row.organization_id);

          UPDATE public.reports
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 768 (class 1255 OID 21122)
-- Name: delete_rfis(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_rfis(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.rfis;
        BEGIN
          SELECT * INTO _row FROM public.rfis WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','rfis', _row.project_id, _row.organization_id);

          UPDATE public.rfis
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 911 (class 1255 OID 21123)
-- Name: delete_safety_incidents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_safety_incidents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.safety_incidents;
        BEGIN
          SELECT * INTO _row FROM public.safety_incidents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','safety_incidents', _row.project_id, _row.organization_id);

          UPDATE public.safety_incidents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 933 (class 1255 OID 21124)
-- Name: delete_sensor_data(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_sensor_data(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.sensor_data;
        BEGIN
          SELECT * INTO _row FROM public.sensor_data WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','sensor_data', _row.project_id, _row.organization_id);

          UPDATE public.sensor_data
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 803 (class 1255 OID 21125)
-- Name: delete_subcontractor_agreements(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_subcontractor_agreements(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.subcontractor_agreements;
        BEGIN
          SELECT * INTO _row FROM public.subcontractor_agreements WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','subcontractor_agreements', _row.project_id, _row.organization_id);

          UPDATE public.subcontractor_agreements
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 615 (class 1255 OID 21126)
-- Name: delete_subcontracts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_subcontracts(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.subcontracts;
        BEGIN
          SELECT * INTO _row FROM public.subcontracts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','subcontracts', _row.project_id, _row.organization_id);

          UPDATE public.subcontracts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 556 (class 1255 OID 21127)
-- Name: delete_submittals(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_submittals(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.submittals;
        BEGIN
          SELECT * INTO _row FROM public.submittals WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','submittals', _row.project_id, _row.organization_id);

          UPDATE public.submittals
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 641 (class 1255 OID 21128)
-- Name: delete_tack_rates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_tack_rates(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.tack_rates;
        BEGIN
          SELECT * INTO _row FROM public.tack_rates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','tack_rates', _row.project_id, _row.organization_id);

          UPDATE public.tack_rates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 1069 (class 1255 OID 21129)
-- Name: delete_task_dependencies(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_task_dependencies(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.task_dependencies;
        BEGIN
          SELECT * INTO _row FROM public.task_dependencies WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','task_dependencies', _row.project_id, _row.organization_id);

          UPDATE public.task_dependencies
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 717 (class 1255 OID 21130)
-- Name: delete_task_status_logs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_task_status_logs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.task_status_logs;
        BEGIN
          SELECT * INTO _row FROM public.task_status_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','task_status_logs', _row.project_id, _row.organization_id);

          UPDATE public.task_status_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 759 (class 1255 OID 21131)
-- Name: delete_tasks(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_tasks(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.tasks;
        BEGIN
          SELECT * INTO _row FROM public.tasks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','tasks', _row.project_id, _row.organization_id);

          UPDATE public.tasks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 926 (class 1255 OID 21132)
-- Name: delete_training_records(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_training_records(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.training_records;
        BEGIN
          SELECT * INTO _row FROM public.training_records WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','training_records', _row.project_id, _row.organization_id);

          UPDATE public.training_records
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 910 (class 1255 OID 21133)
-- Name: delete_user_projects(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_user_projects(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.user_projects;
        BEGIN
          SELECT * INTO _row FROM public.user_projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','user_projects', _row.project_id, _row.organization_id);

          UPDATE public.user_projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 710 (class 1255 OID 21134)
-- Name: delete_vendor_bid_packages(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendor_bid_packages(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendor_bid_packages;
        BEGIN
          SELECT * INTO _row FROM public.vendor_bid_packages WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_bid_packages', _row.project_id, _row.organization_id);

          UPDATE public.vendor_bid_packages
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 625 (class 1255 OID 21135)
-- Name: delete_vendor_contacts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendor_contacts(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendor_contacts;
        BEGIN
          SELECT * INTO _row FROM public.vendor_contacts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_contacts', _row.project_id, _row.organization_id);

          UPDATE public.vendor_contacts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 937 (class 1255 OID 21136)
-- Name: delete_vendor_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendor_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendor_documents;
        BEGIN
          SELECT * INTO _row FROM public.vendor_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_documents', _row.project_id, _row.organization_id);

          UPDATE public.vendor_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 815 (class 1255 OID 21137)
-- Name: delete_vendor_qualifications(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendor_qualifications(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendor_qualifications;
        BEGIN
          SELECT * INTO _row FROM public.vendor_qualifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_qualifications', _row.project_id, _row.organization_id);

          UPDATE public.vendor_qualifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 890 (class 1255 OID 21138)
-- Name: delete_vendors(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendors(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendors;
        BEGIN
          SELECT * INTO _row FROM public.vendors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendors', _row.project_id, _row.organization_id);

          UPDATE public.vendors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 720 (class 1255 OID 21139)
-- Name: delete_wbs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_wbs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.wbs;
        BEGIN
          SELECT * INTO _row FROM public.wbs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','wbs', _row.project_id, _row.organization_id);

          UPDATE public.wbs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 791 (class 1255 OID 21140)
-- Name: delete_workflows(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_workflows(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.workflows;
        BEGIN
          SELECT * INTO _row FROM public.workflows WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','workflows', _row.project_id, _row.organization_id);

          UPDATE public.workflows
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- TOC entry 776 (class 1255 OID 21141)
-- Name: ensure_fk_indexes_for_schema(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ensure_fk_indexes_for_schema(_schema text DEFAULT 'public'::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
DECLARE
  r RECORD;
  idx_name text;
BEGIN
  FOR r IN
    WITH fks AS (
      SELECT
        con.oid                              AS con_oid,        -- (fixed: was c.oid)
        n.nspname                            AS child_schema,
        t.relname                            AS child_table,
        con.conname                          AS fk_name,
        con.conrelid                         AS child_relid,
        con.conkey                           AS child_attnums
      FROM pg_constraint con
      JOIN pg_class     t  ON t.oid = con.conrelid
      JOIN pg_namespace n  ON n.oid = t.relnamespace
      WHERE con.contype = 'f'
        AND n.nspname = _schema
    ),
    fk_cols AS (
      -- ordered FK column names
      SELECT
        f.con_oid,
        f.child_schema,
        f.child_table,
        f.fk_name,
        f.child_relid,
        ARRAY_AGG(a.attname ORDER BY s.ord) AS child_cols
      FROM fks f
      JOIN LATERAL generate_subscripts(f.child_attnums, 1) AS s(ord) ON TRUE
      JOIN pg_attribute a
        ON a.attrelid = f.child_relid
       AND a.attnum   = f.child_attnums[s.ord]
      GROUP BY f.con_oid, f.child_schema, f.child_table, f.fk_name, f.child_relid
    ),
    idx_cols AS (
      -- for each index on the child table, get its ordered column NAMES
      SELECT
        i.indrelid                                  AS tbl_relid,
        i.indexrelid                                AS idx_relid,
        ARRAY_AGG(att.attname ORDER BY k.ord)       AS idx_colnames
      FROM pg_index i
      JOIN LATERAL unnest(i.indkey) WITH ORDINALITY AS k(attnum, ord) ON TRUE
      JOIN pg_attribute att
        ON att.attrelid = i.indexrelid
       AND att.attnum   = k.ord      -- attribute order within index
      GROUP BY i.indrelid, i.indexrelid
    ),
    needs AS (
      SELECT
        fk.child_schema,
        fk.child_table,
        fk.fk_name,
        fk.child_relid,
        fk.child_cols
      FROM fk_cols fk
      WHERE NOT EXISTS (
        SELECT 1
        FROM idx_cols ix
        WHERE ix.tbl_relid = fk.child_relid
          AND ix.idx_colnames = fk.child_cols
      )
    )
    SELECT *
    FROM needs
    ORDER BY child_schema, child_table, fk_name
  LOOP
    -- Build a deterministic (and short) index name, add suffix if collides
    idx_name := format('ix_%s__fk_%s', r.child_table, r.fk_name);
    WHILE EXISTS (
      SELECT 1
      FROM pg_class c
      JOIN pg_namespace n ON n.oid = c.relnamespace
      WHERE n.nspname = r.child_schema
        AND c.relname = idx_name
    ) LOOP
      idx_name := idx_name || '_' || floor(random()*1000)::int;
    END LOOP;

    -- CREATE INDEX ON child table over the FK columns in order
    EXECUTE format(
      'CREATE INDEX %I ON %I.%I (%s);',
      idx_name,
      r.child_schema,
      r.child_table,
      (
        SELECT string_agg(quote_ident(col), ', ')
        FROM unnest(r.child_cols) AS col
      )
    );

    RAISE NOTICE 'Created FK index % on %.% (%).',
      idx_name, r.child_schema, r.child_table, array_to_string(r.child_cols, ', ');
  END LOOP;
END
$$;


--
-- TOC entry 725 (class 1255 OID 21142)
-- Name: ensure_soft_delete_cols(regclass); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ensure_soft_delete_cols(_tbl regclass) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  col_exists bool;
begin
  select exists (
    select 1 from pg_attribute 
     where attrelid = _tbl
       and attname  = 'deleted_at'
       and not attisdropped)
  into col_exists;

  if not col_exists then
    execute format('alter table %s add column deleted_at timestamptz', _tbl);
  end if;
end;
$$;


--
-- TOC entry 346 (class 1259 OID 21143)
-- Name: accounts_payable; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.accounts_payable (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    amount_due numeric,
    due_date date,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.accounts_payable FORCE ROW LEVEL SECURITY;


--
-- TOC entry 669 (class 1255 OID 21151)
-- Name: filter_accounts_payable(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_accounts_payable(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.accounts_payable
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','accounts_payable', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='accounts_payable'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='accounts_payable'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='accounts_payable'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.accounts_payable WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 347 (class 1259 OID 21153)
-- Name: accounts_receivable; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.accounts_receivable (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    amount_due numeric,
    due_date date,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.accounts_receivable FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1030 (class 1255 OID 21161)
-- Name: filter_accounts_receivable(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_accounts_receivable(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.accounts_receivable
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','accounts_receivable', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='accounts_receivable'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='accounts_receivable'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='accounts_receivable'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.accounts_receivable WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 348 (class 1259 OID 21163)
-- Name: activity_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.activity_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    activity_type text,
    activity_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.activity_logs FORCE ROW LEVEL SECURITY;


--
-- TOC entry 824 (class 1255 OID 21172)
-- Name: filter_activity_logs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_activity_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.activity_logs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','activity_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='activity_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='activity_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='activity_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.activity_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 349 (class 1259 OID 21174)
-- Name: asphalt_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.asphalt_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.asphalt_types FORCE ROW LEVEL SECURITY;


--
-- TOC entry 588 (class 1255 OID 21182)
-- Name: filter_asphalt_types(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_asphalt_types(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.asphalt_types
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','asphalt_types', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='asphalt_types'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='asphalt_types'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='asphalt_types'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.asphalt_types WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 436 (class 1259 OID 22221)
-- Name: audit_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.audit_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    table_name text NOT NULL,
    action text NOT NULL,
    row_id uuid,
    before_data jsonb,
    after_data jsonb,
    changed_by uuid DEFAULT auth.uid(),
    changed_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone
);


--
-- TOC entry 1074 (class 1255 OID 27710)
-- Name: filter_audit_log(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_audit_log(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _where           text := 'deleted_at IS NULL';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      -- Normalize filters to an object
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      -- Authorization gate (RLS still applies)
      PERFORM check_access('select','audit_log', _project_id, _organization_id);

      -- Build WHERE from filters
      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='audit_log'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='audit_log'
            AND column_name <> 'deleted_at';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='audit_log'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.audit_log WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- TOC entry 350 (class 1259 OID 21184)
-- Name: audit_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.audit_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    action text,
    performed_by uuid,
    performed_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.audit_logs FORCE ROW LEVEL SECURITY;


--
-- TOC entry 792 (class 1255 OID 21193)
-- Name: filter_audit_logs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_audit_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.audit_logs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','audit_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='audit_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='audit_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='audit_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.audit_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 351 (class 1259 OID 21195)
-- Name: avatars; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.avatars (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    url text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    is_preset boolean DEFAULT false NOT NULL
);

ALTER TABLE ONLY public.avatars FORCE ROW LEVEL SECURITY;


--
-- TOC entry 802 (class 1255 OID 21203)
-- Name: filter_avatars(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_avatars(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.avatars
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','avatars', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='avatars'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='avatars'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='avatars'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.avatars WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 352 (class 1259 OID 21205)
-- Name: bid_packages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bid_packages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    status text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.bid_packages FORCE ROW LEVEL SECURITY;


--
-- TOC entry 831 (class 1255 OID 21213)
-- Name: filter_bid_packages(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_bid_packages(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.bid_packages
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bid_packages', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bid_packages'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bid_packages'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bid_packages'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bid_packages WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 353 (class 1259 OID 21215)
-- Name: bid_vendors; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bid_vendors (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bid_package_id uuid,
    vendor_id uuid,
    invited_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.bid_vendors FORCE ROW LEVEL SECURITY;


--
-- TOC entry 548 (class 1255 OID 21222)
-- Name: filter_bid_vendors(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_bid_vendors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.bid_vendors
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bid_vendors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bid_vendors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bid_vendors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bid_vendors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bid_vendors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 354 (class 1259 OID 21224)
-- Name: bids; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bids (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bid_package_id uuid,
    vendor_id uuid,
    amount numeric,
    submitted_at timestamp with time zone DEFAULT now(),
    status public.general_status DEFAULT 'pending'::public.general_status,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.bids FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1062 (class 1255 OID 21234)
-- Name: filter_bids(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_bids(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.bids
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bids', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bids'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bids'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bids'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bids WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 355 (class 1259 OID 21235)
-- Name: bim_models; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bim_models (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.bim_models FORCE ROW LEVEL SECURITY;


--
-- TOC entry 647 (class 1255 OID 21244)
-- Name: filter_bim_models(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_bim_models(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.bim_models
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bim_models', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bim_models'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bim_models'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bim_models'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bim_models WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 356 (class 1259 OID 21246)
-- Name: certifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.certifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid,
    certification_type text,
    issue_date date,
    expiry_date date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.certifications FORCE ROW LEVEL SECURITY;


--
-- TOC entry 892 (class 1255 OID 21254)
-- Name: filter_certifications(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_certifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.certifications
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','certifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='certifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='certifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='certifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.certifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 357 (class 1259 OID 21256)
-- Name: change_orders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.change_orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    number text NOT NULL,
    description text,
    status text,
    amount numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.change_orders FORCE ROW LEVEL SECURITY;


--
-- TOC entry 561 (class 1255 OID 21264)
-- Name: filter_change_orders(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_change_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.change_orders
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','change_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='change_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='change_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='change_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.change_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 358 (class 1259 OID 21266)
-- Name: commitments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.commitments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    vendor_id uuid,
    type public.commitment_type,
    amount numeric,
    status text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.commitments FORCE ROW LEVEL SECURITY;


--
-- TOC entry 827 (class 1255 OID 21274)
-- Name: filter_commitments(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_commitments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.commitments
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','commitments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='commitments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='commitments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='commitments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.commitments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 359 (class 1259 OID 21276)
-- Name: compliance_checks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.compliance_checks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    check_date date,
    description text,
    result text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.compliance_checks FORCE ROW LEVEL SECURITY;


--
-- TOC entry 983 (class 1255 OID 21284)
-- Name: filter_compliance_checks(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_compliance_checks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.compliance_checks
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','compliance_checks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='compliance_checks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='compliance_checks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='compliance_checks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.compliance_checks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 360 (class 1259 OID 21286)
-- Name: compliance_tracking; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.compliance_tracking (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    tracking_type text,
    status text,
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.compliance_tracking FORCE ROW LEVEL SECURITY;


--
-- TOC entry 702 (class 1255 OID 21294)
-- Name: filter_compliance_tracking(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_compliance_tracking(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.compliance_tracking
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','compliance_tracking', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='compliance_tracking'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='compliance_tracking'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='compliance_tracking'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.compliance_tracking WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 361 (class 1259 OID 21296)
-- Name: cost_codes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cost_codes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    code text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.cost_codes FORCE ROW LEVEL SECURITY;


--
-- TOC entry 569 (class 1255 OID 21304)
-- Name: filter_cost_codes(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_cost_codes(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.cost_codes
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','cost_codes', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='cost_codes'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='cost_codes'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='cost_codes'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.cost_codes WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 362 (class 1259 OID 21306)
-- Name: crew_assignments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crew_assignments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    crew_id uuid,
    profile_id uuid,
    assigned_date date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.crew_assignments FORCE ROW LEVEL SECURITY;


--
-- TOC entry 611 (class 1255 OID 21312)
-- Name: filter_crew_assignments(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_crew_assignments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.crew_assignments
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crew_assignments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crew_assignments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crew_assignments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crew_assignments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crew_assignments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 363 (class 1259 OID 21314)
-- Name: crew_members; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crew_members (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    crew_id uuid,
    profile_id uuid,
    role text,
    start_date date,
    end_date date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.crew_members FORCE ROW LEVEL SECURITY;


--
-- TOC entry 845 (class 1255 OID 21322)
-- Name: filter_crew_members(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_crew_members(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.crew_members
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crew_members', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crew_members'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crew_members'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crew_members'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crew_members WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 364 (class 1259 OID 21329)
-- Name: crews; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crews (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.crews FORCE ROW LEVEL SECURITY;


--
-- TOC entry 692 (class 1255 OID 21337)
-- Name: filter_crews(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_crews(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.crews
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crews', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crews'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crews'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crews'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crews WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 365 (class 1259 OID 21339)
-- Name: daily_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.daily_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    date date NOT NULL,
    weather jsonb,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.daily_logs FORCE ROW LEVEL SECURITY;


--
-- TOC entry 644 (class 1255 OID 21347)
-- Name: filter_daily_logs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_daily_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.daily_logs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','daily_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='daily_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='daily_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='daily_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.daily_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 366 (class 1259 OID 21349)
-- Name: dashboard_configs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.dashboard_configs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    config jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.dashboard_configs FORCE ROW LEVEL SECURITY;


--
-- TOC entry 996 (class 1255 OID 21357)
-- Name: filter_dashboard_configs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_dashboard_configs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.dashboard_configs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','dashboard_configs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='dashboard_configs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='dashboard_configs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='dashboard_configs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.dashboard_configs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 367 (class 1259 OID 21359)
-- Name: document_references; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.document_references (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_id uuid,
    reference_type text,
    reference_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.document_references FORCE ROW LEVEL SECURITY;


--
-- TOC entry 779 (class 1255 OID 21367)
-- Name: filter_document_references(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_document_references(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.document_references
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','document_references', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='document_references'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='document_references'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='document_references'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.document_references WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 368 (class 1259 OID 21369)
-- Name: documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    type text,
    url text,
    uploaded_by uuid,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.documents FORCE ROW LEVEL SECURITY;


--
-- TOC entry 998 (class 1255 OID 21378)
-- Name: filter_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 369 (class 1259 OID 21380)
-- Name: drawing_versions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.drawing_versions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_id uuid,
    version text,
    uploaded_by uuid,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.drawing_versions FORCE ROW LEVEL SECURITY;


--
-- TOC entry 541 (class 1255 OID 21389)
-- Name: filter_drawing_versions(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_drawing_versions(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.drawing_versions
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','drawing_versions', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='drawing_versions'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='drawing_versions'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='drawing_versions'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.drawing_versions WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 370 (class 1259 OID 21391)
-- Name: dump_trucks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.dump_trucks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    make text,
    model text,
    capacity numeric,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.dump_trucks FORCE ROW LEVEL SECURITY;


--
-- TOC entry 633 (class 1255 OID 21399)
-- Name: filter_dump_trucks(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_dump_trucks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.dump_trucks
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','dump_trucks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='dump_trucks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='dump_trucks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='dump_trucks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.dump_trucks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 371 (class 1259 OID 21401)
-- Name: employees; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.employees (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    profile_id uuid,
    hire_date date,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.employees FORCE ROW LEVEL SECURITY;


--
-- TOC entry 533 (class 1255 OID 21409)
-- Name: filter_employees(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_employees(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.employees
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','employees', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='employees'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='employees'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='employees'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.employees WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 372 (class 1259 OID 21411)
-- Name: equipment; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.equipment (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    name text NOT NULL,
    type public.equipment_type,
    model text,
    serial_number text,
    status text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.equipment FORCE ROW LEVEL SECURITY;


--
-- TOC entry 958 (class 1255 OID 21419)
-- Name: filter_equipment(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_equipment(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.equipment
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 373 (class 1259 OID 21421)
-- Name: equipment_assignments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.equipment_assignments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    equipment_id uuid,
    project_id uuid,
    assigned_to uuid,
    assigned_date date,
    released_date date,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.equipment_assignments FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1028 (class 1255 OID 21429)
-- Name: filter_equipment_assignments(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_equipment_assignments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.equipment_assignments
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_assignments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_assignments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_assignments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_assignments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_assignments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 374 (class 1259 OID 21431)
-- Name: equipment_maintenance; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.equipment_maintenance (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    equipment_id uuid,
    maintenance_date date,
    type text,
    description text,
    performed_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.equipment_maintenance FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1004 (class 1255 OID 21439)
-- Name: filter_equipment_maintenance(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_equipment_maintenance(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.equipment_maintenance
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_maintenance', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_maintenance'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_maintenance'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_maintenance'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_maintenance WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 375 (class 1259 OID 21441)
-- Name: equipment_usage; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.equipment_usage (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    equipment_id uuid,
    date date NOT NULL,
    hours_used numeric,
    quantity numeric,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.equipment_usage FORCE ROW LEVEL SECURITY;


--
-- TOC entry 764 (class 1255 OID 21449)
-- Name: filter_equipment_usage(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_equipment_usage(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.equipment_usage
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_usage', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_usage'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_usage'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_usage'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_usage WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 376 (class 1259 OID 21451)
-- Name: estimate_line_items; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.estimate_line_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    estimate_id uuid,
    cost_code_id uuid,
    name text,
    unit_measure text,
    quantity numeric,
    unit_price numeric,
    total_cost numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.estimate_line_items FORCE ROW LEVEL SECURITY;


--
-- TOC entry 604 (class 1255 OID 21459)
-- Name: filter_estimate_line_items(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_estimate_line_items(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.estimate_line_items
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','estimate_line_items', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='estimate_line_items'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='estimate_line_items'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='estimate_line_items'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.estimate_line_items WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 377 (class 1259 OID 21461)
-- Name: estimates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.estimates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    status text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.estimates FORCE ROW LEVEL SECURITY;


--
-- TOC entry 914 (class 1255 OID 21469)
-- Name: filter_estimates(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_estimates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.estimates
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','estimates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='estimates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='estimates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='estimates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.estimates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 378 (class 1259 OID 21471)
-- Name: financial_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.financial_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    document_type text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.financial_documents FORCE ROW LEVEL SECURITY;


--
-- TOC entry 854 (class 1255 OID 21480)
-- Name: filter_financial_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_financial_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.financial_documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','financial_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='financial_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='financial_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='financial_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.financial_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 379 (class 1259 OID 21482)
-- Name: general_ledger; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.general_ledger (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    entry_date date,
    description text,
    debit numeric,
    credit numeric,
    balance numeric,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.general_ledger FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1078 (class 1255 OID 21490)
-- Name: filter_general_ledger(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_general_ledger(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.general_ledger
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','general_ledger', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='general_ledger'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='general_ledger'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='general_ledger'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.general_ledger WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 380 (class 1259 OID 21492)
-- Name: hr_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.hr_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid,
    document_type text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.hr_documents FORCE ROW LEVEL SECURITY;


--
-- TOC entry 726 (class 1255 OID 21501)
-- Name: filter_hr_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_hr_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.hr_documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','hr_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='hr_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='hr_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='hr_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.hr_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 381 (class 1259 OID 21503)
-- Name: inspections; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inspections (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    inspection_type text,
    date date,
    status text,
    result jsonb,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.inspections FORCE ROW LEVEL SECURITY;


--
-- TOC entry 825 (class 1255 OID 21511)
-- Name: filter_inspections(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_inspections(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.inspections
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','inspections', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='inspections'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='inspections'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='inspections'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.inspections WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 382 (class 1259 OID 21513)
-- Name: integration_tokens; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.integration_tokens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    service_name text,
    token text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.integration_tokens FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1008 (class 1255 OID 21521)
-- Name: filter_integration_tokens(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_integration_tokens(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.integration_tokens
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','integration_tokens', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='integration_tokens'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='integration_tokens'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='integration_tokens'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.integration_tokens WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 383 (class 1259 OID 21523)
-- Name: inventory_transactions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inventory_transactions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_id uuid,
    transaction_type text,
    quantity numeric,
    transaction_date date,
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.inventory_transactions FORCE ROW LEVEL SECURITY;


--
-- TOC entry 532 (class 1255 OID 21531)
-- Name: filter_inventory_transactions(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_inventory_transactions(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.inventory_transactions
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','inventory_transactions', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='inventory_transactions'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='inventory_transactions'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='inventory_transactions'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.inventory_transactions WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 384 (class 1259 OID 21533)
-- Name: issues; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.issues (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    type text,
    status text,
    reported_by uuid,
    description text,
    resolved boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.issues FORCE ROW LEVEL SECURITY;


--
-- TOC entry 648 (class 1255 OID 21542)
-- Name: filter_issues(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_issues(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.issues
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','issues', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='issues'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='issues'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='issues'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.issues WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 385 (class 1259 OID 21544)
-- Name: job_titles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.job_titles (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.job_titles FORCE ROW LEVEL SECURITY;


--
-- TOC entry 943 (class 1255 OID 21552)
-- Name: filter_job_titles(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_job_titles(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.job_titles
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','job_titles', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='job_titles'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='job_titles'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='job_titles'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.job_titles WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 386 (class 1259 OID 21554)
-- Name: labor_records; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.labor_records (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    line_item_id uuid,
    worker_count integer,
    hours_worked numeric,
    work_date date,
    work_type text,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.labor_records FORCE ROW LEVEL SECURITY;


--
-- TOC entry 601 (class 1255 OID 21562)
-- Name: filter_labor_records(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_labor_records(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.labor_records
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','labor_records', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='labor_records'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='labor_records'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='labor_records'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.labor_records WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 387 (class 1259 OID 21564)
-- Name: line_item_entries; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.line_item_entries (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    line_item_id uuid,
    date date NOT NULL,
    quantity_completed numeric,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.line_item_entries FORCE ROW LEVEL SECURITY;


--
-- TOC entry 670 (class 1255 OID 21572)
-- Name: filter_line_item_entries(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_line_item_entries(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.line_item_entries
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_item_entries', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_item_entries'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_item_entries'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_item_entries'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_item_entries WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 388 (class 1259 OID 21574)
-- Name: line_item_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.line_item_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    formula jsonb,
    variables jsonb,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.line_item_templates FORCE ROW LEVEL SECURITY;


--
-- TOC entry 564 (class 1255 OID 21582)
-- Name: filter_line_item_templates(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_line_item_templates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.line_item_templates
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_item_templates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_item_templates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_item_templates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_item_templates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_item_templates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 389 (class 1259 OID 21584)
-- Name: line_items; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.line_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    map_id uuid,
    wbs_id uuid,
    project_id uuid,
    cost_code_id uuid,
    template_id uuid,
    name text NOT NULL,
    description text,
    unit_measure text NOT NULL,
    quantity numeric,
    unit_price numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.line_items FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1060 (class 1255 OID 21592)
-- Name: filter_line_items(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_line_items(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.line_items
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_items', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_items'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_items'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_items'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_items WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 390 (class 1259 OID 21594)
-- Name: maps; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.maps (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    wbs_id uuid,
    project_id uuid,
    name text NOT NULL,
    description text,
    coordinates text,
    scope text,
    order_num integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.maps FORCE ROW LEVEL SECURITY;


--
-- TOC entry 893 (class 1255 OID 21602)
-- Name: filter_maps(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_maps(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.maps
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','maps', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='maps'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='maps'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='maps'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.maps WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 391 (class 1259 OID 21603)
-- Name: material_inventory; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.material_inventory (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_id uuid,
    organization_id uuid,
    quantity numeric,
    last_updated timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.material_inventory FORCE ROW LEVEL SECURITY;


--
-- TOC entry 989 (class 1255 OID 21612)
-- Name: filter_material_inventory(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_material_inventory(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.material_inventory
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_inventory', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_inventory'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_inventory'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_inventory'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_inventory WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 392 (class 1259 OID 21614)
-- Name: material_orders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.material_orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_id uuid,
    project_id uuid,
    order_date date,
    quantity numeric,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.material_orders FORCE ROW LEVEL SECURITY;


--
-- TOC entry 786 (class 1255 OID 21622)
-- Name: filter_material_orders(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_material_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.material_orders
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 393 (class 1259 OID 21624)
-- Name: material_receipts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.material_receipts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_order_id uuid,
    received_date date,
    quantity numeric,
    received_by uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.material_receipts FORCE ROW LEVEL SECURITY;


--
-- TOC entry 555 (class 1255 OID 21632)
-- Name: filter_material_receipts(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_material_receipts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.material_receipts
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_receipts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_receipts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_receipts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_receipts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_receipts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 394 (class 1259 OID 21634)
-- Name: materials; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.materials (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    name text NOT NULL,
    description text,
    unit text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.materials FORCE ROW LEVEL SECURITY;


--
-- TOC entry 695 (class 1255 OID 21642)
-- Name: filter_materials(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_materials(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.materials
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','materials', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='materials'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='materials'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='materials'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.materials WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 395 (class 1259 OID 21644)
-- Name: meeting_minutes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.meeting_minutes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    meeting_date date,
    notes text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.meeting_minutes FORCE ROW LEVEL SECURITY;


--
-- TOC entry 554 (class 1255 OID 21652)
-- Name: filter_meeting_minutes(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_meeting_minutes(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.meeting_minutes
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','meeting_minutes', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='meeting_minutes'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='meeting_minutes'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='meeting_minutes'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.meeting_minutes WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 396 (class 1259 OID 21654)
-- Name: notifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    category public.notification_category DEFAULT 'general'::public.notification_category NOT NULL,
    message text NOT NULL,
    payload jsonb DEFAULT '{}'::jsonb,
    is_read boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.notifications FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1050 (class 1255 OID 21665)
-- Name: filter_notifications(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_notifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.notifications
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
declare
  _project_id uuid := nullif(_filters->>'project_id', '')::uuid;
  _organization_id uuid := nullif(_filters->>'organization_id', '')::uuid;
  _where text := 'deleted_at IS NULL';
  kv record;
  _sel text;
  _order_clause text;
  sqltxt text;
  dir text := lower(coalesce(_direction, 'asc'));
begin
  if _filters is null or jsonb_typeof(_filters) <> 'object' then
    _filters := '{}'::jsonb;
  end if;

  perform check_access('select','notifications', _project_id, _organization_id);

  for kv in select * from jsonb_each(_filters) loop
    if kv.key not in ('project_id','organization_id') then
      if jsonb_typeof(kv.value) = 'object' then
        if (kv.value ? '$gte') then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' >= ' || quote_literal(kv.value->>'$gte');
        end if;
        if (kv.value ? '$lte') then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' <= ' || quote_literal(kv.value->>'$lte');
        end if;
        if (kv.value ? '$ilike') then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        end if;
        if (kv.value ? '$in') then
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'SELECT value FROM jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)'
            || ' AS t(value))';
        end if;
      else
        if jsonb_typeof(kv.value) = 'null' then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' IS NULL';
        elsif jsonb_typeof(kv.value) = 'string' then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(kv.value #>> '{}');
        else
          _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(kv.value::text);
        end if;
      end if;
    end if;
  end loop;

  if _order_by is null or trim(_order_by) = '' then
    _order_by := 'id';
  end if;

  if not exists (
    select 1
    from information_schema.columns
    where table_schema='public'
      and table_name='notifications'
      and column_name=_order_by
  ) then
    if exists (
      select 1 from information_schema.columns
      where table_schema='public' and table_name='notifications' and column_name='created_at'
    ) then
      _order_by := 'created_at';
    elsif exists (
      select 1 from information_schema.columns
      where table_schema='public' and table_name='notifications' and column_name='updated_at'
    ) then
      _order_by := 'updated_at';
    else
      _order_by := 'id';
    end if;
  end if;

  if dir not in ('asc','desc') then
    dir := 'asc';
  end if;

  if _select_cols is null then
    _sel := '*';
  elsif _select_cols = array['*'] then
    _sel := '*';
  else
    if exists (
      select unnest(_select_cols)
      except
      select column_name
        from information_schema.columns
        where table_schema='public' and table_name='notifications'
    ) then
      raise exception 'unknown column in select_cols'
        using detail = jsonb_build_object('columns', _select_cols);
    end if;

    select string_agg(quote_ident(c), ', ')
      into _sel
      from unnest(_select_cols) c;

    if _sel is null or btrim(_sel) = '' then
      _sel := '*';
    end if;
  end if;

  if _order_by = 'is_read' then
    _order_clause := 'is_read asc';
  else
    _order_clause := 'is_read asc, ' || quote_ident(_order_by) || ' ' || dir;
  end if;

  sqltxt := 'SELECT ' || _sel
         || ' FROM public.notifications WHERE ' || _where
         || ' ORDER BY ' || _order_clause;

  if _limit is not null then
    sqltxt := sqltxt || ' LIMIT ' || greatest(_limit, 0);
  end if;
  if _offset is not null then
    sqltxt := sqltxt || ' OFFSET ' || greatest(_offset, 0);
  end if;

  return query execute sqltxt;
end;
$_$;


--
-- TOC entry 526 (class 1259 OID 43246)
-- Name: organization_invites; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_invites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid NOT NULL,
    invited_profile_id uuid NOT NULL,
    invited_by_profile_id uuid NOT NULL,
    role text,
    status text NOT NULL,
    comment text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    responded_at timestamp with time zone,
    CONSTRAINT organization_invites_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'declined'::text, 'cancelled'::text])))
);

ALTER TABLE ONLY public.organization_invites FORCE ROW LEVEL SECURITY;


--
-- TOC entry 619 (class 1255 OID 43254)
-- Name: filter_organization_invites(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_invites(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_invites
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
DECLARE
  _organization_id uuid := nullif(_filters->>'organization_id', '')::uuid;
  _where text := 'true';
  kv record;
  _sel text;
  sqltxt text;
  dir text := lower(coalesce(_direction, 'asc'));
BEGIN
  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
    _filters := '{}'::jsonb;
  END IF;

  PERFORM check_access('select', 'organization_invites', NULL, _organization_id);

  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
    IF kv.key NOT IN ('organization_id') THEN
      IF jsonb_typeof(kv.value) = 'object' THEN
        IF (kv.value ? '$gte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' >= ' || quote_literal(kv.value->>'$gte');
        END IF;
        IF (kv.value ? '$lte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' <= ' || quote_literal(kv.value->>'$lte');
        END IF;
        IF (kv.value ? '$ilike') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        END IF;
        IF (kv.value ? '$in') THEN
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'SELECT value FROM jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)'
            || ' AS t(value))';
        END IF;
      ELSE
        IF jsonb_typeof(kv.value) = 'null' THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' IS NULL';
        ELSIF jsonb_typeof(kv.value) = 'string' THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(kv.value #>> '{}');
        ELSE
          _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(kv.value::text);
        END IF;
      END IF;
    END IF;
  END LOOP;

  IF _order_by IS NULL OR trim(_order_by) = '' THEN
    _order_by := 'id';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'organization_invites'
      AND column_name = _order_by
  ) THEN
    IF EXISTS (
      SELECT 1
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name = 'organization_invites'
        AND column_name = 'created_at'
    ) THEN
      _order_by := 'created_at';
    ELSIF EXISTS (
      SELECT 1
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name = 'organization_invites'
        AND column_name = 'updated_at'
    ) THEN
      _order_by := 'updated_at';
    ELSE
      _order_by := 'id';
    END IF;
  END IF;

  IF dir NOT IN ('asc', 'desc') THEN
    dir := 'asc';
  END IF;

  IF _select_cols IS NULL OR _select_cols = array['*'] THEN
    _sel := '*';
  ELSE
    IF EXISTS (
      SELECT unnest(_select_cols)
      EXCEPT
      SELECT column_name
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name = 'organization_invites'
    ) THEN
      RAISE EXCEPTION 'unknown column in select_cols'
        USING DETAIL = jsonb_build_object('columns', _select_cols);
    END IF;

    SELECT string_agg(quote_ident(c), ', ')
      INTO _sel
      FROM unnest(_select_cols) c;

    IF _sel IS NULL OR btrim(_sel) = '' THEN
      _sel := '*';
    END IF;
  END IF;

  sqltxt := 'SELECT ' || _sel
         || ' FROM public.organization_invites WHERE ' || _where
         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

  IF _limit IS NOT NULL THEN
    sqltxt := sqltxt || ' LIMIT ' || greatest(_limit, 0);
  END IF;
  IF _offset IS NOT NULL THEN
    sqltxt := sqltxt || ' OFFSET ' || greatest(_offset, 0);
  END IF;

  RETURN QUERY EXECUTE sqltxt;
END;
$_$;


--
-- TOC entry 524 (class 1259 OID 26528)
-- Name: organization_member_rates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_member_rates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    membership_id uuid NOT NULL,
    rate_type text NOT NULL,
    rate_amount numeric NOT NULL,
    effective_start timestamp with time zone NOT NULL,
    effective_end timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT organization_member_rates_rate_type_check CHECK ((rate_type = ANY (ARRAY['pay_rate'::text, 'bill_rate'::text])))
);

ALTER TABLE ONLY public.organization_member_rates FORCE ROW LEVEL SECURITY;


--
-- TOC entry 898 (class 1255 OID 27714)
-- Name: filter_organization_member_rates(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_member_rates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_member_rates
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _membership_id   uuid := (_filters->>'membership_id')::uuid;
      _where           text := 'true';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      IF _organization_id IS NULL AND _membership_id IS NOT NULL THEN
        SELECT organization_id INTO _organization_id
          FROM public.organization_members
         WHERE id = _membership_id;
      END IF;

      PERFORM check_access('select','organization_member_rates', _project_id, _organization_id);

      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='organization_member_rates'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organization_member_rates';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='organization_member_rates'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.organization_member_rates WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- TOC entry 397 (class 1259 OID 21667)
-- Name: organization_members; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_members (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    organization_id uuid,
    role text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.organization_members FORCE ROW LEVEL SECURITY;


--
-- TOC entry 626 (class 1255 OID 21675)
-- Name: filter_organization_members(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_members(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_members
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
DECLARE
  _project_id      uuid := (_filters->>'project_id')::uuid;
  _organization_id uuid := (_filters->>'organization_id')::uuid;
  _where           text := 'deleted_at IS NULL';
  kv               record;
  _sel             text;
  sqltxt           text;
  dir              text := lower(coalesce(_direction, 'asc'));
BEGIN
  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
    _filters := '{}'::jsonb;
  END IF;

  PERFORM check_access('select','organization_members', _project_id, _organization_id);

  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
    IF kv.key NOT IN ('project_id','organization_id') THEN
      IF jsonb_typeof(kv.value) = 'object' THEN
        IF (kv.value ? '$gte') THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' >= '  || quote_literal(kv.value->>'$gte');
        END IF;
        IF (kv.value ? '$lte') THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' <= '  || quote_literal(kv.value->>'$lte');
        END IF;
        IF (kv.value ? '$ilike') THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        END IF;
        IF (kv.value ? '$in') THEN
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'SELECT value FROM jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)'
            || ' AS t(value))';
        END IF;
      ELSE
        IF jsonb_typeof(kv.value) = 'null' THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' IS NULL';
        ELSIF jsonb_typeof(kv.value) = 'string' THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' = '   || quote_literal(kv.value #>> '{}');
        ELSE
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' = '   || quote_literal(kv.value::text);
        END IF;
      END IF;
    END IF;
  END LOOP;

  IF _order_by IS NULL OR trim(_order_by) = '' THEN
    _order_by := 'id';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema='public'
      AND table_name='organization_members'
      AND column_name=_order_by
  ) THEN
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema='public' AND table_name='organization_members' AND column_name='created_at'
    ) THEN
      _order_by := 'created_at';
    ELSE
      _order_by := 'id';
    END IF;
  END IF;

  IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

  IF _select_cols IS NOT NULL AND _select_cols <> array['*'] THEN
    IF EXISTS (
      SELECT UNNEST(_select_cols)
      EXCEPT
      SELECT column_name
        FROM information_schema.columns
        WHERE table_schema='public' AND table_name='organization_members'
    ) THEN
      RAISE EXCEPTION 'unknown column in select_cols'
        USING DETAIL = jsonb_build_object('columns', _select_cols);
    END IF;
  END IF;

  _sel := '*';

  sqltxt := 'SELECT ' || _sel
         || ' FROM public.organization_members WHERE ' || _where
         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

  IF _limit  IS NOT NULL THEN
    sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
  END IF;
  IF _offset IS NOT NULL THEN
    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
  END IF;

  RETURN QUERY EXECUTE sqltxt;
END;
$_$;


--
-- TOC entry 398 (class 1259 OID 21677)
-- Name: organization_projects; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    project_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.organization_projects FORCE ROW LEVEL SECURITY;


--
-- TOC entry 602 (class 1255 OID 21683)
-- Name: filter_organization_projects(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_projects
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','organization_projects', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organization_projects'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='organization_projects'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='organization_projects'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.organization_projects WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 522 (class 1259 OID 26485)
-- Name: organization_service_areas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_service_areas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid NOT NULL,
    service_area_text text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

ALTER TABLE ONLY public.organization_service_areas FORCE ROW LEVEL SECURITY;


--
-- TOC entry 982 (class 1255 OID 27718)
-- Name: filter_organization_service_areas(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_service_areas(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_service_areas
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _where           text := 'true';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      PERFORM check_access('select','organization_service_areas', _project_id, _organization_id);

      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='organization_service_areas'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organization_service_areas';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='organization_service_areas'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.organization_service_areas WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- TOC entry 399 (class 1259 OID 21685)
-- Name: organizations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organizations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    mission_statement text,
    headquarters text,
    logo_url text
);

ALTER TABLE ONLY public.organizations FORCE ROW LEVEL SECURITY;


--
-- TOC entry 920 (class 1255 OID 21693)
-- Name: filter_organizations(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organizations(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organizations
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','organizations', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organizations'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='organizations'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='organizations'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.organizations WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 400 (class 1259 OID 21694)
-- Name: payments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.payments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    commitment_id uuid,
    amount numeric,
    paid_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.payments FORCE ROW LEVEL SECURITY;


--
-- TOC entry 587 (class 1255 OID 21702)
-- Name: filter_payments(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_payments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.payments
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','payments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='payments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='payments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='payments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.payments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 401 (class 1259 OID 21704)
-- Name: payroll; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.payroll (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid,
    pay_period_start date,
    pay_period_end date,
    gross_pay numeric,
    net_pay numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.payroll FORCE ROW LEVEL SECURITY;


--
-- TOC entry 552 (class 1255 OID 21712)
-- Name: filter_payroll(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_payroll(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.payroll
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','payroll', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='payroll'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='payroll'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='payroll'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.payroll WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 402 (class 1259 OID 21714)
-- Name: photos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.photos (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    url text NOT NULL,
    caption text,
    uploaded_by uuid,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.photos FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1061 (class 1255 OID 21723)
-- Name: filter_photos(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_photos(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.photos
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','photos', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='photos'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='photos'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='photos'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.photos WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 403 (class 1259 OID 21725)
-- Name: prequalifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.prequalifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid,
    status text,
    reviewed_by uuid,
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.prequalifications FORCE ROW LEVEL SECURITY;


--
-- TOC entry 547 (class 1255 OID 21733)
-- Name: filter_prequalifications(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_prequalifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.prequalifications
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','prequalifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='prequalifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='prequalifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='prequalifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.prequalifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 404 (class 1259 OID 21735)
-- Name: procurement_workflows; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procurement_workflows (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text,
    status text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.procurement_workflows FORCE ROW LEVEL SECURITY;


--
-- TOC entry 929 (class 1255 OID 21743)
-- Name: filter_procurement_workflows(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_procurement_workflows(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.procurement_workflows
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','procurement_workflows', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='procurement_workflows'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='procurement_workflows'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='procurement_workflows'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.procurement_workflows WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 688 (class 1255 OID 21753)
-- Name: filter_profiles(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_profiles(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.profiles
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','profiles', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='profiles'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='profiles'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='profiles'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.profiles WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 406 (class 1259 OID 21755)
-- Name: progress_billings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.progress_billings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    billing_number text,
    amount numeric,
    status text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.progress_billings FORCE ROW LEVEL SECURITY;


--
-- TOC entry 936 (class 1255 OID 21763)
-- Name: filter_progress_billings(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_progress_billings(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.progress_billings
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','progress_billings', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='progress_billings'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='progress_billings'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='progress_billings'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.progress_billings WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 407 (class 1259 OID 21765)
-- Name: project_inspectors; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_inspectors (
    project_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    assigned_by uuid,
    assigned_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.project_inspectors FORCE ROW LEVEL SECURITY;


--
-- TOC entry 828 (class 1255 OID 21769)
-- Name: filter_project_inspectors(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_project_inspectors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.project_inspectors
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','project_inspectors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='project_inspectors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='project_inspectors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='project_inspectors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.project_inspectors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 525 (class 1259 OID 26547)
-- Name: project_invites; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_invites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid NOT NULL,
    invited_profile_id uuid NOT NULL,
    invited_by_profile_id uuid NOT NULL,
    status text NOT NULL,
    comment text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    responded_at timestamp with time zone,
    CONSTRAINT project_invites_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'declined'::text, 'cancelled'::text])))
);

ALTER TABLE ONLY public.project_invites FORCE ROW LEVEL SECURITY;


--
-- TOC entry 949 (class 1255 OID 27722)
-- Name: filter_project_invites(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_project_invites(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.project_invites
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _where           text := 'true';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      PERFORM check_access('select','project_invites', _project_id, _organization_id);

      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='project_invites'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='project_invites';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='project_invites'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.project_invites WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- TOC entry 523 (class 1259 OID 26504)
-- Name: project_service_areas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_service_areas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid NOT NULL,
    service_area_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

ALTER TABLE ONLY public.project_service_areas FORCE ROW LEVEL SECURITY;


--
-- TOC entry 945 (class 1255 OID 27726)
-- Name: filter_project_service_areas(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_project_service_areas(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.project_service_areas
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _where           text := 'true';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      PERFORM check_access('select','project_service_areas', _project_id, _organization_id);

      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='project_service_areas'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='project_service_areas';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='project_service_areas'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.project_service_areas WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- TOC entry 883 (class 1255 OID 21779)
-- Name: filter_projects(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.projects
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
DECLARE
  _project_id      uuid;
  _organization_id uuid;
  _where           text := 'deleted_at IS NULL';
  kv               record;
  sqltxt           text;
  dir              text := lower(coalesce(_direction, 'asc'));
  order_col        text := coalesce(nullif(_order_by, ''), 'id');
  v_text           text;
BEGIN
  -- normalize filters
  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
    _filters := '{}'::jsonb;
  END IF;

  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;
  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;

  IF NOT public.check_access_bool('select','projects', _project_id, _organization_id) THEN
    RETURN;
  END IF;

  -- safe order_by (fallback instead of raising)
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema='public'
      AND table_name='projects'
      AND column_name=order_col
  ) THEN
    order_col := 'id';
  END IF;

  IF dir NOT IN ('asc','desc') THEN
    dir := 'asc';
  END IF;

  -- build WHERE
  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
    IF kv.key NOT IN ('project_id','organization_id') THEN

      -- ignore unknown columns instead of erroring
      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='projects'
          AND column_name=kv.key
      ) THEN
        CONTINUE;
      END IF;

      IF kv.value = 'null'::jsonb THEN
        _where := _where || ' AND ' || quote_ident(kv.key) || ' IS NULL';

      ELSIF jsonb_typeof(kv.value) = 'object' THEN
        IF (kv.value ? '$gte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' >= ' || quote_literal(kv.value->>'$gte');
        END IF;

        IF (kv.value ? '$lte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' <= ' || quote_literal(kv.value->>'$lte');
        END IF;

        IF (kv.value ? '$ilike') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        END IF;

        IF (kv.value ? '$in') THEN
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'ARRAY(SELECT jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';
        END IF;

      ELSE
        v_text := kv.value #>> '{}';
        _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(v_text);
      END IF;
    END IF;
  END LOOP;

  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where
         || ' ORDER BY ' || quote_ident(order_col) || ' ' || dir;

  IF _limit IS NOT NULL THEN
    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);
  END IF;

  IF _offset IS NOT NULL THEN
    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);
  END IF;

  RETURN QUERY EXECUTE sqltxt;
END;
$_$;


--
-- TOC entry 409 (class 1259 OID 21783)
-- Name: punch_lists; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.punch_lists (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    item text,
    status text,
    assigned_to uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.punch_lists FORCE ROW LEVEL SECURITY;


--
-- TOC entry 961 (class 1255 OID 21791)
-- Name: filter_punch_lists(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_punch_lists(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.punch_lists
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','punch_lists', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='punch_lists'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='punch_lists'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='punch_lists'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.punch_lists WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 410 (class 1259 OID 21793)
-- Name: purchase_orders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.purchase_orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    vendor_id uuid,
    order_number text,
    order_date date,
    amount numeric,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.purchase_orders FORCE ROW LEVEL SECURITY;


--
-- TOC entry 990 (class 1255 OID 21801)
-- Name: filter_purchase_orders(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_purchase_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.purchase_orders
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','purchase_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='purchase_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='purchase_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='purchase_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.purchase_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 411 (class 1259 OID 21803)
-- Name: quality_reviews; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.quality_reviews (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    review_date date,
    reviewer uuid,
    findings jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.quality_reviews FORCE ROW LEVEL SECURITY;


--
-- TOC entry 577 (class 1255 OID 21811)
-- Name: filter_quality_reviews(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_quality_reviews(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.quality_reviews
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','quality_reviews', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='quality_reviews'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='quality_reviews'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='quality_reviews'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.quality_reviews WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 412 (class 1259 OID 21813)
-- Name: regulatory_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.regulatory_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    document_type text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.regulatory_documents FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1034 (class 1255 OID 21822)
-- Name: filter_regulatory_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_regulatory_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.regulatory_documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','regulatory_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='regulatory_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='regulatory_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='regulatory_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.regulatory_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 413 (class 1259 OID 21824)
-- Name: reports; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.reports (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    report_type text,
    generated_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.reports FORCE ROW LEVEL SECURITY;


--
-- TOC entry 642 (class 1255 OID 21833)
-- Name: filter_reports(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_reports(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.reports
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','reports', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='reports'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='reports'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='reports'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.reports WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 414 (class 1259 OID 21835)
-- Name: rfis; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.rfis (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    subject text,
    status text,
    question text,
    answer text,
    submitted_by uuid,
    reviewed_by uuid,
    submitted_at timestamp with time zone DEFAULT now(),
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.rfis FORCE ROW LEVEL SECURITY;


--
-- TOC entry 716 (class 1255 OID 21844)
-- Name: filter_rfis(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_rfis(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.rfis
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','rfis', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='rfis'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='rfis'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='rfis'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.rfis WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 415 (class 1259 OID 21845)
-- Name: safety_incidents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.safety_incidents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    incident_date date,
    description text,
    reported_by uuid,
    severity text,
    resolved boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.safety_incidents FORCE ROW LEVEL SECURITY;


--
-- TOC entry 538 (class 1255 OID 21854)
-- Name: filter_safety_incidents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_safety_incidents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.safety_incidents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','safety_incidents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='safety_incidents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='safety_incidents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='safety_incidents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.safety_incidents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 416 (class 1259 OID 21856)
-- Name: sensor_data; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.sensor_data (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    data jsonb,
    collected_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.sensor_data FORCE ROW LEVEL SECURITY;


--
-- TOC entry 562 (class 1255 OID 21865)
-- Name: filter_sensor_data(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_sensor_data(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.sensor_data
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','sensor_data', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='sensor_data'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='sensor_data'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='sensor_data'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.sensor_data WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 417 (class 1259 OID 21867)
-- Name: subcontractor_agreements; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.subcontractor_agreements (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    subcontract_id uuid,
    agreement_url text,
    signed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.subcontractor_agreements FORCE ROW LEVEL SECURITY;


--
-- TOC entry 799 (class 1255 OID 21875)
-- Name: filter_subcontractor_agreements(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_subcontractor_agreements(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.subcontractor_agreements
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','subcontractor_agreements', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='subcontractor_agreements'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='subcontractor_agreements'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='subcontractor_agreements'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.subcontractor_agreements WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 418 (class 1259 OID 21877)
-- Name: subcontracts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.subcontracts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    vendor_id uuid,
    amount numeric,
    status text,
    signed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.subcontracts FORCE ROW LEVEL SECURITY;


--
-- TOC entry 819 (class 1255 OID 21885)
-- Name: filter_subcontracts(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_subcontracts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.subcontracts
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','subcontracts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='subcontracts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='subcontracts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='subcontracts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.subcontracts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 419 (class 1259 OID 21887)
-- Name: submittals; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.submittals (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text,
    status public.general_status,
    submitted_by uuid,
    reviewed_by uuid,
    submitted_at timestamp with time zone DEFAULT now(),
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.submittals FORCE ROW LEVEL SECURITY;


--
-- TOC entry 721 (class 1255 OID 21896)
-- Name: filter_submittals(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_submittals(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.submittals
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','submittals', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='submittals'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='submittals'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='submittals'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.submittals WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 420 (class 1259 OID 21898)
-- Name: tack_rates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tack_rates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    rate numeric,
    material_type text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.tack_rates FORCE ROW LEVEL SECURITY;


--
-- TOC entry 765 (class 1255 OID 21906)
-- Name: filter_tack_rates(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_tack_rates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.tack_rates
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','tack_rates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='tack_rates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='tack_rates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='tack_rates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.tack_rates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 421 (class 1259 OID 21908)
-- Name: task_dependencies; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.task_dependencies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    task_id uuid NOT NULL,
    depends_on_task_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.task_dependencies FORCE ROW LEVEL SECURITY;


--
-- TOC entry 750 (class 1255 OID 21913)
-- Name: filter_task_dependencies(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_task_dependencies(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.task_dependencies
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','task_dependencies', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='task_dependencies'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='task_dependencies'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='task_dependencies'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.task_dependencies WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 422 (class 1259 OID 21915)
-- Name: task_status_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.task_status_logs (
    task_id uuid NOT NULL,
    status public.task_status NOT NULL,
    changed_at timestamp without time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);

ALTER TABLE ONLY public.task_status_logs FORCE ROW LEVEL SECURITY;


--
-- TOC entry 732 (class 1255 OID 21919)
-- Name: filter_task_status_logs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_task_status_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.task_status_logs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','task_status_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='task_status_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='task_status_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='task_status_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.task_status_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 423 (class 1259 OID 21921)
-- Name: tasks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tasks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid NOT NULL,
    name text NOT NULL,
    description text,
    start_date date,
    end_date date,
    status public.task_status DEFAULT 'not_started'::public.task_status NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.tasks FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1006 (class 1255 OID 21930)
-- Name: filter_tasks(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_tasks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.tasks
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','tasks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='tasks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='tasks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='tasks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.tasks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 424 (class 1259 OID 21932)
-- Name: training_records; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.training_records (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid,
    training_type text,
    completion_date date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.training_records FORCE ROW LEVEL SECURITY;


--
-- TOC entry 1081 (class 1255 OID 21940)
-- Name: filter_training_records(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_training_records(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.training_records
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','training_records', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='training_records'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='training_records'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='training_records'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.training_records WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 425 (class 1259 OID 21942)
-- Name: user_projects; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    project_id uuid,
    role text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.user_projects FORCE ROW LEVEL SECURITY;


--
-- TOC entry 887 (class 1255 OID 21950)
-- Name: filter_user_projects(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_user_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.user_projects
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','user_projects', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='user_projects'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='user_projects'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='user_projects'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.user_projects WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 426 (class 1259 OID 21952)
-- Name: vendor_bid_packages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendor_bid_packages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bid_package_id uuid,
    vendor_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendor_bid_packages FORCE ROW LEVEL SECURITY;


--
-- TOC entry 927 (class 1255 OID 21958)
-- Name: filter_vendor_bid_packages(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendor_bid_packages(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendor_bid_packages
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_bid_packages', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_bid_packages'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_bid_packages'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_bid_packages'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_bid_packages WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 427 (class 1259 OID 21960)
-- Name: vendor_contacts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendor_contacts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid,
    name text,
    email text,
    phone text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendor_contacts FORCE ROW LEVEL SECURITY;


--
-- TOC entry 818 (class 1255 OID 21968)
-- Name: filter_vendor_contacts(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendor_contacts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendor_contacts
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_contacts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_contacts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_contacts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_contacts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_contacts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 428 (class 1259 OID 21970)
-- Name: vendor_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendor_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid,
    document_type text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendor_documents FORCE ROW LEVEL SECURITY;


--
-- TOC entry 781 (class 1255 OID 21979)
-- Name: filter_vendor_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendor_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendor_documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 429 (class 1259 OID 21981)
-- Name: vendor_qualifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendor_qualifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid,
    qualification_type text,
    status text,
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendor_qualifications FORCE ROW LEVEL SECURITY;


--
-- TOC entry 826 (class 1255 OID 21989)
-- Name: filter_vendor_qualifications(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendor_qualifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendor_qualifications
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_qualifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_qualifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_qualifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_qualifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_qualifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 430 (class 1259 OID 21991)
-- Name: vendors; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendors (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    name text NOT NULL,
    status public.general_status,
    contact_email text,
    contact_phone text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendors FORCE ROW LEVEL SECURITY;


--
-- TOC entry 797 (class 1255 OID 21999)
-- Name: filter_vendors(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendors
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 431 (class 1259 OID 22001)
-- Name: wbs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wbs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    location text,
    order_num integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.wbs FORCE ROW LEVEL SECURITY;


--
-- TOC entry 847 (class 1255 OID 22009)
-- Name: filter_wbs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_wbs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.wbs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','wbs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='wbs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='wbs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='wbs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.wbs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 1020 (class 1255 OID 22010)
-- Name: filter_workflows(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_workflows(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.workflows
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','workflows', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='workflows'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='workflows'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='workflows'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.workflows WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- TOC entry 866 (class 1255 OID 22012)
-- Name: fn_cashflow_curve(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_cashflow_curve(p_project_id uuid) RETURNS TABLE(cur_date date, billed numeric, cost numeric)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH bills AS (
    SELECT created_at::date AS d, SUM(amount) AS amt
    FROM public.progress_billings
    WHERE project_id = p_project_id
    GROUP BY 1
  ), costs AS (
    SELECT entry_date::date AS d, SUM(debit) AS amt
    FROM public.general_ledger
    WHERE project_id = p_project_id
    GROUP BY 1
  ), dates AS (
    SELECT d::date FROM bills
    UNION
    SELECT d::date FROM costs
  )
  SELECT
    dates.d AS cur_date,
    SUM(b.amt) OVER (ORDER BY dates.d
                     ROWS UNBOUNDED PRECEDING) AS billed,
    SUM(c.amt) OVER (ORDER BY dates.d
                     ROWS UNBOUNDED PRECEDING) AS cost
  FROM dates
  LEFT JOIN bills b ON b.d = dates.d
  LEFT JOIN costs c ON c.d = dates.d
  ORDER BY cur_date;
$$;


--
-- TOC entry 1005 (class 1255 OID 22013)
-- Name: fn_eqp_7d_avg_hours(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_eqp_7d_avg_hours(p_equipment_id uuid) RETURNS TABLE(day date, avg_hours numeric)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    eu.date,
    ROUND(
      AVG(eu.hours_used)
      OVER (
        ORDER BY eu.date
        RANGE BETWEEN INTERVAL '6 days' PRECEDING 
              AND CURRENT ROW
      ), 2
    ) AS avg_hours
  FROM public.equipment_usage eu
  WHERE eu.equipment_id = p_equipment_id
  ORDER BY eu.date;
$$;


--
-- TOC entry 872 (class 1255 OID 22014)
-- Name: fn_find_rpc_dupes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_find_rpc_dupes() RETURNS TABLE(fname text, args text, cnt integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    p.proname             AS fname,
    pg_catalog.pg_get_function_arguments(p.oid) AS args,
    COUNT(*) OVER (PARTITION BY p.proname)     AS cnt
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
  ORDER BY cnt DESC, fname;
$$;


--
-- TOC entry 877 (class 1255 OID 22015)
-- Name: fn_inventory_balance(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_inventory_balance(_material_id uuid) RETURNS TABLE(day date, balance numeric)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH tx AS (
    SELECT
      (transaction_date::date) AS day,
      CASE
        WHEN transaction_type IN ('receive', 'in', 'purchase') THEN quantity
        WHEN transaction_type IN ('issue', 'out', 'usage')     THEN -quantity
        ELSE 0
      END AS qty
    FROM public.inventory_transactions
    WHERE material_id = _material_id
  )
  SELECT
    day,
    SUM(qty) OVER (
      ORDER BY day
      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS balance
  FROM tx
  ORDER BY day;
$$;


--
-- TOC entry 570 (class 1255 OID 22016)
-- Name: fn_list_tables_and_columns(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_list_tables_and_columns() RETURNS TABLE(table_name text, column_name text)
    LANGUAGE sql IMMUTABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT table_name, column_name
  FROM information_schema.columns
  WHERE table_schema = 'public'
  ORDER BY table_name, ordinal_position;
$$;


--
-- TOC entry 762 (class 1255 OID 22017)
-- Name: fn_materials_on_hand(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_materials_on_hand(p_material_id uuid) RETURNS TABLE(trans_date date, on_hand bigint)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    it.transaction_date::date                           AS trans_date,
    SUM((it.transaction_type = 'receipt')::int
      - (it.transaction_type = 'issue')::int)
      OVER (ORDER BY it.transaction_date::date
            ROWS UNBOUNDED PRECEDING)                   AS on_hand
  FROM public.inventory_transactions it
  WHERE it.material_id = p_material_id
  ORDER BY trans_date;
$$;


--
-- TOC entry 1032 (class 1255 OID 22018)
-- Name: fn_task_cycle_time(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_task_cycle_time(p_task_id uuid) RETURNS TABLE(status text, days_in_phase integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH logs AS (
    SELECT
      status,
      changed_at,
      LEAD(changed_at) OVER (ORDER BY changed_at) AS next_change
    FROM public.task_status_logs
    WHERE task_id = p_task_id
  )
  SELECT
    status,
    EXTRACT(epoch FROM (next_change - changed_at))/86400::int AS days_in_phase
  FROM logs
  WHERE next_change IS NOT NULL;
$$;


--
-- TOC entry 1021 (class 1255 OID 22019)
-- Name: fn_top5_cost_codes(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_top5_cost_codes(p_project_id uuid) RETURNS TABLE(cost_code_id uuid, total_spend numeric, rank integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    eli.cost_code_id,
    SUM(eli.total_cost)             AS total_spend,
    RANK() OVER (ORDER BY SUM(eli.total_cost) DESC) AS rank
  FROM public.estimate_line_items eli
  JOIN public.estimates e ON e.id = eli.estimate_id
  WHERE e.project_id = p_project_id
  GROUP BY eli.cost_code_id
  ORDER BY total_spend DESC
  LIMIT 5;
$$;


--
-- TOC entry 951 (class 1255 OID 22020)
-- Name: fn_weekly_receipt_perf(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_weekly_receipt_perf(p_project_id uuid) RETURNS TABLE(week_start date, on_time_count integer, late_count integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH rec AS (
    SELECT
      mr.material_order_id,
      mr.received_date,
      mo.project_id,
      mo.order_date,
      date_trunc('week', mr.received_date)::date AS wk
    FROM public.material_receipts mr
    JOIN public.material_orders  mo ON mo.id = mr.material_order_id
    WHERE mo.project_id = p_project_id
  )
  SELECT
    wk                  AS week_start,
    SUM((received_date <= order_date)::int) AS on_time_count,
    SUM((received_date >  order_date)::int) AS late_count
  FROM rec
  GROUP BY wk
  ORDER BY wk;
$$;


--
-- TOC entry 1049 (class 1255 OID 22021)
-- Name: fn_worst10_crews_by_incidents(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_worst10_crews_by_incidents() RETURNS TABLE(crew_id uuid, incident_count integer, rank integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    ca.crew_id,
    COUNT(si.*)                      AS incident_count,
    RANK() OVER (ORDER BY COUNT(si.*) DESC) AS rank
  FROM public.safety_incidents si
  JOIN public.crew_assignments ca
    ON ca.profile_id = si.reported_by
  GROUP BY ca.crew_id
  ORDER BY incident_count DESC
  LIMIT 10;
$$;


--
-- TOC entry 1033 (class 1255 OID 26476)
-- Name: get_avatar_by_id_public(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_avatar_by_id_public(p_avatar_id uuid) RETURNS public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_row public.avatars;
begin
  select *
  into v_row
  from public.avatars
  where id = p_avatar_id
    and deleted_at is null;

  return v_row;
end;
$$;


--
-- TOC entry 766 (class 1255 OID 27746)
-- Name: get_avatar_storage_paths(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_avatar_storage_paths() RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    BEGIN
      IF COALESCE(auth.role(), '') NOT IN ('service_role', 'supabase_admin') THEN
        RAISE EXCEPTION 'not authorized';
      END IF;

      RETURN QUERY
      SELECT regexp_replace(url, '^.*?/storage/v1/object/public/avatars-personal/', '')
        FROM public.avatars
       WHERE deleted_at IS NULL
         AND url LIKE '%/storage/v1/object/public/avatars-personal/%';
    END;
    $$;


--
-- TOC entry 617 (class 1255 OID 27699)
-- Name: get_contract_with_wkt(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_contract_with_wkt(p_contract_id uuid) RETURNS TABLE(id uuid, project_id uuid, contract_number text, title text, description text, start_date date, end_date date, budget numeric, status public.project_status, created_at timestamp with time zone, updated_at timestamp with time zone, coordinates_wkt text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  perform check_access('select','projects', p_contract_id, null);

  return query
  select
    p.id,
    p.id as project_id,
    ''::text as contract_number,
    p.name as title,
    p.description,
    p.start_date,
    p.end_date,
    null::numeric as budget,
    p.status,
    p.created_at,
    p.updated_at,
    null::text as coordinates_wkt
  from public.projects p
  where p.id = p_contract_id
    and p.deleted_at is null;
end;
$$;


--
-- TOC entry 598 (class 1255 OID 26469)
-- Name: get_job_titles_public(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_job_titles_public() RETURNS SETOF public.job_titles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  return query
  select *
  from public.job_titles
  where deleted_at is null
  order by name asc;
end;
$$;


--
-- TOC entry 848 (class 1255 OID 45478)
-- Name: get_my_member_organizations(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_member_organizations() RETURNS TABLE(id uuid, name text, role text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
begin
  v_user_id := auth.uid();

  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  return query
  with my_profile as (
    select p.id, p.organization_id
    from public.profiles p
    where p.id = v_user_id
      and p.deleted_at is null
  ),
  membership_orgs as (
    select
      o.id,
      o.name,
      om.role
    from public.organization_members om
    join public.organizations o
      on o.id = om.organization_id
    where om.profile_id = v_user_id
      and om.deleted_at is null
      and o.deleted_at is null
  ),
  primary_org_fallback as (
    select
      o.id,
      o.name,
      null::text as role
    from my_profile p
    join public.organizations o
      on o.id = p.organization_id
    left join public.organization_members om
      on om.organization_id = p.organization_id
     and om.profile_id = p.id
     and om.deleted_at is null
    where p.organization_id is not null
      and o.deleted_at is null
      and om.id is null
  )
  select distinct r.id, r.name, r.role
  from (
    select * from membership_orgs
    union all
    select * from primary_org_fallback
  ) r
  order by r.name asc;
end;
$$;


--
-- TOC entry 984 (class 1255 OID 26442)
-- Name: get_my_org_profiles_minimal(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_org_profiles_minimal() RETURNS TABLE(id uuid, full_name text, email text, avatar_id uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_org_id uuid;
begin
  v_org_id := (
    select organization_id
    from public.profiles
    where id = auth.uid()
  );

  return query
  select p.id, p.full_name, p.email, p.avatar_id
  from public.profiles p
  where p.organization_id = v_org_id
    and p.deleted_at is null;
end;
$$;


--
-- TOC entry 987 (class 1255 OID 26399)
-- Name: get_my_profile(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_profile() RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    return null;
  end if;

  select *
  into v_profile
  from public.profiles
  where id = v_user_id;

  return v_profile;
end;
$$;


--
-- TOC entry 865 (class 1255 OID 27695)
-- Name: get_organization_by_id(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_organization_by_id(p_organization_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_role text;
  v_has_membership boolean := false;
  v_org jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select role into v_role
  from public.profiles
  where id = v_user_id;

  if v_role is null then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  if v_role = 'system_admin' then
    v_has_membership := true;
  else
    select exists (
      select 1
      from public.organization_members
      where organization_id = p_organization_id
        and profile_id = v_user_id
        and deleted_at is null
    ) into v_has_membership;
  end if;

  if v_has_membership is not true then
    raise exception 'Access denied: not a member of organization %', p_organization_id;
  end if;

  select jsonb_build_object(
    'id', id,
    'name', name,
    'description', description,
    'mission_statement', mission_statement,
    'headquarters', headquarters,
    'logo_url', logo_url,
    'created_at', created_at,
    'updated_at', updated_at
  )
  into v_org
  from public.organizations
  where id = p_organization_id
    and deleted_at is null;

  if v_org is null then
    raise exception 'Organization not found: %', p_organization_id;
  end if;

  return v_org;
end;
$$;


--
-- TOC entry 1080 (class 1255 OID 26475)
-- Name: get_organizations_public(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_organizations_public(p_query text) RETURNS TABLE(id uuid, name text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  return query
  select o.id, o.name
  from public.organizations o
  where o.deleted_at is null
    and o.name ilike '%' || coalesce(p_query, '') || '%'
  order by o.name asc
  limit 10;
end;
$$;


--
-- TOC entry 850 (class 1255 OID 46682)
-- Name: get_pending_organization_invites_with_profiles(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_pending_organization_invites_with_profiles(p_organization_id uuid) RETURNS TABLE(id uuid, organization_id uuid, invited_profile_id uuid, invited_by_profile_id uuid, status text, role text, comment text, created_at timestamp with time zone, responded_at timestamp with time zone, requester_full_name text, requester_email text, requester_phone text, requester_location text, requester_avatar_url text, requester_avatar_id uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
declare
  v_user_id uuid := auth.uid();
  v_global_role public.user_role_type;
  v_is_org_admin boolean := false;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if p_organization_id is null then
    raise exception 'organization_id is required';
  end if;

  select p.role
    into v_global_role
  from public.profiles p
  where p.id = v_user_id
    and p.deleted_at is null;

  select exists (
    select 1
    from public.organization_members om
    where om.organization_id = p_organization_id
      and om.profile_id = v_user_id
      and om.deleted_at is null
      and om.role in ('owner', 'admin')
  )
  into v_is_org_admin;

  if coalesce(v_global_role::text, '') not in ('system_admin', 'org_admin') and not v_is_org_admin then
    raise exception 'Access denied'
      using errcode = '42501';
  end if;

  return query
  select
    oi.id,
    oi.organization_id,
    oi.invited_profile_id,
    oi.invited_by_profile_id,
    oi.status,
    oi.role,
    oi.comment,
    oi.created_at,
    oi.responded_at,
    pr.full_name as requester_full_name,
    pr.email as requester_email,
    pr.phone as requester_phone,
    pr.location as requester_location,
    av.url as requester_avatar_url,
    pr.avatar_id as requester_avatar_id
  from public.organization_invites oi
  left join public.profiles pr
    on pr.id = oi.invited_profile_id
   and pr.deleted_at is null
  left join public.avatars av
    on av.id = pr.avatar_id
   and av.deleted_at is null
  where oi.organization_id = p_organization_id
    and oi.status = 'pending'
  order by oi.created_at asc;
end;
$$;


--
-- TOC entry 536 (class 1255 OID 26451)
-- Name: get_preset_avatars_public(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_preset_avatars_public() RETURNS SETOF public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  return query
  select *
  from public.avatars
  where deleted_at is null
    and coalesce(is_preset, false) = true
  order by created_at asc;
end;
$$;


--
-- TOC entry 747 (class 1255 OID 27700)
-- Name: get_profiles_by_contract(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_profiles_by_contract(p_contract_id uuid) RETURNS TABLE(id uuid, full_name text, email text, role public.user_role_type, contract_role text, assigned_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  perform check_access('select','user_projects', p_contract_id, null);

  return query
  select
    pr.id,
    pr.full_name,
    pr.email,
    pr.role,
    up.role as contract_role,
    up.created_at as assigned_at
  from public.user_projects up
  join public.profiles pr on pr.id = up.user_id
  where up.project_id = p_contract_id
    and up.deleted_at is null
  order by pr.full_name nulls last, pr.email;
end;
$$;


--
-- TOC entry 888 (class 1255 OID 22022)
-- Name: handle_auth_user_profile_sync(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.handle_auth_user_profile_sync() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'auth'
    SET row_security TO 'off'
    AS $$
begin
  -- Ensure a profile row exists, and keep email in sync.
  -- Do NOT touch role/org/full_name/phone here.
  insert into public.profiles as p
    (id, email, created_at, updated_at)
  values
    (new.id, new.email, now(), now())
  on conflict (id) do update
    set email = excluded.email,
        updated_at = now();

  return new;
end;
$$;


--
-- TOC entry 624 (class 1255 OID 22023)
-- Name: insert_accounts_payable(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_accounts_payable(_input jsonb) RETURNS SETOF public.accounts_payable
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.accounts_payable;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','accounts_payable', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.accounts_payable
        SELECT (jsonb_populate_record(NULL::public.accounts_payable, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 599 (class 1255 OID 22024)
-- Name: insert_accounts_receivable(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_accounts_receivable(_input jsonb) RETURNS SETOF public.accounts_receivable
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.accounts_receivable;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','accounts_receivable', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.accounts_receivable
        SELECT (jsonb_populate_record(NULL::public.accounts_receivable, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 693 (class 1255 OID 22025)
-- Name: insert_activity_logs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_activity_logs(_input jsonb) RETURNS SETOF public.activity_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.activity_logs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','activity_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.activity_logs
        SELECT (jsonb_populate_record(NULL::public.activity_logs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 772 (class 1255 OID 22026)
-- Name: insert_asphalt_types(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_asphalt_types(_input jsonb) RETURNS SETOF public.asphalt_types
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.asphalt_types;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','asphalt_types', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.asphalt_types
        SELECT (jsonb_populate_record(NULL::public.asphalt_types, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 737 (class 1255 OID 27711)
-- Name: insert_audit_log(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_audit_log(_input jsonb) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _new_row         public.audit_log;
    BEGIN
      PERFORM check_access('insert','audit_log', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'changed_at' - 'changed_by' - 'deleted_at';

      INSERT INTO public.audit_log
      SELECT (jsonb_populate_record(NULL::public.audit_log, _input)).*
      RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 809 (class 1255 OID 22027)
-- Name: insert_audit_logs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_audit_logs(_input jsonb) RETURNS SETOF public.audit_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.audit_logs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','audit_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.audit_logs
        SELECT (jsonb_populate_record(NULL::public.audit_logs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 683 (class 1255 OID 22028)
-- Name: insert_avatars(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_avatars(_input jsonb) RETURNS SETOF public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    DECLARE
      _new_row public.avatars;
    BEGIN
      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

      IF (_input ? 'id') IS FALSE OR (_input->>'id') IS NULL THEN
        _input := jsonb_set(_input, '{id}', to_jsonb(gen_random_uuid()), true);
      END IF;

      IF (_input ? 'created_at') IS FALSE OR (_input->>'created_at') IS NULL THEN
        _input := jsonb_set(_input, '{created_at}', to_jsonb(now()), true);
      END IF;

      IF (_input ? 'updated_at') IS FALSE OR (_input->>'updated_at') IS NULL THEN
        _input := jsonb_set(_input, '{updated_at}', to_jsonb(now()), true);
      END IF;

      INSERT INTO public.avatars
      SELECT (jsonb_populate_record(NULL::public.avatars, _input)).*
      RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 770 (class 1255 OID 22029)
-- Name: insert_bid_packages(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_bid_packages(_input jsonb) RETURNS SETOF public.bid_packages
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bid_packages;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bid_packages', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.bid_packages
        SELECT (jsonb_populate_record(NULL::public.bid_packages, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 790 (class 1255 OID 22030)
-- Name: insert_bid_vendors(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_bid_vendors(_input jsonb) RETURNS SETOF public.bid_vendors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bid_vendors;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bid_vendors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.bid_vendors
        SELECT (jsonb_populate_record(NULL::public.bid_vendors, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 894 (class 1255 OID 22031)
-- Name: insert_bids(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_bids(_input jsonb) RETURNS SETOF public.bids
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bids;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bids', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.bids
        SELECT (jsonb_populate_record(NULL::public.bids, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 889 (class 1255 OID 22032)
-- Name: insert_bim_models(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_bim_models(_input jsonb) RETURNS SETOF public.bim_models
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bim_models;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bim_models', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.bim_models
        SELECT (jsonb_populate_record(NULL::public.bim_models, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 841 (class 1255 OID 22033)
-- Name: insert_certifications(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_certifications(_input jsonb) RETURNS SETOF public.certifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.certifications;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','certifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.certifications
        SELECT (jsonb_populate_record(NULL::public.certifications, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 542 (class 1255 OID 22034)
-- Name: insert_change_orders(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_change_orders(_input jsonb) RETURNS SETOF public.change_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.change_orders;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','change_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.change_orders
        SELECT (jsonb_populate_record(NULL::public.change_orders, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 579 (class 1255 OID 22035)
-- Name: insert_commitments(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_commitments(_input jsonb) RETURNS SETOF public.commitments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.commitments;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','commitments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.commitments
        SELECT (jsonb_populate_record(NULL::public.commitments, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 665 (class 1255 OID 22036)
-- Name: insert_compliance_checks(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_compliance_checks(_input jsonb) RETURNS SETOF public.compliance_checks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.compliance_checks;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','compliance_checks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.compliance_checks
        SELECT (jsonb_populate_record(NULL::public.compliance_checks, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 807 (class 1255 OID 22037)
-- Name: insert_compliance_tracking(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_compliance_tracking(_input jsonb) RETURNS SETOF public.compliance_tracking
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.compliance_tracking;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','compliance_tracking', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.compliance_tracking
        SELECT (jsonb_populate_record(NULL::public.compliance_tracking, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 940 (class 1255 OID 22038)
-- Name: insert_cost_codes(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_cost_codes(_input jsonb) RETURNS SETOF public.cost_codes
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.cost_codes;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','cost_codes', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.cost_codes
        SELECT (jsonb_populate_record(NULL::public.cost_codes, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 808 (class 1255 OID 22039)
-- Name: insert_crew_assignments(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_crew_assignments(_input jsonb) RETURNS SETOF public.crew_assignments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crew_assignments;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crew_assignments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.crew_assignments
        SELECT (jsonb_populate_record(NULL::public.crew_assignments, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 968 (class 1255 OID 22040)
-- Name: insert_crew_members(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_crew_members(_input jsonb) RETURNS SETOF public.crew_members
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crew_members;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crew_members', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.crew_members
        SELECT (jsonb_populate_record(NULL::public.crew_members, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 923 (class 1255 OID 22041)
-- Name: insert_crews(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_crews(_input jsonb) RETURNS SETOF public.crews
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crews;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crews', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.crews
        SELECT (jsonb_populate_record(NULL::public.crews, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 743 (class 1255 OID 22042)
-- Name: insert_daily_logs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_daily_logs(_input jsonb) RETURNS SETOF public.daily_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.daily_logs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','daily_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.daily_logs
        SELECT (jsonb_populate_record(NULL::public.daily_logs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 868 (class 1255 OID 22043)
-- Name: insert_dashboard_configs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_dashboard_configs(_input jsonb) RETURNS SETOF public.dashboard_configs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.dashboard_configs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','dashboard_configs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.dashboard_configs
        SELECT (jsonb_populate_record(NULL::public.dashboard_configs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 703 (class 1255 OID 22044)
-- Name: insert_document_references(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_document_references(_input jsonb) RETURNS SETOF public.document_references
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.document_references;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','document_references', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.document_references
        SELECT (jsonb_populate_record(NULL::public.document_references, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 590 (class 1255 OID 22045)
-- Name: insert_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_documents(_input jsonb) RETURNS SETOF public.documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.documents
        SELECT (jsonb_populate_record(NULL::public.documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 925 (class 1255 OID 22046)
-- Name: insert_drawing_versions(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_drawing_versions(_input jsonb) RETURNS SETOF public.drawing_versions
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.drawing_versions;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','drawing_versions', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.drawing_versions
        SELECT (jsonb_populate_record(NULL::public.drawing_versions, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 741 (class 1255 OID 22047)
-- Name: insert_dump_trucks(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_dump_trucks(_input jsonb) RETURNS SETOF public.dump_trucks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.dump_trucks;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','dump_trucks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.dump_trucks
        SELECT (jsonb_populate_record(NULL::public.dump_trucks, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 606 (class 1255 OID 22048)
-- Name: insert_employees(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_employees(_input jsonb) RETURNS SETOF public.employees
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.employees;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','employees', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.employees
        SELECT (jsonb_populate_record(NULL::public.employees, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 985 (class 1255 OID 22049)
-- Name: insert_equipment(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_equipment(_input jsonb) RETURNS SETOF public.equipment
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.equipment
        SELECT (jsonb_populate_record(NULL::public.equipment, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 549 (class 1255 OID 22050)
-- Name: insert_equipment_assignments(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_equipment_assignments(_input jsonb) RETURNS SETOF public.equipment_assignments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_assignments;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_assignments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.equipment_assignments
        SELECT (jsonb_populate_record(NULL::public.equipment_assignments, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 738 (class 1255 OID 22051)
-- Name: insert_equipment_maintenance(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_equipment_maintenance(_input jsonb) RETURNS SETOF public.equipment_maintenance
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_maintenance;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_maintenance', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.equipment_maintenance
        SELECT (jsonb_populate_record(NULL::public.equipment_maintenance, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 677 (class 1255 OID 22052)
-- Name: insert_equipment_usage(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_equipment_usage(_input jsonb) RETURNS SETOF public.equipment_usage
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_usage;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_usage', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.equipment_usage
        SELECT (jsonb_populate_record(NULL::public.equipment_usage, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 821 (class 1255 OID 22053)
-- Name: insert_estimate_line_items(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_estimate_line_items(_input jsonb) RETURNS SETOF public.estimate_line_items
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.estimate_line_items;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','estimate_line_items', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.estimate_line_items
        SELECT (jsonb_populate_record(NULL::public.estimate_line_items, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 576 (class 1255 OID 22054)
-- Name: insert_estimates(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_estimates(_input jsonb) RETURNS SETOF public.estimates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.estimates;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','estimates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.estimates
        SELECT (jsonb_populate_record(NULL::public.estimates, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 673 (class 1255 OID 22055)
-- Name: insert_financial_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_financial_documents(_input jsonb) RETURNS SETOF public.financial_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.financial_documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','financial_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.financial_documents
        SELECT (jsonb_populate_record(NULL::public.financial_documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 900 (class 1255 OID 22056)
-- Name: insert_general_ledger(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_general_ledger(_input jsonb) RETURNS SETOF public.general_ledger
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.general_ledger;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','general_ledger', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.general_ledger
        SELECT (jsonb_populate_record(NULL::public.general_ledger, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 650 (class 1255 OID 22057)
-- Name: insert_hr_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_hr_documents(_input jsonb) RETURNS SETOF public.hr_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.hr_documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','hr_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.hr_documents
        SELECT (jsonb_populate_record(NULL::public.hr_documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 992 (class 1255 OID 22058)
-- Name: insert_inspections(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_inspections(_input jsonb) RETURNS SETOF public.inspections
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.inspections;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','inspections', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.inspections
        SELECT (jsonb_populate_record(NULL::public.inspections, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 960 (class 1255 OID 22059)
-- Name: insert_integration_tokens(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_integration_tokens(_input jsonb) RETURNS SETOF public.integration_tokens
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.integration_tokens;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','integration_tokens', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.integration_tokens
        SELECT (jsonb_populate_record(NULL::public.integration_tokens, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 980 (class 1255 OID 22060)
-- Name: insert_inventory_transactions(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_inventory_transactions(_input jsonb) RETURNS SETOF public.inventory_transactions
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.inventory_transactions;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','inventory_transactions', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.inventory_transactions
        SELECT (jsonb_populate_record(NULL::public.inventory_transactions, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 952 (class 1255 OID 22061)
-- Name: insert_issues(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_issues(_input jsonb) RETURNS SETOF public.issues
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.issues;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','issues', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.issues
        SELECT (jsonb_populate_record(NULL::public.issues, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 973 (class 1255 OID 26470)
-- Name: insert_job_title_public(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_job_title_public(p_name text) RETURNS public.job_titles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_name text;
  v_existing public.job_titles;
  v_row public.job_titles;
begin
  v_name := nullif(btrim(p_name), '');
  if v_name is null then
    raise exception 'Job title cannot be empty';
  end if;

  select * into v_existing
  from public.job_titles
  where lower(name) = lower(v_name)
    and deleted_at is null
  limit 1;

  if v_existing.id is not null then
    return v_existing;
  end if;

  insert into public.job_titles (name, created_at, updated_at)
  values (v_name, now(), now())
  returning * into v_row;

  return v_row;
end;
$$;


--
-- TOC entry 1059 (class 1255 OID 22062)
-- Name: insert_job_titles(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_job_titles(_input jsonb) RETURNS SETOF public.job_titles
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.job_titles;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','job_titles', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.job_titles
        SELECT (jsonb_populate_record(NULL::public.job_titles, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 614 (class 1255 OID 22063)
-- Name: insert_labor_records(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_labor_records(_input jsonb) RETURNS SETOF public.labor_records
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.labor_records;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','labor_records', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.labor_records
        SELECT (jsonb_populate_record(NULL::public.labor_records, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 664 (class 1255 OID 22064)
-- Name: insert_line_item_entries(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_line_item_entries(_input jsonb) RETURNS SETOF public.line_item_entries
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_item_entries;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_item_entries', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.line_item_entries
        SELECT (jsonb_populate_record(NULL::public.line_item_entries, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 724 (class 1255 OID 22065)
-- Name: insert_line_item_templates(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_line_item_templates(_input jsonb) RETURNS SETOF public.line_item_templates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_item_templates;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_item_templates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.line_item_templates
        SELECT (jsonb_populate_record(NULL::public.line_item_templates, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 804 (class 1255 OID 22066)
-- Name: insert_line_items(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_line_items(_input jsonb) RETURNS SETOF public.line_items
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_items;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_items', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.line_items
        SELECT (jsonb_populate_record(NULL::public.line_items, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 969 (class 1255 OID 22067)
-- Name: insert_maps(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_maps(_input jsonb) RETURNS SETOF public.maps
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.maps;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','maps', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.maps
        SELECT (jsonb_populate_record(NULL::public.maps, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 684 (class 1255 OID 22068)
-- Name: insert_material_inventory(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_material_inventory(_input jsonb) RETURNS SETOF public.material_inventory
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_inventory;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_inventory', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.material_inventory
        SELECT (jsonb_populate_record(NULL::public.material_inventory, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 857 (class 1255 OID 22069)
-- Name: insert_material_orders(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_material_orders(_input jsonb) RETURNS SETOF public.material_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_orders;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.material_orders
        SELECT (jsonb_populate_record(NULL::public.material_orders, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 838 (class 1255 OID 22070)
-- Name: insert_material_receipts(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_material_receipts(_input jsonb) RETURNS SETOF public.material_receipts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_receipts;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_receipts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.material_receipts
        SELECT (jsonb_populate_record(NULL::public.material_receipts, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 774 (class 1255 OID 22071)
-- Name: insert_materials(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_materials(_input jsonb) RETURNS SETOF public.materials
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.materials;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','materials', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.materials
        SELECT (jsonb_populate_record(NULL::public.materials, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 907 (class 1255 OID 22072)
-- Name: insert_meeting_minutes(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_meeting_minutes(_input jsonb) RETURNS SETOF public.meeting_minutes
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.meeting_minutes;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','meeting_minutes', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.meeting_minutes
        SELECT (jsonb_populate_record(NULL::public.meeting_minutes, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1067 (class 1255 OID 22073)
-- Name: insert_notifications(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_notifications(_input jsonb) RETURNS SETOF public.notifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.notifications;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','notifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.notifications
        SELECT (jsonb_populate_record(NULL::public.notifications, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 796 (class 1255 OID 43255)
-- Name: insert_organization_invites(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_invites(_input jsonb) RETURNS SETOF public.organization_invites
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _organization_id uuid := (_input->>'organization_id')::uuid;
  _new_row public.organization_invites;
  _row public.organization_invites := (jsonb_populate_record(NULL::public.organization_invites, COALESCE(_input, '{}'::jsonb)));
  _admin record;
BEGIN
  PERFORM check_access('insert','organization_invites', NULL, _organization_id);

  -- ensure DB defaults are applied when callers omit id/created_at
  _row.id := COALESCE(_row.id, gen_random_uuid());
  _row.created_at := COALESCE(_row.created_at, now());

  INSERT INTO public.organization_invites (id, organization_id, invited_profile_id, invited_by_profile_id, role, status, comment, created_at, responded_at)
  VALUES (_row.id, _row.organization_id, _row.invited_profile_id, _row.invited_by_profile_id, _row.role, _row.status, _row.comment, _row.created_at, _row.responded_at)
  RETURNING * INTO _new_row;

  -- notify all org_admins about the new request/invite
  FOR _admin IN
    SELECT profile_id FROM public.organization_members WHERE organization_id = _new_row.organization_id AND role = 'org_admin'
  LOOP
    BEGIN
      PERFORM public.insert_notifications(
        jsonb_build_object(
          'user_id', _admin.profile_id,
          'category', 'general',
          'message', ('Membership request for ' || (_new_row.role::text) || ' â€” ' || _new_row.invited_profile_id),
          'payload', jsonb_build_object('invite_id', _new_row.id, 'organization_id', _new_row.organization_id, 'invited_profile_id', _new_row.invited_profile_id, 'role', _new_row.role)
        )
      );
    EXCEPTION WHEN OTHERS THEN
      NULL; -- swallow notification errors so invite still succeeds
    END;
  END LOOP;

  RETURN NEXT _new_row;
END;
$$;


--
-- TOC entry 816 (class 1255 OID 27715)
-- Name: insert_organization_member_rates(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_member_rates(_input jsonb) RETURNS SETOF public.organization_member_rates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _membership_id   uuid := (_input->>'membership_id')::uuid;
      _new_row         public.organization_member_rates;
    BEGIN
      IF _organization_id IS NULL AND _membership_id IS NOT NULL THEN
        SELECT organization_id INTO _organization_id
          FROM public.organization_members
         WHERE id = _membership_id;
      END IF;

      PERFORM check_access('insert','organization_member_rates', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at' - 'updated_at';

      INSERT INTO public.organization_member_rates
      SELECT (jsonb_populate_record(NULL::public.organization_member_rates, _input)).*
      RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 706 (class 1255 OID 22074)
-- Name: insert_organization_members(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_members(_input jsonb) RETURNS SETOF public.organization_members
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organization_members;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organization_members', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.organization_members
        SELECT (jsonb_populate_record(NULL::public.organization_members, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1024 (class 1255 OID 22075)
-- Name: insert_organization_projects(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_projects(_input jsonb) RETURNS SETOF public.organization_projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organization_projects;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organization_projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.organization_projects
        SELECT (jsonb_populate_record(NULL::public.organization_projects, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 718 (class 1255 OID 27719)
-- Name: insert_organization_service_areas(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_service_areas(_input jsonb) RETURNS SETOF public.organization_service_areas
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _new_row         public.organization_service_areas;
    BEGIN
      PERFORM check_access('insert','organization_service_areas', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at' - 'updated_at';

      INSERT INTO public.organization_service_areas
      SELECT (jsonb_populate_record(NULL::public.organization_service_areas, _input)).*
      RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 757 (class 1255 OID 22076)
-- Name: insert_organizations(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organizations(_input jsonb) RETURNS SETOF public.organizations
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organizations;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organizations', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.organizations
        SELECT (jsonb_populate_record(NULL::public.organizations, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 593 (class 1255 OID 22077)
-- Name: insert_payments(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_payments(_input jsonb) RETURNS SETOF public.payments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.payments;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','payments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.payments
        SELECT (jsonb_populate_record(NULL::public.payments, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 991 (class 1255 OID 22078)
-- Name: insert_payroll(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_payroll(_input jsonb) RETURNS SETOF public.payroll
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.payroll;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','payroll', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.payroll
        SELECT (jsonb_populate_record(NULL::public.payroll, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 731 (class 1255 OID 22079)
-- Name: insert_photos(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_photos(_input jsonb) RETURNS SETOF public.photos
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.photos;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','photos', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.photos
        SELECT (jsonb_populate_record(NULL::public.photos, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 661 (class 1255 OID 22080)
-- Name: insert_prequalifications(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_prequalifications(_input jsonb) RETURNS SETOF public.prequalifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.prequalifications;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','prequalifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.prequalifications
        SELECT (jsonb_populate_record(NULL::public.prequalifications, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1016 (class 1255 OID 22081)
-- Name: insert_procurement_workflows(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_procurement_workflows(_input jsonb) RETURNS SETOF public.procurement_workflows
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.procurement_workflows;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','procurement_workflows', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.procurement_workflows
        SELECT (jsonb_populate_record(NULL::public.procurement_workflows, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 760 (class 1255 OID 22082)
-- Name: insert_profiles(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_profiles(_input jsonb) RETURNS SETOF public.profiles
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.profiles;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','profiles', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.profiles
        SELECT (jsonb_populate_record(NULL::public.profiles, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 965 (class 1255 OID 22083)
-- Name: insert_progress_billings(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_progress_billings(_input jsonb) RETURNS SETOF public.progress_billings
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.progress_billings;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','progress_billings', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.progress_billings
        SELECT (jsonb_populate_record(NULL::public.progress_billings, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 566 (class 1255 OID 22084)
-- Name: insert_project_inspectors(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_project_inspectors(_input jsonb) RETURNS SETOF public.project_inspectors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.project_inspectors;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','project_inspectors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.project_inspectors
        SELECT (jsonb_populate_record(NULL::public.project_inspectors, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 572 (class 1255 OID 27723)
-- Name: insert_project_invites(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_project_invites(_input jsonb) RETURNS SETOF public.project_invites
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _new_row         public.project_invites;
    BEGIN
      PERFORM check_access('insert','project_invites', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at';

      INSERT INTO public.project_invites
      SELECT (jsonb_populate_record(NULL::public.project_invites, _input)).*
      RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 959 (class 1255 OID 27727)
-- Name: insert_project_service_areas(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_project_service_areas(_input jsonb) RETURNS SETOF public.project_service_areas
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _new_row         public.project_service_areas;
    BEGIN
      PERFORM check_access('insert','project_service_areas', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at' - 'updated_at';

      INSERT INTO public.project_service_areas
      SELECT (jsonb_populate_record(NULL::public.project_service_areas, _input)).*
      RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 734 (class 1255 OID 22085)
-- Name: insert_projects(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_projects(_input jsonb) RETURNS SETOF public.projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.projects;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.projects
        SELECT (jsonb_populate_record(NULL::public.projects, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 878 (class 1255 OID 22086)
-- Name: insert_punch_lists(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_punch_lists(_input jsonb) RETURNS SETOF public.punch_lists
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.punch_lists;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','punch_lists', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.punch_lists
        SELECT (jsonb_populate_record(NULL::public.punch_lists, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 812 (class 1255 OID 22087)
-- Name: insert_purchase_orders(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_purchase_orders(_input jsonb) RETURNS SETOF public.purchase_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.purchase_orders;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','purchase_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.purchase_orders
        SELECT (jsonb_populate_record(NULL::public.purchase_orders, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 755 (class 1255 OID 22088)
-- Name: insert_quality_reviews(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_quality_reviews(_input jsonb) RETURNS SETOF public.quality_reviews
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.quality_reviews;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','quality_reviews', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.quality_reviews
        SELECT (jsonb_populate_record(NULL::public.quality_reviews, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 864 (class 1255 OID 22089)
-- Name: insert_regulatory_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_regulatory_documents(_input jsonb) RETURNS SETOF public.regulatory_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.regulatory_documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','regulatory_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.regulatory_documents
        SELECT (jsonb_populate_record(NULL::public.regulatory_documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 975 (class 1255 OID 22090)
-- Name: insert_reports(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_reports(_input jsonb) RETURNS SETOF public.reports
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.reports;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','reports', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.reports
        SELECT (jsonb_populate_record(NULL::public.reports, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 928 (class 1255 OID 22091)
-- Name: insert_rfis(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_rfis(_input jsonb) RETURNS SETOF public.rfis
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.rfis;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','rfis', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.rfis
        SELECT (jsonb_populate_record(NULL::public.rfis, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1043 (class 1255 OID 22092)
-- Name: insert_safety_incidents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_safety_incidents(_input jsonb) RETURNS SETOF public.safety_incidents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.safety_incidents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','safety_incidents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.safety_incidents
        SELECT (jsonb_populate_record(NULL::public.safety_incidents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1029 (class 1255 OID 22093)
-- Name: insert_sensor_data(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_sensor_data(_input jsonb) RETURNS SETOF public.sensor_data
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.sensor_data;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','sensor_data', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.sensor_data
        SELECT (jsonb_populate_record(NULL::public.sensor_data, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 832 (class 1255 OID 22094)
-- Name: insert_subcontractor_agreements(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_subcontractor_agreements(_input jsonb) RETURNS SETOF public.subcontractor_agreements
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.subcontractor_agreements;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','subcontractor_agreements', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.subcontractor_agreements
        SELECT (jsonb_populate_record(NULL::public.subcontractor_agreements, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 733 (class 1255 OID 22095)
-- Name: insert_subcontracts(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_subcontracts(_input jsonb) RETURNS SETOF public.subcontracts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.subcontracts;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','subcontracts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.subcontracts
        SELECT (jsonb_populate_record(NULL::public.subcontracts, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 675 (class 1255 OID 22096)
-- Name: insert_submittals(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_submittals(_input jsonb) RETURNS SETOF public.submittals
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.submittals;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','submittals', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.submittals
        SELECT (jsonb_populate_record(NULL::public.submittals, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 657 (class 1255 OID 22097)
-- Name: insert_tack_rates(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_tack_rates(_input jsonb) RETURNS SETOF public.tack_rates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.tack_rates;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','tack_rates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.tack_rates
        SELECT (jsonb_populate_record(NULL::public.tack_rates, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 873 (class 1255 OID 22098)
-- Name: insert_task_dependencies(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_task_dependencies(_input jsonb) RETURNS SETOF public.task_dependencies
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.task_dependencies;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','task_dependencies', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.task_dependencies
        SELECT (jsonb_populate_record(NULL::public.task_dependencies, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 788 (class 1255 OID 22099)
-- Name: insert_task_status_logs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_task_status_logs(_input jsonb) RETURNS SETOF public.task_status_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.task_status_logs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','task_status_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.task_status_logs
        SELECT (jsonb_populate_record(NULL::public.task_status_logs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 908 (class 1255 OID 22100)
-- Name: insert_tasks(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_tasks(_input jsonb) RETURNS SETOF public.tasks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.tasks;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','tasks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.tasks
        SELECT (jsonb_populate_record(NULL::public.tasks, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 607 (class 1255 OID 22101)
-- Name: insert_training_records(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_training_records(_input jsonb) RETURNS SETOF public.training_records
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.training_records;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','training_records', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.training_records
        SELECT (jsonb_populate_record(NULL::public.training_records, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1012 (class 1255 OID 22102)
-- Name: insert_user_projects(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_user_projects(_input jsonb) RETURNS SETOF public.user_projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.user_projects;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','user_projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.user_projects
        SELECT (jsonb_populate_record(NULL::public.user_projects, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1058 (class 1255 OID 22103)
-- Name: insert_vendor_bid_packages(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendor_bid_packages(_input jsonb) RETURNS SETOF public.vendor_bid_packages
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_bid_packages;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_bid_packages', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendor_bid_packages
        SELECT (jsonb_populate_record(NULL::public.vendor_bid_packages, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 869 (class 1255 OID 22104)
-- Name: insert_vendor_contacts(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendor_contacts(_input jsonb) RETURNS SETOF public.vendor_contacts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_contacts;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_contacts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendor_contacts
        SELECT (jsonb_populate_record(NULL::public.vendor_contacts, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 767 (class 1255 OID 22105)
-- Name: insert_vendor_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendor_documents(_input jsonb) RETURNS SETOF public.vendor_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_documents;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendor_documents
        SELECT (jsonb_populate_record(NULL::public.vendor_documents, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1015 (class 1255 OID 22106)
-- Name: insert_vendor_qualifications(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendor_qualifications(_input jsonb) RETURNS SETOF public.vendor_qualifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_qualifications;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_qualifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendor_qualifications
        SELECT (jsonb_populate_record(NULL::public.vendor_qualifications, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 662 (class 1255 OID 22107)
-- Name: insert_vendors(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendors(_input jsonb) RETURNS SETOF public.vendors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendors;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.vendors
        SELECT (jsonb_populate_record(NULL::public.vendors, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 568 (class 1255 OID 22108)
-- Name: insert_wbs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_wbs(_input jsonb) RETURNS SETOF public.wbs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.wbs;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','wbs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.wbs
        SELECT (jsonb_populate_record(NULL::public.wbs, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 978 (class 1255 OID 22109)
-- Name: insert_workflows(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_workflows(_input jsonb) RETURNS SETOF public.workflows
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.workflows;
      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','workflows', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

        INSERT INTO public.workflows
        SELECT (jsonb_populate_record(NULL::public.workflows, _input)).*
        RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 957 (class 1255 OID 45479)
-- Name: notifications_broadcast_trigger(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notifications_broadcast_trigger() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
BEGIN
  PERFORM realtime.broadcast_changes(
    'user:notifications:' || NEW.user_id::text,
    TG_OP,
    TG_OP,
    TG_TABLE_NAME,
    TG_TABLE_SCHEMA,
    NEW,
    NULL
  );
  RETURN NEW;
END;
$$;


--
-- TOC entry 621 (class 1255 OID 22110)
-- Name: notify_new_bid(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_bid() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM public.create_notification(
    (SELECT owner_id FROM public.projects WHERE id = NEW.project_id),
    'bid_received',
    'A new bid ('||NEW.id||') was submitted.',
    jsonb_build_object('bid_id', NEW.id, 'vendor_id', NEW.vendor_id)
  );
  RETURN NEW;
END;
$$;


--
-- TOC entry 780 (class 1255 OID 22111)
-- Name: on_create_function_pin_search_path(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.on_create_function_pin_search_path() RETURNS event_trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
DECLARE
  r record;
  regproc text;
BEGIN
  FOR r IN
    SELECT *
    FROM pg_event_trigger_ddl_commands()
  LOOP
    -- Only act on CREATE FUNCTION and ALTER FUNCTION
    IF r.command_tag IN ('CREATE FUNCTION', 'ALTER FUNCTION') THEN
      regproc := (r.objid::regprocedure)::text;

      IF EXISTS (
        SELECT 1
        FROM pg_proc p
        WHERE p.oid = r.objid
          AND p.prosecdef = TRUE
          AND NOT EXISTS (
            SELECT 1
            FROM unnest(coalesce(p.proconfig, '{}'::text[])) kv
            WHERE split_part(kv, '=', 1) = 'search_path'
          )
      ) THEN
        EXECUTE format(
          'ALTER FUNCTION %s SET search_path = pg_catalog, public;',
          regproc
        );
        RAISE NOTICE 'Pinned search_path for %', regproc;
      END IF;
    END IF;
  END LOOP;
END
$$;


--
-- TOC entry 861 (class 1255 OID 22112)
-- Name: on_ddl_ensure_fk_indexes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.on_ddl_ensure_fk_indexes() RETURNS event_trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
BEGIN
  PERFORM public.ensure_fk_indexes_for_schema('public');
END
$$;


--
-- TOC entry 557 (class 1255 OID 27745)
-- Name: purge_orphaned_avatars(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.purge_orphaned_avatars() RETURNS SETOF public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    BEGIN
      IF COALESCE(auth.role(), '') NOT IN ('service_role', 'supabase_admin') THEN
        RAISE EXCEPTION 'not authorized';
      END IF;

      RETURN QUERY
      DELETE FROM public.avatars AS a
       WHERE a.is_preset = false
         AND NOT EXISTS (
           SELECT 1
             FROM public.profiles AS p
            WHERE p.avatar_id = a.id
              AND p.deleted_at IS NULL
         )
       RETURNING *;
    END;
    $$;


--
-- TOC entry 835 (class 1255 OID 22113)
-- Name: rank_equipment_usage(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rank_equipment_usage(p_project_id uuid) RETURNS TABLE(equipment_id uuid, total_hours numeric, usage_rank integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH usage AS (
    SELECT ea.equipment_id, SUM(eu.hours_used) AS total_hours
      FROM public.equipment_usage eu
      JOIN public.equipment_assignments ea
        ON eu.equipment_id = ea.equipment_id
     WHERE ea.project_id = p_project_id
     GROUP BY ea.equipment_id
  )
  SELECT
    equipment_id,
    total_hours,
    RANK() OVER (ORDER BY total_hours DESC) AS usage_rank
  FROM usage;
$$;


--
-- TOC entry 769 (class 1255 OID 22114)
-- Name: refresh_project_cost_summary(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_project_cost_summary() RETURNS void
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  REFRESH MATERIALIZED VIEW public.project_cost_summary;
$$;


--
-- TOC entry 1053 (class 1255 OID 27701)
-- Name: remove_profile_from_contract(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.remove_profile_from_contract(p_contract_id uuid, p_profile_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  perform check_access('delete','user_projects', p_contract_id, null);

  update public.user_projects
  set deleted_at = now(),
      updated_at = now()
  where project_id = p_contract_id
    and user_id = p_profile_id
    and deleted_at is null;
end;
$$;


--
-- TOC entry 667 (class 1255 OID 46684)
-- Name: review_organization_invite(uuid, text, timestamp with time zone, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.review_organization_invite(p_invite_id uuid, p_decision text, p_responded_at timestamp with time zone DEFAULT now(), p_selected_job_title_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.organization_invites
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
declare
  _old_row public.organization_invites;
  _new_row public.organization_invites;
  _reviewer_id uuid := auth.uid();
  _org_name text;
  _reviewer_name text;
  _job_title_name text;
  _position_label text;
  _decision_word text;
begin
  if p_decision not in ('accepted', 'declined') then
    raise exception 'invalid decision' using detail = jsonb_build_object('decision', p_decision);
  end if;

  select * into _old_row from public.organization_invites where id = p_invite_id;
  if _old_row is null then
    raise exception 'row not found' using detail = jsonb_build_object('id', p_invite_id);
  end if;

  perform check_access('update', 'organization_invites', null, _old_row.organization_id);

  if _old_row.status <> 'pending' then
    raise exception 'status is not pending' using detail = jsonb_build_object('id', p_invite_id, 'status', _old_row.status);
  end if;

  update public.organization_invites
     set status = p_decision,
         responded_at = coalesce(p_responded_at, now())
   where id = p_invite_id
   returning * into _new_row;

  if _new_row.status = 'accepted' then
    if not exists (
      select 1
      from public.organization_members m
      where m.organization_id = _new_row.organization_id
        and m.profile_id = _new_row.invited_profile_id
    ) then
      insert into public.organization_members (organization_id, profile_id, role, created_at, updated_at)
      values (_new_row.organization_id, _new_row.invited_profile_id, coalesce(_new_row.role, 'org_user'), now(), now());

      update public.profiles
         set organization_id = _new_row.organization_id,
             updated_at = now()
       where id = _new_row.invited_profile_id;
    end if;

    if p_selected_job_title_id is not null then
      perform public.set_org_member_job_title(
        _new_row.organization_id,
        _new_row.invited_profile_id,
        p_selected_job_title_id
      );
    end if;
  end if;

  if p_selected_job_title_id is not null then
    select jt.name into _job_title_name
    from public.job_titles jt
    where jt.id = p_selected_job_title_id;
  end if;

  select o.name into _org_name from public.organizations o where o.id = _new_row.organization_id;
  select p.full_name into _reviewer_name from public.profiles p where p.id = _reviewer_id;

  _position_label := coalesce(
    nullif(trim(_job_title_name), ''),
    nullif(trim(_new_row.role::text), ''),
    'member'
  );

  _decision_word := case when _new_row.status = 'accepted' then 'approved' else 'denied' end;

  begin
    perform public.insert_notifications(
      jsonb_build_object(
        'user_id', _new_row.invited_profile_id,
        'organization_id', _new_row.organization_id,
        'category', 'workflow_update',
        'message',
          'Your request to join ' || coalesce(_org_name, 'this organization')
          || ' has been ' || _decision_word
          || ' for the position of ' || _position_label || '.',
        'payload', jsonb_build_object(
          'event', 'membership_request_reviewed',
          'invite_id', _new_row.id,
          'organization_id', _new_row.organization_id,
          'organization_name', _org_name,
          'invited_profile_id', _new_row.invited_profile_id,
          'status', _new_row.status,
          'decision_word', _decision_word,
          'requested_role', _new_row.role,
          'selected_job_title_id', p_selected_job_title_id,
          'selected_job_title_name', _job_title_name,
          'position_label', _position_label,
          'reviewed_by_profile_id', _reviewer_id,
          'reviewed_by_name', _reviewer_name,
          'reviewed_at', _new_row.responded_at,
          'reason', _new_row.comment
        )
      )
    );
  exception when others then
    null;
  end;

  return next _new_row;
end;
$$;


--
-- TOC entry 822 (class 1255 OID 27708)
-- Name: rpc_calculator_template_payload(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_calculator_template_payload(p_template_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_template jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','line_item_templates', null, v_org_id);

  select jsonb_build_object(
    'id', t.id,
    'name', t.name,
    'formula', t.formula,
    'variables', t.variables,
    'created_at', t.created_at,
    'updated_at', t.updated_at
  )
  into v_template
  from public.line_item_templates t
  where t.id = p_template_id
    and t.deleted_at is null;

  if v_template is null then
    raise exception 'Template not found: %', p_template_id;
  end if;

  return jsonb_build_object(
    'template', v_template
  );
end;
$$;


--
-- TOC entry 915 (class 1255 OID 27707)
-- Name: rpc_calculators_payload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_calculators_payload() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_templates jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','line_item_templates', null, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', t.id,
        'name', t.name,
        'formula', t.formula,
        'variables', t.variables,
        'created_at', t.created_at,
        'updated_at', t.updated_at
      )
      order by t.updated_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_templates
  from public.line_item_templates t
  where t.deleted_at is null;

  return jsonb_build_object(
    'templates', v_templates
  );
end;
$$;


--
-- TOC entry 974 (class 1255 OID 27704)
-- Name: rpc_equipment_log_payload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_equipment_log_payload() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_logs jsonb;
  v_equipment jsonb;
  v_operators jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','equipment_usage', null, v_org_id);
  perform check_access('select','equipment', null, v_org_id);
  perform check_access('select','profiles', null, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', eu.id,
        'equipment_id', eu.equipment_id,
        'usage_date', eu.date,
        'hours_used', eu.hours_used,
        'notes', eu.notes
      )
      order by eu.date desc nulls last
    ),
    '[]'::jsonb
  )
  into v_logs
  from public.equipment_usage eu
  join public.equipment e on e.id = eu.equipment_id
  where eu.deleted_at is null
    and e.deleted_at is null
    and (v_org_id is null or e.organization_id = v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', e.id,
        'name', e.name,
        'serial_number', e.serial_number,
        'model', e.model
      )
      order by e.name
    ),
    '[]'::jsonb
  )
  into v_equipment
  from public.equipment e
  where e.deleted_at is null
    and (v_org_id is null or e.organization_id = v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', p.id,
        'full_name', p.full_name,
        'email', p.email
      )
      order by p.full_name nulls last, p.email
    ),
    '[]'::jsonb
  )
  into v_operators
  from public.profiles p
  where p.deleted_at is null
    and (v_org_id is null or p.organization_id = v_org_id);

  return jsonb_build_object(
    'logs', v_logs,
    'equipment', v_equipment,
    'operators', v_operators
  );
end;
$$;


--
-- TOC entry 583 (class 1255 OID 27706)
-- Name: rpc_equipment_maintenance_payload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_equipment_maintenance_payload() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_records jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','equipment_maintenance', null, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', em.id,
        'equipment_id', em.equipment_id,
        'description', em.description,
        'maintenance_date', em.maintenance_date,
        'performed_by', em.performed_by,
        'type', em.type,
        'created_at', em.created_at,
        'updated_at', em.updated_at
      )
      order by em.maintenance_date desc nulls last
    ),
    '[]'::jsonb
  )
  into v_records
  from public.equipment_maintenance em
  join public.equipment e on e.id = em.equipment_id
  where em.deleted_at is null
    and e.deleted_at is null
    and (v_org_id is null or e.organization_id = v_org_id);

  return jsonb_build_object(
    'records', v_records
  );
end;
$$;


--
-- TOC entry 563 (class 1255 OID 27705)
-- Name: rpc_estimates_payload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_estimates_payload() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_estimates jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','estimates', null, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', e.id,
        'project_id', e.project_id,
        'name', e.name,
        'status', e.status,
        'created_at', e.created_at,
        'updated_at', e.updated_at
      )
      order by e.updated_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_estimates
  from public.estimates e
  join public.projects p on p.id = e.project_id
  where e.deleted_at is null
    and p.deleted_at is null
    and (v_org_id is null or p.organization_id = v_org_id);

  return jsonb_build_object(
    'estimates', v_estimates
  );
end;
$$;


--
-- TOC entry 944 (class 1255 OID 27698)
-- Name: rpc_inspections_payload(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_inspections_payload(p_project_id uuid DEFAULT NULL::uuid, p_wbs_id uuid DEFAULT NULL::uuid, p_map_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_project_id uuid := p_project_id;
  v_wbs_id uuid := p_wbs_id;
  v_map_id uuid := p_map_id;
  v_projects jsonb;
  v_wbs jsonb;
  v_maps jsonb;
  v_line_items jsonb;
  v_inspections jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select *
  into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;

  if v_project_id is null and v_wbs_id is not null then
    select project_id into v_project_id
    from public.wbs
    where id = v_wbs_id
      and deleted_at is null;
  end if;

  if v_project_id is null and v_map_id is not null then
    select project_id into v_project_id
    from public.maps
    where id = v_map_id
      and deleted_at is null;
  end if;

  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','projects', v_project_id, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name
      )
      order by name
    ),
    '[]'::jsonb
  )
  into v_projects
  from public.projects
  where deleted_at is null
    and (v_org_id is null or organization_id = v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name
      )
      order by order_num nulls last, name
    ),
    '[]'::jsonb
  )
  into v_wbs
  from public.wbs
  where deleted_at is null
    and v_project_id is not null
    and project_id = v_project_id;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name,
        'wbs_id', wbs_id
      )
      order by order_num nulls last, name
    ),
    '[]'::jsonb
  )
  into v_maps
  from public.maps
  where deleted_at is null
    and v_wbs_id is not null
    and wbs_id = v_wbs_id;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', coalesce(description, name)
      )
      order by updated_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_line_items
  from public.line_items
  where deleted_at is null
    and v_map_id is not null
    and map_id = v_map_id;

  if v_project_id is not null then
    select coalesce(
      jsonb_agg(
        jsonb_build_object(
          'id', id,
          'name', name,
          'notes', notes,
          'project_id', project_id,
          'result', result,
          'created_at', created_at,
          'updated_at', updated_at
        )
        order by created_at desc nulls last
      ),
      '[]'::jsonb
    )
    into v_inspections
    from public.inspections
    where deleted_at is null
      and project_id = v_project_id;
  else
    select coalesce(
      jsonb_agg(
        jsonb_build_object(
          'id', i.id,
          'name', i.name,
          'notes', i.notes,
          'project_id', i.project_id,
          'result', i.result,
          'created_at', i.created_at,
          'updated_at', i.updated_at
        )
        order by i.created_at desc nulls last
      ),
      '[]'::jsonb
    )
    into v_inspections
    from public.inspections i
    join public.projects p on p.id = i.project_id
    where i.deleted_at is null
      and p.deleted_at is null
      and (v_org_id is null or p.organization_id = v_org_id);
  end if;

  return jsonb_build_object(
    'projects', v_projects,
    'wbs', v_wbs,
    'maps', v_maps,
    'line_items', v_line_items,
    'inspections', v_inspections
  );
end;
$$;


--
-- TOC entry 972 (class 1255 OID 27709)
-- Name: rpc_issues_payload(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_issues_payload(p_project_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_issues jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  if p_project_id is null then
    raise exception 'Project id is required';
  end if;

  perform check_access('select','issues', p_project_id, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', i.id,
        'project_id', i.project_id,
        'name', i.name,
        'description', i.description,
        'type', i.type,
        'status', i.status,
        'resolved', i.resolved,
        'reported_by', i.reported_by,
        'created_at', i.created_at,
        'updated_at', i.updated_at,
        'deleted_at', i.deleted_at,
        'profiles', jsonb_build_object(
          'full_name', p.full_name,
          'email', p.email
        )
      )
      order by i.created_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_issues
  from public.issues i
  left join public.profiles p on p.id = i.reported_by
  where i.project_id = p_project_id
    and i.deleted_at is null;

  return jsonb_build_object(
    'issues', v_issues
  );
end;
$$;


--
-- TOC entry 918 (class 1255 OID 33272)
-- Name: rpc_org_dashboard_payload(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_org_dashboard_payload(p_organization_id uuid, p_members_page integer DEFAULT 1, p_page_size integer DEFAULT 10) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id uuid;
  v_role text;
  v_has_membership boolean := false;
  v_page int := GREATEST(COALESCE(p_members_page, 1), 1);
  v_page_size int := GREATEST(COALESCE(p_page_size, 10), 1);
  v_offset int := (v_page - 1) * v_page_size;
  v_organization jsonb;
  v_service_areas jsonb;
  v_members_items jsonb;
  v_members_total int := 0;
  v_total_members int := 0;
  v_total_projects int := 0;
  v_members_yoy int := 0;
  v_projects_yoy int := 0;
  v_members_last_year int := 0;
  v_projects_last_year int := 0;
  v_open_issues int := 0;
  v_pending_inspections int := 0;
BEGIN
  -- Access check follows existing security patterns.
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role
  INTO v_role
  FROM public.profiles
  WHERE id = v_user_id;

  IF v_role IS NULL THEN
    RAISE EXCEPTION 'Access denied: profile not found for user %', v_user_id;
  END IF;

  IF v_role = 'system_admin' THEN
    v_has_membership := true;
  ELSE
    SELECT EXISTS (
      SELECT 1
      FROM public.organization_members
      WHERE organization_id = p_organization_id
        AND profile_id = v_user_id
        AND deleted_at IS NULL
    )
    INTO v_has_membership;
  END IF;

  IF v_has_membership IS NOT TRUE THEN
    RAISE EXCEPTION 'Access denied: not a member of organization %', p_organization_id;
  END IF;

  -- Organization header payload.
  SELECT jsonb_build_object(
    'id', id,
    'name', name,
    'description', description,
    'mission_statement', mission_statement,
    'headquarters', headquarters,
    'logo_url', logo_url
  )
  INTO v_organization
  FROM public.organizations
  WHERE id = p_organization_id
    AND deleted_at IS NULL;

  IF v_organization IS NULL THEN
    RAISE EXCEPTION 'Organization not found: %', p_organization_id;
  END IF;

  -- Service areas, ordered alphabetically.
  SELECT COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'service_area_text', service_area_text
      )
      ORDER BY service_area_text
    ),
    '[]'::jsonb
  )
  INTO v_service_areas
  FROM public.organization_service_areas
  WHERE organization_id = p_organization_id;

  -- Members pagination and total count.
  SELECT COUNT(*)
  INTO v_members_total
  FROM public.organization_members
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  SELECT COALESCE(jsonb_agg(to_jsonb(member_row)), '[]'::jsonb)
  INTO v_members_items
  FROM (
    SELECT
      p.id AS profile_id,
      p.full_name,
      p.email,
      p.role AS global_role,
      om.role AS membership_role
    FROM public.organization_members om
    JOIN public.profiles p ON p.id = om.profile_id
    WHERE om.organization_id = p_organization_id
      AND om.deleted_at IS NULL
    ORDER BY p.full_name NULLS LAST, p.email
    LIMIT v_page_size
    OFFSET v_offset
  ) member_row;

  -- Basic metrics for the dashboard.
  SELECT COUNT(*)
  INTO v_total_members
  FROM public.organization_members
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  SELECT COUNT(*)
  INTO v_total_projects
  FROM public.projects
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  -- Open issues for the organization (same logic as profile-scoped RPC)
  SELECT COUNT(*)
  INTO v_open_issues
  FROM public.issues i
  JOIN public.projects p ON p.id = i.project_id
  WHERE p.organization_id = p_organization_id
    AND i.deleted_at IS NULL
    AND COALESCE(i.resolved, false) = false;

  -- Pending inspections for the organization (same logic as profile-scoped RPC)
  SELECT COUNT(*)
  INTO v_pending_inspections
  FROM public.inspections ins
  JOIN public.projects p ON p.id = ins.project_id
  WHERE p.organization_id = p_organization_id
    AND ins.deleted_at IS NULL
    AND (ins.status IS NULL OR lower(ins.status) NOT IN ('completed', 'complete', 'closed', 'passed'));

  -- Year-over-year calculations (difference from 1 year ago)
  -- Members: count active members from exactly 1 year ago
  SELECT COUNT(*)
  INTO v_members_last_year
  FROM public.organization_members
  WHERE organization_id = p_organization_id
    AND created_at <= NOW() - INTERVAL '1 year'
    AND (deleted_at IS NULL OR deleted_at > NOW() - INTERVAL '1 year');

  -- Projects: count active projects from exactly 1 year ago
  SELECT COUNT(*)
  INTO v_projects_last_year
  FROM public.projects
  WHERE organization_id = p_organization_id
    AND created_at <= NOW() - INTERVAL '1 year'
    AND (deleted_at IS NULL OR deleted_at > NOW() - INTERVAL '1 year');

  -- Calculate YOY change (current - last year)
  v_members_yoy := v_total_members - v_members_last_year;
  v_projects_yoy := v_total_projects - v_projects_last_year;

  RETURN jsonb_build_object(
    'organization', v_organization,
    'service_areas', v_service_areas,
    'members', jsonb_build_object(
      'total_count', v_members_total,
      'items', v_members_items
    ),
    'metrics', jsonb_build_object(
      'total_members', v_total_members,
      'total_projects', v_total_projects,
      'members_yoy', v_members_yoy,
      'projects_yoy', v_projects_yoy,
      'open_issues', v_open_issues,
      'pending_inspections', v_pending_inspections
    )
  );
END;
$$;


--
-- TOC entry 795 (class 1255 OID 27696)
-- Name: rpc_profile_dashboard_payload(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_profile_dashboard_payload(p_projects_page integer DEFAULT 1, p_page_size integer DEFAULT 10) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_role text;
  v_org_id uuid;
  v_has_membership boolean := false;
  v_page int := greatest(coalesce(p_projects_page, 1), 1);
  v_page_size int := greatest(coalesce(p_page_size, 10), 1);
  v_offset int := (v_page - 1) * v_page_size;
  v_org jsonb;
  v_job_titles jsonb;
  v_projects jsonb := '[]'::jsonb;
  v_projects_total int := 0;
  v_active_projects int := 0;
  v_open_issues int := 0;
  v_pending_inspections int := 0;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select *
  into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_role := v_profile.role;
  v_org_id := v_profile.organization_id;

  if v_org_id is not null then
    if v_role = 'system_admin' then
      v_has_membership := true;
    else
      select exists (
        select 1
        from public.organization_members
        where organization_id = v_org_id
          and profile_id = v_user_id
          and deleted_at is null
      ) into v_has_membership;
    end if;

    if v_has_membership is not true then
      raise exception 'Access denied: not a member of organization %', v_org_id;
    end if;

    select jsonb_build_object(
      'id', id,
      'name', name,
      'description', description,
      'mission_statement', mission_statement,
      'headquarters', headquarters,
      'logo_url', logo_url,
      'created_at', created_at,
      'updated_at', updated_at
    )
    into v_org
    from public.organizations
    where id = v_org_id
      and deleted_at is null;

    select count(*)
    into v_projects_total
    from public.projects
    where organization_id = v_org_id
      and deleted_at is null;

    select coalesce(
      jsonb_agg(
        jsonb_build_object(
          'id', id,
          'organization_id', organization_id,
          'name', name,
          'description', description,
          'status', status,
          'start_date', start_date,
          'end_date', end_date,
          'created_at', created_at,
          'updated_at', updated_at
        )
        order by updated_at desc nulls last
      ),
      '[]'::jsonb
    )
    into v_projects
    from (
      select *
      from public.projects
      where organization_id = v_org_id
        and deleted_at is null
      order by updated_at desc nulls last
      limit v_page_size
      offset v_offset
    ) p;

    select count(*)
    into v_active_projects
    from public.projects
    where organization_id = v_org_id
      and deleted_at is null
      and status = 'active';

    select count(*)
    into v_open_issues
    from public.issues i
    join public.projects p on p.id = i.project_id
    where p.organization_id = v_org_id
      and i.deleted_at is null
      and coalesce(i.resolved, false) = false;

    select count(*)
    into v_pending_inspections
    from public.inspections ins
    join public.projects p on p.id = ins.project_id
    where p.organization_id = v_org_id
      and ins.deleted_at is null
      and (ins.status is null or lower(ins.status) not in ('completed', 'complete', 'closed', 'passed'));
  else
    v_org := null;
    v_projects := '[]'::jsonb;
  end if;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name
      )
      order by name
    ),
    '[]'::jsonb
  )
  into v_job_titles
  from public.job_titles
  where deleted_at is null;

  return jsonb_build_object(
    'profile', jsonb_build_object(
      'id', v_profile.id,
      'full_name', v_profile.full_name,
      'email', v_profile.email,
      'phone', v_profile.phone,
      'avatar_id', v_profile.avatar_id,
      'role', v_profile.role,
      'job_title_id', v_profile.job_title_id,
      'organization_id', v_profile.organization_id,
      'created_at', v_profile.created_at,
      'updated_at', v_profile.updated_at,
      'deleted_at', v_profile.deleted_at,
      'profile_completed_at', v_profile.profile_completed_at
    ),
    'organization', v_org,
    'job_titles', v_job_titles,
    'projects', jsonb_build_object(
      'total_count', v_projects_total,
      'items', v_projects
    ),
    'metrics', jsonb_build_object(
      'active_projects', v_active_projects,
      'open_issues', v_open_issues,
      'pending_inspections', v_pending_inspections
    )
  );
end;
$$;


--
-- TOC entry 660 (class 1255 OID 27697)
-- Name: rpc_project_dashboard_payload(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_project_dashboard_payload(p_project_id uuid, p_line_items_page integer DEFAULT 1, p_page_size integer DEFAULT 50) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_role text;
  v_project public.projects%rowtype;
  v_has_membership boolean := false;
  v_page int := greatest(coalesce(p_line_items_page, 1), 1);
  v_page_size int := greatest(coalesce(p_page_size, 50), 1);
  v_offset int := (v_page - 1) * v_page_size;
  v_wbs jsonb := '[]'::jsonb;
  v_wbs_total int := 0;
  v_line_items jsonb := '[]'::jsonb;
  v_line_items_total int := 0;
  v_issues_count int := 0;
  v_change_orders_count int := 0;
  v_inspections_count int := 0;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if p_project_id is null then
    raise exception 'Project id is required';
  end if;

  select role into v_role
  from public.profiles
  where id = v_user_id;

  if v_role is null then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  select *
  into v_project
  from public.projects
  where id = p_project_id
    and deleted_at is null;

  if not found then
    raise exception 'Project not found: %', p_project_id;
  end if;

  if v_role = 'system_admin' then
    v_has_membership := true;
  else
    select exists (
      select 1
      from public.organization_members
      where organization_id = v_project.organization_id
        and profile_id = v_user_id
        and deleted_at is null
    ) into v_has_membership;
  end if;

  if v_has_membership is not true then
    raise exception 'Access denied: not a member of organization %', v_project.organization_id;
  end if;

  select count(*)
  into v_wbs_total
  from public.wbs
  where project_id = p_project_id
    and deleted_at is null;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'project_id', project_id,
        'name', name,
        'location', location,
        'order_num', order_num,
        'created_at', created_at,
        'updated_at', updated_at
      )
      order by order_num nulls last, name
    ),
    '[]'::jsonb
  )
  into v_wbs
  from public.wbs
  where project_id = p_project_id
    and deleted_at is null;

  select count(*)
  into v_line_items_total
  from public.line_items
  where project_id = p_project_id
    and deleted_at is null;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'project_id', project_id,
        'wbs_id', wbs_id,
        'map_id', map_id,
        'cost_code_id', cost_code_id,
        'template_id', template_id,
        'name', name,
        'description', description,
        'unit_measure', unit_measure,
        'quantity', quantity,
        'unit_price', unit_price,
        'created_at', created_at,
        'updated_at', updated_at
      )
      order by updated_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_line_items
  from (
    select *
    from public.line_items
    where project_id = p_project_id
      and deleted_at is null
    order by updated_at desc nulls last
    limit v_page_size
    offset v_offset
  ) li;

  select count(*)
  into v_issues_count
  from public.issues
  where project_id = p_project_id
    and deleted_at is null;

  select count(*)
  into v_change_orders_count
  from public.change_orders
  where project_id = p_project_id
    and deleted_at is null;

  select count(*)
  into v_inspections_count
  from public.inspections
  where project_id = p_project_id
    and deleted_at is null;

  return jsonb_build_object(
    'project', jsonb_build_object(
      'id', v_project.id,
      'organization_id', v_project.organization_id,
      'name', v_project.name,
      'description', v_project.description,
      'status', v_project.status,
      'start_date', v_project.start_date,
      'end_date', v_project.end_date,
      'created_at', v_project.created_at,
      'updated_at', v_project.updated_at
    ),
    'wbs', jsonb_build_object(
      'total_count', v_wbs_total,
      'items', v_wbs
    ),
    'line_items', jsonb_build_object(
      'total_count', v_line_items_total,
      'items', v_line_items
    ),
    'counts', jsonb_build_object(
      'issues', v_issues_count,
      'change_orders', v_change_orders_count,
      'inspections', v_inspections_count
    )
  );
end;
$$;


--
-- TOC entry 613 (class 1255 OID 45574)
-- Name: set_my_primary_organization(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_my_primary_organization(p_organization_id uuid) RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_profile public.profiles;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_organization_id IS NULL THEN
    RAISE EXCEPTION 'organization_id is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.profile_id = v_user_id
      AND om.organization_id = p_organization_id
      AND om.deleted_at IS NULL
  ) THEN
    RAISE EXCEPTION 'Not a member of the selected organization'
      USING ERRCODE = '42501';
  END IF;

  UPDATE public.profiles p
  SET
    organization_id = p_organization_id,
    updated_at = now()
  WHERE p.id = v_user_id
  RETURNING * INTO v_profile;

  RETURN v_profile;
END;
$$;


--
-- TOC entry 652 (class 1255 OID 46683)
-- Name: set_org_member_job_title(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_org_member_job_title(p_org_id uuid, p_profile_id uuid, p_job_title_id uuid) RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
declare
  v_user_id uuid := auth.uid();
  v_is_allowed boolean := false;
  v_profile public.profiles;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if p_org_id is null or p_profile_id is null or p_job_title_id is null then
    raise exception 'Missing required inputs';
  end if;

  -- Allow system/org admin OR owner/admin member in this org
  select exists (
    select 1
    from public.profiles me
    where me.id = v_user_id
      and me.deleted_at is null
      and me.role in ('system_admin','org_admin')
  ) or exists (
    select 1
    from public.organization_members om
    where om.organization_id = p_org_id
      and om.profile_id = v_user_id
      and om.deleted_at is null
      and om.role in ('owner','admin')
  )
  into v_is_allowed;

  if not v_is_allowed then
    raise exception 'Access denied'
      using errcode = '42501';
  end if;

  -- Ensure target is an active member of this org
  if not exists (
    select 1
    from public.organization_members om
    where om.organization_id = p_org_id
      and om.profile_id = p_profile_id
      and om.deleted_at is null
  ) then
    raise exception 'Target is not an active member of this organization'
      using errcode = 'P0001';
  end if;

  update public.profiles p
  set job_title_id = p_job_title_id,
      updated_at = now()
  where p.id = p_profile_id
    and p.deleted_at is null
  returning * into v_profile;

  if v_profile.id is null then
    raise exception 'Target profile not found'
      using errcode = 'P0001';
  end if;

  return v_profile;
end;
$$;


--
-- TOC entry 905 (class 1255 OID 26406)
-- Name: set_org_member_role(uuid, uuid, public.org_role); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_org_member_role(p_org_id uuid, p_profile_id uuid, p_role public.org_role) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id uuid;
  v_is_owner boolean;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_org_id IS NULL OR p_profile_id IS NULL THEN
    RAISE EXCEPTION 'Missing organization or profile id';
  END IF;

  SELECT EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.organization_id = p_org_id
      AND om.profile_id = v_user_id
      AND om.role = 'owner'
  ) INTO v_is_owner;

  IF NOT v_is_owner THEN
    RAISE EXCEPTION 'Access denied: not an owner';
  END IF;

  UPDATE public.organization_members
  SET role = p_role,
      updated_at = now()
  WHERE organization_id = p_org_id
    AND profile_id = p_profile_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Member not found';
  END IF;
END;
$$;


--
-- TOC entry 862 (class 1255 OID 22115)
-- Name: set_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'pg_catalog', 'public'
    AS $$
BEGIN
  IF TG_OP = 'UPDATE' THEN
    NEW.updated_at := now();
  END IF;
  RETURN NEW;
END;
$$;


--
-- TOC entry 814 (class 1255 OID 22116)
-- Name: touch_created_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.touch_created_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'pg_catalog', 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    NEW.created_at := now();
  END IF;
  RETURN NEW;
END;
$$;


--
-- TOC entry 708 (class 1255 OID 22117)
-- Name: update_accounts_payable(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_accounts_payable(_id uuid, _input jsonb) RETURNS SETOF public.accounts_payable
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.accounts_payable;
        _new_row public.accounts_payable;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.accounts_payable := (jsonb_populate_record(NULL::public.accounts_payable, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.accounts_payable WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','accounts_payable', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.accounts_payable
           SET amount_due = COALESCE(_row.amount_due, amount_due), due_date = COALESCE(_row.due_date, due_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 681 (class 1255 OID 22118)
-- Name: update_accounts_receivable(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_accounts_receivable(_id uuid, _input jsonb) RETURNS SETOF public.accounts_receivable
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.accounts_receivable;
        _new_row public.accounts_receivable;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.accounts_receivable := (jsonb_populate_record(NULL::public.accounts_receivable, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.accounts_receivable WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','accounts_receivable', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.accounts_receivable
           SET amount_due = COALESCE(_row.amount_due, amount_due), due_date = COALESCE(_row.due_date, due_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 844 (class 1255 OID 22119)
-- Name: update_activity_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_activity_logs(_id uuid, _input jsonb) RETURNS SETOF public.activity_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.activity_logs;
        _new_row public.activity_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.activity_logs := (jsonb_populate_record(NULL::public.activity_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.activity_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','activity_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.activity_logs
           SET profile_id = COALESCE(_row.profile_id, profile_id), activity_type = COALESCE(_row.activity_type, activity_type), activity_at = COALESCE(_row.activity_at, activity_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 573 (class 1255 OID 22120)
-- Name: update_asphalt_types(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_asphalt_types(_id uuid, _input jsonb) RETURNS SETOF public.asphalt_types
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.asphalt_types;
        _new_row public.asphalt_types;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.asphalt_types := (jsonb_populate_record(NULL::public.asphalt_types, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.asphalt_types WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','asphalt_types', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.asphalt_types
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1051 (class 1255 OID 27712)
-- Name: update_audit_log(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_audit_log(_id uuid, _input jsonb) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.audit_log;
      _new_row public.audit_log;
      _row     public.audit_log := (jsonb_populate_record(NULL::public.audit_log, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      SELECT * INTO _old_row FROM public.audit_log WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('update','audit_log', NULL, NULL);

      UPDATE public.audit_log
         SET table_name = COALESCE(_row.table_name, table_name),
             action = COALESCE(_row.action, action),
             row_id = COALESCE(_row.row_id, row_id),
             before_data = COALESCE(_row.before_data, before_data),
             after_data = COALESCE(_row.after_data, after_data)
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 659 (class 1255 OID 22121)
-- Name: update_audit_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_audit_logs(_id uuid, _input jsonb) RETURNS SETOF public.audit_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.audit_logs;
        _new_row public.audit_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.audit_logs := (jsonb_populate_record(NULL::public.audit_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.audit_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','audit_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.audit_logs
           SET action = COALESCE(_row.action, action), performed_by = COALESCE(_row.performed_by, performed_by), performed_at = COALESCE(_row.performed_at, performed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 686 (class 1255 OID 22122)
-- Name: update_avatars(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_avatars(_id uuid, _input jsonb) RETURNS SETOF public.avatars
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.avatars;
        _new_row public.avatars;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.avatars := (jsonb_populate_record(NULL::public.avatars, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.avatars WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','avatars', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.avatars
           SET url = COALESCE(_row.url, url), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 921 (class 1255 OID 22124)
-- Name: update_bid_packages(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bid_packages(_id uuid, _input jsonb) RETURNS SETOF public.bid_packages
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.bid_packages;
        _new_row public.bid_packages;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bid_packages := (jsonb_populate_record(NULL::public.bid_packages, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bid_packages WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bid_packages', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bid_packages
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 947 (class 1255 OID 22125)
-- Name: update_bid_vendors(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bid_vendors(_id uuid, _input jsonb) RETURNS SETOF public.bid_vendors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.bid_vendors;
        _new_row public.bid_vendors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bid_vendors := (jsonb_populate_record(NULL::public.bid_vendors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bid_vendors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bid_vendors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bid_vendors
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), invited_at = COALESCE(_row.invited_at, invited_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 540 (class 1255 OID 22126)
-- Name: update_bids(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bids(_id uuid, _input jsonb) RETURNS SETOF public.bids
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.bids;
        _new_row public.bids;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bids := (jsonb_populate_record(NULL::public.bids, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bids WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bids', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bids
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), amount = COALESCE(_row.amount, amount), submitted_at = COALESCE(_row.submitted_at, submitted_at), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 592 (class 1255 OID 22127)
-- Name: update_bim_models(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bim_models(_id uuid, _input jsonb) RETURNS SETOF public.bim_models
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.bim_models;
        _new_row public.bim_models;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bim_models := (jsonb_populate_record(NULL::public.bim_models, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bim_models WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bim_models', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bim_models
           SET name = COALESCE(_row.name, name), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1038 (class 1255 OID 22128)
-- Name: update_certifications(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_certifications(_id uuid, _input jsonb) RETURNS SETOF public.certifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.certifications;
        _new_row public.certifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.certifications := (jsonb_populate_record(NULL::public.certifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.certifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','certifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.certifications
           SET employee_id = COALESCE(_row.employee_id, employee_id), certification_type = COALESCE(_row.certification_type, certification_type), issue_date = COALESCE(_row.issue_date, issue_date), expiry_date = COALESCE(_row.expiry_date, expiry_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 682 (class 1255 OID 22129)
-- Name: update_change_orders(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_change_orders(_id uuid, _input jsonb) RETURNS SETOF public.change_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.change_orders;
        _new_row public.change_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.change_orders := (jsonb_populate_record(NULL::public.change_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.change_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','change_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.change_orders
           SET number = COALESCE(_row.number, number), description = COALESCE(_row.description, description), status = COALESCE(_row.status, status), amount = COALESCE(_row.amount, amount), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 800 (class 1255 OID 22130)
-- Name: update_commitments(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_commitments(_id uuid, _input jsonb) RETURNS SETOF public.commitments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.commitments;
        _new_row public.commitments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.commitments := (jsonb_populate_record(NULL::public.commitments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.commitments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','commitments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.commitments
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), type = COALESCE(_row.type, type), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 543 (class 1255 OID 22131)
-- Name: update_compliance_checks(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_compliance_checks(_id uuid, _input jsonb) RETURNS SETOF public.compliance_checks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.compliance_checks;
        _new_row public.compliance_checks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.compliance_checks := (jsonb_populate_record(NULL::public.compliance_checks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.compliance_checks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','compliance_checks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.compliance_checks
           SET check_date = COALESCE(_row.check_date, check_date), description = COALESCE(_row.description, description), result = COALESCE(_row.result, result), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 685 (class 1255 OID 22132)
-- Name: update_compliance_tracking(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_compliance_tracking(_id uuid, _input jsonb) RETURNS SETOF public.compliance_tracking
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.compliance_tracking;
        _new_row public.compliance_tracking;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.compliance_tracking := (jsonb_populate_record(NULL::public.compliance_tracking, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.compliance_tracking WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','compliance_tracking', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.compliance_tracking
           SET tracking_type = COALESCE(_row.tracking_type, tracking_type), status = COALESCE(_row.status, status), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1044 (class 1255 OID 22133)
-- Name: update_cost_codes(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_cost_codes(_id uuid, _input jsonb) RETURNS SETOF public.cost_codes
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.cost_codes;
        _new_row public.cost_codes;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.cost_codes := (jsonb_populate_record(NULL::public.cost_codes, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.cost_codes WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','cost_codes', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.cost_codes
           SET code = COALESCE(_row.code, code), description = COALESCE(_row.description, description), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1011 (class 1255 OID 22134)
-- Name: update_crew_assignments(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_crew_assignments(_id uuid, _input jsonb) RETURNS SETOF public.crew_assignments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.crew_assignments;
        _new_row public.crew_assignments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crew_assignments := (jsonb_populate_record(NULL::public.crew_assignments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crew_assignments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crew_assignments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crew_assignments
           SET crew_id = COALESCE(_row.crew_id, crew_id), profile_id = COALESCE(_row.profile_id, profile_id), assigned_date = COALESCE(_row.assigned_date, assigned_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 942 (class 1255 OID 22135)
-- Name: update_crew_members(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_crew_members(_id uuid, _input jsonb) RETURNS SETOF public.crew_members
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.crew_members;
        _new_row public.crew_members;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crew_members := (jsonb_populate_record(NULL::public.crew_members, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crew_members WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crew_members', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crew_members
           SET crew_id = COALESCE(_row.crew_id, crew_id), profile_id = COALESCE(_row.profile_id, profile_id), role = COALESCE(_row.role, role), start_date = COALESCE(_row.start_date, start_date), end_date = COALESCE(_row.end_date, end_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 704 (class 1255 OID 22136)
-- Name: update_crews(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_crews(_id uuid, _input jsonb) RETURNS SETOF public.crews
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.crews;
        _new_row public.crews;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crews := (jsonb_populate_record(NULL::public.crews, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crews WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crews', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crews
           SET name = COALESCE(_row.name, name), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 730 (class 1255 OID 22137)
-- Name: update_daily_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_daily_logs(_id uuid, _input jsonb) RETURNS SETOF public.daily_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.daily_logs;
        _new_row public.daily_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.daily_logs := (jsonb_populate_record(NULL::public.daily_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.daily_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','daily_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.daily_logs
           SET date = COALESCE(_row.date, date), weather = COALESCE(_row.weather, weather), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 880 (class 1255 OID 22138)
-- Name: update_dashboard_configs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_dashboard_configs(_id uuid, _input jsonb) RETURNS SETOF public.dashboard_configs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.dashboard_configs;
        _new_row public.dashboard_configs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.dashboard_configs := (jsonb_populate_record(NULL::public.dashboard_configs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.dashboard_configs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','dashboard_configs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.dashboard_configs
           SET profile_id = COALESCE(_row.profile_id, profile_id), config = COALESCE(_row.config, config), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 674 (class 1255 OID 22139)
-- Name: update_document_references(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_document_references(_id uuid, _input jsonb) RETURNS SETOF public.document_references
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.document_references;
        _new_row public.document_references;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.document_references := (jsonb_populate_record(NULL::public.document_references, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.document_references WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','document_references', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.document_references
           SET document_id = COALESCE(_row.document_id, document_id), reference_type = COALESCE(_row.reference_type, reference_type), reference_id = COALESCE(_row.reference_id, reference_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 591 (class 1255 OID 22140)
-- Name: update_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.documents;
        _new_row public.documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.documents
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 839 (class 1255 OID 22141)
-- Name: update_drawing_versions(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_drawing_versions(_id uuid, _input jsonb) RETURNS SETOF public.drawing_versions
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.drawing_versions;
        _new_row public.drawing_versions;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.drawing_versions := (jsonb_populate_record(NULL::public.drawing_versions, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.drawing_versions WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','drawing_versions', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.drawing_versions
           SET document_id = COALESCE(_row.document_id, document_id), version = COALESCE(_row.version, version), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 646 (class 1255 OID 22142)
-- Name: update_dump_trucks(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_dump_trucks(_id uuid, _input jsonb) RETURNS SETOF public.dump_trucks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.dump_trucks;
        _new_row public.dump_trucks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.dump_trucks := (jsonb_populate_record(NULL::public.dump_trucks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.dump_trucks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','dump_trucks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.dump_trucks
           SET make = COALESCE(_row.make, make), model = COALESCE(_row.model, model), capacity = COALESCE(_row.capacity, capacity), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 668 (class 1255 OID 22143)
-- Name: update_employees(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_employees(_id uuid, _input jsonb) RETURNS SETOF public.employees
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.employees;
        _new_row public.employees;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.employees := (jsonb_populate_record(NULL::public.employees, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.employees WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','employees', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.employees
           SET profile_id = COALESCE(_row.profile_id, profile_id), hire_date = COALESCE(_row.hire_date, hire_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 653 (class 1255 OID 22144)
-- Name: update_equipment(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_equipment(_id uuid, _input jsonb) RETURNS SETOF public.equipment
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.equipment;
        _new_row public.equipment;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment := (jsonb_populate_record(NULL::public.equipment, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), model = COALESCE(_row.model, model), serial_number = COALESCE(_row.serial_number, serial_number), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 820 (class 1255 OID 22145)
-- Name: update_equipment_assignments(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_equipment_assignments(_id uuid, _input jsonb) RETURNS SETOF public.equipment_assignments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.equipment_assignments;
        _new_row public.equipment_assignments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_assignments := (jsonb_populate_record(NULL::public.equipment_assignments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_assignments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_assignments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_assignments
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), assigned_to = COALESCE(_row.assigned_to, assigned_to), assigned_date = COALESCE(_row.assigned_date, assigned_date), released_date = COALESCE(_row.released_date, released_date), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 687 (class 1255 OID 22146)
-- Name: update_equipment_maintenance(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_equipment_maintenance(_id uuid, _input jsonb) RETURNS SETOF public.equipment_maintenance
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.equipment_maintenance;
        _new_row public.equipment_maintenance;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_maintenance := (jsonb_populate_record(NULL::public.equipment_maintenance, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_maintenance WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_maintenance', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_maintenance
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), maintenance_date = COALESCE(_row.maintenance_date, maintenance_date), type = COALESCE(_row.type, type), description = COALESCE(_row.description, description), performed_by = COALESCE(_row.performed_by, performed_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 777 (class 1255 OID 22147)
-- Name: update_equipment_usage(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_equipment_usage(_id uuid, _input jsonb) RETURNS SETOF public.equipment_usage
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.equipment_usage;
        _new_row public.equipment_usage;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_usage := (jsonb_populate_record(NULL::public.equipment_usage, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_usage WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_usage', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_usage
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), date = COALESCE(_row.date, date), hours_used = COALESCE(_row.hours_used, hours_used), quantity = COALESCE(_row.quantity, quantity), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 711 (class 1255 OID 22148)
-- Name: update_estimate_line_items(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_estimate_line_items(_id uuid, _input jsonb) RETURNS SETOF public.estimate_line_items
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.estimate_line_items;
        _new_row public.estimate_line_items;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.estimate_line_items := (jsonb_populate_record(NULL::public.estimate_line_items, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.estimate_line_items WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','estimate_line_items', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.estimate_line_items
           SET estimate_id = COALESCE(_row.estimate_id, estimate_id), cost_code_id = COALESCE(_row.cost_code_id, cost_code_id), name = COALESCE(_row.name, name), unit_measure = COALESCE(_row.unit_measure, unit_measure), quantity = COALESCE(_row.quantity, quantity), unit_price = COALESCE(_row.unit_price, unit_price), total_cost = COALESCE(_row.total_cost, total_cost), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 691 (class 1255 OID 22149)
-- Name: update_estimates(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_estimates(_id uuid, _input jsonb) RETURNS SETOF public.estimates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.estimates;
        _new_row public.estimates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.estimates := (jsonb_populate_record(NULL::public.estimates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.estimates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','estimates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.estimates
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1048 (class 1255 OID 22150)
-- Name: update_financial_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_financial_documents(_id uuid, _input jsonb) RETURNS SETOF public.financial_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.financial_documents;
        _new_row public.financial_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.financial_documents := (jsonb_populate_record(NULL::public.financial_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.financial_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','financial_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.financial_documents
           SET document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 558 (class 1255 OID 22151)
-- Name: update_general_ledger(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_general_ledger(_id uuid, _input jsonb) RETURNS SETOF public.general_ledger
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.general_ledger;
        _new_row public.general_ledger;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.general_ledger := (jsonb_populate_record(NULL::public.general_ledger, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.general_ledger WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','general_ledger', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.general_ledger
           SET entry_date = COALESCE(_row.entry_date, entry_date), description = COALESCE(_row.description, description), debit = COALESCE(_row.debit, debit), credit = COALESCE(_row.credit, credit), balance = COALESCE(_row.balance, balance), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 584 (class 1255 OID 22152)
-- Name: update_hr_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_hr_documents(_id uuid, _input jsonb) RETURNS SETOF public.hr_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.hr_documents;
        _new_row public.hr_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.hr_documents := (jsonb_populate_record(NULL::public.hr_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.hr_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','hr_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.hr_documents
           SET employee_id = COALESCE(_row.employee_id, employee_id), document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1056 (class 1255 OID 22153)
-- Name: update_inspections(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_inspections(_id uuid, _input jsonb) RETURNS SETOF public.inspections
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.inspections;
        _new_row public.inspections;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.inspections := (jsonb_populate_record(NULL::public.inspections, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.inspections WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','inspections', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.inspections
           SET name = COALESCE(_row.name, name), inspection_type = COALESCE(_row.inspection_type, inspection_type), date = COALESCE(_row.date, date), status = COALESCE(_row.status, status), result = COALESCE(_row.result, result), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 698 (class 1255 OID 22154)
-- Name: update_integration_tokens(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_integration_tokens(_id uuid, _input jsonb) RETURNS SETOF public.integration_tokens
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.integration_tokens;
        _new_row public.integration_tokens;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.integration_tokens := (jsonb_populate_record(NULL::public.integration_tokens, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.integration_tokens WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','integration_tokens', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.integration_tokens
           SET profile_id = COALESCE(_row.profile_id, profile_id), service_name = COALESCE(_row.service_name, service_name), token = COALESCE(_row.token, token), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 739 (class 1255 OID 22155)
-- Name: update_inventory_transactions(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_inventory_transactions(_id uuid, _input jsonb) RETURNS SETOF public.inventory_transactions
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.inventory_transactions;
        _new_row public.inventory_transactions;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.inventory_transactions := (jsonb_populate_record(NULL::public.inventory_transactions, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.inventory_transactions WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','inventory_transactions', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.inventory_transactions
           SET material_id = COALESCE(_row.material_id, material_id), transaction_type = COALESCE(_row.transaction_type, transaction_type), quantity = COALESCE(_row.quantity, quantity), transaction_date = COALESCE(_row.transaction_date, transaction_date), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 806 (class 1255 OID 22156)
-- Name: update_issues(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_issues(_id uuid, _input jsonb) RETURNS SETOF public.issues
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.issues;
        _new_row public.issues;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.issues := (jsonb_populate_record(NULL::public.issues, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.issues WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','issues', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.issues
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), status = COALESCE(_row.status, status), reported_by = COALESCE(_row.reported_by, reported_by), description = COALESCE(_row.description, description), resolved = COALESCE(_row.resolved, resolved), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1047 (class 1255 OID 22157)
-- Name: update_job_titles(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_job_titles(_id uuid, _input jsonb) RETURNS SETOF public.job_titles
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.job_titles;
        _new_row public.job_titles;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.job_titles := (jsonb_populate_record(NULL::public.job_titles, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.job_titles WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','job_titles', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.job_titles
           SET name = COALESCE(_row.name, name), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 962 (class 1255 OID 22158)
-- Name: update_labor_records(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_labor_records(_id uuid, _input jsonb) RETURNS SETOF public.labor_records
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.labor_records;
        _new_row public.labor_records;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.labor_records := (jsonb_populate_record(NULL::public.labor_records, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.labor_records WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','labor_records', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.labor_records
           SET line_item_id = COALESCE(_row.line_item_id, line_item_id), worker_count = COALESCE(_row.worker_count, worker_count), hours_worked = COALESCE(_row.hours_worked, hours_worked), work_date = COALESCE(_row.work_date, work_date), work_type = COALESCE(_row.work_type, work_type), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 714 (class 1255 OID 22159)
-- Name: update_line_item_entries(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_line_item_entries(_id uuid, _input jsonb) RETURNS SETOF public.line_item_entries
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.line_item_entries;
        _new_row public.line_item_entries;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_item_entries := (jsonb_populate_record(NULL::public.line_item_entries, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_item_entries WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_item_entries', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_item_entries
           SET line_item_id = COALESCE(_row.line_item_id, line_item_id), date = COALESCE(_row.date, date), quantity_completed = COALESCE(_row.quantity_completed, quantity_completed), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 891 (class 1255 OID 22160)
-- Name: update_line_item_templates(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_line_item_templates(_id uuid, _input jsonb) RETURNS SETOF public.line_item_templates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.line_item_templates;
        _new_row public.line_item_templates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_item_templates := (jsonb_populate_record(NULL::public.line_item_templates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_item_templates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_item_templates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_item_templates
           SET name = COALESCE(_row.name, name), formula = COALESCE(_row.formula, formula), variables = COALESCE(_row.variables, variables), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 628 (class 1255 OID 22161)
-- Name: update_line_items(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_line_items(_id uuid, _input jsonb) RETURNS SETOF public.line_items
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.line_items;
        _new_row public.line_items;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_items := (jsonb_populate_record(NULL::public.line_items, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_items WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_items', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_items
           SET map_id = COALESCE(_row.map_id, map_id), wbs_id = COALESCE(_row.wbs_id, wbs_id), cost_code_id = COALESCE(_row.cost_code_id, cost_code_id), template_id = COALESCE(_row.template_id, template_id), name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), unit_measure = COALESCE(_row.unit_measure, unit_measure), quantity = COALESCE(_row.quantity, quantity), unit_price = COALESCE(_row.unit_price, unit_price), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 840 (class 1255 OID 22162)
-- Name: update_maps(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_maps(_id uuid, _input jsonb) RETURNS SETOF public.maps
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.maps;
        _new_row public.maps;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.maps := (jsonb_populate_record(NULL::public.maps, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.maps WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','maps', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.maps
           SET wbs_id = COALESCE(_row.wbs_id, wbs_id), name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), coordinates = COALESCE(_row.coordinates, coordinates), scope = COALESCE(_row.scope, scope), order_num = COALESCE(_row.order_num, order_num), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 727 (class 1255 OID 22163)
-- Name: update_material_inventory(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_material_inventory(_id uuid, _input jsonb) RETURNS SETOF public.material_inventory
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.material_inventory;
        _new_row public.material_inventory;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_inventory := (jsonb_populate_record(NULL::public.material_inventory, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_inventory WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_inventory', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_inventory
           SET material_id = COALESCE(_row.material_id, material_id), quantity = COALESCE(_row.quantity, quantity), last_updated = COALESCE(_row.last_updated, last_updated), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 629 (class 1255 OID 22164)
-- Name: update_material_orders(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_material_orders(_id uuid, _input jsonb) RETURNS SETOF public.material_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.material_orders;
        _new_row public.material_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_orders := (jsonb_populate_record(NULL::public.material_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_orders
           SET material_id = COALESCE(_row.material_id, material_id), order_date = COALESCE(_row.order_date, order_date), quantity = COALESCE(_row.quantity, quantity), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 649 (class 1255 OID 22165)
-- Name: update_material_receipts(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_material_receipts(_id uuid, _input jsonb) RETURNS SETOF public.material_receipts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.material_receipts;
        _new_row public.material_receipts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_receipts := (jsonb_populate_record(NULL::public.material_receipts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_receipts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_receipts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_receipts
           SET material_order_id = COALESCE(_row.material_order_id, material_order_id), received_date = COALESCE(_row.received_date, received_date), quantity = COALESCE(_row.quantity, quantity), received_by = COALESCE(_row.received_by, received_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 723 (class 1255 OID 22166)
-- Name: update_materials(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_materials(_id uuid, _input jsonb) RETURNS SETOF public.materials
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.materials;
        _new_row public.materials;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.materials := (jsonb_populate_record(NULL::public.materials, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.materials WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','materials', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.materials
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), unit = COALESCE(_row.unit, unit), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 896 (class 1255 OID 22167)
-- Name: update_meeting_minutes(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_meeting_minutes(_id uuid, _input jsonb) RETURNS SETOF public.meeting_minutes
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.meeting_minutes;
        _new_row public.meeting_minutes;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.meeting_minutes := (jsonb_populate_record(NULL::public.meeting_minutes, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.meeting_minutes WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','meeting_minutes', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.meeting_minutes
           SET meeting_date = COALESCE(_row.meeting_date, meeting_date), notes = COALESCE(_row.notes, notes), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 616 (class 1255 OID 28853)
-- Name: update_my_organization(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_my_organization(_input jsonb) RETURNS SETOF public.organizations
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    DECLARE
      v_profile public.profiles;
      v_org public.organizations;
      v_row public.organizations := (jsonb_populate_record(NULL::public.organizations, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      IF auth.uid() IS NULL THEN
        RAISE EXCEPTION 'not authenticated';
      END IF;

      SELECT * INTO v_profile FROM public.profiles WHERE id = auth.uid();
      IF v_profile IS NULL THEN
        RAISE EXCEPTION 'profile not found' USING DETAIL = jsonb_build_object('id', auth.uid());
      END IF;

      IF v_profile.role IS DISTINCT FROM 'system_admin' AND v_profile.role IS DISTINCT FROM 'org_admin' AND v_profile.role IS DISTINCT FROM 'org_supervisor' THEN
        RAISE EXCEPTION 'Access denied: role % cannot update organizations', v_profile.role;
      END IF;

      IF v_profile.organization_id IS NULL THEN
        RAISE EXCEPTION 'organization not found for user %', auth.uid();
      END IF;

      SELECT * INTO v_org FROM public.organizations WHERE id = v_profile.organization_id;
      IF v_org IS NULL THEN
        RAISE EXCEPTION 'organization not found' USING DETAIL = jsonb_build_object('id', v_profile.organization_id);
      END IF;

      UPDATE public.organizations
         SET name = CASE WHEN _input ? 'name' THEN v_row.name ELSE name END,
             description = CASE WHEN _input ? 'description' THEN v_row.description ELSE description END,
             mission_statement = CASE WHEN _input ? 'mission_statement' THEN v_row.mission_statement ELSE mission_statement END,
             headquarters = CASE WHEN _input ? 'headquarters' THEN v_row.headquarters ELSE headquarters END,
             logo_url = CASE WHEN _input ? 'logo_url' THEN v_row.logo_url ELSE logo_url END,
             updated_at = now()
       WHERE id = v_profile.organization_id
       RETURNING * INTO v_org;

      RETURN NEXT v_org;
    END;
    $$;


--
-- TOC entry 748 (class 1255 OID 27734)
-- Name: update_my_profile(text, text, uuid, uuid, public.user_role_type); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_my_profile(p_full_name text DEFAULT NULL::text, p_phone text DEFAULT NULL::text, p_job_title_id uuid DEFAULT NULL::uuid, p_avatar_id uuid DEFAULT NULL::uuid, p_role public.user_role_type DEFAULT NULL::public.user_role_type) RETURNS SETOF public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    DECLARE
      v_profile public.profiles;
    BEGIN
      IF auth.uid() IS NULL THEN
        RAISE EXCEPTION 'not authenticated';
      END IF;

      SELECT * INTO v_profile FROM public.profiles WHERE id = auth.uid();
      IF v_profile IS NULL THEN
        RAISE EXCEPTION 'profile not found' USING DETAIL = jsonb_build_object('id', auth.uid());
      END IF;

      IF p_role IS NOT NULL AND p_role = 'system_admin' AND v_profile.role <> 'system_admin' THEN
        RAISE EXCEPTION 'system_admin role cannot be assigned via onboarding';
      END IF;

      UPDATE public.profiles
         SET full_name = COALESCE(p_full_name, full_name),
             phone = COALESCE(p_phone, phone),
             job_title_id = COALESCE(p_job_title_id, job_title_id),
             avatar_id = COALESCE(p_avatar_id, avatar_id),
             role = COALESCE(p_role, role),
             updated_at = now()
       WHERE id = v_profile.id
       RETURNING * INTO v_profile;

      RETURN NEXT v_profile;
    END;
    $$;


--
-- TOC entry 813 (class 1255 OID 22168)
-- Name: update_notifications(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_notifications(_id uuid, _input jsonb) RETURNS SETOF public.notifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.notifications;
        _new_row public.notifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.notifications := (jsonb_populate_record(NULL::public.notifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.notifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','notifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.notifications
           SET user_id = COALESCE(_row.user_id, user_id), category = COALESCE(_row.category, category), message = COALESCE(_row.message, message), payload = COALESCE(_row.payload, payload), is_read = COALESCE(_row.is_read, is_read), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 638 (class 1255 OID 43256)
-- Name: update_organization_invites(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_invites(_id uuid, _input jsonb) RETURNS SETOF public.organization_invites
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _old_row public.organization_invites;
  _new_row public.organization_invites;
  _row public.organization_invites := (jsonb_populate_record(NULL::public.organization_invites, COALESCE(_input, '{}'::jsonb)));
BEGIN
  SELECT * INTO _old_row FROM public.organization_invites WHERE id = _id;
  IF _old_row IS NULL THEN RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id); END IF;

  PERFORM check_access('update','organization_invites', NULL, _old_row.organization_id);

  UPDATE public.organization_invites
     SET organization_id = COALESCE(_row.organization_id, organization_id),
         invited_profile_id = COALESCE(_row.invited_profile_id, invited_profile_id),
         invited_by_profile_id = COALESCE(_row.invited_by_profile_id, invited_by_profile_id),
         role = COALESCE(_row.role, role),
         status = COALESCE(_row.status, status),
         comment = COALESCE(_row.comment, comment),
         responded_at = COALESCE(_row.responded_at, now())
   WHERE id = _id
   RETURNING * INTO _new_row;

  -- if approved, create organization membership and notify requester
  IF _new_row.status = 'accepted' THEN
    -- create membership if not exists
    IF NOT EXISTS (
      SELECT 1 FROM public.organization_members WHERE organization_id = _new_row.organization_id AND profile_id = _new_row.invited_profile_id
    ) THEN
      INSERT INTO public.organization_members (organization_id, profile_id, role, created_at, updated_at)
      VALUES (_new_row.organization_id, _new_row.invited_profile_id, COALESCE(_new_row.role, 'org_user'), now(), now());

      -- update profile.organization_id
      UPDATE public.profiles SET organization_id = _new_row.organization_id, updated_at = now() WHERE id = _new_row.invited_profile_id;
    END IF;

    -- notify requester
    BEGIN
      PERFORM public.insert_notifications(
        jsonb_build_object(
          'user_id', _new_row.invited_profile_id,
          'category', 'general',
          'message', ('Your request to join organization ' || _new_row.organization_id || ' was approved'),
          'payload', jsonb_build_object('invite_id', _new_row.id, 'organization_id', _new_row.organization_id, 'status', _new_row.status)
        )
      );
    EXCEPTION WHEN OTHERS THEN NULL; END;

  ELSIF _new_row.status = 'declined' THEN
    -- notify requester of decline
    BEGIN
      PERFORM public.insert_notifications(
        jsonb_build_object(
          'user_id', _new_row.invited_profile_id,
          'category', 'general',
          'message', ('Your request to join organization ' || _new_row.organization_id || ' was declined'),
          'payload', jsonb_build_object('invite_id', _new_row.id, 'organization_id', _new_row.organization_id, 'status', _new_row.status, 'reason', _new_row.comment)
        )
      );
    EXCEPTION WHEN OTHERS THEN NULL; END;
  END IF;

  RETURN NEXT _new_row;
END;
$$;


--
-- TOC entry 1018 (class 1255 OID 27716)
-- Name: update_organization_member_rates(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_member_rates(_id uuid, _input jsonb) RETURNS SETOF public.organization_member_rates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.organization_member_rates;
      _new_row public.organization_member_rates;
      _row     public.organization_member_rates := (jsonb_populate_record(NULL::public.organization_member_rates, COALESCE(_input, '{}'::jsonb)));
      _organization_id uuid;
    BEGIN
      SELECT * INTO _old_row FROM public.organization_member_rates WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      SELECT organization_id INTO _organization_id
        FROM public.organization_members
       WHERE id = _old_row.membership_id;

      PERFORM check_access('update','organization_member_rates', NULL, _organization_id);

      UPDATE public.organization_member_rates
         SET membership_id = COALESCE(_row.membership_id, membership_id),
             rate_type = COALESCE(_row.rate_type, rate_type),
             rate_amount = COALESCE(_row.rate_amount, rate_amount),
             effective_start = COALESCE(_row.effective_start, effective_start),
             effective_end = COALESCE(_row.effective_end, effective_end),
             updated_at = now()
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 879 (class 1255 OID 22169)
-- Name: update_organization_members(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_members(_id uuid, _input jsonb) RETURNS SETOF public.organization_members
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.organization_members;
        _new_row public.organization_members;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.organization_members := (jsonb_populate_record(NULL::public.organization_members, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.organization_members WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','organization_members', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.organization_members
           SET profile_id = COALESCE(_row.profile_id, profile_id), role = COALESCE(_row.role, role), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 941 (class 1255 OID 22170)
-- Name: update_organization_projects(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_projects(_id uuid, _input jsonb) RETURNS SETOF public.organization_projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.organization_projects;
        _new_row public.organization_projects;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.organization_projects := (jsonb_populate_record(NULL::public.organization_projects, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.organization_projects WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','organization_projects', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.organization_projects
           SET updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 634 (class 1255 OID 27720)
-- Name: update_organization_service_areas(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_service_areas(_id uuid, _input jsonb) RETURNS SETOF public.organization_service_areas
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.organization_service_areas;
      _new_row public.organization_service_areas;
      _row     public.organization_service_areas := (jsonb_populate_record(NULL::public.organization_service_areas, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      SELECT * INTO _old_row FROM public.organization_service_areas WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('update','organization_service_areas', NULL, _old_row.organization_id);

      UPDATE public.organization_service_areas
         SET organization_id = COALESCE(_row.organization_id, organization_id),
             service_area_text = COALESCE(_row.service_area_text, service_area_text),
             updated_at = now()
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 946 (class 1255 OID 22171)
-- Name: update_organizations(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organizations(_id uuid, _input jsonb) RETURNS SETOF public.organizations
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    DECLARE
      _old_row public.organizations;
      _new_row public.organizations;
      _row     public.organizations := (jsonb_populate_record(NULL::public.organizations, COALESCE(_input, '{}'::jsonb)));
      _caller_role text;
      _caller_org_id uuid;
    BEGIN
      IF auth.uid() IS NULL THEN
        RAISE EXCEPTION 'not authenticated';
      END IF;

      SELECT role, organization_id INTO _caller_role, _caller_org_id
      FROM public.profiles
      WHERE id = auth.uid();

      IF _caller_role IS NULL THEN
        RAISE EXCEPTION 'Access denied: profile not found for user %', auth.uid();
      END IF;

      SELECT * INTO _old_row FROM public.organizations WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      IF _caller_role <> 'system_admin' THEN
        IF _caller_role <> 'org_admin' THEN
          RAISE EXCEPTION 'Access denied: role % cannot update organizations', _caller_role;
        END IF;
        IF _caller_org_id IS NULL OR _caller_org_id <> _old_row.id THEN
          RAISE EXCEPTION 'Access denied: you do not belong to organization %', _old_row.id;
        END IF;
      END IF;

        UPDATE public.organizations
         SET name = CASE WHEN _input ? 'name' THEN _row.name ELSE name END,
           description = CASE WHEN _input ? 'description' THEN _row.description ELSE description END,
           mission_statement = CASE WHEN _input ? 'mission_statement' THEN _row.mission_statement ELSE mission_statement END,
           headquarters = CASE WHEN _input ? 'headquarters' THEN _row.headquarters ELSE headquarters END,
           logo_url = CASE WHEN _input ? 'logo_url' THEN _row.logo_url ELSE logo_url END,
           updated_at = now()
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 964 (class 1255 OID 22172)
-- Name: update_payments(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_payments(_id uuid, _input jsonb) RETURNS SETOF public.payments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.payments;
        _new_row public.payments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.payments := (jsonb_populate_record(NULL::public.payments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.payments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','payments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.payments
           SET commitment_id = COALESCE(_row.commitment_id, commitment_id), amount = COALESCE(_row.amount, amount), paid_at = COALESCE(_row.paid_at, paid_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 843 (class 1255 OID 22173)
-- Name: update_payroll(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_payroll(_id uuid, _input jsonb) RETURNS SETOF public.payroll
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.payroll;
        _new_row public.payroll;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.payroll := (jsonb_populate_record(NULL::public.payroll, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.payroll WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','payroll', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.payroll
           SET employee_id = COALESCE(_row.employee_id, employee_id), pay_period_start = COALESCE(_row.pay_period_start, pay_period_start), pay_period_end = COALESCE(_row.pay_period_end, pay_period_end), gross_pay = COALESCE(_row.gross_pay, gross_pay), net_pay = COALESCE(_row.net_pay, net_pay), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 950 (class 1255 OID 22174)
-- Name: update_photos(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_photos(_id uuid, _input jsonb) RETURNS SETOF public.photos
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.photos;
        _new_row public.photos;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.photos := (jsonb_populate_record(NULL::public.photos, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.photos WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','photos', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.photos
           SET url = COALESCE(_row.url, url), caption = COALESCE(_row.caption, caption), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 546 (class 1255 OID 22175)
-- Name: update_prequalifications(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_prequalifications(_id uuid, _input jsonb) RETURNS SETOF public.prequalifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.prequalifications;
        _new_row public.prequalifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.prequalifications := (jsonb_populate_record(NULL::public.prequalifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.prequalifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','prequalifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.prequalifications
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), status = COALESCE(_row.status, status), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 754 (class 1255 OID 22176)
-- Name: update_procurement_workflows(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_procurement_workflows(_id uuid, _input jsonb) RETURNS SETOF public.procurement_workflows
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.procurement_workflows;
        _new_row public.procurement_workflows;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.procurement_workflows := (jsonb_populate_record(NULL::public.procurement_workflows, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.procurement_workflows WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','procurement_workflows', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.procurement_workflows
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 618 (class 1255 OID 27702)
-- Name: update_profile_contract_role(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_profile_contract_role(p_contract_id uuid, p_profile_id uuid, p_role text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  perform check_access('update','user_projects', p_contract_id, null);

  if p_role is null or trim(p_role) = '' then
    raise exception 'Role is required';
  end if;

  if lower(p_role) not in ('project_manager', 'admin', 'member', 'viewer') then
    raise exception 'Invalid contract role: %', p_role;
  end if;

  update public.user_projects
  set role = p_role,
      updated_at = now()
  where project_id = p_contract_id
    and user_id = p_profile_id
    and deleted_at is null;
end;
$$;


--
-- TOC entry 859 (class 1255 OID 22177)
-- Name: update_profiles(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_profiles(_id uuid, _input jsonb) RETURNS SETOF public.profiles
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _old_row public.profiles;
  _new_row public.profiles;
  _row     public.profiles := (jsonb_populate_record(NULL::public.profiles, COALESCE(_input, '{}'::jsonb)));
BEGIN
  SELECT * INTO _old_row
  FROM public.profiles
  WHERE id = _id;

  IF _old_row IS NULL THEN
    RAISE EXCEPTION 'row not found'
      USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  -- FIX: profiles has no project_id; scope access by organization only.
  PERFORM check_access('update', 'profiles', NULL, _old_row.organization_id);

  UPDATE public.profiles
  SET
    email = COALESCE(_row.email, email),
    full_name = COALESCE(_row.full_name, full_name),
    phone = COALESCE(_row.phone, phone),
    job_title_id = COALESCE(_row.job_title_id, job_title_id),
    avatar_url = COALESCE(_row.avatar_url, avatar_url),
    role = COALESCE(_row.role, role),
    updated_at = now()
  WHERE id = _id
  RETURNING * INTO _new_row;

  RETURN NEXT _new_row;
END;
$$;


--
-- TOC entry 938 (class 1255 OID 22178)
-- Name: update_progress_billings(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_progress_billings(_id uuid, _input jsonb) RETURNS SETOF public.progress_billings
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.progress_billings;
        _new_row public.progress_billings;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.progress_billings := (jsonb_populate_record(NULL::public.progress_billings, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.progress_billings WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','progress_billings', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.progress_billings
           SET billing_number = COALESCE(_row.billing_number, billing_number), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 834 (class 1255 OID 22179)
-- Name: update_project_inspectors(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_project_inspectors(_id uuid, _input jsonb) RETURNS SETOF public.project_inspectors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.project_inspectors;
        _new_row public.project_inspectors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.project_inspectors := (jsonb_populate_record(NULL::public.project_inspectors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.project_inspectors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','project_inspectors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.project_inspectors
           SET profile_id = COALESCE(_row.profile_id, profile_id), assigned_by = COALESCE(_row.assigned_by, assigned_by), assigned_at = COALESCE(_row.assigned_at, assigned_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 630 (class 1255 OID 27724)
-- Name: update_project_invites(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_project_invites(_id uuid, _input jsonb) RETURNS SETOF public.project_invites
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.project_invites;
      _new_row public.project_invites;
      _row     public.project_invites := (jsonb_populate_record(NULL::public.project_invites, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      SELECT * INTO _old_row FROM public.project_invites WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('update','project_invites', _old_row.project_id, NULL);

      UPDATE public.project_invites
         SET project_id = COALESCE(_row.project_id, project_id),
             invited_profile_id = COALESCE(_row.invited_profile_id, invited_profile_id),
             invited_by_profile_id = COALESCE(_row.invited_by_profile_id, invited_by_profile_id),
             status = COALESCE(_row.status, status),
             comment = COALESCE(_row.comment, comment),
             responded_at = COALESCE(_row.responded_at, responded_at)
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 793 (class 1255 OID 27728)
-- Name: update_project_service_areas(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_project_service_areas(_id uuid, _input jsonb) RETURNS SETOF public.project_service_areas
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.project_service_areas;
      _new_row public.project_service_areas;
      _row     public.project_service_areas := (jsonb_populate_record(NULL::public.project_service_areas, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      SELECT * INTO _old_row FROM public.project_service_areas WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('update','project_service_areas', _old_row.project_id, NULL);

      UPDATE public.project_service_areas
         SET project_id = COALESCE(_row.project_id, project_id),
             service_area_id = COALESCE(_row.service_area_id, service_area_id),
             updated_at = now()
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- TOC entry 778 (class 1255 OID 22180)
-- Name: update_projects(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_projects(_id uuid, _input jsonb) RETURNS SETOF public.projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.projects;
        _new_row public.projects;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.projects := (jsonb_populate_record(NULL::public.projects, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.projects WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','projects', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.projects
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), status = COALESCE(_row.status, status), start_date = COALESCE(_row.start_date, start_date), end_date = COALESCE(_row.end_date, end_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 609 (class 1255 OID 22181)
-- Name: update_punch_lists(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_punch_lists(_id uuid, _input jsonb) RETURNS SETOF public.punch_lists
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.punch_lists;
        _new_row public.punch_lists;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.punch_lists := (jsonb_populate_record(NULL::public.punch_lists, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.punch_lists WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','punch_lists', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.punch_lists
           SET item = COALESCE(_row.item, item), status = COALESCE(_row.status, status), assigned_to = COALESCE(_row.assigned_to, assigned_to), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 594 (class 1255 OID 22182)
-- Name: update_purchase_orders(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_purchase_orders(_id uuid, _input jsonb) RETURNS SETOF public.purchase_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.purchase_orders;
        _new_row public.purchase_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.purchase_orders := (jsonb_populate_record(NULL::public.purchase_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.purchase_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','purchase_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.purchase_orders
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), order_number = COALESCE(_row.order_number, order_number), order_date = COALESCE(_row.order_date, order_date), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 632 (class 1255 OID 22183)
-- Name: update_quality_reviews(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_quality_reviews(_id uuid, _input jsonb) RETURNS SETOF public.quality_reviews
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.quality_reviews;
        _new_row public.quality_reviews;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.quality_reviews := (jsonb_populate_record(NULL::public.quality_reviews, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.quality_reviews WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','quality_reviews', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.quality_reviews
           SET review_date = COALESCE(_row.review_date, review_date), reviewer = COALESCE(_row.reviewer, reviewer), findings = COALESCE(_row.findings, findings), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 676 (class 1255 OID 22184)
-- Name: update_regulatory_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_regulatory_documents(_id uuid, _input jsonb) RETURNS SETOF public.regulatory_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.regulatory_documents;
        _new_row public.regulatory_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.regulatory_documents := (jsonb_populate_record(NULL::public.regulatory_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.regulatory_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','regulatory_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.regulatory_documents
           SET document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 870 (class 1255 OID 22185)
-- Name: update_reports(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_reports(_id uuid, _input jsonb) RETURNS SETOF public.reports
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.reports;
        _new_row public.reports;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.reports := (jsonb_populate_record(NULL::public.reports, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.reports WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','reports', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.reports
           SET report_type = COALESCE(_row.report_type, report_type), generated_at = COALESCE(_row.generated_at, generated_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 882 (class 1255 OID 22186)
-- Name: update_rfis(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_rfis(_id uuid, _input jsonb) RETURNS SETOF public.rfis
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.rfis;
        _new_row public.rfis;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.rfis := (jsonb_populate_record(NULL::public.rfis, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.rfis WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','rfis', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.rfis
           SET subject = COALESCE(_row.subject, subject), status = COALESCE(_row.status, status), question = COALESCE(_row.question, question), answer = COALESCE(_row.answer, answer), submitted_by = COALESCE(_row.submitted_by, submitted_by), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), submitted_at = COALESCE(_row.submitted_at, submitted_at), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 689 (class 1255 OID 22187)
-- Name: update_safety_incidents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_safety_incidents(_id uuid, _input jsonb) RETURNS SETOF public.safety_incidents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.safety_incidents;
        _new_row public.safety_incidents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.safety_incidents := (jsonb_populate_record(NULL::public.safety_incidents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.safety_incidents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','safety_incidents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.safety_incidents
           SET incident_date = COALESCE(_row.incident_date, incident_date), description = COALESCE(_row.description, description), reported_by = COALESCE(_row.reported_by, reported_by), severity = COALESCE(_row.severity, severity), resolved = COALESCE(_row.resolved, resolved), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 981 (class 1255 OID 22188)
-- Name: update_sensor_data(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_sensor_data(_id uuid, _input jsonb) RETURNS SETOF public.sensor_data
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.sensor_data;
        _new_row public.sensor_data;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.sensor_data := (jsonb_populate_record(NULL::public.sensor_data, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.sensor_data WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','sensor_data', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.sensor_data
           SET data = COALESCE(_row.data, data), collected_at = COALESCE(_row.collected_at, collected_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 932 (class 1255 OID 22189)
-- Name: update_subcontractor_agreements(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_subcontractor_agreements(_id uuid, _input jsonb) RETURNS SETOF public.subcontractor_agreements
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.subcontractor_agreements;
        _new_row public.subcontractor_agreements;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.subcontractor_agreements := (jsonb_populate_record(NULL::public.subcontractor_agreements, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.subcontractor_agreements WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','subcontractor_agreements', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.subcontractor_agreements
           SET subcontract_id = COALESCE(_row.subcontract_id, subcontract_id), agreement_url = COALESCE(_row.agreement_url, agreement_url), signed_at = COALESCE(_row.signed_at, signed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 906 (class 1255 OID 22190)
-- Name: update_subcontracts(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_subcontracts(_id uuid, _input jsonb) RETURNS SETOF public.subcontracts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.subcontracts;
        _new_row public.subcontracts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.subcontracts := (jsonb_populate_record(NULL::public.subcontracts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.subcontracts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','subcontracts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.subcontracts
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), signed_at = COALESCE(_row.signed_at, signed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 544 (class 1255 OID 22191)
-- Name: update_submittals(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_submittals(_id uuid, _input jsonb) RETURNS SETOF public.submittals
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.submittals;
        _new_row public.submittals;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.submittals := (jsonb_populate_record(NULL::public.submittals, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.submittals WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','submittals', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.submittals
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), submitted_by = COALESCE(_row.submitted_by, submitted_by), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), submitted_at = COALESCE(_row.submitted_at, submitted_at), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 655 (class 1255 OID 22192)
-- Name: update_tack_rates(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_tack_rates(_id uuid, _input jsonb) RETURNS SETOF public.tack_rates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.tack_rates;
        _new_row public.tack_rates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.tack_rates := (jsonb_populate_record(NULL::public.tack_rates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.tack_rates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','tack_rates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.tack_rates
           SET rate = COALESCE(_row.rate, rate), material_type = COALESCE(_row.material_type, material_type), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 578 (class 1255 OID 22193)
-- Name: update_task_dependencies(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_task_dependencies(_id uuid, _input jsonb) RETURNS SETOF public.task_dependencies
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.task_dependencies;
        _new_row public.task_dependencies;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.task_dependencies := (jsonb_populate_record(NULL::public.task_dependencies, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.task_dependencies WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','task_dependencies', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.task_dependencies
           SET task_id = COALESCE(_row.task_id, task_id), depends_on_task_id = COALESCE(_row.depends_on_task_id, depends_on_task_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1072 (class 1255 OID 22194)
-- Name: update_task_status_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_task_status_logs(_id uuid, _input jsonb) RETURNS SETOF public.task_status_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.task_status_logs;
        _new_row public.task_status_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.task_status_logs := (jsonb_populate_record(NULL::public.task_status_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.task_status_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','task_status_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.task_status_logs
           SET task_id = COALESCE(_row.task_id, task_id), status = COALESCE(_row.status, status), changed_at = COALESCE(_row.changed_at, changed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 971 (class 1255 OID 22195)
-- Name: update_tasks(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_tasks(_id uuid, _input jsonb) RETURNS SETOF public.tasks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.tasks;
        _new_row public.tasks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.tasks := (jsonb_populate_record(NULL::public.tasks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.tasks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','tasks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.tasks
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), start_date = COALESCE(_row.start_date, start_date), end_date = COALESCE(_row.end_date, end_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 690 (class 1255 OID 22196)
-- Name: update_training_records(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_training_records(_id uuid, _input jsonb) RETURNS SETOF public.training_records
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.training_records;
        _new_row public.training_records;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.training_records := (jsonb_populate_record(NULL::public.training_records, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.training_records WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','training_records', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.training_records
           SET employee_id = COALESCE(_row.employee_id, employee_id), training_type = COALESCE(_row.training_type, training_type), completion_date = COALESCE(_row.completion_date, completion_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 719 (class 1255 OID 22197)
-- Name: update_user_projects(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_projects(_id uuid, _input jsonb) RETURNS SETOF public.user_projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.user_projects;
        _new_row public.user_projects;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.user_projects := (jsonb_populate_record(NULL::public.user_projects, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.user_projects WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','user_projects', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.user_projects
           SET user_id = COALESCE(_row.user_id, user_id), role = COALESCE(_row.role, role), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1057 (class 1255 OID 22198)
-- Name: update_vendor_bid_packages(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendor_bid_packages(_id uuid, _input jsonb) RETURNS SETOF public.vendor_bid_packages
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendor_bid_packages;
        _new_row public.vendor_bid_packages;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_bid_packages := (jsonb_populate_record(NULL::public.vendor_bid_packages, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_bid_packages WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_bid_packages', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_bid_packages
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 571 (class 1255 OID 22199)
-- Name: update_vendor_contacts(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendor_contacts(_id uuid, _input jsonb) RETURNS SETOF public.vendor_contacts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendor_contacts;
        _new_row public.vendor_contacts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_contacts := (jsonb_populate_record(NULL::public.vendor_contacts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_contacts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_contacts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_contacts
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), name = COALESCE(_row.name, name), email = COALESCE(_row.email, email), phone = COALESCE(_row.phone, phone), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 658 (class 1255 OID 22200)
-- Name: update_vendor_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendor_documents(_id uuid, _input jsonb) RETURNS SETOF public.vendor_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendor_documents;
        _new_row public.vendor_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_documents := (jsonb_populate_record(NULL::public.vendor_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_documents
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1037 (class 1255 OID 22201)
-- Name: update_vendor_qualifications(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendor_qualifications(_id uuid, _input jsonb) RETURNS SETOF public.vendor_qualifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendor_qualifications;
        _new_row public.vendor_qualifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_qualifications := (jsonb_populate_record(NULL::public.vendor_qualifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_qualifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_qualifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_qualifications
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), qualification_type = COALESCE(_row.qualification_type, qualification_type), status = COALESCE(_row.status, status), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1026 (class 1255 OID 22202)
-- Name: update_vendors(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendors(_id uuid, _input jsonb) RETURNS SETOF public.vendors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendors;
        _new_row public.vendors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendors := (jsonb_populate_record(NULL::public.vendors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendors
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), contact_email = COALESCE(_row.contact_email, contact_email), contact_phone = COALESCE(_row.contact_phone, contact_phone), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 565 (class 1255 OID 22203)
-- Name: update_wbs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_wbs(_id uuid, _input jsonb) RETURNS SETOF public.wbs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.wbs;
        _new_row public.wbs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.wbs := (jsonb_populate_record(NULL::public.wbs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.wbs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','wbs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.wbs
           SET name = COALESCE(_row.name, name), location = COALESCE(_row.location, location), order_num = COALESCE(_row.order_num, order_num), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 1010 (class 1255 OID 22204)
-- Name: update_workflows(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_workflows(_id uuid, _input jsonb) RETURNS SETOF public.workflows
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.workflows;
        _new_row public.workflows;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.workflows := (jsonb_populate_record(NULL::public.workflows, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.workflows WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','workflows', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.workflows
           SET entity_schema = COALESCE(_row.entity_schema, entity_schema), entity_table = COALESCE(_row.entity_table, entity_table), entity_id = COALESCE(_row.entity_id, entity_id), workflow_name = COALESCE(_row.workflow_name, workflow_name), current_state = COALESCE(_row.current_state, current_state), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- TOC entry 605 (class 1255 OID 27741)
-- Name: upsert_my_avatar(text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.upsert_my_avatar(p_url text, p_is_preset boolean DEFAULT false) RETURNS SETOF public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    DECLARE
      v_profile public.profiles;
      v_avatar public.avatars;
    BEGIN
      IF auth.uid() IS NULL THEN
        RAISE EXCEPTION 'not authenticated';
      END IF;

      SELECT * INTO v_profile FROM public.profiles WHERE id = auth.uid();
      IF v_profile IS NULL THEN
        RAISE EXCEPTION 'profile not found' USING DETAIL = jsonb_build_object('id', auth.uid());
      END IF;

      IF v_profile.avatar_id IS NOT NULL THEN
        SELECT * INTO v_avatar FROM public.avatars WHERE id = v_profile.avatar_id;
      END IF;

      IF v_avatar.id IS NOT NULL AND v_avatar.is_preset = false THEN
        UPDATE public.avatars
           SET url = p_url,
           is_preset = false,
               updated_at = now()
         WHERE id = v_avatar.id
         RETURNING * INTO v_avatar;
      ELSE
        INSERT INTO public.avatars (url, is_preset, created_at, updated_at)
        VALUES (p_url, COALESCE(p_is_preset, false), now(), now())
        RETURNING * INTO v_avatar;

        UPDATE public.profiles
           SET avatar_id = v_avatar.id,
               updated_at = now()
         WHERE id = v_profile.id;
      END IF;

      RETURN NEXT v_avatar;
    END;
    $$;


--
-- TOC entry 432 (class 1259 OID 22205)
-- Name: accounts_payable_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.accounts_payable_active AS
 SELECT id,
    project_id,
    amount_due,
    due_date,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.accounts_payable
  WHERE (deleted_at IS NULL);


--
-- TOC entry 433 (class 1259 OID 22209)
-- Name: accounts_receivable_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.accounts_receivable_active AS
 SELECT id,
    project_id,
    amount_due,
    due_date,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.accounts_receivable
  WHERE (deleted_at IS NULL);


--
-- TOC entry 434 (class 1259 OID 22213)
-- Name: activity_logs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.activity_logs_active AS
 SELECT id,
    profile_id,
    activity_type,
    activity_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.activity_logs
  WHERE (deleted_at IS NULL);


--
-- TOC entry 435 (class 1259 OID 22217)
-- Name: asphalt_types_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.asphalt_types_active AS
 SELECT id,
    name,
    description,
    created_at,
    updated_at,
    deleted_at
   FROM public.asphalt_types
  WHERE (deleted_at IS NULL);


--
-- TOC entry 437 (class 1259 OID 22229)
-- Name: audit_log_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.audit_log_active AS
 SELECT id,
    table_name,
    action,
    row_id,
    before_data,
    after_data,
    changed_by,
    changed_at,
    deleted_at
   FROM public.audit_log
  WHERE (deleted_at IS NULL);


--
-- TOC entry 438 (class 1259 OID 22233)
-- Name: audit_logs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.audit_logs_active AS
 SELECT id,
    project_id,
    action,
    performed_by,
    performed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.audit_logs
  WHERE (deleted_at IS NULL);


--
-- TOC entry 439 (class 1259 OID 22237)
-- Name: avatars_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.avatars_active AS
 SELECT id,
    url,
    created_at,
    updated_at,
    deleted_at
   FROM public.avatars
  WHERE (deleted_at IS NULL);


--
-- TOC entry 440 (class 1259 OID 22241)
-- Name: bid_packages_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.bid_packages_active AS
 SELECT id,
    project_id,
    name,
    status,
    created_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.bid_packages
  WHERE (deleted_at IS NULL);


--
-- TOC entry 441 (class 1259 OID 22245)
-- Name: bid_vendors_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.bid_vendors_active AS
 SELECT id,
    bid_package_id,
    vendor_id,
    invited_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.bid_vendors
  WHERE (deleted_at IS NULL);


--
-- TOC entry 442 (class 1259 OID 22249)
-- Name: bids_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.bids_active AS
 SELECT id,
    bid_package_id,
    vendor_id,
    amount,
    submitted_at,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.bids
  WHERE (deleted_at IS NULL);


--
-- TOC entry 443 (class 1259 OID 22253)
-- Name: bim_models_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.bim_models_active AS
 SELECT id,
    project_id,
    name,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.bim_models
  WHERE (deleted_at IS NULL);


--
-- TOC entry 444 (class 1259 OID 22257)
-- Name: certifications_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.certifications_active AS
 SELECT id,
    employee_id,
    certification_type,
    issue_date,
    expiry_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.certifications
  WHERE (deleted_at IS NULL);


--
-- TOC entry 445 (class 1259 OID 22261)
-- Name: change_orders_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.change_orders_active AS
 SELECT id,
    project_id,
    number,
    description,
    status,
    amount,
    created_at,
    updated_at,
    deleted_at
   FROM public.change_orders
  WHERE (deleted_at IS NULL);


--
-- TOC entry 446 (class 1259 OID 22265)
-- Name: commitments_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.commitments_active AS
 SELECT id,
    project_id,
    vendor_id,
    type,
    amount,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.commitments
  WHERE (deleted_at IS NULL);


--
-- TOC entry 447 (class 1259 OID 22269)
-- Name: compliance_checks_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.compliance_checks_active AS
 SELECT id,
    project_id,
    check_date,
    description,
    result,
    created_at,
    updated_at,
    deleted_at
   FROM public.compliance_checks
  WHERE (deleted_at IS NULL);


--
-- TOC entry 448 (class 1259 OID 22273)
-- Name: compliance_tracking_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.compliance_tracking_active AS
 SELECT id,
    project_id,
    tracking_type,
    status,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.compliance_tracking
  WHERE (deleted_at IS NULL);


--
-- TOC entry 449 (class 1259 OID 22277)
-- Name: cost_codes_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.cost_codes_active AS
 SELECT id,
    code,
    description,
    created_at,
    updated_at,
    deleted_at
   FROM public.cost_codes
  WHERE (deleted_at IS NULL);


--
-- TOC entry 450 (class 1259 OID 22281)
-- Name: crew_assignments_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.crew_assignments_active AS
 SELECT id,
    crew_id,
    profile_id,
    assigned_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.crew_assignments
  WHERE (deleted_at IS NULL);


--
-- TOC entry 451 (class 1259 OID 22285)
-- Name: crew_members_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.crew_members_active AS
 SELECT id,
    crew_id,
    profile_id,
    role,
    start_date,
    end_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.crew_members
  WHERE (deleted_at IS NULL);


--
-- TOC entry 452 (class 1259 OID 22289)
-- Name: crews_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.crews_active AS
 SELECT id,
    project_id,
    name,
    created_at,
    updated_at,
    deleted_at
   FROM public.crews
  WHERE (deleted_at IS NULL);


--
-- TOC entry 453 (class 1259 OID 22293)
-- Name: daily_logs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.daily_logs_active AS
 SELECT id,
    project_id,
    date,
    weather,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.daily_logs
  WHERE (deleted_at IS NULL);


--
-- TOC entry 454 (class 1259 OID 22297)
-- Name: dashboard_configs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.dashboard_configs_active AS
 SELECT id,
    profile_id,
    config,
    created_at,
    updated_at,
    deleted_at
   FROM public.dashboard_configs
  WHERE (deleted_at IS NULL);


--
-- TOC entry 455 (class 1259 OID 22301)
-- Name: document_references_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.document_references_active AS
 SELECT id,
    document_id,
    reference_type,
    reference_id,
    created_at,
    updated_at,
    deleted_at
   FROM public.document_references
  WHERE (deleted_at IS NULL);


--
-- TOC entry 456 (class 1259 OID 22305)
-- Name: documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.documents_active AS
 SELECT id,
    project_id,
    name,
    type,
    url,
    uploaded_by,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.documents
  WHERE (deleted_at IS NULL);


--
-- TOC entry 457 (class 1259 OID 22309)
-- Name: drawing_versions_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.drawing_versions_active AS
 SELECT id,
    document_id,
    version,
    uploaded_by,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.drawing_versions
  WHERE (deleted_at IS NULL);


--
-- TOC entry 458 (class 1259 OID 22313)
-- Name: dump_trucks_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.dump_trucks_active AS
 SELECT id,
    organization_id,
    make,
    model,
    capacity,
    created_at,
    updated_at,
    deleted_at
   FROM public.dump_trucks
  WHERE (deleted_at IS NULL);


--
-- TOC entry 459 (class 1259 OID 22317)
-- Name: employees_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.employees_active AS
 SELECT id,
    organization_id,
    profile_id,
    hire_date,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.employees
  WHERE (deleted_at IS NULL);


--
-- TOC entry 460 (class 1259 OID 22321)
-- Name: equipment_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.equipment_active AS
 SELECT id,
    organization_id,
    name,
    type,
    model,
    serial_number,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.equipment
  WHERE (deleted_at IS NULL);


--
-- TOC entry 461 (class 1259 OID 22325)
-- Name: equipment_assignments_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.equipment_assignments_active AS
 SELECT id,
    equipment_id,
    project_id,
    assigned_to,
    assigned_date,
    released_date,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.equipment_assignments
  WHERE (deleted_at IS NULL);


--
-- TOC entry 462 (class 1259 OID 22329)
-- Name: equipment_maintenance_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.equipment_maintenance_active AS
 SELECT id,
    equipment_id,
    maintenance_date,
    type,
    description,
    performed_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.equipment_maintenance
  WHERE (deleted_at IS NULL);


--
-- TOC entry 463 (class 1259 OID 22333)
-- Name: equipment_usage_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.equipment_usage_active AS
 SELECT id,
    equipment_id,
    date,
    hours_used,
    quantity,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.equipment_usage
  WHERE (deleted_at IS NULL);


--
-- TOC entry 464 (class 1259 OID 22337)
-- Name: estimate_line_items_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.estimate_line_items_active AS
 SELECT id,
    estimate_id,
    cost_code_id,
    name,
    unit_measure,
    quantity,
    unit_price,
    total_cost,
    created_at,
    updated_at,
    deleted_at
   FROM public.estimate_line_items
  WHERE (deleted_at IS NULL);


--
-- TOC entry 465 (class 1259 OID 22341)
-- Name: estimates_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.estimates_active AS
 SELECT id,
    project_id,
    name,
    status,
    created_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.estimates
  WHERE (deleted_at IS NULL);


--
-- TOC entry 466 (class 1259 OID 22345)
-- Name: financial_documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.financial_documents_active AS
 SELECT id,
    project_id,
    document_type,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.financial_documents
  WHERE (deleted_at IS NULL);


--
-- TOC entry 467 (class 1259 OID 22349)
-- Name: general_ledger_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.general_ledger_active AS
 SELECT id,
    project_id,
    entry_date,
    description,
    debit,
    credit,
    balance,
    created_at,
    updated_at,
    deleted_at
   FROM public.general_ledger
  WHERE (deleted_at IS NULL);


--
-- TOC entry 468 (class 1259 OID 22353)
-- Name: hr_documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.hr_documents_active AS
 SELECT id,
    employee_id,
    document_type,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.hr_documents
  WHERE (deleted_at IS NULL);


--
-- TOC entry 469 (class 1259 OID 22357)
-- Name: inspections_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.inspections_active AS
 SELECT id,
    project_id,
    name,
    inspection_type,
    date,
    status,
    result,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.inspections
  WHERE (deleted_at IS NULL);


--
-- TOC entry 470 (class 1259 OID 22361)
-- Name: integration_tokens_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.integration_tokens_active AS
 SELECT id,
    profile_id,
    service_name,
    token,
    created_at,
    updated_at,
    deleted_at
   FROM public.integration_tokens
  WHERE (deleted_at IS NULL);


--
-- TOC entry 471 (class 1259 OID 22365)
-- Name: inventory_transactions_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.inventory_transactions_active AS
 SELECT id,
    material_id,
    transaction_type,
    quantity,
    transaction_date,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.inventory_transactions
  WHERE (deleted_at IS NULL);


--
-- TOC entry 472 (class 1259 OID 22369)
-- Name: issues_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.issues_active AS
 SELECT id,
    project_id,
    name,
    type,
    status,
    reported_by,
    description,
    resolved,
    created_at,
    updated_at,
    deleted_at
   FROM public.issues
  WHERE (deleted_at IS NULL);


--
-- TOC entry 473 (class 1259 OID 22373)
-- Name: job_titles_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.job_titles_active AS
 SELECT id,
    name,
    created_at,
    updated_at,
    deleted_at
   FROM public.job_titles
  WHERE (deleted_at IS NULL);


--
-- TOC entry 474 (class 1259 OID 22377)
-- Name: labor_records_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.labor_records_active AS
 SELECT id,
    line_item_id,
    worker_count,
    hours_worked,
    work_date,
    work_type,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.labor_records
  WHERE (deleted_at IS NULL);


--
-- TOC entry 475 (class 1259 OID 22381)
-- Name: line_item_entries_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.line_item_entries_active AS
 SELECT id,
    line_item_id,
    date,
    quantity_completed,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.line_item_entries
  WHERE (deleted_at IS NULL);


--
-- TOC entry 476 (class 1259 OID 22385)
-- Name: line_item_templates_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.line_item_templates_active AS
 SELECT id,
    name,
    formula,
    variables,
    created_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.line_item_templates
  WHERE (deleted_at IS NULL);


--
-- TOC entry 477 (class 1259 OID 22389)
-- Name: line_items_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.line_items_active AS
 SELECT id,
    map_id,
    wbs_id,
    project_id,
    cost_code_id,
    template_id,
    name,
    description,
    unit_measure,
    quantity,
    unit_price,
    created_at,
    updated_at,
    deleted_at
   FROM public.line_items
  WHERE (deleted_at IS NULL);


--
-- TOC entry 478 (class 1259 OID 22393)
-- Name: maps_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.maps_active AS
 SELECT id,
    wbs_id,
    project_id,
    name,
    description,
    coordinates,
    scope,
    order_num,
    created_at,
    updated_at,
    deleted_at
   FROM public.maps
  WHERE (deleted_at IS NULL);


--
-- TOC entry 479 (class 1259 OID 22397)
-- Name: material_inventory_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.material_inventory_active AS
 SELECT id,
    material_id,
    organization_id,
    quantity,
    last_updated,
    created_at,
    updated_at,
    deleted_at
   FROM public.material_inventory
  WHERE (deleted_at IS NULL);


--
-- TOC entry 480 (class 1259 OID 22401)
-- Name: material_orders_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.material_orders_active AS
 SELECT id,
    material_id,
    project_id,
    order_date,
    quantity,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.material_orders
  WHERE (deleted_at IS NULL);


--
-- TOC entry 481 (class 1259 OID 22405)
-- Name: material_receipts_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.material_receipts_active AS
 SELECT id,
    material_order_id,
    received_date,
    quantity,
    received_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.material_receipts
  WHERE (deleted_at IS NULL);


--
-- TOC entry 482 (class 1259 OID 22409)
-- Name: materials_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.materials_active AS
 SELECT id,
    organization_id,
    name,
    description,
    unit,
    created_at,
    updated_at,
    deleted_at
   FROM public.materials
  WHERE (deleted_at IS NULL);


--
-- TOC entry 483 (class 1259 OID 22413)
-- Name: meeting_minutes_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.meeting_minutes_active AS
 SELECT id,
    project_id,
    meeting_date,
    notes,
    created_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.meeting_minutes
  WHERE (deleted_at IS NULL);


--
-- TOC entry 484 (class 1259 OID 22417)
-- Name: notifications_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.notifications_active AS
 SELECT id,
    user_id,
    category,
    message,
    payload,
    is_read,
    created_at,
    updated_at,
    deleted_at
   FROM public.notifications
  WHERE (deleted_at IS NULL);


--
-- TOC entry 485 (class 1259 OID 22421)
-- Name: organization_members_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.organization_members_active AS
 SELECT id,
    profile_id,
    organization_id,
    role,
    created_at,
    updated_at,
    deleted_at
   FROM public.organization_members
  WHERE (deleted_at IS NULL);


--
-- TOC entry 486 (class 1259 OID 22425)
-- Name: organization_projects_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.organization_projects_active AS
 SELECT id,
    organization_id,
    project_id,
    created_at,
    updated_at,
    deleted_at
   FROM public.organization_projects
  WHERE (deleted_at IS NULL);


--
-- TOC entry 487 (class 1259 OID 22429)
-- Name: organizations_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.organizations_active AS
 SELECT id,
    name,
    description,
    created_at,
    updated_at,
    deleted_at
   FROM public.organizations
  WHERE (deleted_at IS NULL);


--
-- TOC entry 488 (class 1259 OID 22433)
-- Name: payments_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.payments_active AS
 SELECT id,
    project_id,
    commitment_id,
    amount,
    paid_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.payments
  WHERE (deleted_at IS NULL);


--
-- TOC entry 489 (class 1259 OID 22437)
-- Name: payroll_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.payroll_active AS
 SELECT id,
    employee_id,
    pay_period_start,
    pay_period_end,
    gross_pay,
    net_pay,
    created_at,
    updated_at,
    deleted_at
   FROM public.payroll
  WHERE (deleted_at IS NULL);


--
-- TOC entry 490 (class 1259 OID 22441)
-- Name: photos_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.photos_active AS
 SELECT id,
    project_id,
    url,
    caption,
    uploaded_by,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.photos
  WHERE (deleted_at IS NULL);


--
-- TOC entry 491 (class 1259 OID 22445)
-- Name: prequalifications_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.prequalifications_active AS
 SELECT id,
    vendor_id,
    status,
    reviewed_by,
    reviewed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.prequalifications
  WHERE (deleted_at IS NULL);


--
-- TOC entry 492 (class 1259 OID 22449)
-- Name: procurement_workflows_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.procurement_workflows_active AS
 SELECT id,
    project_id,
    name,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.procurement_workflows
  WHERE (deleted_at IS NULL);


--
-- TOC entry 521 (class 1259 OID 26437)
-- Name: profiles_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.profiles_active AS
 SELECT id,
    email,
    full_name,
    phone,
    job_title_id,
    organization_id,
    created_at,
    updated_at,
    role,
    deleted_at,
    profile_completed_at,
    avatar_id
   FROM public.profiles
  WHERE (deleted_at IS NULL);


--
-- TOC entry 493 (class 1259 OID 22457)
-- Name: progress_billings_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.progress_billings_active AS
 SELECT id,
    project_id,
    billing_number,
    amount,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.progress_billings
  WHERE (deleted_at IS NULL);


--
-- TOC entry 494 (class 1259 OID 22461)
-- Name: project_cost_summary; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.project_cost_summary AS
 SELECT p.id AS project_id,
    p.name AS project_name,
    COALESCE(sum((li.quantity * li.unit_price)), (0)::numeric) AS total_estimated_cost,
    COALESCE(sum(po.amount), (0)::numeric) AS total_commitment_amount,
    COALESCE(sum(pb.amount), (0)::numeric) AS total_billed_amount
   FROM (((public.projects p
     LEFT JOIN public.line_items li ON ((li.project_id = p.id)))
     LEFT JOIN public.purchase_orders po ON ((po.project_id = p.id)))
     LEFT JOIN public.progress_billings pb ON ((pb.project_id = p.id)))
  GROUP BY p.id, p.name
  WITH NO DATA;


--
-- TOC entry 495 (class 1259 OID 22468)
-- Name: project_inspectors_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.project_inspectors_active AS
 SELECT project_id,
    profile_id,
    assigned_by,
    assigned_at,
    deleted_at
   FROM public.project_inspectors
  WHERE (deleted_at IS NULL);


--
-- TOC entry 496 (class 1259 OID 22472)
-- Name: projects_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.projects_active AS
 SELECT id,
    organization_id,
    name,
    description,
    status,
    start_date,
    end_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.projects
  WHERE (deleted_at IS NULL);


--
-- TOC entry 497 (class 1259 OID 22476)
-- Name: punch_lists_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.punch_lists_active AS
 SELECT id,
    project_id,
    item,
    status,
    assigned_to,
    created_at,
    updated_at,
    deleted_at
   FROM public.punch_lists
  WHERE (deleted_at IS NULL);


--
-- TOC entry 498 (class 1259 OID 22480)
-- Name: purchase_orders_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.purchase_orders_active AS
 SELECT id,
    project_id,
    vendor_id,
    order_number,
    order_date,
    amount,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.purchase_orders
  WHERE (deleted_at IS NULL);


--
-- TOC entry 499 (class 1259 OID 22484)
-- Name: quality_reviews_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.quality_reviews_active AS
 SELECT id,
    project_id,
    review_date,
    reviewer,
    findings,
    created_at,
    updated_at,
    deleted_at
   FROM public.quality_reviews
  WHERE (deleted_at IS NULL);


--
-- TOC entry 500 (class 1259 OID 22488)
-- Name: regulatory_documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.regulatory_documents_active AS
 SELECT id,
    project_id,
    document_type,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.regulatory_documents
  WHERE (deleted_at IS NULL);


--
-- TOC entry 501 (class 1259 OID 22492)
-- Name: reports_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.reports_active AS
 SELECT id,
    project_id,
    report_type,
    generated_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.reports
  WHERE (deleted_at IS NULL);


--
-- TOC entry 502 (class 1259 OID 22496)
-- Name: rfis_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.rfis_active AS
 SELECT id,
    project_id,
    subject,
    status,
    question,
    answer,
    submitted_by,
    reviewed_by,
    submitted_at,
    reviewed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.rfis
  WHERE (deleted_at IS NULL);


--
-- TOC entry 503 (class 1259 OID 22500)
-- Name: safety_incidents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.safety_incidents_active AS
 SELECT id,
    project_id,
    incident_date,
    description,
    reported_by,
    severity,
    resolved,
    created_at,
    updated_at,
    deleted_at
   FROM public.safety_incidents
  WHERE (deleted_at IS NULL);


--
-- TOC entry 504 (class 1259 OID 22504)
-- Name: sensor_data_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.sensor_data_active AS
 SELECT id,
    project_id,
    data,
    collected_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.sensor_data
  WHERE (deleted_at IS NULL);


--
-- TOC entry 505 (class 1259 OID 22508)
-- Name: subcontractor_agreements_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.subcontractor_agreements_active AS
 SELECT id,
    subcontract_id,
    agreement_url,
    signed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.subcontractor_agreements
  WHERE (deleted_at IS NULL);


--
-- TOC entry 506 (class 1259 OID 22512)
-- Name: subcontracts_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.subcontracts_active AS
 SELECT id,
    project_id,
    vendor_id,
    amount,
    status,
    signed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.subcontracts
  WHERE (deleted_at IS NULL);


--
-- TOC entry 507 (class 1259 OID 22516)
-- Name: submittals_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.submittals_active AS
 SELECT id,
    project_id,
    name,
    status,
    submitted_by,
    reviewed_by,
    submitted_at,
    reviewed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.submittals
  WHERE (deleted_at IS NULL);


--
-- TOC entry 508 (class 1259 OID 22520)
-- Name: tack_rates_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.tack_rates_active AS
 SELECT id,
    project_id,
    rate,
    material_type,
    created_at,
    updated_at,
    deleted_at
   FROM public.tack_rates
  WHERE (deleted_at IS NULL);


--
-- TOC entry 509 (class 1259 OID 22524)
-- Name: task_dependencies_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.task_dependencies_active AS
 SELECT id,
    task_id,
    depends_on_task_id,
    created_at,
    deleted_at
   FROM public.task_dependencies
  WHERE (deleted_at IS NULL);


--
-- TOC entry 510 (class 1259 OID 22528)
-- Name: task_status_logs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.task_status_logs_active AS
 SELECT task_id,
    status,
    changed_at,
    deleted_at
   FROM public.task_status_logs
  WHERE (deleted_at IS NULL);


--
-- TOC entry 511 (class 1259 OID 22532)
-- Name: tasks_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.tasks_active AS
 SELECT id,
    project_id,
    name,
    description,
    start_date,
    end_date,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.tasks
  WHERE (deleted_at IS NULL);


--
-- TOC entry 512 (class 1259 OID 22536)
-- Name: training_records_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.training_records_active AS
 SELECT id,
    employee_id,
    training_type,
    completion_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.training_records
  WHERE (deleted_at IS NULL);


--
-- TOC entry 513 (class 1259 OID 22540)
-- Name: user_projects_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.user_projects_active AS
 SELECT id,
    user_id,
    project_id,
    role,
    created_at,
    updated_at,
    deleted_at
   FROM public.user_projects
  WHERE (deleted_at IS NULL);


--
-- TOC entry 514 (class 1259 OID 22544)
-- Name: vendor_bid_packages_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendor_bid_packages_active AS
 SELECT id,
    bid_package_id,
    vendor_id,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendor_bid_packages
  WHERE (deleted_at IS NULL);


--
-- TOC entry 515 (class 1259 OID 22548)
-- Name: vendor_contacts_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendor_contacts_active AS
 SELECT id,
    vendor_id,
    name,
    email,
    phone,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendor_contacts
  WHERE (deleted_at IS NULL);


--
-- TOC entry 516 (class 1259 OID 22552)
-- Name: vendor_documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendor_documents_active AS
 SELECT id,
    vendor_id,
    document_type,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendor_documents
  WHERE (deleted_at IS NULL);


--
-- TOC entry 517 (class 1259 OID 22556)
-- Name: vendor_qualifications_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendor_qualifications_active AS
 SELECT id,
    vendor_id,
    qualification_type,
    status,
    reviewed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendor_qualifications
  WHERE (deleted_at IS NULL);


--
-- TOC entry 518 (class 1259 OID 22560)
-- Name: vendors_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendors_active AS
 SELECT id,
    organization_id,
    name,
    status,
    contact_email,
    contact_phone,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendors
  WHERE (deleted_at IS NULL);


--
-- TOC entry 519 (class 1259 OID 22564)
-- Name: wbs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.wbs_active AS
 SELECT id,
    project_id,
    name,
    location,
    order_num,
    created_at,
    updated_at,
    deleted_at
   FROM public.wbs
  WHERE (deleted_at IS NULL);


--
-- TOC entry 520 (class 1259 OID 22568)
-- Name: workflows_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.workflows_active AS
 SELECT id,
    entity_schema,
    entity_table,
    entity_id,
    workflow_name,
    current_state,
    created_at,
    updated_at,
    deleted_at
   FROM public.workflows
  WHERE (deleted_at IS NULL);


--
-- TOC entry 5090 (class 2606 OID 22574)
-- Name: accounts_payable accounts_payable_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.accounts_payable
    ADD CONSTRAINT accounts_payable_pkey PRIMARY KEY (id);


--
-- TOC entry 5093 (class 2606 OID 22576)
-- Name: accounts_receivable accounts_receivable_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.accounts_receivable
    ADD CONSTRAINT accounts_receivable_pkey PRIMARY KEY (id);


--
-- TOC entry 5096 (class 2606 OID 22578)
-- Name: activity_logs activity_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.activity_logs
    ADD CONSTRAINT activity_logs_pkey PRIMARY KEY (id);


--
-- TOC entry 5099 (class 2606 OID 22580)
-- Name: asphalt_types asphalt_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.asphalt_types
    ADD CONSTRAINT asphalt_types_pkey PRIMARY KEY (id);


--
-- TOC entry 5407 (class 2606 OID 22582)
-- Name: audit_log audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_pkey PRIMARY KEY (id);


--
-- TOC entry 5101 (class 2606 OID 22584)
-- Name: audit_logs audit_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_pkey PRIMARY KEY (id);


--
-- TOC entry 5105 (class 2606 OID 22586)
-- Name: avatars avatars_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.avatars
    ADD CONSTRAINT avatars_pkey PRIMARY KEY (id);


--
-- TOC entry 5107 (class 2606 OID 22588)
-- Name: bid_packages bid_packages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_packages
    ADD CONSTRAINT bid_packages_pkey PRIMARY KEY (id);


--
-- TOC entry 5111 (class 2606 OID 22590)
-- Name: bid_vendors bid_vendors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_vendors
    ADD CONSTRAINT bid_vendors_pkey PRIMARY KEY (id);


--
-- TOC entry 5115 (class 2606 OID 22592)
-- Name: bids bids_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bids
    ADD CONSTRAINT bids_pkey PRIMARY KEY (id);


--
-- TOC entry 5119 (class 2606 OID 22594)
-- Name: bim_models bim_models_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bim_models
    ADD CONSTRAINT bim_models_pkey PRIMARY KEY (id);


--
-- TOC entry 5122 (class 2606 OID 22596)
-- Name: certifications certifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.certifications
    ADD CONSTRAINT certifications_pkey PRIMARY KEY (id);


--
-- TOC entry 5125 (class 2606 OID 22598)
-- Name: change_orders change_orders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.change_orders
    ADD CONSTRAINT change_orders_pkey PRIMARY KEY (id);


--
-- TOC entry 5128 (class 2606 OID 22600)
-- Name: commitments commitments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.commitments
    ADD CONSTRAINT commitments_pkey PRIMARY KEY (id);


--
-- TOC entry 5132 (class 2606 OID 22602)
-- Name: compliance_checks compliance_checks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compliance_checks
    ADD CONSTRAINT compliance_checks_pkey PRIMARY KEY (id);


--
-- TOC entry 5135 (class 2606 OID 22604)
-- Name: compliance_tracking compliance_tracking_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compliance_tracking
    ADD CONSTRAINT compliance_tracking_pkey PRIMARY KEY (id);


--
-- TOC entry 5138 (class 2606 OID 22608)
-- Name: cost_codes cost_codes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_codes
    ADD CONSTRAINT cost_codes_pkey PRIMARY KEY (id);


--
-- TOC entry 5142 (class 2606 OID 22610)
-- Name: crew_assignments crew_assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_assignments
    ADD CONSTRAINT crew_assignments_pkey PRIMARY KEY (id);


--
-- TOC entry 5146 (class 2606 OID 22612)
-- Name: crew_members crew_members_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_members
    ADD CONSTRAINT crew_members_pkey PRIMARY KEY (id);


--
-- TOC entry 5150 (class 2606 OID 22614)
-- Name: crews crews_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crews
    ADD CONSTRAINT crews_pkey PRIMARY KEY (id);


--
-- TOC entry 5153 (class 2606 OID 22616)
-- Name: daily_logs daily_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.daily_logs
    ADD CONSTRAINT daily_logs_pkey PRIMARY KEY (id);


--
-- TOC entry 5156 (class 2606 OID 22618)
-- Name: dashboard_configs dashboard_configs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dashboard_configs
    ADD CONSTRAINT dashboard_configs_pkey PRIMARY KEY (id);


--
-- TOC entry 5159 (class 2606 OID 22620)
-- Name: document_references document_references_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.document_references
    ADD CONSTRAINT document_references_pkey PRIMARY KEY (id);


--
-- TOC entry 5162 (class 2606 OID 22622)
-- Name: documents documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT documents_pkey PRIMARY KEY (id);


--
-- TOC entry 5166 (class 2606 OID 22624)
-- Name: drawing_versions drawing_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.drawing_versions
    ADD CONSTRAINT drawing_versions_pkey PRIMARY KEY (id);


--
-- TOC entry 5170 (class 2606 OID 22626)
-- Name: dump_trucks dump_trucks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dump_trucks
    ADD CONSTRAINT dump_trucks_pkey PRIMARY KEY (id);


--
-- TOC entry 5173 (class 2606 OID 22628)
-- Name: employees employees_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.employees
    ADD CONSTRAINT employees_pkey PRIMARY KEY (id);


--
-- TOC entry 5180 (class 2606 OID 22630)
-- Name: equipment_assignments equipment_assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_assignments
    ADD CONSTRAINT equipment_assignments_pkey PRIMARY KEY (id);


--
-- TOC entry 5185 (class 2606 OID 22632)
-- Name: equipment_maintenance equipment_maintenance_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_maintenance
    ADD CONSTRAINT equipment_maintenance_pkey PRIMARY KEY (id);


--
-- TOC entry 5177 (class 2606 OID 22634)
-- Name: equipment equipment_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment
    ADD CONSTRAINT equipment_pkey PRIMARY KEY (id);


--
-- TOC entry 5189 (class 2606 OID 22636)
-- Name: equipment_usage equipment_usage_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_usage
    ADD CONSTRAINT equipment_usage_pkey PRIMARY KEY (id);


--
-- TOC entry 5192 (class 2606 OID 22638)
-- Name: estimate_line_items estimate_line_items_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimate_line_items
    ADD CONSTRAINT estimate_line_items_pkey PRIMARY KEY (id);


--
-- TOC entry 5196 (class 2606 OID 22640)
-- Name: estimates estimates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimates
    ADD CONSTRAINT estimates_pkey PRIMARY KEY (id);


--
-- TOC entry 5200 (class 2606 OID 22642)
-- Name: financial_documents financial_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.financial_documents
    ADD CONSTRAINT financial_documents_pkey PRIMARY KEY (id);


--
-- TOC entry 5203 (class 2606 OID 22644)
-- Name: general_ledger general_ledger_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.general_ledger
    ADD CONSTRAINT general_ledger_pkey PRIMARY KEY (id);


--
-- TOC entry 5206 (class 2606 OID 22646)
-- Name: hr_documents hr_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.hr_documents
    ADD CONSTRAINT hr_documents_pkey PRIMARY KEY (id);


--
-- TOC entry 5210 (class 2606 OID 22648)
-- Name: inspections inspections_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inspections
    ADD CONSTRAINT inspections_pkey PRIMARY KEY (id);


--
-- TOC entry 5212 (class 2606 OID 22650)
-- Name: integration_tokens integration_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.integration_tokens
    ADD CONSTRAINT integration_tokens_pkey PRIMARY KEY (id);


--
-- TOC entry 5215 (class 2606 OID 22652)
-- Name: inventory_transactions inventory_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inventory_transactions
    ADD CONSTRAINT inventory_transactions_pkey PRIMARY KEY (id);


--
-- TOC entry 5219 (class 2606 OID 22654)
-- Name: issues issues_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.issues
    ADD CONSTRAINT issues_pkey PRIMARY KEY (id);


--
-- TOC entry 5222 (class 2606 OID 22656)
-- Name: job_titles job_titles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.job_titles
    ADD CONSTRAINT job_titles_pkey PRIMARY KEY (id);


--
-- TOC entry 5225 (class 2606 OID 22658)
-- Name: labor_records labor_records_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.labor_records
    ADD CONSTRAINT labor_records_pkey PRIMARY KEY (id);


--
-- TOC entry 5228 (class 2606 OID 22660)
-- Name: line_item_entries line_item_entries_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_item_entries
    ADD CONSTRAINT line_item_entries_pkey PRIMARY KEY (id);


--
-- TOC entry 5231 (class 2606 OID 22662)
-- Name: line_item_templates line_item_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_item_templates
    ADD CONSTRAINT line_item_templates_pkey PRIMARY KEY (id);


--
-- TOC entry 5238 (class 2606 OID 22664)
-- Name: line_items line_items_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT line_items_pkey PRIMARY KEY (id);


--
-- TOC entry 5242 (class 2606 OID 22666)
-- Name: maps maps_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.maps
    ADD CONSTRAINT maps_pkey PRIMARY KEY (id);


--
-- TOC entry 5246 (class 2606 OID 22668)
-- Name: material_inventory material_inventory_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_inventory
    ADD CONSTRAINT material_inventory_pkey PRIMARY KEY (id);


--
-- TOC entry 5250 (class 2606 OID 22670)
-- Name: material_orders material_orders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_orders
    ADD CONSTRAINT material_orders_pkey PRIMARY KEY (id);


--
-- TOC entry 5254 (class 2606 OID 22672)
-- Name: material_receipts material_receipts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_receipts
    ADD CONSTRAINT material_receipts_pkey PRIMARY KEY (id);


--
-- TOC entry 5257 (class 2606 OID 22674)
-- Name: materials materials_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.materials
    ADD CONSTRAINT materials_pkey PRIMARY KEY (id);


--
-- TOC entry 5261 (class 2606 OID 22676)
-- Name: meeting_minutes meeting_minutes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.meeting_minutes
    ADD CONSTRAINT meeting_minutes_pkey PRIMARY KEY (id);


--
-- TOC entry 5265 (class 2606 OID 22678)
-- Name: notifications notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_pkey PRIMARY KEY (id);


--
-- TOC entry 5431 (class 2606 OID 45506)
-- Name: organization_invites organization_invites_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_invites
    ADD CONSTRAINT organization_invites_pkey PRIMARY KEY (id);


--
-- TOC entry 5420 (class 2606 OID 26538)
-- Name: organization_member_rates organization_member_rates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_member_rates
    ADD CONSTRAINT organization_member_rates_pkey PRIMARY KEY (id);


--
-- TOC entry 5271 (class 2606 OID 22680)
-- Name: organization_members organization_members_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT organization_members_pkey PRIMARY KEY (id);


--
-- TOC entry 5277 (class 2606 OID 22682)
-- Name: organization_projects organization_projects_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_projects
    ADD CONSTRAINT organization_projects_pkey PRIMARY KEY (id);


--
-- TOC entry 5411 (class 2606 OID 26494)
-- Name: organization_service_areas organization_service_areas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_service_areas
    ADD CONSTRAINT organization_service_areas_pkey PRIMARY KEY (id);


--
-- TOC entry 5279 (class 2606 OID 22684)
-- Name: organizations organizations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT organizations_pkey PRIMARY KEY (id);


--
-- TOC entry 5285 (class 2606 OID 22686)
-- Name: payments payments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_pkey PRIMARY KEY (id);


--
-- TOC entry 5288 (class 2606 OID 22688)
-- Name: payroll payroll_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payroll
    ADD CONSTRAINT payroll_pkey PRIMARY KEY (id);


--
-- TOC entry 5292 (class 2606 OID 22690)
-- Name: photos photos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.photos
    ADD CONSTRAINT photos_pkey PRIMARY KEY (id);


--
-- TOC entry 5296 (class 2606 OID 22692)
-- Name: prequalifications prequalifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.prequalifications
    ADD CONSTRAINT prequalifications_pkey PRIMARY KEY (id);


--
-- TOC entry 5299 (class 2606 OID 22694)
-- Name: procurement_workflows procurement_workflows_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procurement_workflows
    ADD CONSTRAINT procurement_workflows_pkey PRIMARY KEY (id);


--
-- TOC entry 5304 (class 2606 OID 22696)
-- Name: profiles profiles_email_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_email_key UNIQUE (email);


--
-- TOC entry 5306 (class 2606 OID 22698)
-- Name: profiles profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_pkey PRIMARY KEY (id);


--
-- TOC entry 5309 (class 2606 OID 22700)
-- Name: progress_billings progress_billings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.progress_billings
    ADD CONSTRAINT progress_billings_pkey PRIMARY KEY (id);


--
-- TOC entry 5314 (class 2606 OID 22702)
-- Name: project_inspectors project_inspectors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_inspectors
    ADD CONSTRAINT project_inspectors_pkey PRIMARY KEY (project_id, profile_id);


--
-- TOC entry 5424 (class 2606 OID 26556)
-- Name: project_invites project_invites_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_invites
    ADD CONSTRAINT project_invites_pkey PRIMARY KEY (id);


--
-- TOC entry 5413 (class 2606 OID 26511)
-- Name: project_service_areas project_service_areas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_service_areas
    ADD CONSTRAINT project_service_areas_pkey PRIMARY KEY (id);


--
-- TOC entry 5317 (class 2606 OID 22704)
-- Name: projects projects_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_pkey PRIMARY KEY (id);


--
-- TOC entry 5323 (class 2606 OID 22706)
-- Name: punch_lists punch_lists_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.punch_lists
    ADD CONSTRAINT punch_lists_pkey PRIMARY KEY (id);


--
-- TOC entry 5327 (class 2606 OID 22708)
-- Name: purchase_orders purchase_orders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.purchase_orders
    ADD CONSTRAINT purchase_orders_pkey PRIMARY KEY (id);


--
-- TOC entry 5331 (class 2606 OID 22710)
-- Name: quality_reviews quality_reviews_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.quality_reviews
    ADD CONSTRAINT quality_reviews_pkey PRIMARY KEY (id);


--
-- TOC entry 5334 (class 2606 OID 22712)
-- Name: regulatory_documents regulatory_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regulatory_documents
    ADD CONSTRAINT regulatory_documents_pkey PRIMARY KEY (id);


--
-- TOC entry 5337 (class 2606 OID 22714)
-- Name: reports reports_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reports
    ADD CONSTRAINT reports_pkey PRIMARY KEY (id);


--
-- TOC entry 5342 (class 2606 OID 22716)
-- Name: rfis rfis_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rfis
    ADD CONSTRAINT rfis_pkey PRIMARY KEY (id);


--
-- TOC entry 5346 (class 2606 OID 22718)
-- Name: safety_incidents safety_incidents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.safety_incidents
    ADD CONSTRAINT safety_incidents_pkey PRIMARY KEY (id);


--
-- TOC entry 5349 (class 2606 OID 22720)
-- Name: sensor_data sensor_data_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.sensor_data
    ADD CONSTRAINT sensor_data_pkey PRIMARY KEY (id);


--
-- TOC entry 5352 (class 2606 OID 22722)
-- Name: subcontractor_agreements subcontractor_agreements_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontractor_agreements
    ADD CONSTRAINT subcontractor_agreements_pkey PRIMARY KEY (id);


--
-- TOC entry 5356 (class 2606 OID 22724)
-- Name: subcontracts subcontracts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontracts
    ADD CONSTRAINT subcontracts_pkey PRIMARY KEY (id);


--
-- TOC entry 5361 (class 2606 OID 22726)
-- Name: submittals submittals_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.submittals
    ADD CONSTRAINT submittals_pkey PRIMARY KEY (id);


--
-- TOC entry 5364 (class 2606 OID 22728)
-- Name: tack_rates tack_rates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tack_rates
    ADD CONSTRAINT tack_rates_pkey PRIMARY KEY (id);


--
-- TOC entry 5368 (class 2606 OID 22730)
-- Name: task_dependencies task_dependencies_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.task_dependencies
    ADD CONSTRAINT task_dependencies_pkey PRIMARY KEY (id);


--
-- TOC entry 5372 (class 2606 OID 45509)
-- Name: task_status_logs task_status_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.task_status_logs
    ADD CONSTRAINT task_status_logs_pkey PRIMARY KEY (id);


--
-- TOC entry 5375 (class 2606 OID 22732)
-- Name: tasks tasks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tasks
    ADD CONSTRAINT tasks_pkey PRIMARY KEY (id);


--
-- TOC entry 5378 (class 2606 OID 22734)
-- Name: training_records training_records_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.training_records
    ADD CONSTRAINT training_records_pkey PRIMARY KEY (id);


--
-- TOC entry 5140 (class 2606 OID 22736)
-- Name: cost_codes uq_cost_codes_code; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_codes
    ADD CONSTRAINT uq_cost_codes_code UNIQUE (code);


--
-- TOC entry 5273 (class 2606 OID 22738)
-- Name: organization_members uq_organization_members; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT uq_organization_members UNIQUE (profile_id, organization_id);


--
-- TOC entry 5281 (class 2606 OID 22740)
-- Name: organizations uq_organizations_name; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT uq_organizations_name UNIQUE (name);


--
-- TOC entry 5319 (class 2606 OID 22744)
-- Name: projects uq_projects_name; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT uq_projects_name UNIQUE (name, organization_id);


--
-- TOC entry 5382 (class 2606 OID 22746)
-- Name: user_projects uq_user_projects; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_projects
    ADD CONSTRAINT uq_user_projects UNIQUE (user_id, project_id);


--
-- TOC entry 5400 (class 2606 OID 22748)
-- Name: vendors uq_vendors_name; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendors
    ADD CONSTRAINT uq_vendors_name UNIQUE (name, organization_id);


--
-- TOC entry 5384 (class 2606 OID 22750)
-- Name: user_projects user_projects_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_projects
    ADD CONSTRAINT user_projects_pkey PRIMARY KEY (id);


--
-- TOC entry 5388 (class 2606 OID 22752)
-- Name: vendor_bid_packages vendor_bid_packages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_bid_packages
    ADD CONSTRAINT vendor_bid_packages_pkey PRIMARY KEY (id);


--
-- TOC entry 5391 (class 2606 OID 22754)
-- Name: vendor_contacts vendor_contacts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_contacts
    ADD CONSTRAINT vendor_contacts_pkey PRIMARY KEY (id);


--
-- TOC entry 5394 (class 2606 OID 22756)
-- Name: vendor_documents vendor_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_documents
    ADD CONSTRAINT vendor_documents_pkey PRIMARY KEY (id);


--
-- TOC entry 5397 (class 2606 OID 22758)
-- Name: vendor_qualifications vendor_qualifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_qualifications
    ADD CONSTRAINT vendor_qualifications_pkey PRIMARY KEY (id);


--
-- TOC entry 5402 (class 2606 OID 22760)
-- Name: vendors vendors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendors
    ADD CONSTRAINT vendors_pkey PRIMARY KEY (id);


--
-- TOC entry 5405 (class 2606 OID 22762)
-- Name: wbs wbs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wbs
    ADD CONSTRAINT wbs_pkey PRIMARY KEY (id);


--
-- TOC entry 5088 (class 2606 OID 22764)
-- Name: workflows workflows_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workflows
    ADD CONSTRAINT workflows_pkey PRIMARY KEY (id);


--
-- TOC entry 5163 (class 1259 OID 22765)
-- Name: idx_documents_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_documents_project_id ON public.documents USING btree (project_id);


--
-- TOC entry 5208 (class 1259 OID 22766)
-- Name: idx_inspections_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_inspections_project_id ON public.inspections USING btree (project_id);


--
-- TOC entry 5217 (class 1259 OID 22767)
-- Name: idx_issues_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_issues_project_id ON public.issues USING btree (project_id);


--
-- TOC entry 5232 (class 1259 OID 22768)
-- Name: idx_line_items_map_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_line_items_map_id ON public.line_items USING btree (map_id);


--
-- TOC entry 5233 (class 1259 OID 22769)
-- Name: idx_line_items_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_line_items_project_id ON public.line_items USING btree (project_id);


--
-- TOC entry 5234 (class 1259 OID 22770)
-- Name: idx_line_items_wbs_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_line_items_wbs_id ON public.line_items USING btree (wbs_id);


--
-- TOC entry 5239 (class 1259 OID 22771)
-- Name: idx_maps_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_maps_project_id ON public.maps USING btree (project_id);


--
-- TOC entry 5240 (class 1259 OID 22772)
-- Name: idx_maps_wbs_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_maps_wbs_id ON public.maps USING btree (wbs_id);


--
-- TOC entry 5262 (class 1259 OID 45487)
-- Name: idx_notifications_user_created_at_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notifications_user_created_at_active ON public.notifications USING btree (user_id, created_at DESC) WHERE (deleted_at IS NULL);


--
-- TOC entry 5263 (class 1259 OID 45488)
-- Name: idx_notifications_user_unread_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notifications_user_unread_active ON public.notifications USING btree (user_id) WHERE ((deleted_at IS NULL) AND (is_read = false));


--
-- TOC entry 5315 (class 1259 OID 22773)
-- Name: idx_projects_organization_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_projects_organization_id ON public.projects USING btree (organization_id);


--
-- TOC entry 5369 (class 1259 OID 45510)
-- Name: idx_task_status_logs_task_changed; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_task_status_logs_task_changed ON public.task_status_logs USING btree (task_id, changed_at DESC);


--
-- TOC entry 5370 (class 1259 OID 45511)
-- Name: idx_task_status_logs_task_changed_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_task_status_logs_task_changed_at ON public.task_status_logs USING btree (task_id, changed_at DESC);


--
-- TOC entry 5379 (class 1259 OID 22774)
-- Name: idx_user_projects_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_projects_project_id ON public.user_projects USING btree (project_id);


--
-- TOC entry 5380 (class 1259 OID 22775)
-- Name: idx_user_projects_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_projects_user_id ON public.user_projects USING btree (user_id);


--
-- TOC entry 5403 (class 1259 OID 22776)
-- Name: idx_wbs_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wbs_project_id ON public.wbs USING btree (project_id);


--
-- TOC entry 5091 (class 1259 OID 22777)
-- Name: ix_accounts_payable__fk_fk_ap_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_accounts_payable__fk_fk_ap_project ON public.accounts_payable USING btree (project_id);


--
-- TOC entry 5094 (class 1259 OID 22778)
-- Name: ix_accounts_receivable__fk_fk_ar_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_accounts_receivable__fk_fk_ar_project ON public.accounts_receivable USING btree (project_id);


--
-- TOC entry 5097 (class 1259 OID 22779)
-- Name: ix_activity_logs__fk_fk_activity_logs_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_activity_logs__fk_fk_activity_logs_profile ON public.activity_logs USING btree (profile_id);


--
-- TOC entry 5102 (class 1259 OID 22780)
-- Name: ix_audit_logs__fk_fk_audit_logs_performed_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_audit_logs__fk_fk_audit_logs_performed_by ON public.audit_logs USING btree (performed_by);


--
-- TOC entry 5103 (class 1259 OID 22781)
-- Name: ix_audit_logs__fk_fk_audit_logs_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_audit_logs__fk_fk_audit_logs_project ON public.audit_logs USING btree (project_id);


--
-- TOC entry 5108 (class 1259 OID 22782)
-- Name: ix_bid_packages__fk_fk_bid_packages_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bid_packages__fk_fk_bid_packages_created_by ON public.bid_packages USING btree (created_by);


--
-- TOC entry 5109 (class 1259 OID 22783)
-- Name: ix_bid_packages__fk_fk_bid_packages_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bid_packages__fk_fk_bid_packages_project ON public.bid_packages USING btree (project_id);


--
-- TOC entry 5112 (class 1259 OID 22784)
-- Name: ix_bid_vendors__fk_fk_bid_vendors_bid_package; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bid_vendors__fk_fk_bid_vendors_bid_package ON public.bid_vendors USING btree (bid_package_id);


--
-- TOC entry 5113 (class 1259 OID 22785)
-- Name: ix_bid_vendors__fk_fk_bid_vendors_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bid_vendors__fk_fk_bid_vendors_vendor ON public.bid_vendors USING btree (vendor_id);


--
-- TOC entry 5116 (class 1259 OID 22786)
-- Name: ix_bids__fk_fk_bids_bid_package; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bids__fk_fk_bids_bid_package ON public.bids USING btree (bid_package_id);


--
-- TOC entry 5117 (class 1259 OID 22787)
-- Name: ix_bids__fk_fk_bids_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bids__fk_fk_bids_vendor ON public.bids USING btree (vendor_id);


--
-- TOC entry 5120 (class 1259 OID 22788)
-- Name: ix_bim_models__fk_fk_bim_models_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bim_models__fk_fk_bim_models_project ON public.bim_models USING btree (project_id);


--
-- TOC entry 5123 (class 1259 OID 22789)
-- Name: ix_certifications__fk_fk_certifications_employee; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_certifications__fk_fk_certifications_employee ON public.certifications USING btree (employee_id);


--
-- TOC entry 5126 (class 1259 OID 22790)
-- Name: ix_change_orders__fk_fk_change_orders_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_change_orders__fk_fk_change_orders_project ON public.change_orders USING btree (project_id);


--
-- TOC entry 5129 (class 1259 OID 22791)
-- Name: ix_commitments__fk_fk_commitments_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_commitments__fk_fk_commitments_project ON public.commitments USING btree (project_id);


--
-- TOC entry 5130 (class 1259 OID 22792)
-- Name: ix_commitments__fk_fk_commitments_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_commitments__fk_fk_commitments_vendor ON public.commitments USING btree (vendor_id);


--
-- TOC entry 5133 (class 1259 OID 22793)
-- Name: ix_compliance_checks__fk_fk_compliance_checks_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_compliance_checks__fk_fk_compliance_checks_project ON public.compliance_checks USING btree (project_id);


--
-- TOC entry 5136 (class 1259 OID 22794)
-- Name: ix_compliance_tracking__fk_fk_compliance_tracking_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_compliance_tracking__fk_fk_compliance_tracking_project ON public.compliance_tracking USING btree (project_id);


--
-- TOC entry 5143 (class 1259 OID 22795)
-- Name: ix_crew_assignments__fk_fk_crew_assignments_crew; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crew_assignments__fk_fk_crew_assignments_crew ON public.crew_assignments USING btree (crew_id);


--
-- TOC entry 5144 (class 1259 OID 22796)
-- Name: ix_crew_assignments__fk_fk_crew_assignments_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crew_assignments__fk_fk_crew_assignments_profile ON public.crew_assignments USING btree (profile_id);


--
-- TOC entry 5147 (class 1259 OID 22797)
-- Name: ix_crew_members__fk_fk_crew_members_crew; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crew_members__fk_fk_crew_members_crew ON public.crew_members USING btree (crew_id);


--
-- TOC entry 5148 (class 1259 OID 22798)
-- Name: ix_crew_members__fk_fk_crew_members_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crew_members__fk_fk_crew_members_profile ON public.crew_members USING btree (profile_id);


--
-- TOC entry 5151 (class 1259 OID 22799)
-- Name: ix_crews__fk_fk_crews_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crews__fk_fk_crews_project ON public.crews USING btree (project_id);


--
-- TOC entry 5154 (class 1259 OID 22800)
-- Name: ix_daily_logs__fk_fk_daily_logs_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_daily_logs__fk_fk_daily_logs_project ON public.daily_logs USING btree (project_id);


--
-- TOC entry 5157 (class 1259 OID 22801)
-- Name: ix_dashboard_configs__fk_fk_dashboard_configs_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_dashboard_configs__fk_fk_dashboard_configs_profile ON public.dashboard_configs USING btree (profile_id);


--
-- TOC entry 5160 (class 1259 OID 22802)
-- Name: ix_document_references__fk_fk_document_references_document; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_document_references__fk_fk_document_references_document ON public.document_references USING btree (document_id);


--
-- TOC entry 5164 (class 1259 OID 22803)
-- Name: ix_documents__fk_fk_documents_uploaded_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_documents__fk_fk_documents_uploaded_by ON public.documents USING btree (uploaded_by);


--
-- TOC entry 5167 (class 1259 OID 22804)
-- Name: ix_drawing_versions__fk_fk_drawing_versions_document; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_drawing_versions__fk_fk_drawing_versions_document ON public.drawing_versions USING btree (document_id);


--
-- TOC entry 5168 (class 1259 OID 22805)
-- Name: ix_drawing_versions__fk_fk_drawing_versions_uploaded_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_drawing_versions__fk_fk_drawing_versions_uploaded_by ON public.drawing_versions USING btree (uploaded_by);


--
-- TOC entry 5171 (class 1259 OID 22806)
-- Name: ix_dump_trucks__fk_fk_dump_trucks_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_dump_trucks__fk_fk_dump_trucks_organization ON public.dump_trucks USING btree (organization_id);


--
-- TOC entry 5174 (class 1259 OID 22807)
-- Name: ix_employees__fk_fk_employees_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_employees__fk_fk_employees_organization ON public.employees USING btree (organization_id);


--
-- TOC entry 5175 (class 1259 OID 22808)
-- Name: ix_employees__fk_fk_employees_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_employees__fk_fk_employees_profile ON public.employees USING btree (profile_id);


--
-- TOC entry 5178 (class 1259 OID 22809)
-- Name: ix_equipment__fk_fk_equipment_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment__fk_fk_equipment_organization ON public.equipment USING btree (organization_id);


--
-- TOC entry 5181 (class 1259 OID 22810)
-- Name: ix_equipment_assignments__fk_fk_equipment_assignments_assigned_; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_assignments__fk_fk_equipment_assignments_assigned_ ON public.equipment_assignments USING btree (assigned_to);


--
-- TOC entry 5182 (class 1259 OID 22811)
-- Name: ix_equipment_assignments__fk_fk_equipment_assignments_equipment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_assignments__fk_fk_equipment_assignments_equipment ON public.equipment_assignments USING btree (equipment_id);


--
-- TOC entry 5183 (class 1259 OID 22812)
-- Name: ix_equipment_assignments__fk_fk_equipment_assignments_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_assignments__fk_fk_equipment_assignments_project ON public.equipment_assignments USING btree (project_id);


--
-- TOC entry 5186 (class 1259 OID 22813)
-- Name: ix_equipment_maintenance__fk_fk_equipment_maintenance_equipment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_maintenance__fk_fk_equipment_maintenance_equipment ON public.equipment_maintenance USING btree (equipment_id);


--
-- TOC entry 5187 (class 1259 OID 22814)
-- Name: ix_equipment_maintenance__fk_fk_equipment_maintenance_performed; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_maintenance__fk_fk_equipment_maintenance_performed ON public.equipment_maintenance USING btree (performed_by);


--
-- TOC entry 5190 (class 1259 OID 22815)
-- Name: ix_equipment_usage__fk_fk_equipment_usage_equipment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_usage__fk_fk_equipment_usage_equipment ON public.equipment_usage USING btree (equipment_id);


--
-- TOC entry 5193 (class 1259 OID 22816)
-- Name: ix_estimate_line_items__fk_fk_estimate_line_items_cost_code; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_estimate_line_items__fk_fk_estimate_line_items_cost_code ON public.estimate_line_items USING btree (cost_code_id);


--
-- TOC entry 5194 (class 1259 OID 22817)
-- Name: ix_estimate_line_items__fk_fk_estimate_line_items_estimate; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_estimate_line_items__fk_fk_estimate_line_items_estimate ON public.estimate_line_items USING btree (estimate_id);


--
-- TOC entry 5197 (class 1259 OID 22818)
-- Name: ix_estimates__fk_fk_estimates_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_estimates__fk_fk_estimates_created_by ON public.estimates USING btree (created_by);


--
-- TOC entry 5198 (class 1259 OID 22819)
-- Name: ix_estimates__fk_fk_estimates_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_estimates__fk_fk_estimates_project ON public.estimates USING btree (project_id);


--
-- TOC entry 5201 (class 1259 OID 22820)
-- Name: ix_financial_documents__fk_fk_financial_documents_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_financial_documents__fk_fk_financial_documents_project ON public.financial_documents USING btree (project_id);


--
-- TOC entry 5204 (class 1259 OID 22821)
-- Name: ix_general_ledger__fk_fk_gl_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_general_ledger__fk_fk_gl_project ON public.general_ledger USING btree (project_id);


--
-- TOC entry 5207 (class 1259 OID 22822)
-- Name: ix_hr_documents__fk_fk_hr_documents_employee; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_hr_documents__fk_fk_hr_documents_employee ON public.hr_documents USING btree (employee_id);


--
-- TOC entry 5213 (class 1259 OID 22823)
-- Name: ix_integration_tokens__fk_fk_integration_tokens_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_integration_tokens__fk_fk_integration_tokens_profile ON public.integration_tokens USING btree (profile_id);


--
-- TOC entry 5216 (class 1259 OID 22824)
-- Name: ix_inventory_transactions__fk_fk_inventory_transactions_materia; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_inventory_transactions__fk_fk_inventory_transactions_materia ON public.inventory_transactions USING btree (material_id);


--
-- TOC entry 5220 (class 1259 OID 22825)
-- Name: ix_issues__fk_fk_issues_reported_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_issues__fk_fk_issues_reported_by ON public.issues USING btree (reported_by);


--
-- TOC entry 5223 (class 1259 OID 22826)
-- Name: ix_labor_records__fk_fk_labor_records_line_item; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_labor_records__fk_fk_labor_records_line_item ON public.labor_records USING btree (line_item_id);


--
-- TOC entry 5226 (class 1259 OID 22827)
-- Name: ix_line_item_entries__fk_fk_line_item_entries_line_item; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_line_item_entries__fk_fk_line_item_entries_line_item ON public.line_item_entries USING btree (line_item_id);


--
-- TOC entry 5229 (class 1259 OID 22828)
-- Name: ix_line_item_templates__fk_fk_line_item_templates_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_line_item_templates__fk_fk_line_item_templates_created_by ON public.line_item_templates USING btree (created_by);


--
-- TOC entry 5235 (class 1259 OID 22829)
-- Name: ix_line_items__fk_fk_line_items_cost_code; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_line_items__fk_fk_line_items_cost_code ON public.line_items USING btree (cost_code_id);


--
-- TOC entry 5236 (class 1259 OID 22830)
-- Name: ix_line_items__fk_fk_line_items_template; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_line_items__fk_fk_line_items_template ON public.line_items USING btree (template_id);


--
-- TOC entry 5243 (class 1259 OID 22831)
-- Name: ix_material_inventory__fk_fk_material_inventory_material; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_inventory__fk_fk_material_inventory_material ON public.material_inventory USING btree (material_id);


--
-- TOC entry 5244 (class 1259 OID 22832)
-- Name: ix_material_inventory__fk_fk_material_inventory_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_inventory__fk_fk_material_inventory_organization ON public.material_inventory USING btree (organization_id);


--
-- TOC entry 5247 (class 1259 OID 22833)
-- Name: ix_material_orders__fk_fk_material_orders_material; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_orders__fk_fk_material_orders_material ON public.material_orders USING btree (material_id);


--
-- TOC entry 5248 (class 1259 OID 22834)
-- Name: ix_material_orders__fk_fk_material_orders_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_orders__fk_fk_material_orders_project ON public.material_orders USING btree (project_id);


--
-- TOC entry 5251 (class 1259 OID 22835)
-- Name: ix_material_receipts__fk_fk_material_receipts_material_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_receipts__fk_fk_material_receipts_material_order ON public.material_receipts USING btree (material_order_id);


--
-- TOC entry 5252 (class 1259 OID 22836)
-- Name: ix_material_receipts__fk_fk_material_receipts_received_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_receipts__fk_fk_material_receipts_received_by ON public.material_receipts USING btree (received_by);


--
-- TOC entry 5255 (class 1259 OID 22837)
-- Name: ix_materials__fk_fk_materials_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_materials__fk_fk_materials_organization ON public.materials USING btree (organization_id);


--
-- TOC entry 5258 (class 1259 OID 22838)
-- Name: ix_meeting_minutes__fk_fk_meeting_minutes_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_meeting_minutes__fk_fk_meeting_minutes_created_by ON public.meeting_minutes USING btree (created_by);


--
-- TOC entry 5259 (class 1259 OID 22839)
-- Name: ix_meeting_minutes__fk_fk_meeting_minutes_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_meeting_minutes__fk_fk_meeting_minutes_project ON public.meeting_minutes USING btree (project_id);


--
-- TOC entry 5427 (class 1259 OID 43259)
-- Name: ix_organization_invites__fk_invited_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_invites__fk_invited_profile_id ON public.organization_invites USING btree (invited_profile_id);


--
-- TOC entry 5428 (class 1259 OID 43258)
-- Name: ix_organization_invites__fk_org_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_invites__fk_org_id ON public.organization_invites USING btree (organization_id);


--
-- TOC entry 5417 (class 1259 OID 26544)
-- Name: ix_organization_member_rates__fk_organization_member_rates_memb; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_member_rates__fk_organization_member_rates_memb ON public.organization_member_rates USING btree (membership_id);


--
-- TOC entry 5266 (class 1259 OID 22841)
-- Name: ix_organization_members__fk_fk_org_members_org; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_members__fk_fk_org_members_org ON public.organization_members USING btree (organization_id);


--
-- TOC entry 5267 (class 1259 OID 22842)
-- Name: ix_organization_members__fk_fk_org_members_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_members__fk_fk_org_members_profile ON public.organization_members USING btree (profile_id);


--
-- TOC entry 5274 (class 1259 OID 22843)
-- Name: ix_organization_projects__fk_fk_org_projects_org; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_projects__fk_fk_org_projects_org ON public.organization_projects USING btree (organization_id);


--
-- TOC entry 5275 (class 1259 OID 22844)
-- Name: ix_organization_projects__fk_fk_org_projects_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_projects__fk_fk_org_projects_project ON public.organization_projects USING btree (project_id);


--
-- TOC entry 5282 (class 1259 OID 22845)
-- Name: ix_payments__fk_fk_payments_commitment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_payments__fk_fk_payments_commitment ON public.payments USING btree (commitment_id);


--
-- TOC entry 5283 (class 1259 OID 22846)
-- Name: ix_payments__fk_fk_payments_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_payments__fk_fk_payments_project ON public.payments USING btree (project_id);


--
-- TOC entry 5286 (class 1259 OID 22847)
-- Name: ix_payroll__fk_fk_payroll_employee; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_payroll__fk_fk_payroll_employee ON public.payroll USING btree (employee_id);


--
-- TOC entry 5289 (class 1259 OID 22848)
-- Name: ix_photos__fk_fk_photos_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_photos__fk_fk_photos_project ON public.photos USING btree (project_id);


--
-- TOC entry 5290 (class 1259 OID 22849)
-- Name: ix_photos__fk_fk_photos_uploaded_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_photos__fk_fk_photos_uploaded_by ON public.photos USING btree (uploaded_by);


--
-- TOC entry 5293 (class 1259 OID 22850)
-- Name: ix_prequalifications__fk_fk_prequalifications_reviewed_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_prequalifications__fk_fk_prequalifications_reviewed_by ON public.prequalifications USING btree (reviewed_by);


--
-- TOC entry 5294 (class 1259 OID 22851)
-- Name: ix_prequalifications__fk_fk_prequalifications_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_prequalifications__fk_fk_prequalifications_vendor ON public.prequalifications USING btree (vendor_id);


--
-- TOC entry 5297 (class 1259 OID 22852)
-- Name: ix_procurement_workflows__fk_fk_procurement_workflows_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_procurement_workflows__fk_fk_procurement_workflows_project ON public.procurement_workflows USING btree (project_id);


--
-- TOC entry 5300 (class 1259 OID 26436)
-- Name: ix_profiles__fk_fk_profiles_avatar_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_profiles__fk_fk_profiles_avatar_id ON public.profiles USING btree (avatar_id);


--
-- TOC entry 5301 (class 1259 OID 22853)
-- Name: ix_profiles__fk_fk_profiles_job_titles; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_profiles__fk_fk_profiles_job_titles ON public.profiles USING btree (job_title_id);


--
-- TOC entry 5302 (class 1259 OID 22854)
-- Name: ix_profiles__fk_fk_profiles_organizations; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_profiles__fk_fk_profiles_organizations ON public.profiles USING btree (organization_id);


--
-- TOC entry 5307 (class 1259 OID 22855)
-- Name: ix_progress_billings__fk_fk_progress_billings_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_progress_billings__fk_fk_progress_billings_project ON public.progress_billings USING btree (project_id);


--
-- TOC entry 5310 (class 1259 OID 22856)
-- Name: ix_project_inspectors__fk_project_inspectors_assigned_by_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_project_inspectors__fk_project_inspectors_assigned_by_fkey ON public.project_inspectors USING btree (assigned_by);


--
-- TOC entry 5311 (class 1259 OID 22857)
-- Name: ix_project_inspectors__fk_project_inspectors_profile_id_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_project_inspectors__fk_project_inspectors_profile_id_fkey ON public.project_inspectors USING btree (profile_id);


--
-- TOC entry 5312 (class 1259 OID 22858)
-- Name: ix_project_inspectors__fk_project_inspectors_project_id_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_project_inspectors__fk_project_inspectors_project_id_fkey ON public.project_inspectors USING btree (project_id);


--
-- TOC entry 5421 (class 1259 OID 26572)
-- Name: ix_project_invites__fk_project_invites_invited_by_profile_id_fk; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_project_invites__fk_project_invites_invited_by_profile_id_fk ON public.project_invites USING btree (invited_by_profile_id);


--
-- TOC entry 5320 (class 1259 OID 22859)
-- Name: ix_punch_lists__fk_fk_punch_lists_assigned_to; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_punch_lists__fk_fk_punch_lists_assigned_to ON public.punch_lists USING btree (assigned_to);


--
-- TOC entry 5321 (class 1259 OID 22860)
-- Name: ix_punch_lists__fk_fk_punch_lists_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_punch_lists__fk_fk_punch_lists_project ON public.punch_lists USING btree (project_id);


--
-- TOC entry 5324 (class 1259 OID 22861)
-- Name: ix_purchase_orders__fk_fk_purchase_orders_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_purchase_orders__fk_fk_purchase_orders_project ON public.purchase_orders USING btree (project_id);


--
-- TOC entry 5325 (class 1259 OID 22862)
-- Name: ix_purchase_orders__fk_fk_purchase_orders_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_purchase_orders__fk_fk_purchase_orders_vendor ON public.purchase_orders USING btree (vendor_id);


--
-- TOC entry 5328 (class 1259 OID 22863)
-- Name: ix_quality_reviews__fk_fk_quality_reviews_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_quality_reviews__fk_fk_quality_reviews_project ON public.quality_reviews USING btree (project_id);


--
-- TOC entry 5329 (class 1259 OID 22864)
-- Name: ix_quality_reviews__fk_fk_quality_reviews_reviewer; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_quality_reviews__fk_fk_quality_reviews_reviewer ON public.quality_reviews USING btree (reviewer);


--
-- TOC entry 5332 (class 1259 OID 22865)
-- Name: ix_regulatory_documents__fk_fk_regulatory_documents_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_regulatory_documents__fk_fk_regulatory_documents_project ON public.regulatory_documents USING btree (project_id);


--
-- TOC entry 5335 (class 1259 OID 22866)
-- Name: ix_reports__fk_fk_reports_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_reports__fk_fk_reports_project ON public.reports USING btree (project_id);


--
-- TOC entry 5338 (class 1259 OID 22867)
-- Name: ix_rfis__fk_fk_rfis_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_rfis__fk_fk_rfis_project ON public.rfis USING btree (project_id);


--
-- TOC entry 5339 (class 1259 OID 22868)
-- Name: ix_rfis__fk_fk_rfis_reviewed_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_rfis__fk_fk_rfis_reviewed_by ON public.rfis USING btree (reviewed_by);


--
-- TOC entry 5340 (class 1259 OID 22869)
-- Name: ix_rfis__fk_fk_rfis_submitted_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_rfis__fk_fk_rfis_submitted_by ON public.rfis USING btree (submitted_by);


--
-- TOC entry 5343 (class 1259 OID 22870)
-- Name: ix_safety_incidents__fk_fk_safety_incidents_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_safety_incidents__fk_fk_safety_incidents_project ON public.safety_incidents USING btree (project_id);


--
-- TOC entry 5344 (class 1259 OID 22871)
-- Name: ix_safety_incidents__fk_fk_safety_incidents_reported_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_safety_incidents__fk_fk_safety_incidents_reported_by ON public.safety_incidents USING btree (reported_by);


--
-- TOC entry 5347 (class 1259 OID 22872)
-- Name: ix_sensor_data__fk_fk_sensor_data_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_sensor_data__fk_fk_sensor_data_project ON public.sensor_data USING btree (project_id);


--
-- TOC entry 5350 (class 1259 OID 22873)
-- Name: ix_subcontractor_agreements__fk_fk_subcontractor_agreements_sub; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_subcontractor_agreements__fk_fk_subcontractor_agreements_sub ON public.subcontractor_agreements USING btree (subcontract_id);


--
-- TOC entry 5353 (class 1259 OID 22874)
-- Name: ix_subcontracts__fk_fk_subcontracts_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_subcontracts__fk_fk_subcontracts_project ON public.subcontracts USING btree (project_id);


--
-- TOC entry 5354 (class 1259 OID 22875)
-- Name: ix_subcontracts__fk_fk_subcontracts_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_subcontracts__fk_fk_subcontracts_vendor ON public.subcontracts USING btree (vendor_id);


--
-- TOC entry 5357 (class 1259 OID 22876)
-- Name: ix_submittals__fk_fk_submittals_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_submittals__fk_fk_submittals_project ON public.submittals USING btree (project_id);


--
-- TOC entry 5358 (class 1259 OID 22877)
-- Name: ix_submittals__fk_fk_submittals_reviewed_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_submittals__fk_fk_submittals_reviewed_by ON public.submittals USING btree (reviewed_by);


--
-- TOC entry 5359 (class 1259 OID 22878)
-- Name: ix_submittals__fk_fk_submittals_submitted_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_submittals__fk_fk_submittals_submitted_by ON public.submittals USING btree (submitted_by);


--
-- TOC entry 5362 (class 1259 OID 22879)
-- Name: ix_tack_rates__fk_fk_tack_rates_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_tack_rates__fk_fk_tack_rates_project ON public.tack_rates USING btree (project_id);


--
-- TOC entry 5365 (class 1259 OID 22880)
-- Name: ix_task_dependencies__fk_task_dependencies_depends_on_task_id_f; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_task_dependencies__fk_task_dependencies_depends_on_task_id_f ON public.task_dependencies USING btree (depends_on_task_id);


--
-- TOC entry 5366 (class 1259 OID 22881)
-- Name: ix_task_dependencies__fk_task_dependencies_task_id_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_task_dependencies__fk_task_dependencies_task_id_fkey ON public.task_dependencies USING btree (task_id);


--
-- TOC entry 5373 (class 1259 OID 22882)
-- Name: ix_tasks__fk_tasks_project_id_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_tasks__fk_tasks_project_id_fkey ON public.tasks USING btree (project_id);


--
-- TOC entry 5376 (class 1259 OID 22883)
-- Name: ix_training_records__fk_fk_training_records_employee; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_training_records__fk_fk_training_records_employee ON public.training_records USING btree (employee_id);


--
-- TOC entry 5385 (class 1259 OID 22884)
-- Name: ix_vendor_bid_packages__fk_fk_vendor_bid_packages_bid_package; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_bid_packages__fk_fk_vendor_bid_packages_bid_package ON public.vendor_bid_packages USING btree (bid_package_id);


--
-- TOC entry 5386 (class 1259 OID 22885)
-- Name: ix_vendor_bid_packages__fk_fk_vendor_bid_packages_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_bid_packages__fk_fk_vendor_bid_packages_vendor ON public.vendor_bid_packages USING btree (vendor_id);


--
-- TOC entry 5389 (class 1259 OID 22886)
-- Name: ix_vendor_contacts__fk_fk_vendor_contacts_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_contacts__fk_fk_vendor_contacts_vendor ON public.vendor_contacts USING btree (vendor_id);


--
-- TOC entry 5392 (class 1259 OID 22887)
-- Name: ix_vendor_documents__fk_fk_vendor_documents_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_documents__fk_fk_vendor_documents_vendor ON public.vendor_documents USING btree (vendor_id);


--
-- TOC entry 5395 (class 1259 OID 22888)
-- Name: ix_vendor_qualifications__fk_fk_vendor_qualifications_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_qualifications__fk_fk_vendor_qualifications_vendor ON public.vendor_qualifications USING btree (vendor_id);


--
-- TOC entry 5398 (class 1259 OID 22889)
-- Name: ix_vendors__fk_fk_vendors_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendors__fk_fk_vendors_organization ON public.vendors USING btree (organization_id);


--
-- TOC entry 5429 (class 1259 OID 43260)
-- Name: organization_invites_org_invited_uq; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX organization_invites_org_invited_uq ON public.organization_invites USING btree (organization_id, invited_profile_id);


--
-- TOC entry 5418 (class 1259 OID 26545)
-- Name: organization_member_rates_membership_effective_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX organization_member_rates_membership_effective_idx ON public.organization_member_rates USING btree (membership_id, effective_start DESC);


--
-- TOC entry 5268 (class 1259 OID 26408)
-- Name: organization_members_org_profile_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX organization_members_org_profile_idx ON public.organization_members USING btree (organization_id, profile_id);


--
-- TOC entry 5269 (class 1259 OID 26407)
-- Name: organization_members_org_role_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX organization_members_org_role_idx ON public.organization_members USING btree (organization_id, role);


--
-- TOC entry 5408 (class 1259 OID 26502)
-- Name: organization_service_areas_org_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX organization_service_areas_org_id_idx ON public.organization_service_areas USING btree (organization_id);


--
-- TOC entry 5409 (class 1259 OID 26501)
-- Name: organization_service_areas_org_text_uq; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX organization_service_areas_org_text_uq ON public.organization_service_areas USING btree (organization_id, lower(service_area_text));


--
-- TOC entry 5422 (class 1259 OID 26577)
-- Name: project_invites_invited_profile_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX project_invites_invited_profile_id_idx ON public.project_invites USING btree (invited_profile_id);


--
-- TOC entry 5425 (class 1259 OID 26576)
-- Name: project_invites_project_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX project_invites_project_id_idx ON public.project_invites USING btree (project_id);


--
-- TOC entry 5426 (class 1259 OID 26575)
-- Name: project_invites_project_invited_uq; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX project_invites_project_invited_uq ON public.project_invites USING btree (project_id, invited_profile_id);


--
-- TOC entry 5414 (class 1259 OID 26525)
-- Name: project_service_areas_project_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX project_service_areas_project_id_idx ON public.project_service_areas USING btree (project_id);


--
-- TOC entry 5415 (class 1259 OID 26524)
-- Name: project_service_areas_project_service_uq; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX project_service_areas_project_service_uq ON public.project_service_areas USING btree (project_id, service_area_id);


--
-- TOC entry 5416 (class 1259 OID 26526)
-- Name: project_service_areas_service_area_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX project_service_areas_service_area_id_idx ON public.project_service_areas USING btree (service_area_id);


--
-- TOC entry 5668 (class 2620 OID 45484)
-- Name: notifications notifications_broadcast_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER notifications_broadcast_trigger AFTER INSERT ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.notifications_broadcast_trigger();


--
-- TOC entry 5583 (class 2620 OID 22891)
-- Name: bids trg_notify_new_bid; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_notify_new_bid AFTER INSERT ON public.bids FOR EACH ROW EXECUTE FUNCTION public.notify_new_bid();


--
-- TOC entry 5567 (class 2620 OID 22892)
-- Name: accounts_payable trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.accounts_payable FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5569 (class 2620 OID 22893)
-- Name: accounts_receivable trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.accounts_receivable FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5571 (class 2620 OID 22894)
-- Name: activity_logs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.activity_logs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5573 (class 2620 OID 22895)
-- Name: asphalt_types trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.asphalt_types FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5575 (class 2620 OID 22896)
-- Name: audit_logs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.audit_logs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5577 (class 2620 OID 22897)
-- Name: avatars trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.avatars FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5579 (class 2620 OID 22898)
-- Name: bid_packages trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.bid_packages FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5581 (class 2620 OID 22899)
-- Name: bid_vendors trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.bid_vendors FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5584 (class 2620 OID 22900)
-- Name: bids trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.bids FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5586 (class 2620 OID 22901)
-- Name: bim_models trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.bim_models FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5588 (class 2620 OID 22902)
-- Name: certifications trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.certifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5590 (class 2620 OID 22903)
-- Name: change_orders trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.change_orders FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5592 (class 2620 OID 22904)
-- Name: commitments trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.commitments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5594 (class 2620 OID 22905)
-- Name: compliance_checks trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.compliance_checks FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5596 (class 2620 OID 22906)
-- Name: compliance_tracking trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.compliance_tracking FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5598 (class 2620 OID 22907)
-- Name: cost_codes trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.cost_codes FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5600 (class 2620 OID 22908)
-- Name: crew_assignments trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.crew_assignments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5602 (class 2620 OID 22909)
-- Name: crew_members trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.crew_members FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5604 (class 2620 OID 22910)
-- Name: crews trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.crews FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5606 (class 2620 OID 22911)
-- Name: daily_logs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.daily_logs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5608 (class 2620 OID 22912)
-- Name: dashboard_configs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.dashboard_configs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5610 (class 2620 OID 22913)
-- Name: document_references trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.document_references FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5612 (class 2620 OID 22914)
-- Name: documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5614 (class 2620 OID 22915)
-- Name: drawing_versions trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.drawing_versions FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5616 (class 2620 OID 22916)
-- Name: dump_trucks trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.dump_trucks FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5618 (class 2620 OID 22917)
-- Name: employees trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.employees FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5620 (class 2620 OID 22918)
-- Name: equipment trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.equipment FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5622 (class 2620 OID 22919)
-- Name: equipment_assignments trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.equipment_assignments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5624 (class 2620 OID 22920)
-- Name: equipment_maintenance trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.equipment_maintenance FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5626 (class 2620 OID 22921)
-- Name: equipment_usage trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.equipment_usage FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5628 (class 2620 OID 22922)
-- Name: estimate_line_items trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.estimate_line_items FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5630 (class 2620 OID 22923)
-- Name: estimates trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.estimates FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5632 (class 2620 OID 22924)
-- Name: financial_documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.financial_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5634 (class 2620 OID 22925)
-- Name: general_ledger trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.general_ledger FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5636 (class 2620 OID 22926)
-- Name: hr_documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.hr_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5638 (class 2620 OID 22927)
-- Name: inspections trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.inspections FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5640 (class 2620 OID 22928)
-- Name: integration_tokens trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.integration_tokens FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5642 (class 2620 OID 22929)
-- Name: inventory_transactions trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.inventory_transactions FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5644 (class 2620 OID 22930)
-- Name: issues trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.issues FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5646 (class 2620 OID 22931)
-- Name: job_titles trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.job_titles FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5648 (class 2620 OID 22932)
-- Name: labor_records trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.labor_records FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5650 (class 2620 OID 22933)
-- Name: line_item_entries trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.line_item_entries FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5652 (class 2620 OID 22934)
-- Name: line_item_templates trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.line_item_templates FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5654 (class 2620 OID 22935)
-- Name: line_items trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.line_items FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5656 (class 2620 OID 22936)
-- Name: maps trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.maps FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5658 (class 2620 OID 22937)
-- Name: material_inventory trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.material_inventory FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5660 (class 2620 OID 22938)
-- Name: material_orders trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.material_orders FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5662 (class 2620 OID 22939)
-- Name: material_receipts trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.material_receipts FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5664 (class 2620 OID 22940)
-- Name: materials trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.materials FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5666 (class 2620 OID 22941)
-- Name: meeting_minutes trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.meeting_minutes FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5669 (class 2620 OID 22942)
-- Name: notifications trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5671 (class 2620 OID 22943)
-- Name: organization_members trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.organization_members FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5673 (class 2620 OID 22944)
-- Name: organization_projects trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.organization_projects FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5675 (class 2620 OID 22945)
-- Name: organizations trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.organizations FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5677 (class 2620 OID 22946)
-- Name: payments trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.payments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5679 (class 2620 OID 22947)
-- Name: payroll trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.payroll FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5681 (class 2620 OID 22948)
-- Name: photos trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.photos FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5683 (class 2620 OID 22949)
-- Name: prequalifications trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.prequalifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5685 (class 2620 OID 22950)
-- Name: procurement_workflows trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.procurement_workflows FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5687 (class 2620 OID 22951)
-- Name: profiles trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5689 (class 2620 OID 22952)
-- Name: progress_billings trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.progress_billings FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5691 (class 2620 OID 22953)
-- Name: projects trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5693 (class 2620 OID 22954)
-- Name: punch_lists trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.punch_lists FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5695 (class 2620 OID 22955)
-- Name: purchase_orders trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.purchase_orders FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5697 (class 2620 OID 22956)
-- Name: quality_reviews trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.quality_reviews FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5699 (class 2620 OID 22957)
-- Name: regulatory_documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.regulatory_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5701 (class 2620 OID 22958)
-- Name: reports trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.reports FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5703 (class 2620 OID 22959)
-- Name: rfis trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.rfis FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5705 (class 2620 OID 22960)
-- Name: safety_incidents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.safety_incidents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5707 (class 2620 OID 22961)
-- Name: sensor_data trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.sensor_data FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5709 (class 2620 OID 22962)
-- Name: subcontractor_agreements trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.subcontractor_agreements FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5711 (class 2620 OID 22963)
-- Name: subcontracts trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.subcontracts FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5713 (class 2620 OID 22964)
-- Name: submittals trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.submittals FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5715 (class 2620 OID 22965)
-- Name: tack_rates trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.tack_rates FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5718 (class 2620 OID 22966)
-- Name: tasks trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.tasks FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5720 (class 2620 OID 22967)
-- Name: training_records trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.training_records FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5722 (class 2620 OID 22968)
-- Name: user_projects trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.user_projects FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5724 (class 2620 OID 22969)
-- Name: vendor_bid_packages trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendor_bid_packages FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5726 (class 2620 OID 22970)
-- Name: vendor_contacts trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendor_contacts FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5728 (class 2620 OID 22971)
-- Name: vendor_documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendor_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5730 (class 2620 OID 22972)
-- Name: vendor_qualifications trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendor_qualifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5732 (class 2620 OID 22973)
-- Name: vendors trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendors FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5734 (class 2620 OID 22974)
-- Name: wbs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.wbs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5565 (class 2620 OID 22975)
-- Name: workflows trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.workflows FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- TOC entry 5568 (class 2620 OID 22976)
-- Name: accounts_payable trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.accounts_payable FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5570 (class 2620 OID 22977)
-- Name: accounts_receivable trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.accounts_receivable FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5572 (class 2620 OID 22978)
-- Name: activity_logs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.activity_logs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5574 (class 2620 OID 22979)
-- Name: asphalt_types trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.asphalt_types FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5576 (class 2620 OID 22980)
-- Name: audit_logs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.audit_logs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5578 (class 2620 OID 22981)
-- Name: avatars trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.avatars FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5580 (class 2620 OID 22982)
-- Name: bid_packages trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.bid_packages FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5582 (class 2620 OID 22983)
-- Name: bid_vendors trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.bid_vendors FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5585 (class 2620 OID 22984)
-- Name: bids trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.bids FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5587 (class 2620 OID 22985)
-- Name: bim_models trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.bim_models FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5589 (class 2620 OID 22986)
-- Name: certifications trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.certifications FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5591 (class 2620 OID 22987)
-- Name: change_orders trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.change_orders FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5593 (class 2620 OID 22988)
-- Name: commitments trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.commitments FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5595 (class 2620 OID 22989)
-- Name: compliance_checks trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.compliance_checks FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5597 (class 2620 OID 22990)
-- Name: compliance_tracking trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.compliance_tracking FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5599 (class 2620 OID 22991)
-- Name: cost_codes trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.cost_codes FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5601 (class 2620 OID 22992)
-- Name: crew_assignments trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.crew_assignments FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5603 (class 2620 OID 22993)
-- Name: crew_members trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.crew_members FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5605 (class 2620 OID 22994)
-- Name: crews trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.crews FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5607 (class 2620 OID 22995)
-- Name: daily_logs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.daily_logs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5609 (class 2620 OID 22996)
-- Name: dashboard_configs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.dashboard_configs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5611 (class 2620 OID 22997)
-- Name: document_references trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.document_references FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5613 (class 2620 OID 22998)
-- Name: documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5615 (class 2620 OID 22999)
-- Name: drawing_versions trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.drawing_versions FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5617 (class 2620 OID 23000)
-- Name: dump_trucks trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.dump_trucks FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5619 (class 2620 OID 23001)
-- Name: employees trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.employees FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5621 (class 2620 OID 23002)
-- Name: equipment trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.equipment FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5623 (class 2620 OID 23003)
-- Name: equipment_assignments trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.equipment_assignments FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5625 (class 2620 OID 23004)
-- Name: equipment_maintenance trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.equipment_maintenance FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5627 (class 2620 OID 23005)
-- Name: equipment_usage trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.equipment_usage FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5629 (class 2620 OID 23006)
-- Name: estimate_line_items trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.estimate_line_items FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5631 (class 2620 OID 23007)
-- Name: estimates trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.estimates FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5633 (class 2620 OID 23008)
-- Name: financial_documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.financial_documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5635 (class 2620 OID 23009)
-- Name: general_ledger trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.general_ledger FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5637 (class 2620 OID 23010)
-- Name: hr_documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.hr_documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5639 (class 2620 OID 23011)
-- Name: inspections trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.inspections FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5641 (class 2620 OID 23012)
-- Name: integration_tokens trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.integration_tokens FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5643 (class 2620 OID 23013)
-- Name: inventory_transactions trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.inventory_transactions FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5645 (class 2620 OID 23014)
-- Name: issues trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.issues FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5647 (class 2620 OID 23015)
-- Name: job_titles trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.job_titles FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5649 (class 2620 OID 23016)
-- Name: labor_records trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.labor_records FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5651 (class 2620 OID 23017)
-- Name: line_item_entries trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.line_item_entries FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5653 (class 2620 OID 23018)
-- Name: line_item_templates trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.line_item_templates FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5655 (class 2620 OID 23019)
-- Name: line_items trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.line_items FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5657 (class 2620 OID 23020)
-- Name: maps trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.maps FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5659 (class 2620 OID 23021)
-- Name: material_inventory trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.material_inventory FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5661 (class 2620 OID 23022)
-- Name: material_orders trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.material_orders FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5663 (class 2620 OID 23023)
-- Name: material_receipts trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.material_receipts FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5665 (class 2620 OID 23024)
-- Name: materials trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.materials FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5667 (class 2620 OID 23025)
-- Name: meeting_minutes trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.meeting_minutes FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5670 (class 2620 OID 23026)
-- Name: notifications trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5672 (class 2620 OID 23027)
-- Name: organization_members trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.organization_members FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5674 (class 2620 OID 23028)
-- Name: organization_projects trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.organization_projects FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5676 (class 2620 OID 23029)
-- Name: organizations trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.organizations FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5678 (class 2620 OID 23030)
-- Name: payments trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.payments FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5680 (class 2620 OID 23031)
-- Name: payroll trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.payroll FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5682 (class 2620 OID 23032)
-- Name: photos trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.photos FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5684 (class 2620 OID 23033)
-- Name: prequalifications trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.prequalifications FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5686 (class 2620 OID 23034)
-- Name: procurement_workflows trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.procurement_workflows FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5688 (class 2620 OID 23035)
-- Name: profiles trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5690 (class 2620 OID 23036)
-- Name: progress_billings trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.progress_billings FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5692 (class 2620 OID 23037)
-- Name: projects trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.projects FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5694 (class 2620 OID 23038)
-- Name: punch_lists trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.punch_lists FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5696 (class 2620 OID 23039)
-- Name: purchase_orders trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.purchase_orders FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5698 (class 2620 OID 23040)
-- Name: quality_reviews trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.quality_reviews FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5700 (class 2620 OID 23041)
-- Name: regulatory_documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.regulatory_documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5702 (class 2620 OID 23042)
-- Name: reports trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.reports FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5704 (class 2620 OID 23043)
-- Name: rfis trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.rfis FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5706 (class 2620 OID 23044)
-- Name: safety_incidents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.safety_incidents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5708 (class 2620 OID 23045)
-- Name: sensor_data trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.sensor_data FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5710 (class 2620 OID 23046)
-- Name: subcontractor_agreements trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.subcontractor_agreements FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5712 (class 2620 OID 23047)
-- Name: subcontracts trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.subcontracts FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5714 (class 2620 OID 23048)
-- Name: submittals trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.submittals FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5716 (class 2620 OID 23049)
-- Name: tack_rates trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.tack_rates FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5717 (class 2620 OID 23050)
-- Name: task_dependencies trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.task_dependencies FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5719 (class 2620 OID 23051)
-- Name: tasks trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.tasks FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5721 (class 2620 OID 23052)
-- Name: training_records trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.training_records FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5723 (class 2620 OID 23053)
-- Name: user_projects trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.user_projects FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5725 (class 2620 OID 23054)
-- Name: vendor_bid_packages trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendor_bid_packages FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5727 (class 2620 OID 23055)
-- Name: vendor_contacts trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendor_contacts FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5729 (class 2620 OID 23056)
-- Name: vendor_documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendor_documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5731 (class 2620 OID 23057)
-- Name: vendor_qualifications trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendor_qualifications FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5733 (class 2620 OID 23058)
-- Name: vendors trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendors FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5735 (class 2620 OID 23059)
-- Name: wbs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.wbs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5566 (class 2620 OID 23060)
-- Name: workflows trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.workflows FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- TOC entry 5434 (class 2606 OID 23061)
-- Name: activity_logs fk_activity_logs_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.activity_logs
    ADD CONSTRAINT fk_activity_logs_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- TOC entry 5432 (class 2606 OID 23066)
-- Name: accounts_payable fk_ap_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.accounts_payable
    ADD CONSTRAINT fk_ap_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5433 (class 2606 OID 23071)
-- Name: accounts_receivable fk_ar_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.accounts_receivable
    ADD CONSTRAINT fk_ar_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5435 (class 2606 OID 23076)
-- Name: audit_logs fk_audit_logs_performed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT fk_audit_logs_performed_by FOREIGN KEY (performed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5436 (class 2606 OID 23081)
-- Name: audit_logs fk_audit_logs_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT fk_audit_logs_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5437 (class 2606 OID 23086)
-- Name: bid_packages fk_bid_packages_created_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_packages
    ADD CONSTRAINT fk_bid_packages_created_by FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5438 (class 2606 OID 23091)
-- Name: bid_packages fk_bid_packages_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_packages
    ADD CONSTRAINT fk_bid_packages_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5439 (class 2606 OID 23096)
-- Name: bid_vendors fk_bid_vendors_bid_package; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_vendors
    ADD CONSTRAINT fk_bid_vendors_bid_package FOREIGN KEY (bid_package_id) REFERENCES public.bid_packages(id) ON DELETE CASCADE;


--
-- TOC entry 5440 (class 2606 OID 23101)
-- Name: bid_vendors fk_bid_vendors_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_vendors
    ADD CONSTRAINT fk_bid_vendors_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- TOC entry 5441 (class 2606 OID 23106)
-- Name: bids fk_bids_bid_package; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bids
    ADD CONSTRAINT fk_bids_bid_package FOREIGN KEY (bid_package_id) REFERENCES public.bid_packages(id) ON DELETE CASCADE;


--
-- TOC entry 5442 (class 2606 OID 23111)
-- Name: bids fk_bids_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bids
    ADD CONSTRAINT fk_bids_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- TOC entry 5443 (class 2606 OID 23116)
-- Name: bim_models fk_bim_models_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bim_models
    ADD CONSTRAINT fk_bim_models_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5444 (class 2606 OID 23121)
-- Name: certifications fk_certifications_employee; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.certifications
    ADD CONSTRAINT fk_certifications_employee FOREIGN KEY (employee_id) REFERENCES public.employees(id) ON DELETE CASCADE;


--
-- TOC entry 5445 (class 2606 OID 23126)
-- Name: change_orders fk_change_orders_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.change_orders
    ADD CONSTRAINT fk_change_orders_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5446 (class 2606 OID 23131)
-- Name: commitments fk_commitments_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.commitments
    ADD CONSTRAINT fk_commitments_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5447 (class 2606 OID 23136)
-- Name: commitments fk_commitments_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.commitments
    ADD CONSTRAINT fk_commitments_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE SET NULL;


--
-- TOC entry 5448 (class 2606 OID 23141)
-- Name: compliance_checks fk_compliance_checks_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compliance_checks
    ADD CONSTRAINT fk_compliance_checks_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5449 (class 2606 OID 23146)
-- Name: compliance_tracking fk_compliance_tracking_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compliance_tracking
    ADD CONSTRAINT fk_compliance_tracking_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5450 (class 2606 OID 23151)
-- Name: crew_assignments fk_crew_assignments_crew; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_assignments
    ADD CONSTRAINT fk_crew_assignments_crew FOREIGN KEY (crew_id) REFERENCES public.crews(id) ON DELETE CASCADE;


--
-- TOC entry 5451 (class 2606 OID 23156)
-- Name: crew_assignments fk_crew_assignments_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_assignments
    ADD CONSTRAINT fk_crew_assignments_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- TOC entry 5452 (class 2606 OID 23161)
-- Name: crew_members fk_crew_members_crew; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_members
    ADD CONSTRAINT fk_crew_members_crew FOREIGN KEY (crew_id) REFERENCES public.crews(id) ON DELETE CASCADE;


--
-- TOC entry 5453 (class 2606 OID 23166)
-- Name: crew_members fk_crew_members_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_members
    ADD CONSTRAINT fk_crew_members_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5454 (class 2606 OID 23171)
-- Name: crews fk_crews_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crews
    ADD CONSTRAINT fk_crews_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5455 (class 2606 OID 23176)
-- Name: daily_logs fk_daily_logs_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.daily_logs
    ADD CONSTRAINT fk_daily_logs_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5456 (class 2606 OID 23181)
-- Name: dashboard_configs fk_dashboard_configs_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dashboard_configs
    ADD CONSTRAINT fk_dashboard_configs_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- TOC entry 5457 (class 2606 OID 23186)
-- Name: document_references fk_document_references_document; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.document_references
    ADD CONSTRAINT fk_document_references_document FOREIGN KEY (document_id) REFERENCES public.documents(id) ON DELETE CASCADE;


--
-- TOC entry 5458 (class 2606 OID 23191)
-- Name: documents fk_documents_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT fk_documents_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5459 (class 2606 OID 23196)
-- Name: documents fk_documents_uploaded_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT fk_documents_uploaded_by FOREIGN KEY (uploaded_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5460 (class 2606 OID 23201)
-- Name: drawing_versions fk_drawing_versions_document; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.drawing_versions
    ADD CONSTRAINT fk_drawing_versions_document FOREIGN KEY (document_id) REFERENCES public.documents(id) ON DELETE CASCADE;


--
-- TOC entry 5461 (class 2606 OID 23206)
-- Name: drawing_versions fk_drawing_versions_uploaded_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.drawing_versions
    ADD CONSTRAINT fk_drawing_versions_uploaded_by FOREIGN KEY (uploaded_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5462 (class 2606 OID 23211)
-- Name: dump_trucks fk_dump_trucks_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dump_trucks
    ADD CONSTRAINT fk_dump_trucks_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- TOC entry 5463 (class 2606 OID 23216)
-- Name: employees fk_employees_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.employees
    ADD CONSTRAINT fk_employees_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- TOC entry 5464 (class 2606 OID 23221)
-- Name: employees fk_employees_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.employees
    ADD CONSTRAINT fk_employees_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5466 (class 2606 OID 23226)
-- Name: equipment_assignments fk_equipment_assignments_assigned_to; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_assignments
    ADD CONSTRAINT fk_equipment_assignments_assigned_to FOREIGN KEY (assigned_to) REFERENCES public.crews(id) ON DELETE SET NULL;


--
-- TOC entry 5467 (class 2606 OID 23231)
-- Name: equipment_assignments fk_equipment_assignments_equipment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_assignments
    ADD CONSTRAINT fk_equipment_assignments_equipment FOREIGN KEY (equipment_id) REFERENCES public.equipment(id) ON DELETE CASCADE;


--
-- TOC entry 5468 (class 2606 OID 23236)
-- Name: equipment_assignments fk_equipment_assignments_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_assignments
    ADD CONSTRAINT fk_equipment_assignments_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5469 (class 2606 OID 23241)
-- Name: equipment_maintenance fk_equipment_maintenance_equipment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_maintenance
    ADD CONSTRAINT fk_equipment_maintenance_equipment FOREIGN KEY (equipment_id) REFERENCES public.equipment(id) ON DELETE CASCADE;


--
-- TOC entry 5470 (class 2606 OID 23246)
-- Name: equipment_maintenance fk_equipment_maintenance_performed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_maintenance
    ADD CONSTRAINT fk_equipment_maintenance_performed_by FOREIGN KEY (performed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5465 (class 2606 OID 23251)
-- Name: equipment fk_equipment_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment
    ADD CONSTRAINT fk_equipment_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- TOC entry 5471 (class 2606 OID 23256)
-- Name: equipment_usage fk_equipment_usage_equipment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_usage
    ADD CONSTRAINT fk_equipment_usage_equipment FOREIGN KEY (equipment_id) REFERENCES public.equipment(id) ON DELETE CASCADE;


--
-- TOC entry 5472 (class 2606 OID 23261)
-- Name: estimate_line_items fk_estimate_line_items_cost_code; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimate_line_items
    ADD CONSTRAINT fk_estimate_line_items_cost_code FOREIGN KEY (cost_code_id) REFERENCES public.cost_codes(id) ON DELETE SET NULL;


--
-- TOC entry 5473 (class 2606 OID 23266)
-- Name: estimate_line_items fk_estimate_line_items_estimate; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimate_line_items
    ADD CONSTRAINT fk_estimate_line_items_estimate FOREIGN KEY (estimate_id) REFERENCES public.estimates(id) ON DELETE CASCADE;


--
-- TOC entry 5474 (class 2606 OID 23271)
-- Name: estimates fk_estimates_created_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimates
    ADD CONSTRAINT fk_estimates_created_by FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5475 (class 2606 OID 23276)
-- Name: estimates fk_estimates_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimates
    ADD CONSTRAINT fk_estimates_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5476 (class 2606 OID 23281)
-- Name: financial_documents fk_financial_documents_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.financial_documents
    ADD CONSTRAINT fk_financial_documents_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5477 (class 2606 OID 23286)
-- Name: general_ledger fk_gl_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.general_ledger
    ADD CONSTRAINT fk_gl_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5478 (class 2606 OID 23291)
-- Name: hr_documents fk_hr_documents_employee; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.hr_documents
    ADD CONSTRAINT fk_hr_documents_employee FOREIGN KEY (employee_id) REFERENCES public.employees(id) ON DELETE CASCADE;


--
-- TOC entry 5479 (class 2606 OID 23296)
-- Name: inspections fk_inspections_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inspections
    ADD CONSTRAINT fk_inspections_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5480 (class 2606 OID 23301)
-- Name: integration_tokens fk_integration_tokens_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.integration_tokens
    ADD CONSTRAINT fk_integration_tokens_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- TOC entry 5481 (class 2606 OID 23306)
-- Name: inventory_transactions fk_inventory_transactions_material; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inventory_transactions
    ADD CONSTRAINT fk_inventory_transactions_material FOREIGN KEY (material_id) REFERENCES public.materials(id) ON DELETE SET NULL;


--
-- TOC entry 5482 (class 2606 OID 23311)
-- Name: issues fk_issues_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.issues
    ADD CONSTRAINT fk_issues_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5483 (class 2606 OID 23316)
-- Name: issues fk_issues_reported_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.issues
    ADD CONSTRAINT fk_issues_reported_by FOREIGN KEY (reported_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5484 (class 2606 OID 23321)
-- Name: labor_records fk_labor_records_line_item; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.labor_records
    ADD CONSTRAINT fk_labor_records_line_item FOREIGN KEY (line_item_id) REFERENCES public.line_items(id) ON DELETE CASCADE;


--
-- TOC entry 5485 (class 2606 OID 23326)
-- Name: line_item_entries fk_line_item_entries_line_item; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_item_entries
    ADD CONSTRAINT fk_line_item_entries_line_item FOREIGN KEY (line_item_id) REFERENCES public.line_items(id) ON DELETE CASCADE;


--
-- TOC entry 5486 (class 2606 OID 23331)
-- Name: line_item_templates fk_line_item_templates_created_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_item_templates
    ADD CONSTRAINT fk_line_item_templates_created_by FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5487 (class 2606 OID 23336)
-- Name: line_items fk_line_items_cost_code; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_cost_code FOREIGN KEY (cost_code_id) REFERENCES public.cost_codes(id) ON DELETE SET NULL;


--
-- TOC entry 5488 (class 2606 OID 23341)
-- Name: line_items fk_line_items_map; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_map FOREIGN KEY (map_id) REFERENCES public.maps(id) ON DELETE CASCADE;


--
-- TOC entry 5489 (class 2606 OID 23346)
-- Name: line_items fk_line_items_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5490 (class 2606 OID 23351)
-- Name: line_items fk_line_items_template; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_template FOREIGN KEY (template_id) REFERENCES public.line_item_templates(id) ON DELETE SET NULL;


--
-- TOC entry 5491 (class 2606 OID 23356)
-- Name: line_items fk_line_items_wbs; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_wbs FOREIGN KEY (wbs_id) REFERENCES public.wbs(id) ON DELETE CASCADE;


--
-- TOC entry 5492 (class 2606 OID 23361)
-- Name: maps fk_maps_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.maps
    ADD CONSTRAINT fk_maps_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5493 (class 2606 OID 23366)
-- Name: maps fk_maps_wbs; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.maps
    ADD CONSTRAINT fk_maps_wbs FOREIGN KEY (wbs_id) REFERENCES public.wbs(id) ON DELETE CASCADE;


--
-- TOC entry 5494 (class 2606 OID 23371)
-- Name: material_inventory fk_material_inventory_material; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_inventory
    ADD CONSTRAINT fk_material_inventory_material FOREIGN KEY (material_id) REFERENCES public.materials(id) ON DELETE CASCADE;


--
-- TOC entry 5495 (class 2606 OID 23376)
-- Name: material_inventory fk_material_inventory_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_inventory
    ADD CONSTRAINT fk_material_inventory_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- TOC entry 5496 (class 2606 OID 23381)
-- Name: material_orders fk_material_orders_material; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_orders
    ADD CONSTRAINT fk_material_orders_material FOREIGN KEY (material_id) REFERENCES public.materials(id) ON DELETE CASCADE;


--
-- TOC entry 5497 (class 2606 OID 23386)
-- Name: material_orders fk_material_orders_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_orders
    ADD CONSTRAINT fk_material_orders_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5498 (class 2606 OID 23391)
-- Name: material_receipts fk_material_receipts_material_order; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_receipts
    ADD CONSTRAINT fk_material_receipts_material_order FOREIGN KEY (material_order_id) REFERENCES public.material_orders(id) ON DELETE CASCADE;


--
-- TOC entry 5499 (class 2606 OID 23396)
-- Name: material_receipts fk_material_receipts_received_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_receipts
    ADD CONSTRAINT fk_material_receipts_received_by FOREIGN KEY (received_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5500 (class 2606 OID 23401)
-- Name: materials fk_materials_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.materials
    ADD CONSTRAINT fk_materials_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- TOC entry 5501 (class 2606 OID 23406)
-- Name: meeting_minutes fk_meeting_minutes_created_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.meeting_minutes
    ADD CONSTRAINT fk_meeting_minutes_created_by FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5502 (class 2606 OID 23411)
-- Name: meeting_minutes fk_meeting_minutes_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.meeting_minutes
    ADD CONSTRAINT fk_meeting_minutes_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5504 (class 2606 OID 23416)
-- Name: organization_members fk_org_members_org; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT fk_org_members_org FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE;


--
-- TOC entry 5505 (class 2606 OID 23421)
-- Name: organization_members fk_org_members_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT fk_org_members_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- TOC entry 5506 (class 2606 OID 23426)
-- Name: organization_projects fk_org_projects_org; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_projects
    ADD CONSTRAINT fk_org_projects_org FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE;


--
-- TOC entry 5507 (class 2606 OID 23431)
-- Name: organization_projects fk_org_projects_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_projects
    ADD CONSTRAINT fk_org_projects_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5508 (class 2606 OID 23436)
-- Name: payments fk_payments_commitment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT fk_payments_commitment FOREIGN KEY (commitment_id) REFERENCES public.commitments(id) ON DELETE SET NULL;


--
-- TOC entry 5509 (class 2606 OID 23441)
-- Name: payments fk_payments_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT fk_payments_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5510 (class 2606 OID 23446)
-- Name: payroll fk_payroll_employee; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payroll
    ADD CONSTRAINT fk_payroll_employee FOREIGN KEY (employee_id) REFERENCES public.employees(id) ON DELETE CASCADE;


--
-- TOC entry 5511 (class 2606 OID 23451)
-- Name: photos fk_photos_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.photos
    ADD CONSTRAINT fk_photos_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5512 (class 2606 OID 23456)
-- Name: photos fk_photos_uploaded_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.photos
    ADD CONSTRAINT fk_photos_uploaded_by FOREIGN KEY (uploaded_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5513 (class 2606 OID 23461)
-- Name: prequalifications fk_prequalifications_reviewed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.prequalifications
    ADD CONSTRAINT fk_prequalifications_reviewed_by FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5514 (class 2606 OID 23466)
-- Name: prequalifications fk_prequalifications_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.prequalifications
    ADD CONSTRAINT fk_prequalifications_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- TOC entry 5515 (class 2606 OID 23471)
-- Name: procurement_workflows fk_procurement_workflows_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procurement_workflows
    ADD CONSTRAINT fk_procurement_workflows_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5516 (class 2606 OID 26431)
-- Name: profiles fk_profiles_avatar_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT fk_profiles_avatar_id FOREIGN KEY (avatar_id) REFERENCES public.avatars(id);


--
-- TOC entry 5517 (class 2606 OID 23476)
-- Name: profiles fk_profiles_job_titles; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT fk_profiles_job_titles FOREIGN KEY (job_title_id) REFERENCES public.job_titles(id) ON DELETE SET NULL;


--
-- TOC entry 5518 (class 2606 OID 23481)
-- Name: profiles fk_profiles_organizations; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT fk_profiles_organizations FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- TOC entry 5519 (class 2606 OID 23486)
-- Name: progress_billings fk_progress_billings_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.progress_billings
    ADD CONSTRAINT fk_progress_billings_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5523 (class 2606 OID 23491)
-- Name: projects fk_projects_organizations; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT fk_projects_organizations FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- TOC entry 5524 (class 2606 OID 23496)
-- Name: punch_lists fk_punch_lists_assigned_to; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.punch_lists
    ADD CONSTRAINT fk_punch_lists_assigned_to FOREIGN KEY (assigned_to) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5525 (class 2606 OID 23501)
-- Name: punch_lists fk_punch_lists_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.punch_lists
    ADD CONSTRAINT fk_punch_lists_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5526 (class 2606 OID 23506)
-- Name: purchase_orders fk_purchase_orders_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.purchase_orders
    ADD CONSTRAINT fk_purchase_orders_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5527 (class 2606 OID 23511)
-- Name: purchase_orders fk_purchase_orders_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.purchase_orders
    ADD CONSTRAINT fk_purchase_orders_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE SET NULL;


--
-- TOC entry 5528 (class 2606 OID 23516)
-- Name: quality_reviews fk_quality_reviews_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.quality_reviews
    ADD CONSTRAINT fk_quality_reviews_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5529 (class 2606 OID 23521)
-- Name: quality_reviews fk_quality_reviews_reviewer; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.quality_reviews
    ADD CONSTRAINT fk_quality_reviews_reviewer FOREIGN KEY (reviewer) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5530 (class 2606 OID 23526)
-- Name: regulatory_documents fk_regulatory_documents_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regulatory_documents
    ADD CONSTRAINT fk_regulatory_documents_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5531 (class 2606 OID 23531)
-- Name: reports fk_reports_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reports
    ADD CONSTRAINT fk_reports_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5532 (class 2606 OID 23536)
-- Name: rfis fk_rfis_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rfis
    ADD CONSTRAINT fk_rfis_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5533 (class 2606 OID 23541)
-- Name: rfis fk_rfis_reviewed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rfis
    ADD CONSTRAINT fk_rfis_reviewed_by FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5534 (class 2606 OID 23546)
-- Name: rfis fk_rfis_submitted_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rfis
    ADD CONSTRAINT fk_rfis_submitted_by FOREIGN KEY (submitted_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5535 (class 2606 OID 23551)
-- Name: safety_incidents fk_safety_incidents_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.safety_incidents
    ADD CONSTRAINT fk_safety_incidents_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5536 (class 2606 OID 23556)
-- Name: safety_incidents fk_safety_incidents_reported_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.safety_incidents
    ADD CONSTRAINT fk_safety_incidents_reported_by FOREIGN KEY (reported_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5537 (class 2606 OID 23561)
-- Name: sensor_data fk_sensor_data_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.sensor_data
    ADD CONSTRAINT fk_sensor_data_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5538 (class 2606 OID 23566)
-- Name: subcontractor_agreements fk_subcontractor_agreements_subcontract; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontractor_agreements
    ADD CONSTRAINT fk_subcontractor_agreements_subcontract FOREIGN KEY (subcontract_id) REFERENCES public.subcontracts(id) ON DELETE CASCADE;


--
-- TOC entry 5539 (class 2606 OID 23571)
-- Name: subcontracts fk_subcontracts_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontracts
    ADD CONSTRAINT fk_subcontracts_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5540 (class 2606 OID 23576)
-- Name: subcontracts fk_subcontracts_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontracts
    ADD CONSTRAINT fk_subcontracts_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- TOC entry 5541 (class 2606 OID 23581)
-- Name: submittals fk_submittals_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.submittals
    ADD CONSTRAINT fk_submittals_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5542 (class 2606 OID 23586)
-- Name: submittals fk_submittals_reviewed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.submittals
    ADD CONSTRAINT fk_submittals_reviewed_by FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5543 (class 2606 OID 23591)
-- Name: submittals fk_submittals_submitted_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.submittals
    ADD CONSTRAINT fk_submittals_submitted_by FOREIGN KEY (submitted_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- TOC entry 5544 (class 2606 OID 23596)
-- Name: tack_rates fk_tack_rates_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tack_rates
    ADD CONSTRAINT fk_tack_rates_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5548 (class 2606 OID 23601)
-- Name: training_records fk_training_records_employee; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.training_records
    ADD CONSTRAINT fk_training_records_employee FOREIGN KEY (employee_id) REFERENCES public.employees(id) ON DELETE CASCADE;


--
-- TOC entry 5549 (class 2606 OID 23606)
-- Name: user_projects fk_user_projects_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_projects
    ADD CONSTRAINT fk_user_projects_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5550 (class 2606 OID 23611)
-- Name: user_projects fk_user_projects_user; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_projects
    ADD CONSTRAINT fk_user_projects_user FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- TOC entry 5551 (class 2606 OID 23616)
-- Name: vendor_bid_packages fk_vendor_bid_packages_bid_package; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_bid_packages
    ADD CONSTRAINT fk_vendor_bid_packages_bid_package FOREIGN KEY (bid_package_id) REFERENCES public.bid_packages(id) ON DELETE CASCADE;


--
-- TOC entry 5552 (class 2606 OID 23621)
-- Name: vendor_bid_packages fk_vendor_bid_packages_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_bid_packages
    ADD CONSTRAINT fk_vendor_bid_packages_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- TOC entry 5553 (class 2606 OID 23626)
-- Name: vendor_contacts fk_vendor_contacts_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_contacts
    ADD CONSTRAINT fk_vendor_contacts_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- TOC entry 5554 (class 2606 OID 23631)
-- Name: vendor_documents fk_vendor_documents_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_documents
    ADD CONSTRAINT fk_vendor_documents_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- TOC entry 5555 (class 2606 OID 23636)
-- Name: vendor_qualifications fk_vendor_qualifications_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_qualifications
    ADD CONSTRAINT fk_vendor_qualifications_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- TOC entry 5556 (class 2606 OID 23641)
-- Name: vendors fk_vendors_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendors
    ADD CONSTRAINT fk_vendors_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- TOC entry 5557 (class 2606 OID 23646)
-- Name: wbs fk_wbs_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wbs
    ADD CONSTRAINT fk_wbs_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5503 (class 2606 OID 23651)
-- Name: notifications notifications_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id);


--
-- TOC entry 5561 (class 2606 OID 26539)
-- Name: organization_member_rates organization_member_rates_membership_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_member_rates
    ADD CONSTRAINT organization_member_rates_membership_id_fkey FOREIGN KEY (membership_id) REFERENCES public.organization_members(id) ON DELETE CASCADE;


--
-- TOC entry 5558 (class 2606 OID 26495)
-- Name: organization_service_areas organization_service_areas_organization_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_service_areas
    ADD CONSTRAINT organization_service_areas_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE;


--
-- TOC entry 5520 (class 2606 OID 23656)
-- Name: project_inspectors project_inspectors_assigned_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_inspectors
    ADD CONSTRAINT project_inspectors_assigned_by_fkey FOREIGN KEY (assigned_by) REFERENCES public.profiles(id);


--
-- TOC entry 5521 (class 2606 OID 23661)
-- Name: project_inspectors project_inspectors_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_inspectors
    ADD CONSTRAINT project_inspectors_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id);


--
-- TOC entry 5522 (class 2606 OID 23666)
-- Name: project_inspectors project_inspectors_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_inspectors
    ADD CONSTRAINT project_inspectors_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id);


--
-- TOC entry 5562 (class 2606 OID 26567)
-- Name: project_invites project_invites_invited_by_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_invites
    ADD CONSTRAINT project_invites_invited_by_profile_id_fkey FOREIGN KEY (invited_by_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- TOC entry 5563 (class 2606 OID 26562)
-- Name: project_invites project_invites_invited_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_invites
    ADD CONSTRAINT project_invites_invited_profile_id_fkey FOREIGN KEY (invited_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- TOC entry 5564 (class 2606 OID 26557)
-- Name: project_invites project_invites_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_invites
    ADD CONSTRAINT project_invites_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5559 (class 2606 OID 26512)
-- Name: project_service_areas project_service_areas_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_service_areas
    ADD CONSTRAINT project_service_areas_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- TOC entry 5560 (class 2606 OID 26517)
-- Name: project_service_areas project_service_areas_service_area_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_service_areas
    ADD CONSTRAINT project_service_areas_service_area_id_fkey FOREIGN KEY (service_area_id) REFERENCES public.organization_service_areas(id) ON DELETE CASCADE;


--
-- TOC entry 5545 (class 2606 OID 23671)
-- Name: task_dependencies task_dependencies_depends_on_task_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.task_dependencies
    ADD CONSTRAINT task_dependencies_depends_on_task_id_fkey FOREIGN KEY (depends_on_task_id) REFERENCES public.tasks(id);


--
-- TOC entry 5546 (class 2606 OID 23676)
-- Name: task_dependencies task_dependencies_task_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.task_dependencies
    ADD CONSTRAINT task_dependencies_task_id_fkey FOREIGN KEY (task_id) REFERENCES public.tasks(id);


--
-- TOC entry 5547 (class 2606 OID 23681)
-- Name: tasks tasks_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tasks
    ADD CONSTRAINT tasks_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id);


--
-- TOC entry 5974 (class 0 OID 21143)
-- Dependencies: 346
-- Name: accounts_payable; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.accounts_payable ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5975 (class 0 OID 21153)
-- Dependencies: 347
-- Name: accounts_receivable; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.accounts_receivable ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5976 (class 0 OID 21163)
-- Dependencies: 348
-- Name: activity_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.activity_logs ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5977 (class 0 OID 21174)
-- Dependencies: 349
-- Name: asphalt_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.asphalt_types ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6060 (class 0 OID 22221)
-- Dependencies: 436
-- Name: audit_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5978 (class 0 OID 21184)
-- Dependencies: 350
-- Name: audit_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5979 (class 0 OID 21195)
-- Dependencies: 351
-- Name: avatars; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.avatars ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5980 (class 0 OID 21205)
-- Dependencies: 352
-- Name: bid_packages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bid_packages ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5981 (class 0 OID 21215)
-- Dependencies: 353
-- Name: bid_vendors; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bid_vendors ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5982 (class 0 OID 21224)
-- Dependencies: 354
-- Name: bids; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bids ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5983 (class 0 OID 21235)
-- Dependencies: 355
-- Name: bim_models; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bim_models ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5984 (class 0 OID 21246)
-- Dependencies: 356
-- Name: certifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.certifications ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5985 (class 0 OID 21256)
-- Dependencies: 357
-- Name: change_orders; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.change_orders ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5986 (class 0 OID 21266)
-- Dependencies: 358
-- Name: commitments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.commitments ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5987 (class 0 OID 21276)
-- Dependencies: 359
-- Name: compliance_checks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5988 (class 0 OID 21286)
-- Dependencies: 360
-- Name: compliance_tracking; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.compliance_tracking ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5989 (class 0 OID 21296)
-- Dependencies: 361
-- Name: cost_codes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.cost_codes ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5990 (class 0 OID 21306)
-- Dependencies: 362
-- Name: crew_assignments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crew_assignments ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5991 (class 0 OID 21314)
-- Dependencies: 363
-- Name: crew_members; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crew_members ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5992 (class 0 OID 21329)
-- Dependencies: 364
-- Name: crews; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crews ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5993 (class 0 OID 21339)
-- Dependencies: 365
-- Name: daily_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.daily_logs ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5994 (class 0 OID 21349)
-- Dependencies: 366
-- Name: dashboard_configs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.dashboard_configs ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5995 (class 0 OID 21359)
-- Dependencies: 367
-- Name: document_references; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.document_references ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5996 (class 0 OID 21369)
-- Dependencies: 368
-- Name: documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5997 (class 0 OID 21380)
-- Dependencies: 369
-- Name: drawing_versions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.drawing_versions ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5998 (class 0 OID 21391)
-- Dependencies: 370
-- Name: dump_trucks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.dump_trucks ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5999 (class 0 OID 21401)
-- Dependencies: 371
-- Name: employees; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.employees ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6000 (class 0 OID 21411)
-- Dependencies: 372
-- Name: equipment; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.equipment ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6001 (class 0 OID 21421)
-- Dependencies: 373
-- Name: equipment_assignments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.equipment_assignments ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6002 (class 0 OID 21431)
-- Dependencies: 374
-- Name: equipment_maintenance; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.equipment_maintenance ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6003 (class 0 OID 21441)
-- Dependencies: 375
-- Name: equipment_usage; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.equipment_usage ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6004 (class 0 OID 21451)
-- Dependencies: 376
-- Name: estimate_line_items; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.estimate_line_items ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6005 (class 0 OID 21461)
-- Dependencies: 377
-- Name: estimates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.estimates ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6006 (class 0 OID 21471)
-- Dependencies: 378
-- Name: financial_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.financial_documents ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6007 (class 0 OID 21482)
-- Dependencies: 379
-- Name: general_ledger; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.general_ledger ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6008 (class 0 OID 21492)
-- Dependencies: 380
-- Name: hr_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.hr_documents ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6009 (class 0 OID 21503)
-- Dependencies: 381
-- Name: inspections; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.inspections ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6010 (class 0 OID 21513)
-- Dependencies: 382
-- Name: integration_tokens; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.integration_tokens ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6011 (class 0 OID 21523)
-- Dependencies: 383
-- Name: inventory_transactions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.inventory_transactions ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6012 (class 0 OID 21533)
-- Dependencies: 384
-- Name: issues; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.issues ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6013 (class 0 OID 21544)
-- Dependencies: 385
-- Name: job_titles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.job_titles ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6014 (class 0 OID 21554)
-- Dependencies: 386
-- Name: labor_records; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.labor_records ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6015 (class 0 OID 21564)
-- Dependencies: 387
-- Name: line_item_entries; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.line_item_entries ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6016 (class 0 OID 21574)
-- Dependencies: 388
-- Name: line_item_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.line_item_templates ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6017 (class 0 OID 21584)
-- Dependencies: 389
-- Name: line_items; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.line_items ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6018 (class 0 OID 21594)
-- Dependencies: 390
-- Name: maps; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.maps ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6019 (class 0 OID 21603)
-- Dependencies: 391
-- Name: material_inventory; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.material_inventory ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6020 (class 0 OID 21614)
-- Dependencies: 392
-- Name: material_orders; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.material_orders ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6021 (class 0 OID 21624)
-- Dependencies: 393
-- Name: material_receipts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.material_receipts ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6022 (class 0 OID 21634)
-- Dependencies: 394
-- Name: materials; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.materials ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6023 (class 0 OID 21644)
-- Dependencies: 395
-- Name: meeting_minutes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.meeting_minutes ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6024 (class 0 OID 21654)
-- Dependencies: 396
-- Name: notifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6065 (class 0 OID 43246)
-- Dependencies: 526
-- Name: organization_invites; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_invites ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6063 (class 0 OID 26528)
-- Dependencies: 524
-- Name: organization_member_rates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_member_rates ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6025 (class 0 OID 21667)
-- Dependencies: 397
-- Name: organization_members; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_members ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6026 (class 0 OID 21677)
-- Dependencies: 398
-- Name: organization_projects; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_projects ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6061 (class 0 OID 26485)
-- Dependencies: 522
-- Name: organization_service_areas; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_service_areas ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6027 (class 0 OID 21685)
-- Dependencies: 399
-- Name: organizations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organizations ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6066 (class 3256 OID 23774)
-- Name: accounts_payable p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.accounts_payable FOR DELETE USING (public.check_access_bool('delete'::text, 'accounts_payable'::text, project_id, NULL::uuid));


--
-- TOC entry 6067 (class 3256 OID 23775)
-- Name: accounts_receivable p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.accounts_receivable FOR DELETE USING (public.check_access_bool('delete'::text, 'accounts_receivable'::text, project_id, NULL::uuid));


--
-- TOC entry 6068 (class 3256 OID 23776)
-- Name: activity_logs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.activity_logs FOR DELETE USING (public.check_access_bool('delete'::text, 'activity_logs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6069 (class 3256 OID 23777)
-- Name: asphalt_types p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.asphalt_types FOR DELETE USING (public.check_access_bool('delete'::text, 'asphalt_types'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6070 (class 3256 OID 23778)
-- Name: audit_log p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.audit_log FOR DELETE USING (public.check_access_bool('delete'::text, 'audit_log'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6071 (class 3256 OID 23779)
-- Name: audit_logs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.audit_logs FOR DELETE USING (public.check_access_bool('delete'::text, 'audit_logs'::text, project_id, NULL::uuid));


--
-- TOC entry 6072 (class 3256 OID 23780)
-- Name: avatars p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.avatars FOR DELETE USING (public.check_access_bool('delete'::text, 'avatars'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6073 (class 3256 OID 23781)
-- Name: bid_packages p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.bid_packages FOR DELETE USING (public.check_access_bool('delete'::text, 'bid_packages'::text, project_id, NULL::uuid));


--
-- TOC entry 6074 (class 3256 OID 23782)
-- Name: bid_vendors p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.bid_vendors FOR DELETE USING (public.check_access_bool('delete'::text, 'bid_vendors'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6075 (class 3256 OID 23783)
-- Name: bids p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.bids FOR DELETE USING (public.check_access_bool('delete'::text, 'bids'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6076 (class 3256 OID 23784)
-- Name: bim_models p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.bim_models FOR DELETE USING (public.check_access_bool('delete'::text, 'bim_models'::text, project_id, NULL::uuid));


--
-- TOC entry 6077 (class 3256 OID 23785)
-- Name: certifications p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.certifications FOR DELETE USING (public.check_access_bool('delete'::text, 'certifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6078 (class 3256 OID 23786)
-- Name: change_orders p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.change_orders FOR DELETE USING (public.check_access_bool('delete'::text, 'change_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6079 (class 3256 OID 23787)
-- Name: commitments p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.commitments FOR DELETE USING (public.check_access_bool('delete'::text, 'commitments'::text, project_id, NULL::uuid));


--
-- TOC entry 6080 (class 3256 OID 23788)
-- Name: compliance_checks p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.compliance_checks FOR DELETE USING (public.check_access_bool('delete'::text, 'compliance_checks'::text, project_id, NULL::uuid));


--
-- TOC entry 6081 (class 3256 OID 23789)
-- Name: compliance_tracking p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.compliance_tracking FOR DELETE USING (public.check_access_bool('delete'::text, 'compliance_tracking'::text, project_id, NULL::uuid));


--
-- TOC entry 6082 (class 3256 OID 23790)
-- Name: cost_codes p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.cost_codes FOR DELETE USING (public.check_access_bool('delete'::text, 'cost_codes'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6083 (class 3256 OID 23791)
-- Name: crew_assignments p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.crew_assignments FOR DELETE USING (public.check_access_bool('delete'::text, 'crew_assignments'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6084 (class 3256 OID 23792)
-- Name: crew_members p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.crew_members FOR DELETE USING (public.check_access_bool('delete'::text, 'crew_members'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6085 (class 3256 OID 23793)
-- Name: crews p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.crews FOR DELETE USING (public.check_access_bool('delete'::text, 'crews'::text, project_id, NULL::uuid));


--
-- TOC entry 6086 (class 3256 OID 23794)
-- Name: daily_logs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.daily_logs FOR DELETE USING (public.check_access_bool('delete'::text, 'daily_logs'::text, project_id, NULL::uuid));


--
-- TOC entry 6087 (class 3256 OID 23795)
-- Name: dashboard_configs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.dashboard_configs FOR DELETE USING (public.check_access_bool('delete'::text, 'dashboard_configs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6088 (class 3256 OID 23796)
-- Name: document_references p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.document_references FOR DELETE USING (public.check_access_bool('delete'::text, 'document_references'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6089 (class 3256 OID 23797)
-- Name: documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.documents FOR DELETE USING (public.check_access_bool('delete'::text, 'documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6090 (class 3256 OID 23798)
-- Name: drawing_versions p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.drawing_versions FOR DELETE USING (public.check_access_bool('delete'::text, 'drawing_versions'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6091 (class 3256 OID 23799)
-- Name: dump_trucks p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.dump_trucks FOR DELETE USING (public.check_access_bool('delete'::text, 'dump_trucks'::text, NULL::uuid, organization_id));


--
-- TOC entry 6092 (class 3256 OID 23800)
-- Name: employees p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.employees FOR DELETE USING (public.check_access_bool('delete'::text, 'employees'::text, NULL::uuid, organization_id));


--
-- TOC entry 6093 (class 3256 OID 23801)
-- Name: equipment p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.equipment FOR DELETE USING (public.check_access_bool('delete'::text, 'equipment'::text, NULL::uuid, organization_id));


--
-- TOC entry 6094 (class 3256 OID 23802)
-- Name: equipment_assignments p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.equipment_assignments FOR DELETE USING (public.check_access_bool('delete'::text, 'equipment_assignments'::text, project_id, NULL::uuid));


--
-- TOC entry 6095 (class 3256 OID 23803)
-- Name: equipment_maintenance p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.equipment_maintenance FOR DELETE USING (public.check_access_bool('delete'::text, 'equipment_maintenance'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6096 (class 3256 OID 23804)
-- Name: equipment_usage p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.equipment_usage FOR DELETE USING (public.check_access_bool('delete'::text, 'equipment_usage'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6097 (class 3256 OID 23805)
-- Name: estimate_line_items p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.estimate_line_items FOR DELETE USING (public.check_access_bool('delete'::text, 'estimate_line_items'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6098 (class 3256 OID 23806)
-- Name: estimates p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.estimates FOR DELETE USING (public.check_access_bool('delete'::text, 'estimates'::text, project_id, NULL::uuid));


--
-- TOC entry 6099 (class 3256 OID 23807)
-- Name: financial_documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.financial_documents FOR DELETE USING (public.check_access_bool('delete'::text, 'financial_documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6100 (class 3256 OID 23808)
-- Name: general_ledger p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.general_ledger FOR DELETE USING (public.check_access_bool('delete'::text, 'general_ledger'::text, project_id, NULL::uuid));


--
-- TOC entry 6101 (class 3256 OID 23809)
-- Name: hr_documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.hr_documents FOR DELETE USING (public.check_access_bool('delete'::text, 'hr_documents'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6102 (class 3256 OID 23810)
-- Name: inspections p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.inspections FOR DELETE USING (public.check_access_bool('delete'::text, 'inspections'::text, project_id, NULL::uuid));


--
-- TOC entry 6103 (class 3256 OID 23811)
-- Name: integration_tokens p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.integration_tokens FOR DELETE USING (public.check_access_bool('delete'::text, 'integration_tokens'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6104 (class 3256 OID 23812)
-- Name: inventory_transactions p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.inventory_transactions FOR DELETE USING (public.check_access_bool('delete'::text, 'inventory_transactions'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6105 (class 3256 OID 23813)
-- Name: issues p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.issues FOR DELETE USING (public.check_access_bool('delete'::text, 'issues'::text, project_id, NULL::uuid));


--
-- TOC entry 6106 (class 3256 OID 23814)
-- Name: job_titles p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.job_titles FOR DELETE USING (public.check_access_bool('delete'::text, 'job_titles'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6107 (class 3256 OID 23815)
-- Name: labor_records p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.labor_records FOR DELETE USING (public.check_access_bool('delete'::text, 'labor_records'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6108 (class 3256 OID 23816)
-- Name: line_item_entries p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.line_item_entries FOR DELETE USING (public.check_access_bool('delete'::text, 'line_item_entries'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6109 (class 3256 OID 23817)
-- Name: line_item_templates p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.line_item_templates FOR DELETE USING (public.check_access_bool('delete'::text, 'line_item_templates'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6110 (class 3256 OID 23818)
-- Name: line_items p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.line_items FOR DELETE USING (public.check_access_bool('delete'::text, 'line_items'::text, project_id, NULL::uuid));


--
-- TOC entry 6111 (class 3256 OID 23819)
-- Name: maps p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.maps FOR DELETE USING (public.check_access_bool('delete'::text, 'maps'::text, project_id, NULL::uuid));


--
-- TOC entry 6112 (class 3256 OID 23820)
-- Name: material_inventory p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.material_inventory FOR DELETE USING (public.check_access_bool('delete'::text, 'material_inventory'::text, NULL::uuid, organization_id));


--
-- TOC entry 6113 (class 3256 OID 23821)
-- Name: material_orders p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.material_orders FOR DELETE USING (public.check_access_bool('delete'::text, 'material_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6114 (class 3256 OID 23822)
-- Name: material_receipts p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.material_receipts FOR DELETE USING (public.check_access_bool('delete'::text, 'material_receipts'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6115 (class 3256 OID 23823)
-- Name: materials p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.materials FOR DELETE USING (public.check_access_bool('delete'::text, 'materials'::text, NULL::uuid, organization_id));


--
-- TOC entry 6116 (class 3256 OID 23824)
-- Name: meeting_minutes p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.meeting_minutes FOR DELETE USING (public.check_access_bool('delete'::text, 'meeting_minutes'::text, project_id, NULL::uuid));


--
-- TOC entry 6117 (class 3256 OID 23825)
-- Name: notifications p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.notifications FOR DELETE USING (public.check_access_bool('delete'::text, 'notifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6419 (class 3256 OID 43265)
-- Name: organization_invites p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.organization_invites FOR DELETE USING (public.check_access_bool('delete'::text, 'organization_invites'::text, NULL::uuid, organization_id));


--
-- TOC entry 6118 (class 3256 OID 23826)
-- Name: organization_members p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.organization_members FOR DELETE USING (public.check_access_bool('delete'::text, 'organization_members'::text, NULL::uuid, organization_id));


--
-- TOC entry 6119 (class 3256 OID 23827)
-- Name: organization_projects p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.organization_projects FOR DELETE USING (public.check_access_bool('delete'::text, 'organization_projects'::text, project_id, organization_id));


--
-- TOC entry 6412 (class 3256 OID 28854)
-- Name: organizations p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.organizations FOR DELETE USING (public.check_access_bool('delete'::text, 'organizations'::text, NULL::uuid, id));


--
-- TOC entry 6120 (class 3256 OID 23829)
-- Name: payments p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.payments FOR DELETE USING (public.check_access_bool('delete'::text, 'payments'::text, project_id, NULL::uuid));


--
-- TOC entry 6121 (class 3256 OID 23830)
-- Name: payroll p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.payroll FOR DELETE USING (public.check_access_bool('delete'::text, 'payroll'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6122 (class 3256 OID 23831)
-- Name: photos p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.photos FOR DELETE USING (public.check_access_bool('delete'::text, 'photos'::text, project_id, NULL::uuid));


--
-- TOC entry 6123 (class 3256 OID 23832)
-- Name: prequalifications p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.prequalifications FOR DELETE USING (public.check_access_bool('delete'::text, 'prequalifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6124 (class 3256 OID 23833)
-- Name: procurement_workflows p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.procurement_workflows FOR DELETE USING (public.check_access_bool('delete'::text, 'procurement_workflows'::text, project_id, NULL::uuid));


--
-- TOC entry 6423 (class 3256 OID 45500)
-- Name: profiles p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.profiles AS RESTRICTIVE FOR DELETE TO authenticated USING (public.check_access_bool('delete'::text, 'profiles'::text, NULL::uuid, organization_id));


--
-- TOC entry 6125 (class 3256 OID 23835)
-- Name: progress_billings p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.progress_billings FOR DELETE USING (public.check_access_bool('delete'::text, 'progress_billings'::text, project_id, NULL::uuid));


--
-- TOC entry 6126 (class 3256 OID 23836)
-- Name: project_inspectors p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.project_inspectors FOR DELETE USING (public.check_access_bool('delete'::text, 'project_inspectors'::text, project_id, NULL::uuid));


--
-- TOC entry 6127 (class 3256 OID 23837)
-- Name: projects p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.projects FOR DELETE USING (public.check_access_bool('delete'::text, 'projects'::text, NULL::uuid, organization_id));


--
-- TOC entry 6128 (class 3256 OID 23838)
-- Name: punch_lists p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.punch_lists FOR DELETE USING (public.check_access_bool('delete'::text, 'punch_lists'::text, project_id, NULL::uuid));


--
-- TOC entry 6129 (class 3256 OID 23839)
-- Name: purchase_orders p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.purchase_orders FOR DELETE USING (public.check_access_bool('delete'::text, 'purchase_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6130 (class 3256 OID 23840)
-- Name: quality_reviews p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.quality_reviews FOR DELETE USING (public.check_access_bool('delete'::text, 'quality_reviews'::text, project_id, NULL::uuid));


--
-- TOC entry 6131 (class 3256 OID 23841)
-- Name: regulatory_documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.regulatory_documents FOR DELETE USING (public.check_access_bool('delete'::text, 'regulatory_documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6132 (class 3256 OID 23842)
-- Name: reports p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.reports FOR DELETE USING (public.check_access_bool('delete'::text, 'reports'::text, project_id, NULL::uuid));


--
-- TOC entry 6133 (class 3256 OID 23843)
-- Name: rfis p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.rfis FOR DELETE USING (public.check_access_bool('delete'::text, 'rfis'::text, project_id, NULL::uuid));


--
-- TOC entry 6134 (class 3256 OID 23844)
-- Name: safety_incidents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.safety_incidents FOR DELETE USING (public.check_access_bool('delete'::text, 'safety_incidents'::text, project_id, NULL::uuid));


--
-- TOC entry 6135 (class 3256 OID 23845)
-- Name: sensor_data p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.sensor_data FOR DELETE USING (public.check_access_bool('delete'::text, 'sensor_data'::text, project_id, NULL::uuid));


--
-- TOC entry 6136 (class 3256 OID 23846)
-- Name: subcontractor_agreements p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.subcontractor_agreements FOR DELETE USING (public.check_access_bool('delete'::text, 'subcontractor_agreements'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6137 (class 3256 OID 23847)
-- Name: subcontracts p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.subcontracts FOR DELETE USING (public.check_access_bool('delete'::text, 'subcontracts'::text, project_id, NULL::uuid));


--
-- TOC entry 6138 (class 3256 OID 23848)
-- Name: submittals p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.submittals FOR DELETE USING (public.check_access_bool('delete'::text, 'submittals'::text, project_id, NULL::uuid));


--
-- TOC entry 6139 (class 3256 OID 23849)
-- Name: tack_rates p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.tack_rates FOR DELETE USING (public.check_access_bool('delete'::text, 'tack_rates'::text, project_id, NULL::uuid));


--
-- TOC entry 6140 (class 3256 OID 23850)
-- Name: task_dependencies p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.task_dependencies FOR DELETE USING (public.check_access_bool('delete'::text, 'task_dependencies'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6141 (class 3256 OID 23851)
-- Name: task_status_logs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.task_status_logs FOR DELETE USING (public.check_access_bool('delete'::text, 'task_status_logs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6142 (class 3256 OID 23852)
-- Name: tasks p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.tasks FOR DELETE USING (public.check_access_bool('delete'::text, 'tasks'::text, project_id, NULL::uuid));


--
-- TOC entry 6143 (class 3256 OID 23853)
-- Name: training_records p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.training_records FOR DELETE USING (public.check_access_bool('delete'::text, 'training_records'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6144 (class 3256 OID 23854)
-- Name: user_projects p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.user_projects FOR DELETE USING (public.check_access_bool('delete'::text, 'user_projects'::text, project_id, NULL::uuid));


--
-- TOC entry 6145 (class 3256 OID 23855)
-- Name: vendor_bid_packages p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendor_bid_packages FOR DELETE USING (public.check_access_bool('delete'::text, 'vendor_bid_packages'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6146 (class 3256 OID 23856)
-- Name: vendor_contacts p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendor_contacts FOR DELETE USING (public.check_access_bool('delete'::text, 'vendor_contacts'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6147 (class 3256 OID 23857)
-- Name: vendor_documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendor_documents FOR DELETE USING (public.check_access_bool('delete'::text, 'vendor_documents'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6148 (class 3256 OID 23858)
-- Name: vendor_qualifications p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendor_qualifications FOR DELETE USING (public.check_access_bool('delete'::text, 'vendor_qualifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6149 (class 3256 OID 23859)
-- Name: vendors p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendors FOR DELETE USING (public.check_access_bool('delete'::text, 'vendors'::text, NULL::uuid, organization_id));


--
-- TOC entry 6150 (class 3256 OID 23860)
-- Name: wbs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.wbs FOR DELETE USING (public.check_access_bool('delete'::text, 'wbs'::text, project_id, NULL::uuid));


--
-- TOC entry 6151 (class 3256 OID 23861)
-- Name: workflows p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.workflows FOR DELETE USING (public.check_access_bool('delete'::text, 'workflows'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6152 (class 3256 OID 23862)
-- Name: accounts_payable p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.accounts_payable FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'accounts_payable'::text, project_id, NULL::uuid));


--
-- TOC entry 6153 (class 3256 OID 23863)
-- Name: accounts_receivable p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.accounts_receivable FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'accounts_receivable'::text, project_id, NULL::uuid));


--
-- TOC entry 6154 (class 3256 OID 23864)
-- Name: activity_logs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.activity_logs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'activity_logs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6155 (class 3256 OID 23865)
-- Name: asphalt_types p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.asphalt_types FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'asphalt_types'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6156 (class 3256 OID 23866)
-- Name: audit_log p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.audit_log FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'audit_log'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6157 (class 3256 OID 23867)
-- Name: audit_logs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.audit_logs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'audit_logs'::text, project_id, NULL::uuid));


--
-- TOC entry 6158 (class 3256 OID 23868)
-- Name: avatars p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.avatars FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'avatars'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6159 (class 3256 OID 23869)
-- Name: bid_packages p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.bid_packages FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'bid_packages'::text, project_id, NULL::uuid));


--
-- TOC entry 6160 (class 3256 OID 23870)
-- Name: bid_vendors p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.bid_vendors FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'bid_vendors'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6161 (class 3256 OID 23871)
-- Name: bids p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.bids FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'bids'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6162 (class 3256 OID 23872)
-- Name: bim_models p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.bim_models FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'bim_models'::text, project_id, NULL::uuid));


--
-- TOC entry 6163 (class 3256 OID 23873)
-- Name: certifications p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.certifications FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'certifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6164 (class 3256 OID 23874)
-- Name: change_orders p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.change_orders FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'change_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6165 (class 3256 OID 23875)
-- Name: commitments p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.commitments FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'commitments'::text, project_id, NULL::uuid));


--
-- TOC entry 6166 (class 3256 OID 23876)
-- Name: compliance_checks p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.compliance_checks FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'compliance_checks'::text, project_id, NULL::uuid));


--
-- TOC entry 6167 (class 3256 OID 23877)
-- Name: compliance_tracking p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.compliance_tracking FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'compliance_tracking'::text, project_id, NULL::uuid));


--
-- TOC entry 6168 (class 3256 OID 23878)
-- Name: cost_codes p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.cost_codes FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'cost_codes'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6169 (class 3256 OID 23879)
-- Name: crew_assignments p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.crew_assignments FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'crew_assignments'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6170 (class 3256 OID 23880)
-- Name: crew_members p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.crew_members FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'crew_members'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6171 (class 3256 OID 23881)
-- Name: crews p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.crews FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'crews'::text, project_id, NULL::uuid));


--
-- TOC entry 6172 (class 3256 OID 23882)
-- Name: daily_logs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.daily_logs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'daily_logs'::text, project_id, NULL::uuid));


--
-- TOC entry 6173 (class 3256 OID 23883)
-- Name: dashboard_configs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.dashboard_configs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'dashboard_configs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6174 (class 3256 OID 23884)
-- Name: document_references p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.document_references FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'document_references'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6175 (class 3256 OID 23885)
-- Name: documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6176 (class 3256 OID 23886)
-- Name: drawing_versions p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.drawing_versions FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'drawing_versions'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6177 (class 3256 OID 23887)
-- Name: dump_trucks p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.dump_trucks FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'dump_trucks'::text, NULL::uuid, organization_id));


--
-- TOC entry 6178 (class 3256 OID 23888)
-- Name: employees p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.employees FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'employees'::text, NULL::uuid, organization_id));


--
-- TOC entry 6179 (class 3256 OID 23889)
-- Name: equipment p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.equipment FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'equipment'::text, NULL::uuid, organization_id));


--
-- TOC entry 6180 (class 3256 OID 23890)
-- Name: equipment_assignments p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.equipment_assignments FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'equipment_assignments'::text, project_id, NULL::uuid));


--
-- TOC entry 6181 (class 3256 OID 23891)
-- Name: equipment_maintenance p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.equipment_maintenance FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'equipment_maintenance'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6182 (class 3256 OID 23892)
-- Name: equipment_usage p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.equipment_usage FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'equipment_usage'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6183 (class 3256 OID 23893)
-- Name: estimate_line_items p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.estimate_line_items FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'estimate_line_items'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6184 (class 3256 OID 23894)
-- Name: estimates p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.estimates FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'estimates'::text, project_id, NULL::uuid));


--
-- TOC entry 6185 (class 3256 OID 23895)
-- Name: financial_documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.financial_documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'financial_documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6186 (class 3256 OID 23896)
-- Name: general_ledger p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.general_ledger FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'general_ledger'::text, project_id, NULL::uuid));


--
-- TOC entry 6187 (class 3256 OID 23897)
-- Name: hr_documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.hr_documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'hr_documents'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6188 (class 3256 OID 23898)
-- Name: inspections p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.inspections FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'inspections'::text, project_id, NULL::uuid));


--
-- TOC entry 6189 (class 3256 OID 23899)
-- Name: integration_tokens p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.integration_tokens FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'integration_tokens'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6190 (class 3256 OID 23900)
-- Name: inventory_transactions p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.inventory_transactions FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'inventory_transactions'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6191 (class 3256 OID 23901)
-- Name: issues p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.issues FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'issues'::text, project_id, NULL::uuid));


--
-- TOC entry 6192 (class 3256 OID 23902)
-- Name: job_titles p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.job_titles FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'job_titles'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6193 (class 3256 OID 23903)
-- Name: labor_records p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.labor_records FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'labor_records'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6194 (class 3256 OID 23904)
-- Name: line_item_entries p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.line_item_entries FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'line_item_entries'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6195 (class 3256 OID 23905)
-- Name: line_item_templates p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.line_item_templates FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'line_item_templates'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6196 (class 3256 OID 23906)
-- Name: line_items p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.line_items FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'line_items'::text, project_id, NULL::uuid));


--
-- TOC entry 6197 (class 3256 OID 23907)
-- Name: maps p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.maps FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'maps'::text, project_id, NULL::uuid));


--
-- TOC entry 6198 (class 3256 OID 23908)
-- Name: material_inventory p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.material_inventory FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'material_inventory'::text, NULL::uuid, organization_id));


--
-- TOC entry 6199 (class 3256 OID 23909)
-- Name: material_orders p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.material_orders FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'material_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6200 (class 3256 OID 23910)
-- Name: material_receipts p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.material_receipts FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'material_receipts'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6201 (class 3256 OID 23911)
-- Name: materials p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.materials FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'materials'::text, NULL::uuid, organization_id));


--
-- TOC entry 6202 (class 3256 OID 23912)
-- Name: meeting_minutes p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.meeting_minutes FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'meeting_minutes'::text, project_id, NULL::uuid));


--
-- TOC entry 6203 (class 3256 OID 23913)
-- Name: notifications p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.notifications FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'notifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6416 (class 3256 OID 43262)
-- Name: organization_invites p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.organization_invites FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'organization_invites'::text, NULL::uuid, organization_id));


--
-- TOC entry 6204 (class 3256 OID 23914)
-- Name: organization_members p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.organization_members FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'organization_members'::text, NULL::uuid, organization_id));


--
-- TOC entry 6205 (class 3256 OID 23915)
-- Name: organization_projects p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.organization_projects FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'organization_projects'::text, project_id, organization_id));


--
-- TOC entry 6413 (class 3256 OID 28855)
-- Name: organizations p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.organizations FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'organizations'::text, NULL::uuid, id));


--
-- TOC entry 6206 (class 3256 OID 23917)
-- Name: payments p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.payments FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'payments'::text, project_id, NULL::uuid));


--
-- TOC entry 6207 (class 3256 OID 23918)
-- Name: payroll p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.payroll FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'payroll'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6208 (class 3256 OID 23919)
-- Name: photos p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.photos FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'photos'::text, project_id, NULL::uuid));


--
-- TOC entry 6209 (class 3256 OID 23920)
-- Name: prequalifications p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.prequalifications FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'prequalifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6210 (class 3256 OID 23921)
-- Name: procurement_workflows p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.procurement_workflows FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'procurement_workflows'::text, project_id, NULL::uuid));


--
-- TOC entry 6422 (class 3256 OID 45497)
-- Name: profiles p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.profiles AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK (public.check_access_bool('insert'::text, 'profiles'::text, NULL::uuid, organization_id));


--
-- TOC entry 6211 (class 3256 OID 23923)
-- Name: progress_billings p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.progress_billings FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'progress_billings'::text, project_id, NULL::uuid));


--
-- TOC entry 6212 (class 3256 OID 23924)
-- Name: project_inspectors p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.project_inspectors FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'project_inspectors'::text, project_id, NULL::uuid));


--
-- TOC entry 6213 (class 3256 OID 23925)
-- Name: projects p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.projects FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'projects'::text, NULL::uuid, organization_id));


--
-- TOC entry 6214 (class 3256 OID 23926)
-- Name: punch_lists p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.punch_lists FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'punch_lists'::text, project_id, NULL::uuid));


--
-- TOC entry 6215 (class 3256 OID 23927)
-- Name: purchase_orders p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.purchase_orders FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'purchase_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6216 (class 3256 OID 23928)
-- Name: quality_reviews p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.quality_reviews FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'quality_reviews'::text, project_id, NULL::uuid));


--
-- TOC entry 6217 (class 3256 OID 23929)
-- Name: regulatory_documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.regulatory_documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'regulatory_documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6218 (class 3256 OID 23930)
-- Name: reports p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.reports FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'reports'::text, project_id, NULL::uuid));


--
-- TOC entry 6219 (class 3256 OID 23931)
-- Name: rfis p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.rfis FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'rfis'::text, project_id, NULL::uuid));


--
-- TOC entry 6220 (class 3256 OID 23932)
-- Name: safety_incidents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.safety_incidents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'safety_incidents'::text, project_id, NULL::uuid));


--
-- TOC entry 6221 (class 3256 OID 23933)
-- Name: sensor_data p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.sensor_data FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'sensor_data'::text, project_id, NULL::uuid));


--
-- TOC entry 6222 (class 3256 OID 23934)
-- Name: subcontractor_agreements p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.subcontractor_agreements FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'subcontractor_agreements'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6223 (class 3256 OID 23935)
-- Name: subcontracts p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.subcontracts FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'subcontracts'::text, project_id, NULL::uuid));


--
-- TOC entry 6224 (class 3256 OID 23936)
-- Name: submittals p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.submittals FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'submittals'::text, project_id, NULL::uuid));


--
-- TOC entry 6225 (class 3256 OID 23937)
-- Name: tack_rates p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.tack_rates FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'tack_rates'::text, project_id, NULL::uuid));


--
-- TOC entry 6226 (class 3256 OID 23938)
-- Name: task_dependencies p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.task_dependencies FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'task_dependencies'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6227 (class 3256 OID 23939)
-- Name: task_status_logs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.task_status_logs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'task_status_logs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6228 (class 3256 OID 23940)
-- Name: tasks p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.tasks FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'tasks'::text, project_id, NULL::uuid));


--
-- TOC entry 6229 (class 3256 OID 23941)
-- Name: training_records p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.training_records FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'training_records'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6230 (class 3256 OID 23942)
-- Name: user_projects p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.user_projects FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'user_projects'::text, project_id, NULL::uuid));


--
-- TOC entry 6231 (class 3256 OID 23943)
-- Name: vendor_bid_packages p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendor_bid_packages FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendor_bid_packages'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6232 (class 3256 OID 23944)
-- Name: vendor_contacts p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendor_contacts FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendor_contacts'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6233 (class 3256 OID 23945)
-- Name: vendor_documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendor_documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendor_documents'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6234 (class 3256 OID 23946)
-- Name: vendor_qualifications p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendor_qualifications FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendor_qualifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6235 (class 3256 OID 23947)
-- Name: vendors p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendors FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendors'::text, NULL::uuid, organization_id));


--
-- TOC entry 6236 (class 3256 OID 23948)
-- Name: wbs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.wbs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'wbs'::text, project_id, NULL::uuid));


--
-- TOC entry 6237 (class 3256 OID 23949)
-- Name: workflows p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.workflows FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'workflows'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6238 (class 3256 OID 23950)
-- Name: accounts_payable p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.accounts_payable FOR SELECT USING (public.check_access_bool('select'::text, 'accounts_payable'::text, project_id, NULL::uuid));


--
-- TOC entry 6239 (class 3256 OID 23951)
-- Name: accounts_receivable p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.accounts_receivable FOR SELECT USING (public.check_access_bool('select'::text, 'accounts_receivable'::text, project_id, NULL::uuid));


--
-- TOC entry 6240 (class 3256 OID 23952)
-- Name: activity_logs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.activity_logs FOR SELECT USING (public.check_access_bool('select'::text, 'activity_logs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6241 (class 3256 OID 23953)
-- Name: asphalt_types p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.asphalt_types FOR SELECT USING (public.check_access_bool('select'::text, 'asphalt_types'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6242 (class 3256 OID 23954)
-- Name: audit_log p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.audit_log FOR SELECT USING (public.check_access_bool('select'::text, 'audit_log'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6243 (class 3256 OID 23955)
-- Name: audit_logs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.audit_logs FOR SELECT USING (public.check_access_bool('select'::text, 'audit_logs'::text, project_id, NULL::uuid));


--
-- TOC entry 6244 (class 3256 OID 23956)
-- Name: avatars p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.avatars FOR SELECT USING (public.check_access_bool('select'::text, 'avatars'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6245 (class 3256 OID 23957)
-- Name: bid_packages p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.bid_packages FOR SELECT USING (public.check_access_bool('select'::text, 'bid_packages'::text, project_id, NULL::uuid));


--
-- TOC entry 6246 (class 3256 OID 23958)
-- Name: bid_vendors p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.bid_vendors FOR SELECT USING (public.check_access_bool('select'::text, 'bid_vendors'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6247 (class 3256 OID 23959)
-- Name: bids p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.bids FOR SELECT USING (public.check_access_bool('select'::text, 'bids'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6248 (class 3256 OID 23960)
-- Name: bim_models p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.bim_models FOR SELECT USING (public.check_access_bool('select'::text, 'bim_models'::text, project_id, NULL::uuid));


--
-- TOC entry 6249 (class 3256 OID 23961)
-- Name: certifications p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.certifications FOR SELECT USING (public.check_access_bool('select'::text, 'certifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6250 (class 3256 OID 23962)
-- Name: change_orders p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.change_orders FOR SELECT USING (public.check_access_bool('select'::text, 'change_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6251 (class 3256 OID 23963)
-- Name: commitments p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.commitments FOR SELECT USING (public.check_access_bool('select'::text, 'commitments'::text, project_id, NULL::uuid));


--
-- TOC entry 6252 (class 3256 OID 23964)
-- Name: compliance_checks p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.compliance_checks FOR SELECT USING (public.check_access_bool('select'::text, 'compliance_checks'::text, project_id, NULL::uuid));


--
-- TOC entry 6253 (class 3256 OID 23965)
-- Name: compliance_tracking p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.compliance_tracking FOR SELECT USING (public.check_access_bool('select'::text, 'compliance_tracking'::text, project_id, NULL::uuid));


--
-- TOC entry 6254 (class 3256 OID 23966)
-- Name: cost_codes p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.cost_codes FOR SELECT USING (public.check_access_bool('select'::text, 'cost_codes'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6255 (class 3256 OID 23967)
-- Name: crew_assignments p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.crew_assignments FOR SELECT USING (public.check_access_bool('select'::text, 'crew_assignments'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6256 (class 3256 OID 23968)
-- Name: crew_members p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.crew_members FOR SELECT USING (public.check_access_bool('select'::text, 'crew_members'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6257 (class 3256 OID 23969)
-- Name: crews p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.crews FOR SELECT USING (public.check_access_bool('select'::text, 'crews'::text, project_id, NULL::uuid));


--
-- TOC entry 6258 (class 3256 OID 23970)
-- Name: daily_logs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.daily_logs FOR SELECT USING (public.check_access_bool('select'::text, 'daily_logs'::text, project_id, NULL::uuid));


--
-- TOC entry 6259 (class 3256 OID 23971)
-- Name: dashboard_configs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.dashboard_configs FOR SELECT USING (public.check_access_bool('select'::text, 'dashboard_configs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6260 (class 3256 OID 23972)
-- Name: document_references p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.document_references FOR SELECT USING (public.check_access_bool('select'::text, 'document_references'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6261 (class 3256 OID 23973)
-- Name: documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.documents FOR SELECT USING (public.check_access_bool('select'::text, 'documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6262 (class 3256 OID 23974)
-- Name: drawing_versions p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.drawing_versions FOR SELECT USING (public.check_access_bool('select'::text, 'drawing_versions'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6263 (class 3256 OID 23975)
-- Name: dump_trucks p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.dump_trucks FOR SELECT USING (public.check_access_bool('select'::text, 'dump_trucks'::text, NULL::uuid, organization_id));


--
-- TOC entry 6264 (class 3256 OID 23976)
-- Name: employees p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.employees FOR SELECT USING (public.check_access_bool('select'::text, 'employees'::text, NULL::uuid, organization_id));


--
-- TOC entry 6265 (class 3256 OID 23977)
-- Name: equipment p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.equipment FOR SELECT USING (public.check_access_bool('select'::text, 'equipment'::text, NULL::uuid, organization_id));


--
-- TOC entry 6266 (class 3256 OID 23978)
-- Name: equipment_assignments p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.equipment_assignments FOR SELECT USING (public.check_access_bool('select'::text, 'equipment_assignments'::text, project_id, NULL::uuid));


--
-- TOC entry 6267 (class 3256 OID 23979)
-- Name: equipment_maintenance p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.equipment_maintenance FOR SELECT USING (public.check_access_bool('select'::text, 'equipment_maintenance'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6268 (class 3256 OID 23980)
-- Name: equipment_usage p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.equipment_usage FOR SELECT USING (public.check_access_bool('select'::text, 'equipment_usage'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6269 (class 3256 OID 23981)
-- Name: estimate_line_items p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.estimate_line_items FOR SELECT USING (public.check_access_bool('select'::text, 'estimate_line_items'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6270 (class 3256 OID 23982)
-- Name: estimates p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.estimates FOR SELECT USING (public.check_access_bool('select'::text, 'estimates'::text, project_id, NULL::uuid));


--
-- TOC entry 6271 (class 3256 OID 23983)
-- Name: financial_documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.financial_documents FOR SELECT USING (public.check_access_bool('select'::text, 'financial_documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6272 (class 3256 OID 23984)
-- Name: general_ledger p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.general_ledger FOR SELECT USING (public.check_access_bool('select'::text, 'general_ledger'::text, project_id, NULL::uuid));


--
-- TOC entry 6273 (class 3256 OID 23985)
-- Name: hr_documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.hr_documents FOR SELECT USING (public.check_access_bool('select'::text, 'hr_documents'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6274 (class 3256 OID 23986)
-- Name: inspections p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.inspections FOR SELECT USING (public.check_access_bool('select'::text, 'inspections'::text, project_id, NULL::uuid));


--
-- TOC entry 6275 (class 3256 OID 23987)
-- Name: integration_tokens p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.integration_tokens FOR SELECT USING (public.check_access_bool('select'::text, 'integration_tokens'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6276 (class 3256 OID 23988)
-- Name: inventory_transactions p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.inventory_transactions FOR SELECT USING (public.check_access_bool('select'::text, 'inventory_transactions'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6277 (class 3256 OID 23989)
-- Name: issues p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.issues FOR SELECT USING (public.check_access_bool('select'::text, 'issues'::text, project_id, NULL::uuid));


--
-- TOC entry 6278 (class 3256 OID 23990)
-- Name: job_titles p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.job_titles FOR SELECT USING (public.check_access_bool('select'::text, 'job_titles'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6279 (class 3256 OID 23991)
-- Name: labor_records p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.labor_records FOR SELECT USING (public.check_access_bool('select'::text, 'labor_records'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6280 (class 3256 OID 23992)
-- Name: line_item_entries p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.line_item_entries FOR SELECT USING (public.check_access_bool('select'::text, 'line_item_entries'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6281 (class 3256 OID 23993)
-- Name: line_item_templates p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.line_item_templates FOR SELECT USING (public.check_access_bool('select'::text, 'line_item_templates'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6282 (class 3256 OID 23994)
-- Name: line_items p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.line_items FOR SELECT USING (public.check_access_bool('select'::text, 'line_items'::text, project_id, NULL::uuid));


--
-- TOC entry 6283 (class 3256 OID 23995)
-- Name: maps p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.maps FOR SELECT USING (public.check_access_bool('select'::text, 'maps'::text, project_id, NULL::uuid));


--
-- TOC entry 6284 (class 3256 OID 23996)
-- Name: material_inventory p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.material_inventory FOR SELECT USING (public.check_access_bool('select'::text, 'material_inventory'::text, NULL::uuid, organization_id));


--
-- TOC entry 6285 (class 3256 OID 23997)
-- Name: material_orders p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.material_orders FOR SELECT USING (public.check_access_bool('select'::text, 'material_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6286 (class 3256 OID 23998)
-- Name: material_receipts p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.material_receipts FOR SELECT USING (public.check_access_bool('select'::text, 'material_receipts'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6287 (class 3256 OID 23999)
-- Name: materials p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.materials FOR SELECT USING (public.check_access_bool('select'::text, 'materials'::text, NULL::uuid, organization_id));


--
-- TOC entry 6288 (class 3256 OID 24000)
-- Name: meeting_minutes p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.meeting_minutes FOR SELECT USING (public.check_access_bool('select'::text, 'meeting_minutes'::text, project_id, NULL::uuid));


--
-- TOC entry 6289 (class 3256 OID 24001)
-- Name: notifications p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.notifications FOR SELECT USING (public.check_access_bool('select'::text, 'notifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6417 (class 3256 OID 43263)
-- Name: organization_invites p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.organization_invites FOR SELECT USING (public.check_access_bool('select'::text, 'organization_invites'::text, NULL::uuid, organization_id));


--
-- TOC entry 6290 (class 3256 OID 24002)
-- Name: organization_members p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.organization_members FOR SELECT USING (public.check_access_bool('select'::text, 'organization_members'::text, NULL::uuid, organization_id));


--
-- TOC entry 6291 (class 3256 OID 24003)
-- Name: organization_projects p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.organization_projects FOR SELECT USING (public.check_access_bool('select'::text, 'organization_projects'::text, project_id, organization_id));


--
-- TOC entry 6414 (class 3256 OID 28856)
-- Name: organizations p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.organizations FOR SELECT USING (public.check_access_bool('select'::text, 'organizations'::text, NULL::uuid, id));


--
-- TOC entry 6292 (class 3256 OID 24005)
-- Name: payments p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.payments FOR SELECT USING (public.check_access_bool('select'::text, 'payments'::text, project_id, NULL::uuid));


--
-- TOC entry 6293 (class 3256 OID 24006)
-- Name: payroll p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.payroll FOR SELECT USING (public.check_access_bool('select'::text, 'payroll'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6294 (class 3256 OID 24007)
-- Name: photos p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.photos FOR SELECT USING (public.check_access_bool('select'::text, 'photos'::text, project_id, NULL::uuid));


--
-- TOC entry 6295 (class 3256 OID 24008)
-- Name: prequalifications p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.prequalifications FOR SELECT USING (public.check_access_bool('select'::text, 'prequalifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6296 (class 3256 OID 24009)
-- Name: procurement_workflows p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.procurement_workflows FOR SELECT USING (public.check_access_bool('select'::text, 'procurement_workflows'::text, project_id, NULL::uuid));


--
-- TOC entry 6420 (class 3256 OID 45495)
-- Name: profiles p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.profiles AS RESTRICTIVE FOR SELECT TO authenticated USING (public.check_access_bool('select'::text, 'profiles'::text, NULL::uuid, organization_id));


--
-- TOC entry 6297 (class 3256 OID 24011)
-- Name: progress_billings p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.progress_billings FOR SELECT USING (public.check_access_bool('select'::text, 'progress_billings'::text, project_id, NULL::uuid));


--
-- TOC entry 6298 (class 3256 OID 24012)
-- Name: project_inspectors p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.project_inspectors FOR SELECT USING (public.check_access_bool('select'::text, 'project_inspectors'::text, project_id, NULL::uuid));


--
-- TOC entry 6299 (class 3256 OID 24013)
-- Name: projects p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.projects FOR SELECT USING (public.check_access_bool('select'::text, 'projects'::text, NULL::uuid, organization_id));


--
-- TOC entry 6300 (class 3256 OID 24014)
-- Name: punch_lists p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.punch_lists FOR SELECT USING (public.check_access_bool('select'::text, 'punch_lists'::text, project_id, NULL::uuid));


--
-- TOC entry 6301 (class 3256 OID 24015)
-- Name: purchase_orders p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.purchase_orders FOR SELECT USING (public.check_access_bool('select'::text, 'purchase_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6302 (class 3256 OID 24016)
-- Name: quality_reviews p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.quality_reviews FOR SELECT USING (public.check_access_bool('select'::text, 'quality_reviews'::text, project_id, NULL::uuid));


--
-- TOC entry 6303 (class 3256 OID 24017)
-- Name: regulatory_documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.regulatory_documents FOR SELECT USING (public.check_access_bool('select'::text, 'regulatory_documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6304 (class 3256 OID 24018)
-- Name: reports p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.reports FOR SELECT USING (public.check_access_bool('select'::text, 'reports'::text, project_id, NULL::uuid));


--
-- TOC entry 6305 (class 3256 OID 24019)
-- Name: rfis p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.rfis FOR SELECT USING (public.check_access_bool('select'::text, 'rfis'::text, project_id, NULL::uuid));


--
-- TOC entry 6306 (class 3256 OID 24020)
-- Name: safety_incidents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.safety_incidents FOR SELECT USING (public.check_access_bool('select'::text, 'safety_incidents'::text, project_id, NULL::uuid));


--
-- TOC entry 6307 (class 3256 OID 24021)
-- Name: sensor_data p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.sensor_data FOR SELECT USING (public.check_access_bool('select'::text, 'sensor_data'::text, project_id, NULL::uuid));


--
-- TOC entry 6308 (class 3256 OID 24022)
-- Name: subcontractor_agreements p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.subcontractor_agreements FOR SELECT USING (public.check_access_bool('select'::text, 'subcontractor_agreements'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6309 (class 3256 OID 24023)
-- Name: subcontracts p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.subcontracts FOR SELECT USING (public.check_access_bool('select'::text, 'subcontracts'::text, project_id, NULL::uuid));


--
-- TOC entry 6310 (class 3256 OID 24024)
-- Name: submittals p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.submittals FOR SELECT USING (public.check_access_bool('select'::text, 'submittals'::text, project_id, NULL::uuid));


--
-- TOC entry 6311 (class 3256 OID 24025)
-- Name: tack_rates p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.tack_rates FOR SELECT USING (public.check_access_bool('select'::text, 'tack_rates'::text, project_id, NULL::uuid));


--
-- TOC entry 6312 (class 3256 OID 24026)
-- Name: task_dependencies p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.task_dependencies FOR SELECT USING (public.check_access_bool('select'::text, 'task_dependencies'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6313 (class 3256 OID 24027)
-- Name: task_status_logs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.task_status_logs FOR SELECT USING (public.check_access_bool('select'::text, 'task_status_logs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6314 (class 3256 OID 24028)
-- Name: tasks p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.tasks FOR SELECT USING (public.check_access_bool('select'::text, 'tasks'::text, project_id, NULL::uuid));


--
-- TOC entry 6315 (class 3256 OID 24029)
-- Name: training_records p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.training_records FOR SELECT USING (public.check_access_bool('select'::text, 'training_records'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6316 (class 3256 OID 24030)
-- Name: user_projects p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.user_projects FOR SELECT USING (public.check_access_bool('select'::text, 'user_projects'::text, project_id, NULL::uuid));


--
-- TOC entry 6317 (class 3256 OID 24031)
-- Name: vendor_bid_packages p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendor_bid_packages FOR SELECT USING (public.check_access_bool('select'::text, 'vendor_bid_packages'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6318 (class 3256 OID 24032)
-- Name: vendor_contacts p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendor_contacts FOR SELECT USING (public.check_access_bool('select'::text, 'vendor_contacts'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6319 (class 3256 OID 24035)
-- Name: vendor_documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendor_documents FOR SELECT USING (public.check_access_bool('select'::text, 'vendor_documents'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6320 (class 3256 OID 24036)
-- Name: vendor_qualifications p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendor_qualifications FOR SELECT USING (public.check_access_bool('select'::text, 'vendor_qualifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6321 (class 3256 OID 24037)
-- Name: vendors p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendors FOR SELECT USING (public.check_access_bool('select'::text, 'vendors'::text, NULL::uuid, organization_id));


--
-- TOC entry 6322 (class 3256 OID 24038)
-- Name: wbs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.wbs FOR SELECT USING (public.check_access_bool('select'::text, 'wbs'::text, project_id, NULL::uuid));


--
-- TOC entry 6323 (class 3256 OID 24039)
-- Name: workflows p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.workflows FOR SELECT USING (public.check_access_bool('select'::text, 'workflows'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6324 (class 3256 OID 24040)
-- Name: accounts_payable p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.accounts_payable FOR UPDATE USING (public.check_access_bool('update'::text, 'accounts_payable'::text, project_id, NULL::uuid));


--
-- TOC entry 6325 (class 3256 OID 24041)
-- Name: accounts_receivable p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.accounts_receivable FOR UPDATE USING (public.check_access_bool('update'::text, 'accounts_receivable'::text, project_id, NULL::uuid));


--
-- TOC entry 6326 (class 3256 OID 24042)
-- Name: activity_logs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.activity_logs FOR UPDATE USING (public.check_access_bool('update'::text, 'activity_logs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6327 (class 3256 OID 24043)
-- Name: asphalt_types p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.asphalt_types FOR UPDATE USING (public.check_access_bool('update'::text, 'asphalt_types'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6328 (class 3256 OID 24044)
-- Name: audit_log p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.audit_log FOR UPDATE USING (public.check_access_bool('update'::text, 'audit_log'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6329 (class 3256 OID 24045)
-- Name: audit_logs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.audit_logs FOR UPDATE USING (public.check_access_bool('update'::text, 'audit_logs'::text, project_id, NULL::uuid));


--
-- TOC entry 6330 (class 3256 OID 24046)
-- Name: avatars p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.avatars FOR UPDATE USING (public.check_access_bool('update'::text, 'avatars'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6331 (class 3256 OID 24047)
-- Name: bid_packages p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.bid_packages FOR UPDATE USING (public.check_access_bool('update'::text, 'bid_packages'::text, project_id, NULL::uuid));


--
-- TOC entry 6332 (class 3256 OID 24048)
-- Name: bid_vendors p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.bid_vendors FOR UPDATE USING (public.check_access_bool('update'::text, 'bid_vendors'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6333 (class 3256 OID 24049)
-- Name: bids p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.bids FOR UPDATE USING (public.check_access_bool('update'::text, 'bids'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6334 (class 3256 OID 24050)
-- Name: bim_models p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.bim_models FOR UPDATE USING (public.check_access_bool('update'::text, 'bim_models'::text, project_id, NULL::uuid));


--
-- TOC entry 6335 (class 3256 OID 24051)
-- Name: certifications p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.certifications FOR UPDATE USING (public.check_access_bool('update'::text, 'certifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6336 (class 3256 OID 24052)
-- Name: change_orders p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.change_orders FOR UPDATE USING (public.check_access_bool('update'::text, 'change_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6337 (class 3256 OID 24053)
-- Name: commitments p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.commitments FOR UPDATE USING (public.check_access_bool('update'::text, 'commitments'::text, project_id, NULL::uuid));


--
-- TOC entry 6338 (class 3256 OID 24054)
-- Name: compliance_checks p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.compliance_checks FOR UPDATE USING (public.check_access_bool('update'::text, 'compliance_checks'::text, project_id, NULL::uuid));


--
-- TOC entry 6339 (class 3256 OID 24055)
-- Name: compliance_tracking p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.compliance_tracking FOR UPDATE USING (public.check_access_bool('update'::text, 'compliance_tracking'::text, project_id, NULL::uuid));


--
-- TOC entry 6340 (class 3256 OID 24056)
-- Name: cost_codes p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.cost_codes FOR UPDATE USING (public.check_access_bool('update'::text, 'cost_codes'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6341 (class 3256 OID 24057)
-- Name: crew_assignments p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.crew_assignments FOR UPDATE USING (public.check_access_bool('update'::text, 'crew_assignments'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6342 (class 3256 OID 24058)
-- Name: crew_members p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.crew_members FOR UPDATE USING (public.check_access_bool('update'::text, 'crew_members'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6343 (class 3256 OID 24059)
-- Name: crews p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.crews FOR UPDATE USING (public.check_access_bool('update'::text, 'crews'::text, project_id, NULL::uuid));


--
-- TOC entry 6344 (class 3256 OID 24060)
-- Name: daily_logs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.daily_logs FOR UPDATE USING (public.check_access_bool('update'::text, 'daily_logs'::text, project_id, NULL::uuid));


--
-- TOC entry 6345 (class 3256 OID 24061)
-- Name: dashboard_configs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.dashboard_configs FOR UPDATE USING (public.check_access_bool('update'::text, 'dashboard_configs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6346 (class 3256 OID 24062)
-- Name: document_references p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.document_references FOR UPDATE USING (public.check_access_bool('update'::text, 'document_references'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6347 (class 3256 OID 24063)
-- Name: documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.documents FOR UPDATE USING (public.check_access_bool('update'::text, 'documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6348 (class 3256 OID 24064)
-- Name: drawing_versions p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.drawing_versions FOR UPDATE USING (public.check_access_bool('update'::text, 'drawing_versions'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6349 (class 3256 OID 24065)
-- Name: dump_trucks p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.dump_trucks FOR UPDATE USING (public.check_access_bool('update'::text, 'dump_trucks'::text, NULL::uuid, organization_id));


--
-- TOC entry 6350 (class 3256 OID 24066)
-- Name: employees p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.employees FOR UPDATE USING (public.check_access_bool('update'::text, 'employees'::text, NULL::uuid, organization_id));


--
-- TOC entry 6351 (class 3256 OID 24067)
-- Name: equipment p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.equipment FOR UPDATE USING (public.check_access_bool('update'::text, 'equipment'::text, NULL::uuid, organization_id));


--
-- TOC entry 6352 (class 3256 OID 24068)
-- Name: equipment_assignments p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.equipment_assignments FOR UPDATE USING (public.check_access_bool('update'::text, 'equipment_assignments'::text, project_id, NULL::uuid));


--
-- TOC entry 6353 (class 3256 OID 24069)
-- Name: equipment_maintenance p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.equipment_maintenance FOR UPDATE USING (public.check_access_bool('update'::text, 'equipment_maintenance'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6354 (class 3256 OID 24070)
-- Name: equipment_usage p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.equipment_usage FOR UPDATE USING (public.check_access_bool('update'::text, 'equipment_usage'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6355 (class 3256 OID 24071)
-- Name: estimate_line_items p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.estimate_line_items FOR UPDATE USING (public.check_access_bool('update'::text, 'estimate_line_items'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6356 (class 3256 OID 24072)
-- Name: estimates p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.estimates FOR UPDATE USING (public.check_access_bool('update'::text, 'estimates'::text, project_id, NULL::uuid));


--
-- TOC entry 6357 (class 3256 OID 24073)
-- Name: financial_documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.financial_documents FOR UPDATE USING (public.check_access_bool('update'::text, 'financial_documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6358 (class 3256 OID 24074)
-- Name: general_ledger p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.general_ledger FOR UPDATE USING (public.check_access_bool('update'::text, 'general_ledger'::text, project_id, NULL::uuid));


--
-- TOC entry 6359 (class 3256 OID 24075)
-- Name: hr_documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.hr_documents FOR UPDATE USING (public.check_access_bool('update'::text, 'hr_documents'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6360 (class 3256 OID 24076)
-- Name: inspections p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.inspections FOR UPDATE USING (public.check_access_bool('update'::text, 'inspections'::text, project_id, NULL::uuid));


--
-- TOC entry 6361 (class 3256 OID 24077)
-- Name: integration_tokens p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.integration_tokens FOR UPDATE USING (public.check_access_bool('update'::text, 'integration_tokens'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6362 (class 3256 OID 24078)
-- Name: inventory_transactions p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.inventory_transactions FOR UPDATE USING (public.check_access_bool('update'::text, 'inventory_transactions'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6363 (class 3256 OID 24079)
-- Name: issues p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.issues FOR UPDATE USING (public.check_access_bool('update'::text, 'issues'::text, project_id, NULL::uuid));


--
-- TOC entry 6364 (class 3256 OID 24080)
-- Name: job_titles p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.job_titles FOR UPDATE USING (public.check_access_bool('update'::text, 'job_titles'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6365 (class 3256 OID 24081)
-- Name: labor_records p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.labor_records FOR UPDATE USING (public.check_access_bool('update'::text, 'labor_records'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6366 (class 3256 OID 24082)
-- Name: line_item_entries p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.line_item_entries FOR UPDATE USING (public.check_access_bool('update'::text, 'line_item_entries'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6367 (class 3256 OID 24083)
-- Name: line_item_templates p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.line_item_templates FOR UPDATE USING (public.check_access_bool('update'::text, 'line_item_templates'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6368 (class 3256 OID 24084)
-- Name: line_items p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.line_items FOR UPDATE USING (public.check_access_bool('update'::text, 'line_items'::text, project_id, NULL::uuid));


--
-- TOC entry 6369 (class 3256 OID 24085)
-- Name: maps p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.maps FOR UPDATE USING (public.check_access_bool('update'::text, 'maps'::text, project_id, NULL::uuid));


--
-- TOC entry 6370 (class 3256 OID 24086)
-- Name: material_inventory p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.material_inventory FOR UPDATE USING (public.check_access_bool('update'::text, 'material_inventory'::text, NULL::uuid, organization_id));


--
-- TOC entry 6371 (class 3256 OID 24087)
-- Name: material_orders p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.material_orders FOR UPDATE USING (public.check_access_bool('update'::text, 'material_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6372 (class 3256 OID 24088)
-- Name: material_receipts p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.material_receipts FOR UPDATE USING (public.check_access_bool('update'::text, 'material_receipts'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6373 (class 3256 OID 24089)
-- Name: materials p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.materials FOR UPDATE USING (public.check_access_bool('update'::text, 'materials'::text, NULL::uuid, organization_id));


--
-- TOC entry 6374 (class 3256 OID 24090)
-- Name: meeting_minutes p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.meeting_minutes FOR UPDATE USING (public.check_access_bool('update'::text, 'meeting_minutes'::text, project_id, NULL::uuid));


--
-- TOC entry 6375 (class 3256 OID 24091)
-- Name: notifications p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.notifications FOR UPDATE USING (public.check_access_bool('update'::text, 'notifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6418 (class 3256 OID 43264)
-- Name: organization_invites p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.organization_invites FOR UPDATE USING (public.check_access_bool('update'::text, 'organization_invites'::text, NULL::uuid, organization_id));


--
-- TOC entry 6376 (class 3256 OID 24092)
-- Name: organization_members p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.organization_members FOR UPDATE USING (public.check_access_bool('update'::text, 'organization_members'::text, NULL::uuid, organization_id));


--
-- TOC entry 6377 (class 3256 OID 24093)
-- Name: organization_projects p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.organization_projects FOR UPDATE USING (public.check_access_bool('update'::text, 'organization_projects'::text, project_id, organization_id));


--
-- TOC entry 6415 (class 3256 OID 28857)
-- Name: organizations p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.organizations FOR UPDATE USING (public.check_access_bool('update'::text, 'organizations'::text, NULL::uuid, id));


--
-- TOC entry 6378 (class 3256 OID 24095)
-- Name: payments p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.payments FOR UPDATE USING (public.check_access_bool('update'::text, 'payments'::text, project_id, NULL::uuid));


--
-- TOC entry 6379 (class 3256 OID 24096)
-- Name: payroll p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.payroll FOR UPDATE USING (public.check_access_bool('update'::text, 'payroll'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6380 (class 3256 OID 24097)
-- Name: photos p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.photos FOR UPDATE USING (public.check_access_bool('update'::text, 'photos'::text, project_id, NULL::uuid));


--
-- TOC entry 6381 (class 3256 OID 24098)
-- Name: prequalifications p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.prequalifications FOR UPDATE USING (public.check_access_bool('update'::text, 'prequalifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6382 (class 3256 OID 24099)
-- Name: procurement_workflows p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.procurement_workflows FOR UPDATE USING (public.check_access_bool('update'::text, 'procurement_workflows'::text, project_id, NULL::uuid));


--
-- TOC entry 6421 (class 3256 OID 45496)
-- Name: profiles p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.profiles AS RESTRICTIVE FOR UPDATE TO authenticated USING (public.check_access_bool('update'::text, 'profiles'::text, NULL::uuid, organization_id));


--
-- TOC entry 6383 (class 3256 OID 24101)
-- Name: progress_billings p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.progress_billings FOR UPDATE USING (public.check_access_bool('update'::text, 'progress_billings'::text, project_id, NULL::uuid));


--
-- TOC entry 6384 (class 3256 OID 24102)
-- Name: project_inspectors p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.project_inspectors FOR UPDATE USING (public.check_access_bool('update'::text, 'project_inspectors'::text, project_id, NULL::uuid));


--
-- TOC entry 6385 (class 3256 OID 24103)
-- Name: projects p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.projects FOR UPDATE USING (public.check_access_bool('update'::text, 'projects'::text, NULL::uuid, organization_id));


--
-- TOC entry 6386 (class 3256 OID 24104)
-- Name: punch_lists p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.punch_lists FOR UPDATE USING (public.check_access_bool('update'::text, 'punch_lists'::text, project_id, NULL::uuid));


--
-- TOC entry 6387 (class 3256 OID 24105)
-- Name: purchase_orders p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.purchase_orders FOR UPDATE USING (public.check_access_bool('update'::text, 'purchase_orders'::text, project_id, NULL::uuid));


--
-- TOC entry 6388 (class 3256 OID 24106)
-- Name: quality_reviews p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.quality_reviews FOR UPDATE USING (public.check_access_bool('update'::text, 'quality_reviews'::text, project_id, NULL::uuid));


--
-- TOC entry 6389 (class 3256 OID 24107)
-- Name: regulatory_documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.regulatory_documents FOR UPDATE USING (public.check_access_bool('update'::text, 'regulatory_documents'::text, project_id, NULL::uuid));


--
-- TOC entry 6390 (class 3256 OID 24108)
-- Name: reports p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.reports FOR UPDATE USING (public.check_access_bool('update'::text, 'reports'::text, project_id, NULL::uuid));


--
-- TOC entry 6391 (class 3256 OID 24109)
-- Name: rfis p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.rfis FOR UPDATE USING (public.check_access_bool('update'::text, 'rfis'::text, project_id, NULL::uuid));


--
-- TOC entry 6392 (class 3256 OID 24110)
-- Name: safety_incidents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.safety_incidents FOR UPDATE USING (public.check_access_bool('update'::text, 'safety_incidents'::text, project_id, NULL::uuid));


--
-- TOC entry 6393 (class 3256 OID 24111)
-- Name: sensor_data p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.sensor_data FOR UPDATE USING (public.check_access_bool('update'::text, 'sensor_data'::text, project_id, NULL::uuid));


--
-- TOC entry 6394 (class 3256 OID 24112)
-- Name: subcontractor_agreements p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.subcontractor_agreements FOR UPDATE USING (public.check_access_bool('update'::text, 'subcontractor_agreements'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6395 (class 3256 OID 24113)
-- Name: subcontracts p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.subcontracts FOR UPDATE USING (public.check_access_bool('update'::text, 'subcontracts'::text, project_id, NULL::uuid));


--
-- TOC entry 6396 (class 3256 OID 24114)
-- Name: submittals p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.submittals FOR UPDATE USING (public.check_access_bool('update'::text, 'submittals'::text, project_id, NULL::uuid));


--
-- TOC entry 6397 (class 3256 OID 24115)
-- Name: tack_rates p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.tack_rates FOR UPDATE USING (public.check_access_bool('update'::text, 'tack_rates'::text, project_id, NULL::uuid));


--
-- TOC entry 6398 (class 3256 OID 24116)
-- Name: task_dependencies p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.task_dependencies FOR UPDATE USING (public.check_access_bool('update'::text, 'task_dependencies'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6399 (class 3256 OID 24117)
-- Name: task_status_logs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.task_status_logs FOR UPDATE USING (public.check_access_bool('update'::text, 'task_status_logs'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6400 (class 3256 OID 24118)
-- Name: tasks p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.tasks FOR UPDATE USING (public.check_access_bool('update'::text, 'tasks'::text, project_id, NULL::uuid));


--
-- TOC entry 6401 (class 3256 OID 24119)
-- Name: training_records p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.training_records FOR UPDATE USING (public.check_access_bool('update'::text, 'training_records'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6402 (class 3256 OID 24120)
-- Name: user_projects p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.user_projects FOR UPDATE USING (public.check_access_bool('update'::text, 'user_projects'::text, project_id, NULL::uuid));


--
-- TOC entry 6403 (class 3256 OID 24121)
-- Name: vendor_bid_packages p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendor_bid_packages FOR UPDATE USING (public.check_access_bool('update'::text, 'vendor_bid_packages'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6404 (class 3256 OID 24122)
-- Name: vendor_contacts p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendor_contacts FOR UPDATE USING (public.check_access_bool('update'::text, 'vendor_contacts'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6405 (class 3256 OID 24123)
-- Name: vendor_documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendor_documents FOR UPDATE USING (public.check_access_bool('update'::text, 'vendor_documents'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6406 (class 3256 OID 24124)
-- Name: vendor_qualifications p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendor_qualifications FOR UPDATE USING (public.check_access_bool('update'::text, 'vendor_qualifications'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6407 (class 3256 OID 24125)
-- Name: vendors p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendors FOR UPDATE USING (public.check_access_bool('update'::text, 'vendors'::text, NULL::uuid, organization_id));


--
-- TOC entry 6408 (class 3256 OID 24126)
-- Name: wbs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.wbs FOR UPDATE USING (public.check_access_bool('update'::text, 'wbs'::text, project_id, NULL::uuid));


--
-- TOC entry 6409 (class 3256 OID 24127)
-- Name: workflows p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.workflows FOR UPDATE USING (public.check_access_bool('update'::text, 'workflows'::text, NULL::uuid, NULL::uuid));


--
-- TOC entry 6028 (class 0 OID 21694)
-- Dependencies: 400
-- Name: payments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6029 (class 0 OID 21704)
-- Dependencies: 401
-- Name: payroll; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.payroll ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6030 (class 0 OID 21714)
-- Dependencies: 402
-- Name: photos; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.photos ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6031 (class 0 OID 21725)
-- Dependencies: 403
-- Name: prequalifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.prequalifications ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6032 (class 0 OID 21735)
-- Dependencies: 404
-- Name: procurement_workflows; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procurement_workflows ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6033 (class 0 OID 21745)
-- Dependencies: 405
-- Name: profiles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6424 (class 3256 OID 45502)
-- Name: profiles profiles_insert_authenticated; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY profiles_insert_authenticated ON public.profiles FOR INSERT TO authenticated WITH CHECK ((((id = ( SELECT auth.uid() AS uid)) AND (NOT (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE (p.id = ( SELECT auth.uid() AS uid)))))) OR (id = ( SELECT auth.uid() AS uid))));


--
-- TOC entry 6410 (class 3256 OID 25268)
-- Name: profiles profiles_select_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY profiles_select_own ON public.profiles FOR SELECT TO authenticated USING ((id = ( SELECT auth.uid() AS uid)));


--
-- TOC entry 6411 (class 3256 OID 25270)
-- Name: profiles profiles_update_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY profiles_update_own ON public.profiles FOR UPDATE TO authenticated USING ((id = ( SELECT auth.uid() AS uid))) WITH CHECK ((id = ( SELECT auth.uid() AS uid)));


--
-- TOC entry 6034 (class 0 OID 21755)
-- Dependencies: 406
-- Name: progress_billings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.progress_billings ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6035 (class 0 OID 21765)
-- Dependencies: 407
-- Name: project_inspectors; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.project_inspectors ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6064 (class 0 OID 26547)
-- Dependencies: 525
-- Name: project_invites; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.project_invites ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6062 (class 0 OID 26504)
-- Dependencies: 523
-- Name: project_service_areas; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.project_service_areas ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6036 (class 0 OID 21771)
-- Dependencies: 408
-- Name: projects; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6037 (class 0 OID 21783)
-- Dependencies: 409
-- Name: punch_lists; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.punch_lists ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6038 (class 0 OID 21793)
-- Dependencies: 410
-- Name: purchase_orders; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.purchase_orders ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6039 (class 0 OID 21803)
-- Dependencies: 411
-- Name: quality_reviews; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.quality_reviews ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6040 (class 0 OID 21813)
-- Dependencies: 412
-- Name: regulatory_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.regulatory_documents ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6041 (class 0 OID 21824)
-- Dependencies: 413
-- Name: reports; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6042 (class 0 OID 21835)
-- Dependencies: 414
-- Name: rfis; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.rfis ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6043 (class 0 OID 21845)
-- Dependencies: 415
-- Name: safety_incidents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.safety_incidents ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6044 (class 0 OID 21856)
-- Dependencies: 416
-- Name: sensor_data; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.sensor_data ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6045 (class 0 OID 21867)
-- Dependencies: 417
-- Name: subcontractor_agreements; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.subcontractor_agreements ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6046 (class 0 OID 21877)
-- Dependencies: 418
-- Name: subcontracts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.subcontracts ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6047 (class 0 OID 21887)
-- Dependencies: 419
-- Name: submittals; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.submittals ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6048 (class 0 OID 21898)
-- Dependencies: 420
-- Name: tack_rates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.tack_rates ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6049 (class 0 OID 21908)
-- Dependencies: 421
-- Name: task_dependencies; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.task_dependencies ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6050 (class 0 OID 21915)
-- Dependencies: 422
-- Name: task_status_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.task_status_logs ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6051 (class 0 OID 21921)
-- Dependencies: 423
-- Name: tasks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6052 (class 0 OID 21932)
-- Dependencies: 424
-- Name: training_records; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.training_records ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6053 (class 0 OID 21942)
-- Dependencies: 425
-- Name: user_projects; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_projects ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6054 (class 0 OID 21952)
-- Dependencies: 426
-- Name: vendor_bid_packages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendor_bid_packages ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6055 (class 0 OID 21960)
-- Dependencies: 427
-- Name: vendor_contacts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendor_contacts ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6056 (class 0 OID 21970)
-- Dependencies: 428
-- Name: vendor_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendor_documents ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6057 (class 0 OID 21981)
-- Dependencies: 429
-- Name: vendor_qualifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendor_qualifications ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6058 (class 0 OID 21991)
-- Dependencies: 430
-- Name: vendors; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendors ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 6059 (class 0 OID 22001)
-- Dependencies: 431
-- Name: wbs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.wbs ENABLE ROW LEVEL SECURITY;

--
-- TOC entry 5973 (class 0 OID 21041)
-- Dependencies: 345
-- Name: workflows; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;

-- Completed on 2026-02-21 02:31:24

--
-- PostgreSQL database dump complete
--

