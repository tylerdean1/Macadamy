--
-- PostgreSQL database dump
--

-- Dumped from database version 17.6
-- Dumped by pg_dump version 17.5

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: public; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA public;


--
-- Name: certification_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.certification_type AS ENUM (
    'osha_10',
    'osha_30',
    'cpr',
    'first_aid',
    'equipment_card',
    'other'
);


--
-- Name: commitment_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.commitment_type AS ENUM (
    'subcontract',
    'purchase_order',
    'change_order'
);


--
-- Name: document_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.document_type AS ENUM (
    'drawing',
    'spec',
    'rfi',
    'submittal',
    'change_order',
    'other'
);


--
-- Name: equipment_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.equipment_type AS ENUM (
    'truck',
    'excavator',
    'grader',
    'roller',
    'loader',
    'misc'
);


--
-- Name: general_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.general_status AS ENUM (
    'draft',
    'pending',
    'approved',
    'rejected',
    'active',
    'inactive',
    'complete',
    'closed'
);


--
-- Name: issue_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.issue_type AS ENUM (
    'safety',
    'quality',
    'field',
    'equipment',
    'other'
);


--
-- Name: notification_category; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.notification_category AS ENUM (
    'bid_received',
    'approval_needed',
    'deadline_reminder',
    'task_assigned',
    'workflow_update',
    'general'
);


--
-- Name: org_role; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.org_role AS ENUM (
    'admin',
    'manager',
    'superintendent',
    'foreman',
    'worker',
    'viewer',
    'accountant',
    'hr',
    'estimator',
    'guest',
    'owner'
);


--
-- Name: project_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.project_status AS ENUM (
    'planned',
    'active',
    'complete',
    'archived',
    'on_hold',
    'canceled'
);


--
-- Name: task_status; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.task_status AS ENUM (
    'not_started',
    'in_progress',
    'completed',
    'blocked'
);


--
-- Name: unit_measure; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.unit_measure AS ENUM (
    'Feet (FT)',
    'Inches (IN)',
    'Linear Feet (LF)',
    'Mile (MI)',
    'Shoulder Mile (SMI)',
    'Square Feet (SF)',
    'Square Yard (SY)',
    'Acre (AC)',
    'Cubic Foot (CF)',
    'Cubic Yard (CY)',
    'Gallon (GAL)',
    'Pounds (LBS)',
    'TON',
    'Each (EA)',
    'Lump Sum (LS)',
    'Hour (HR)',
    'DAY',
    'Station (STA)',
    'MSF (1000SF)',
    'MLF (1000LF)',
    'Cubic Feet per Second (CFS)',
    'Pounds per Square Inch (PSI)',
    'Percent (%)',
    'Degrees (*)'
);


--
-- Name: user_role_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.user_role_type AS ENUM (
    'system_admin',
    'org_admin',
    'org_supervisor',
    'org_user',
    'org_viewer',
    'inspector',
    'auditor'
);


--
-- Name: workflow_name; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.workflow_name AS ENUM (
    'estimate_submission',
    'bid_submission',
    'bid_review',
    'contract_award',
    'task_execution',
    'inspection',
    'project_closeout'
);


SET default_table_access_method = heap;

--
-- Name: workflows; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.workflows (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    entity_schema text NOT NULL,
    entity_table text NOT NULL,
    entity_id uuid NOT NULL,
    workflow_name public.workflow_name DEFAULT 'estimate_submission'::public.workflow_name NOT NULL,
    current_state text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.workflows FORCE ROW LEVEL SECURITY;


--
-- Name: advance_workflow(uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.advance_workflow(_id uuid, _new_state text) RETURNS public.workflows
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  UPDATE public.workflows
     SET current_state = _new_state,
         updated_at    = now()
   WHERE id = _id
   RETURNING *;
$$;


--
-- Name: can_edit_org_notification_settings(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.can_edit_org_notification_settings(p_organization_id uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_global_role public.user_role_type;
  v_org_role public.org_role;
BEGIN
  IF v_user_id IS NULL THEN
    RETURN false;
  END IF;

  SELECT p.role
  INTO v_global_role
  FROM public.profiles p
  WHERE p.id = v_user_id;

  IF v_global_role = 'system_admin' THEN
    RETURN true;
  END IF;

  SELECT om.permission_role
  INTO v_org_role
  FROM public.organization_members om
  WHERE om.organization_id = p_organization_id
    AND om.profile_id = v_user_id
    AND om.deleted_at IS NULL
  ORDER BY om.created_at DESC
  LIMIT 1;

  RETURN v_org_role = ANY (ARRAY[
    'owner'::public.org_role,
    'admin'::public.org_role,
    'manager'::public.org_role,
    'superintendent'::public.org_role,
    'foreman'::public.org_role,
    'accountant'::public.org_role,
    'hr'::public.org_role
  ]);
END;
$$;


--
-- Name: profiles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.profiles (
    id uuid NOT NULL,
    email text NOT NULL,
    full_name text,
    phone text,
    organization_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    role public.user_role_type DEFAULT 'org_user'::public.user_role_type,
    deleted_at timestamp with time zone,
    profile_completed_at timestamp with time zone,
    avatar_id uuid,
    location text
);

ALTER TABLE ONLY public.profiles FORCE ROW LEVEL SECURITY;


--
-- Name: change_org_member_job_title_with_reason(uuid, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.change_org_member_job_title_with_reason(p_org_id uuid, p_profile_id uuid, p_job_title_id uuid, p_reason text) RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_actor_id uuid := auth.uid();
  v_actor_name text;
  v_org_name text;
  v_target_name text;
  v_previous_job_title_id uuid;
  v_previous_job_title_name text;
  v_current_job_title_name text;
  v_updated_profile public.profiles;
  v_member record;
BEGIN
  IF v_actor_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_org_id IS NULL OR p_profile_id IS NULL OR p_job_title_id IS NULL THEN
    RAISE EXCEPTION 'Missing required inputs';
  END IF;

  IF COALESCE(TRIM(p_reason), '') = '' THEN
    RAISE EXCEPTION 'Reason is required';
  END IF;

  SELECT om.job_title_id, p.full_name
    INTO v_previous_job_title_id, v_target_name
  FROM public.organization_members om
  JOIN public.profiles p ON p.id = om.profile_id
  WHERE om.organization_id = p_org_id
    AND om.profile_id = p_profile_id
    AND om.deleted_at IS NULL
    AND p.deleted_at IS NULL
  ORDER BY om.created_at DESC
  LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Target is not an active member of this organization' USING errcode = 'P0001';
  END IF;

  IF v_previous_job_title_id = p_job_title_id THEN
    RAISE EXCEPTION 'Selected title is already assigned' USING errcode = 'P0001';
  END IF;

  v_updated_profile := public.set_org_member_job_title(p_org_id, p_profile_id, p_job_title_id);

  SELECT p.full_name INTO v_actor_name FROM public.profiles p WHERE p.id = v_actor_id;
  SELECT o.name INTO v_org_name FROM public.organizations o WHERE o.id = p_org_id;
  SELECT jt.name INTO v_previous_job_title_name FROM public.job_titles jt WHERE jt.id = v_previous_job_title_id;
  SELECT jt.name INTO v_current_job_title_name FROM public.job_titles jt WHERE jt.id = p_job_title_id;

  PERFORM public.insert_notifications(
    jsonb_build_object(
      'user_id', p_profile_id,
      'organization_id', p_org_id,
      'category', 'workflow_update',
      'message',
        'Your position in ' || COALESCE(v_org_name, 'this organization')
        || ' has been changed from ' || COALESCE(v_previous_job_title_name, 'Unassigned')
        || ' to ' || COALESCE(v_current_job_title_name, 'Unassigned')
        || '. Reason: ' || TRIM(p_reason),
      'payload', jsonb_build_object(
        'event', 'member_job_title_changed',
        'organization_id', p_org_id,
        'organization_name', v_org_name,
        'affected_profile_id', p_profile_id,
        'affected_profile_name', v_target_name,
        'previous_job_title_id', v_previous_job_title_id,
        'previous_job_title_name', COALESCE(v_previous_job_title_name, 'Unassigned'),
        'selected_job_title_id', p_job_title_id,
        'selected_job_title_name', COALESCE(v_current_job_title_name, 'Unassigned'),
        'changed_by_profile_id', v_actor_id,
        'changed_by_name', COALESCE(v_actor_name, 'Organization Admin'),
        'reason', TRIM(p_reason),
        'changed_at', now()
      )
    )
  );

  FOR v_member IN
    SELECT om.profile_id
    FROM public.organization_members om
    WHERE om.organization_id = p_org_id
      AND om.deleted_at IS NULL
      AND om.profile_id <> p_profile_id
  LOOP
    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', v_member.profile_id,
        'organization_id', p_org_id,
        'category', 'workflow_update',
        'message',
          COALESCE(v_target_name, p_profile_id::text)
          || '''s title was just changed from '
          || COALESCE(v_previous_job_title_name, 'Unassigned')
          || ' to '
          || COALESCE(v_current_job_title_name, 'Unassigned')
          || '!',
        'payload', jsonb_build_object(
          'event', 'member_job_title_changed_broadcast',
          'organization_id', p_org_id,
          'organization_name', v_org_name,
          'affected_profile_id', p_profile_id,
          'affected_profile_name', v_target_name,
          'previous_job_title_name', COALESCE(v_previous_job_title_name, 'Unassigned'),
          'current_job_title_name', COALESCE(v_current_job_title_name, 'Unassigned'),
          'selected_job_title_name', COALESCE(v_current_job_title_name, 'Unassigned'),
          'changed_by_profile_id', v_actor_id,
          'changed_by_name', COALESCE(v_actor_name, 'Organization Admin'),
          'reason', TRIM(p_reason),
          'changed_at', now()
        )
      )
    );
  END LOOP;

  RETURN v_updated_profile;
END;
$$;


--
-- Name: check_access(text, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_access(_action text, _resource text, _project_id uuid DEFAULT NULL::uuid, _organization_id uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  _user_id uuid := auth.uid();
  _role public.user_role_type;
  _effective_org_id uuid;
  _project_org_id uuid;
  _is_member boolean := false;
begin
  if _user_id is null then
    raise exception 'Not authenticated'
      using errcode = '42501';
  end if;

  select p.role
    into _role
  from public.profiles p
  where p.id = _user_id
    and p.deleted_at is null;

  if _role is null then
    raise exception 'Access denied: profile not found for user %', _user_id
      using errcode = '42501';
  end if;

  if _role = 'system_admin' then
    return;
  end if;

  if _project_id is not null then
    select p.organization_id
      into _project_org_id
    from public.projects p
    where p.id = _project_id
      and p.deleted_at is null;

    if _project_org_id is null then
      raise exception 'Access denied: project % not found', _project_id
        using errcode = '42501';
    end if;
  end if;

  _effective_org_id := _organization_id;
  if _effective_org_id is null and _project_org_id is not null then
    _effective_org_id := _project_org_id;
  elsif _effective_org_id is not null and _project_org_id is not null and _effective_org_id <> _project_org_id then
    raise exception 'Access denied: project % is not in organization %', _project_id, _effective_org_id
      using errcode = '42501';
  end if;

  if _resource in ('organizations', 'organization_members', 'profiles', 'job_titles', 'integration_tokens')
     and _effective_org_id is null then
    raise exception 'Access denied: organization context is required for resource %', _resource
      using errcode = '42501';
  end if;

  if _effective_org_id is not null then
    select exists (
      select 1
      from public.organization_members om
      where om.organization_id = _effective_org_id
        and om.profile_id = _user_id
        and om.deleted_at is null
    )
    into _is_member;

    if not _is_member then
      raise exception 'Access denied: you are not an active member of organization %', _effective_org_id
        using errcode = '42501';
    end if;
  end if;

  if _role = 'org_admin' then
    return;
  end if;

  if _role = 'org_supervisor' then
    if _resource in ('organizations', 'organization_members') then
      raise exception 'Access denied: org_supervisor cannot manage organization metadata or users'
        using errcode = '42501';
    end if;
    return;
  end if;

  if _role = 'org_user' then
    if _action = 'select' and _resource in (
      'organizations', 'organization_members', 'profiles', 'job_titles', 'integration_tokens'
    ) then
      raise exception 'Access denied: org_user cannot read %', _resource
        using errcode = '42501';
    end if;

    if _action in ('insert', 'update', 'delete') then
      if _resource in (
        'daily_logs', 'photos', 'documents', 'rfis', 'submittals',
        'inspections', 'line_item_entries', 'labor_records',
        'equipment_usage', 'issues', 'punch_lists', 'quality_reviews',
        'meeting_minutes'
      ) then
        return;
      elsif _resource = 'notifications' and _effective_org_id is not null then
        -- allow org-scoped notification writes for active org members
        return;
      else
        raise exception 'Access denied: org_user cannot write to %', _resource
          using errcode = '42501';
      end if;
    end if;

    return;
  end if;

  if _role = 'org_viewer' then
    if _action = 'select' then
      return;
    else
      raise exception 'Access denied: org_viewer is read-only'
        using errcode = '42501';
    end if;
  end if;

  if _role = 'inspector' then
    if _action = 'select' then
      return;
    elsif _action in ('insert', 'update') and _resource in (
      'inspections', 'reports', 'documents', 'regulatory_documents'
    ) then
      if _project_id is null then
        raise exception 'Access denied: inspector action requires project context'
          using errcode = '42501';
      end if;

      if not exists (
        select 1
        from public.project_inspectors pi
        where pi.project_id = _project_id
          and pi.profile_id = _user_id
      ) then
        raise exception 'Access denied: inspector not assigned to project %', _project_id
          using errcode = '42501';
      end if;

      return;
    else
      raise exception 'Access denied: inspector cannot % on %', _action, _resource
        using errcode = '42501';
    end if;
  end if;

  if _role = 'auditor' then
    if _action = 'select' then
      return;
    else
      raise exception 'Access denied: auditor is read-only'
        using errcode = '42501';
    end if;
  end if;

  raise exception 'Access denied: unrecognized role % or unsupported action % on %', _role, _action, _resource
    using errcode = '42501';
end;
$$;


--
-- Name: check_access_bool(text, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_access_bool(_action text, _table text, _proj uuid, _org uuid) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM check_access(_action, _table, _proj, _org);
  RETURN true;
EXCEPTION
  WHEN others THEN
    RETURN false;
END;
$$;


--
-- Name: complete_my_profile(text, uuid, uuid, text, public.user_role_type, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.complete_my_profile(p_full_name text, p_avatar_id uuid DEFAULT NULL::uuid, p_organization_id uuid DEFAULT NULL::uuid, p_phone text DEFAULT NULL::text, p_role public.user_role_type DEFAULT NULL::public.user_role_type, p_location text DEFAULT NULL::text) RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
declare
  updated_profile public.profiles;
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  if p_role = 'system_admin' then
    raise exception 'system_admin role cannot be assigned via onboarding';
  end if;

  update public.profiles
  set
    avatar_id = p_avatar_id,
    full_name = p_full_name,
    organization_id = p_organization_id,
    phone = p_phone,
    role = coalesce(p_role, role),
    location = p_location,
    profile_completed_at = coalesce(profile_completed_at, now()),
    updated_at = now()
  where id = auth.uid()
  returning * into updated_profile;

  return updated_profile;
end;
$$;


--
-- Name: count_unread_notifications(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.count_unread_notifications() RETURNS integer
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  select count(*)
    from public.notifications
   where user_id = auth.uid()
     and is_read = false
     and deleted_at is null;
$$;


--
-- Name: create_my_organization(text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_my_organization(p_name text, p_description text DEFAULT NULL::text, p_mission_statement text DEFAULT NULL::text, p_headquarters text DEFAULT NULL::text, p_logo_url text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_org_id uuid;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  insert into public.organizations (
    name, description, mission_statement, headquarters, logo_url, created_at, updated_at
  )
  values (
    p_name,
    nullif(btrim(p_description), ''),
    nullif(btrim(p_mission_statement), ''),
    nullif(btrim(p_headquarters), ''),
    nullif(btrim(p_logo_url), ''),
    now(),
    now()
  )
  returning id into v_org_id;

  insert into public.organization_members (organization_id, profile_id, permission_role, created_at, updated_at)
  values (v_org_id, v_user_id, 'owner'::public.org_role, now(), now());

  update public.profiles
  set organization_id = v_org_id,
      updated_at = now()
  where id = v_user_id;

  return v_org_id;
end;
$$;


--
-- Name: projects; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    name text NOT NULL,
    description text,
    status public.project_status,
    start_date date,
    end_date date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.projects FORCE ROW LEVEL SECURITY;


--
-- Name: create_project_with_owner(jsonb, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.create_project_with_owner(_input jsonb, _role text DEFAULT 'project_manager'::text) RETURNS SETOF public.projects
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_name text := NULLIF(_input->>'name','');
  v_description text := NULLIF(_input->>'description','');
  v_status public.project_status := COALESCE((_input->>'status')::public.project_status, 'planned');
  v_start_date date := NULLIF(_input->>'start_date','')::date;
  v_end_date date := NULLIF(_input->>'end_date','')::date;
  v_project public.projects;
  v_actor_name text;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT * INTO v_profile
  FROM public.profiles
  WHERE id = v_user_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Access denied: profile not found for user %', v_user_id;
  END IF;

  v_org_id := v_profile.organization_id;
  IF v_profile.role = 'system_admin' AND NULLIF(_input->>'organization_id','') IS NOT NULL THEN
    v_org_id := (_input->>'organization_id')::uuid;
  END IF;

  IF v_org_id IS NULL THEN
    RAISE EXCEPTION 'Organization is required to create a project';
  END IF;

  IF v_name IS NULL THEN
    RAISE EXCEPTION 'Project name is required';
  END IF;

  INSERT INTO public.projects (
    name, description, status, start_date, end_date, organization_id
  ) VALUES (
    v_name, v_description, v_status, v_start_date, v_end_date, v_org_id
  )
  RETURNING * INTO v_project;

  INSERT INTO public.user_projects (
    user_id, project_id, role
  ) VALUES (
    v_user_id, v_project.id, _role
  );

  SELECT p.full_name INTO v_actor_name
  FROM public.profiles p
  WHERE p.id = v_user_id;

  PERFORM public.emit_org_notification(
    v_org_id,
    'workflow_update',
    'New project "' || v_project.name || '" was created.',
    jsonb_build_object(
      'event', 'new_project_created',
      'organization_id', v_org_id,
      'project_id', v_project.id,
      'project_name', v_project.name,
      'created_by_profile_id', v_user_id,
      'created_by_name', COALESCE(v_actor_name, 'System'),
      'scope', 'org_wide'
    )
  );

  RETURN NEXT v_project;
END;
$$;


--
-- Name: delete_accounts_payable(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_accounts_payable(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.accounts_payable;
        BEGIN
          SELECT * INTO _row FROM public.accounts_payable WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','accounts_payable', _row.project_id, _row.organization_id);

          UPDATE public.accounts_payable
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_accounts_receivable(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_accounts_receivable(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.accounts_receivable;
        BEGIN
          SELECT * INTO _row FROM public.accounts_receivable WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','accounts_receivable', _row.project_id, _row.organization_id);

          UPDATE public.accounts_receivable
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_activity_logs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_activity_logs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.activity_logs;
        BEGIN
          SELECT * INTO _row FROM public.activity_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','activity_logs', _row.project_id, _row.organization_id);

          UPDATE public.activity_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_asphalt_types(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_asphalt_types(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.asphalt_types;
        BEGIN
          SELECT * INTO _row FROM public.asphalt_types WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','asphalt_types', _row.project_id, _row.organization_id);

          UPDATE public.asphalt_types
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_audit_log(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_audit_log(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.audit_log;
    BEGIN
      SELECT * INTO _row FROM public.audit_log WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('delete','audit_log', NULL, NULL);

      UPDATE public.audit_log
         SET deleted_at = now()
       WHERE id = _id;
    END;
    $$;


--
-- Name: delete_audit_logs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_audit_logs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.audit_logs;
        BEGIN
          SELECT * INTO _row FROM public.audit_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','audit_logs', _row.project_id, _row.organization_id);

          UPDATE public.audit_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_avatars(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_avatars(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.avatars;
        BEGIN
          SELECT * INTO _row FROM public.avatars WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','avatars', _row.project_id, _row.organization_id);

          UPDATE public.avatars
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_bid_packages(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_bid_packages(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.bid_packages;
        BEGIN
          SELECT * INTO _row FROM public.bid_packages WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bid_packages', _row.project_id, _row.organization_id);

          UPDATE public.bid_packages
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_bid_vendors(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_bid_vendors(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.bid_vendors;
        BEGIN
          SELECT * INTO _row FROM public.bid_vendors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bid_vendors', _row.project_id, _row.organization_id);

          UPDATE public.bid_vendors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_bids(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_bids(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.bids;
        BEGIN
          SELECT * INTO _row FROM public.bids WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bids', _row.project_id, _row.organization_id);

          UPDATE public.bids
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_bim_models(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_bim_models(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.bim_models;
        BEGIN
          SELECT * INTO _row FROM public.bim_models WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','bim_models', _row.project_id, _row.organization_id);

          UPDATE public.bim_models
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_certifications(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_certifications(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.certifications;
        BEGIN
          SELECT * INTO _row FROM public.certifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','certifications', _row.project_id, _row.organization_id);

          UPDATE public.certifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_change_orders(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_change_orders(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.change_orders;
        BEGIN
          SELECT * INTO _row FROM public.change_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','change_orders', _row.project_id, _row.organization_id);

          UPDATE public.change_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_commitments(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_commitments(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.commitments;
        BEGIN
          SELECT * INTO _row FROM public.commitments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','commitments', _row.project_id, _row.organization_id);

          UPDATE public.commitments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_compliance_checks(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_compliance_checks(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.compliance_checks;
        BEGIN
          SELECT * INTO _row FROM public.compliance_checks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','compliance_checks', _row.project_id, _row.organization_id);

          UPDATE public.compliance_checks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_compliance_tracking(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_compliance_tracking(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.compliance_tracking;
        BEGIN
          SELECT * INTO _row FROM public.compliance_tracking WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','compliance_tracking', _row.project_id, _row.organization_id);

          UPDATE public.compliance_tracking
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_cost_codes(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_cost_codes(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.cost_codes;
        BEGIN
          SELECT * INTO _row FROM public.cost_codes WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','cost_codes', _row.project_id, _row.organization_id);

          UPDATE public.cost_codes
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_crew_assignments(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_crew_assignments(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.crew_assignments;
        BEGIN
          SELECT * INTO _row FROM public.crew_assignments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crew_assignments', _row.project_id, _row.organization_id);

          UPDATE public.crew_assignments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_crew_members(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_crew_members(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.crew_members;
        BEGIN
          SELECT * INTO _row FROM public.crew_members WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crew_members', _row.project_id, _row.organization_id);

          UPDATE public.crew_members
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_crews(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_crews(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.crews;
        BEGIN
          SELECT * INTO _row FROM public.crews WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','crews', _row.project_id, _row.organization_id);

          UPDATE public.crews
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_daily_logs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_daily_logs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.daily_logs;
        BEGIN
          SELECT * INTO _row FROM public.daily_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','daily_logs', _row.project_id, _row.organization_id);

          UPDATE public.daily_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_dashboard_configs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_dashboard_configs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.dashboard_configs;
        BEGIN
          SELECT * INTO _row FROM public.dashboard_configs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','dashboard_configs', _row.project_id, _row.organization_id);

          UPDATE public.dashboard_configs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_document_references(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_document_references(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.document_references;
        BEGIN
          SELECT * INTO _row FROM public.document_references WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','document_references', _row.project_id, _row.organization_id);

          UPDATE public.document_references
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.documents;
        BEGIN
          SELECT * INTO _row FROM public.documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','documents', _row.project_id, _row.organization_id);

          UPDATE public.documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_drawing_versions(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_drawing_versions(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.drawing_versions;
        BEGIN
          SELECT * INTO _row FROM public.drawing_versions WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','drawing_versions', _row.project_id, _row.organization_id);

          UPDATE public.drawing_versions
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_dump_trucks(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_dump_trucks(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.dump_trucks;
        BEGIN
          SELECT * INTO _row FROM public.dump_trucks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','dump_trucks', _row.project_id, _row.organization_id);

          UPDATE public.dump_trucks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_employees(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_employees(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.employees;
        BEGIN
          SELECT * INTO _row FROM public.employees WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','employees', _row.project_id, _row.organization_id);

          UPDATE public.employees
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_equipment(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_equipment(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.equipment;
        BEGIN
          SELECT * INTO _row FROM public.equipment WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment', _row.project_id, _row.organization_id);

          UPDATE public.equipment
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_equipment_assignments(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_equipment_assignments(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.equipment_assignments;
        BEGIN
          SELECT * INTO _row FROM public.equipment_assignments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_assignments', _row.project_id, _row.organization_id);

          UPDATE public.equipment_assignments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_equipment_maintenance(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_equipment_maintenance(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.equipment_maintenance;
        BEGIN
          SELECT * INTO _row FROM public.equipment_maintenance WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_maintenance', _row.project_id, _row.organization_id);

          UPDATE public.equipment_maintenance
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_equipment_usage(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_equipment_usage(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.equipment_usage;
        BEGIN
          SELECT * INTO _row FROM public.equipment_usage WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','equipment_usage', _row.project_id, _row.organization_id);

          UPDATE public.equipment_usage
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_estimate_line_items(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_estimate_line_items(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.estimate_line_items;
        BEGIN
          SELECT * INTO _row FROM public.estimate_line_items WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','estimate_line_items', _row.project_id, _row.organization_id);

          UPDATE public.estimate_line_items
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_estimates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_estimates(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.estimates;
        BEGIN
          SELECT * INTO _row FROM public.estimates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','estimates', _row.project_id, _row.organization_id);

          UPDATE public.estimates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_financial_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_financial_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.financial_documents;
        BEGIN
          SELECT * INTO _row FROM public.financial_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','financial_documents', _row.project_id, _row.organization_id);

          UPDATE public.financial_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_general_ledger(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_general_ledger(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.general_ledger;
        BEGIN
          SELECT * INTO _row FROM public.general_ledger WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','general_ledger', _row.project_id, _row.organization_id);

          UPDATE public.general_ledger
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_hr_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_hr_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.hr_documents;
        BEGIN
          SELECT * INTO _row FROM public.hr_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','hr_documents', _row.project_id, _row.organization_id);

          UPDATE public.hr_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_inspections(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_inspections(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.inspections;
        BEGIN
          SELECT * INTO _row FROM public.inspections WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','inspections', _row.project_id, _row.organization_id);

          UPDATE public.inspections
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_integration_tokens(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_integration_tokens(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.integration_tokens;
        BEGIN
          SELECT * INTO _row FROM public.integration_tokens WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','integration_tokens', _row.project_id, _row.organization_id);

          UPDATE public.integration_tokens
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_inventory_transactions(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_inventory_transactions(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.inventory_transactions;
        BEGIN
          SELECT * INTO _row FROM public.inventory_transactions WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','inventory_transactions', _row.project_id, _row.organization_id);

          UPDATE public.inventory_transactions
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_issues(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_issues(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.issues;
        BEGIN
          SELECT * INTO _row FROM public.issues WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','issues', _row.project_id, _row.organization_id);

          UPDATE public.issues
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_job_titles(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_job_titles(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.job_titles;
        BEGIN
          SELECT * INTO _row FROM public.job_titles WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','job_titles', _row.project_id, _row.organization_id);

          UPDATE public.job_titles
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_labor_records(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_labor_records(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.labor_records;
        BEGIN
          SELECT * INTO _row FROM public.labor_records WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','labor_records', _row.project_id, _row.organization_id);

          UPDATE public.labor_records
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_line_item_entries(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_line_item_entries(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.line_item_entries;
        BEGIN
          SELECT * INTO _row FROM public.line_item_entries WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_item_entries', _row.project_id, _row.organization_id);

          UPDATE public.line_item_entries
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_line_item_templates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_line_item_templates(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.line_item_templates;
        BEGIN
          SELECT * INTO _row FROM public.line_item_templates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_item_templates', _row.project_id, _row.organization_id);

          UPDATE public.line_item_templates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_line_items(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_line_items(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.line_items;
        BEGIN
          SELECT * INTO _row FROM public.line_items WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','line_items', _row.project_id, _row.organization_id);

          UPDATE public.line_items
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_maps(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_maps(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.maps;
        BEGIN
          SELECT * INTO _row FROM public.maps WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','maps', _row.project_id, _row.organization_id);

          UPDATE public.maps
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_material_inventory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_material_inventory(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.material_inventory;
        BEGIN
          SELECT * INTO _row FROM public.material_inventory WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_inventory', _row.project_id, _row.organization_id);

          UPDATE public.material_inventory
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_material_orders(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_material_orders(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.material_orders;
        BEGIN
          SELECT * INTO _row FROM public.material_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_orders', _row.project_id, _row.organization_id);

          UPDATE public.material_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_material_receipts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_material_receipts(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.material_receipts;
        BEGIN
          SELECT * INTO _row FROM public.material_receipts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','material_receipts', _row.project_id, _row.organization_id);

          UPDATE public.material_receipts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_materials(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_materials(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.materials;
        BEGIN
          SELECT * INTO _row FROM public.materials WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','materials', _row.project_id, _row.organization_id);

          UPDATE public.materials
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_meeting_minutes(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_meeting_minutes(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.meeting_minutes;
        BEGIN
          SELECT * INTO _row FROM public.meeting_minutes WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','meeting_minutes', _row.project_id, _row.organization_id);

          UPDATE public.meeting_minutes
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_notifications(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_notifications(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _row public.notifications;
BEGIN
  SELECT *
  INTO _row
  FROM public.notifications
  WHERE id = _id
    AND deleted_at IS NULL;

  IF _row IS NULL THEN
    RAISE EXCEPTION 'row not found'
      USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  IF _row.user_id <> auth.uid() THEN
    RAISE EXCEPTION 'Access denied for notification delete'
      USING errcode = '42501';
  END IF;

  UPDATE public.notifications
  SET deleted_at = now()
  WHERE id = _id
    AND user_id = auth.uid()
    AND deleted_at IS NULL;
END;
$$;


--
-- Name: delete_organization_invites(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_invites(_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _row public.organization_invites;
BEGIN
  SELECT * INTO _row FROM public.organization_invites WHERE id = _id;
  IF _row IS NULL THEN RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id); END IF;

  PERFORM check_access('delete','organization_invites', NULL, _row.organization_id);

  DELETE FROM public.organization_invites WHERE id = _id;
END;
$$;


--
-- Name: delete_organization_member_rates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_member_rates(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.organization_member_rates;
      _organization_id uuid;
    BEGIN
      SELECT * INTO _row FROM public.organization_member_rates WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      SELECT organization_id INTO _organization_id
        FROM public.organization_members
       WHERE id = _row.membership_id;

      PERFORM check_access('delete','organization_member_rates', NULL, _organization_id);

      DELETE FROM public.organization_member_rates WHERE id = _id;
    END;
    $$;


--
-- Name: delete_organization_members(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_members(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _row public.organization_members;
BEGIN
  SELECT * INTO _row FROM public.organization_members WHERE id = _id;
  IF _row IS NULL THEN
    RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  -- organization_members is org-scoped (no project_id column)
  PERFORM check_access('delete','organization_members', NULL, _row.organization_id);

  UPDATE public.organization_members
     SET deleted_at = now()
   WHERE id = _id;
END;
$$;


--
-- Name: delete_organization_notification_settings(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_notification_settings(_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
  IF NOT public.can_edit_org_notification_settings(_id) THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  DELETE FROM public.organization_notification_settings
  WHERE organization_id = _id;
END;
$$;


--
-- Name: delete_organization_projects(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_projects(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.organization_projects;
        BEGIN
          SELECT * INTO _row FROM public.organization_projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','organization_projects', _row.project_id, _row.organization_id);

          UPDATE public.organization_projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_organization_service_areas(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organization_service_areas(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.organization_service_areas;
    BEGIN
      SELECT * INTO _row FROM public.organization_service_areas WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('delete','organization_service_areas', NULL, _row.organization_id);

      DELETE FROM public.organization_service_areas WHERE id = _id;
    END;
    $$;


--
-- Name: delete_organizations(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_organizations(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.organizations;
        BEGIN
          SELECT * INTO _row FROM public.organizations WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','organizations', _row.project_id, _row.organization_id);

          UPDATE public.organizations
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_payments(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_payments(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.payments;
        BEGIN
          SELECT * INTO _row FROM public.payments WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','payments', _row.project_id, _row.organization_id);

          UPDATE public.payments
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_payroll(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_payroll(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.payroll;
        BEGIN
          SELECT * INTO _row FROM public.payroll WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','payroll', _row.project_id, _row.organization_id);

          UPDATE public.payroll
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_photos(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_photos(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.photos;
        BEGIN
          SELECT * INTO _row FROM public.photos WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','photos', _row.project_id, _row.organization_id);

          UPDATE public.photos
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_prequalifications(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_prequalifications(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.prequalifications;
        BEGIN
          SELECT * INTO _row FROM public.prequalifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','prequalifications', _row.project_id, _row.organization_id);

          UPDATE public.prequalifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_procurement_workflows(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_procurement_workflows(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.procurement_workflows;
        BEGIN
          SELECT * INTO _row FROM public.procurement_workflows WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','procurement_workflows', _row.project_id, _row.organization_id);

          UPDATE public.procurement_workflows
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_profiles(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_profiles(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.profiles;
        BEGIN
          SELECT * INTO _row FROM public.profiles WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','profiles', _row.project_id, _row.organization_id);

          UPDATE public.profiles
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_progress_billings(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_progress_billings(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.progress_billings;
        BEGIN
          SELECT * INTO _row FROM public.progress_billings WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','progress_billings', _row.project_id, _row.organization_id);

          UPDATE public.progress_billings
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_project_inspectors(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_project_inspectors(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.project_inspectors;
        BEGIN
          SELECT * INTO _row FROM public.project_inspectors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','project_inspectors', _row.project_id, _row.organization_id);

          UPDATE public.project_inspectors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_project_invites(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_project_invites(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.project_invites;
    BEGIN
      SELECT * INTO _row FROM public.project_invites WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('delete','project_invites', _row.project_id, NULL);

      DELETE FROM public.project_invites WHERE id = _id;
    END;
    $$;


--
-- Name: delete_project_service_areas(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_project_service_areas(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _row public.project_service_areas;
    BEGIN
      SELECT * INTO _row FROM public.project_service_areas WHERE id = _id;
      IF _row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('delete','project_service_areas', _row.project_id, NULL);

      DELETE FROM public.project_service_areas WHERE id = _id;
    END;
    $$;


--
-- Name: delete_projects(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_projects(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.projects;
        BEGIN
          SELECT * INTO _row FROM public.projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','projects', _row.project_id, _row.organization_id);

          UPDATE public.projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_punch_lists(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_punch_lists(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.punch_lists;
        BEGIN
          SELECT * INTO _row FROM public.punch_lists WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','punch_lists', _row.project_id, _row.organization_id);

          UPDATE public.punch_lists
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_purchase_orders(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_purchase_orders(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.purchase_orders;
        BEGIN
          SELECT * INTO _row FROM public.purchase_orders WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','purchase_orders', _row.project_id, _row.organization_id);

          UPDATE public.purchase_orders
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_quality_reviews(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_quality_reviews(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.quality_reviews;
        BEGIN
          SELECT * INTO _row FROM public.quality_reviews WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','quality_reviews', _row.project_id, _row.organization_id);

          UPDATE public.quality_reviews
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_regulatory_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_regulatory_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.regulatory_documents;
        BEGIN
          SELECT * INTO _row FROM public.regulatory_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','regulatory_documents', _row.project_id, _row.organization_id);

          UPDATE public.regulatory_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_reports(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_reports(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.reports;
        BEGIN
          SELECT * INTO _row FROM public.reports WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','reports', _row.project_id, _row.organization_id);

          UPDATE public.reports
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_rfis(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_rfis(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.rfis;
        BEGIN
          SELECT * INTO _row FROM public.rfis WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','rfis', _row.project_id, _row.organization_id);

          UPDATE public.rfis
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_safety_incidents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_safety_incidents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.safety_incidents;
        BEGIN
          SELECT * INTO _row FROM public.safety_incidents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','safety_incidents', _row.project_id, _row.organization_id);

          UPDATE public.safety_incidents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_sensor_data(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_sensor_data(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.sensor_data;
        BEGIN
          SELECT * INTO _row FROM public.sensor_data WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','sensor_data', _row.project_id, _row.organization_id);

          UPDATE public.sensor_data
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_subcontractor_agreements(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_subcontractor_agreements(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.subcontractor_agreements;
        BEGIN
          SELECT * INTO _row FROM public.subcontractor_agreements WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','subcontractor_agreements', _row.project_id, _row.organization_id);

          UPDATE public.subcontractor_agreements
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_subcontracts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_subcontracts(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.subcontracts;
        BEGIN
          SELECT * INTO _row FROM public.subcontracts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','subcontracts', _row.project_id, _row.organization_id);

          UPDATE public.subcontracts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_submittals(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_submittals(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.submittals;
        BEGIN
          SELECT * INTO _row FROM public.submittals WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','submittals', _row.project_id, _row.organization_id);

          UPDATE public.submittals
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_tack_rates(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_tack_rates(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.tack_rates;
        BEGIN
          SELECT * INTO _row FROM public.tack_rates WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','tack_rates', _row.project_id, _row.organization_id);

          UPDATE public.tack_rates
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_task_dependencies(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_task_dependencies(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.task_dependencies;
        BEGIN
          SELECT * INTO _row FROM public.task_dependencies WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','task_dependencies', _row.project_id, _row.organization_id);

          UPDATE public.task_dependencies
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_task_status_logs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_task_status_logs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.task_status_logs;
        BEGIN
          SELECT * INTO _row FROM public.task_status_logs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','task_status_logs', _row.project_id, _row.organization_id);

          UPDATE public.task_status_logs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_tasks(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_tasks(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.tasks;
        BEGIN
          SELECT * INTO _row FROM public.tasks WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','tasks', _row.project_id, _row.organization_id);

          UPDATE public.tasks
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_training_records(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_training_records(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.training_records;
        BEGIN
          SELECT * INTO _row FROM public.training_records WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','training_records', _row.project_id, _row.organization_id);

          UPDATE public.training_records
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_user_notification_settings(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_user_notification_settings(_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
BEGIN
  IF auth.uid() IS NULL OR _id IS DISTINCT FROM auth.uid() THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  DELETE FROM public.user_notification_settings
  WHERE user_id = _id;
END;
$$;


--
-- Name: delete_user_projects(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_user_projects(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.user_projects;
        BEGIN
          SELECT * INTO _row FROM public.user_projects WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','user_projects', _row.project_id, _row.organization_id);

          UPDATE public.user_projects
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_vendor_bid_packages(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendor_bid_packages(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendor_bid_packages;
        BEGIN
          SELECT * INTO _row FROM public.vendor_bid_packages WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_bid_packages', _row.project_id, _row.organization_id);

          UPDATE public.vendor_bid_packages
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_vendor_contacts(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendor_contacts(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendor_contacts;
        BEGIN
          SELECT * INTO _row FROM public.vendor_contacts WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_contacts', _row.project_id, _row.organization_id);

          UPDATE public.vendor_contacts
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_vendor_documents(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendor_documents(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendor_documents;
        BEGIN
          SELECT * INTO _row FROM public.vendor_documents WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_documents', _row.project_id, _row.organization_id);

          UPDATE public.vendor_documents
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_vendor_qualifications(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendor_qualifications(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendor_qualifications;
        BEGIN
          SELECT * INTO _row FROM public.vendor_qualifications WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendor_qualifications', _row.project_id, _row.organization_id);

          UPDATE public.vendor_qualifications
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_vendors(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_vendors(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.vendors;
        BEGIN
          SELECT * INTO _row FROM public.vendors WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','vendors', _row.project_id, _row.organization_id);

          UPDATE public.vendors
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_wbs(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_wbs(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.wbs;
        BEGIN
          SELECT * INTO _row FROM public.wbs WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','wbs', _row.project_id, _row.organization_id);

          UPDATE public.wbs
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: delete_workflows(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.delete_workflows(_id uuid) RETURNS void
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
        DECLARE
          _row public.workflows;
        BEGIN
          SELECT * INTO _row FROM public.workflows WHERE id = _id;
          IF _row IS NULL THEN
            RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
          END IF;

          PERFORM check_access('delete','workflows', _row.project_id, _row.organization_id);

          UPDATE public.workflows
             SET deleted_at = now()
           WHERE id = _id;
        END;
        $$;


--
-- Name: emit_org_notification(uuid, public.notification_category, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.emit_org_notification(p_organization_id uuid, p_category public.notification_category, p_message text, p_payload jsonb DEFAULT '{}'::jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_member record;
  v_payload jsonb;
BEGIN
  IF p_organization_id IS NULL THEN
    RETURN;
  END IF;

  v_payload := COALESCE(p_payload, '{}'::jsonb)
               || jsonb_build_object(
                 'organization_id', p_organization_id,
                 'scope', 'org_wide'
               );

  FOR v_member IN
    SELECT om.profile_id
    FROM public.organization_members om
    WHERE om.organization_id = p_organization_id
      AND om.deleted_at IS NULL
  LOOP
    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', v_member.profile_id,
        'organization_id', p_organization_id,
        'category', p_category,
        'message', p_message,
        'payload', v_payload
      )
    );
  END LOOP;
END;
$$;


--
-- Name: ensure_fk_indexes_for_schema(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ensure_fk_indexes_for_schema(_schema text DEFAULT 'public'::text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
DECLARE
  r RECORD;
  idx_name text;
BEGIN
  FOR r IN
    WITH fks AS (
      SELECT
        con.oid                              AS con_oid,        -- (fixed: was c.oid)
        n.nspname                            AS child_schema,
        t.relname                            AS child_table,
        con.conname                          AS fk_name,
        con.conrelid                         AS child_relid,
        con.conkey                           AS child_attnums
      FROM pg_constraint con
      JOIN pg_class     t  ON t.oid = con.conrelid
      JOIN pg_namespace n  ON n.oid = t.relnamespace
      WHERE con.contype = 'f'
        AND n.nspname = _schema
    ),
    fk_cols AS (
      -- ordered FK column names
      SELECT
        f.con_oid,
        f.child_schema,
        f.child_table,
        f.fk_name,
        f.child_relid,
        ARRAY_AGG(a.attname ORDER BY s.ord) AS child_cols
      FROM fks f
      JOIN LATERAL generate_subscripts(f.child_attnums, 1) AS s(ord) ON TRUE
      JOIN pg_attribute a
        ON a.attrelid = f.child_relid
       AND a.attnum   = f.child_attnums[s.ord]
      GROUP BY f.con_oid, f.child_schema, f.child_table, f.fk_name, f.child_relid
    ),
    idx_cols AS (
      -- for each index on the child table, get its ordered column NAMES
      SELECT
        i.indrelid                                  AS tbl_relid,
        i.indexrelid                                AS idx_relid,
        ARRAY_AGG(att.attname ORDER BY k.ord)       AS idx_colnames
      FROM pg_index i
      JOIN LATERAL unnest(i.indkey) WITH ORDINALITY AS k(attnum, ord) ON TRUE
      JOIN pg_attribute att
        ON att.attrelid = i.indexrelid
       AND att.attnum   = k.ord      -- attribute order within index
      GROUP BY i.indrelid, i.indexrelid
    ),
    needs AS (
      SELECT
        fk.child_schema,
        fk.child_table,
        fk.fk_name,
        fk.child_relid,
        fk.child_cols
      FROM fk_cols fk
      WHERE NOT EXISTS (
        SELECT 1
        FROM idx_cols ix
        WHERE ix.tbl_relid = fk.child_relid
          AND ix.idx_colnames = fk.child_cols
      )
    )
    SELECT *
    FROM needs
    ORDER BY child_schema, child_table, fk_name
  LOOP
    -- Build a deterministic (and short) index name, add suffix if collides
    idx_name := format('ix_%s__fk_%s', r.child_table, r.fk_name);
    WHILE EXISTS (
      SELECT 1
      FROM pg_class c
      JOIN pg_namespace n ON n.oid = c.relnamespace
      WHERE n.nspname = r.child_schema
        AND c.relname = idx_name
    ) LOOP
      idx_name := idx_name || '_' || floor(random()*1000)::int;
    END LOOP;

    -- CREATE INDEX ON child table over the FK columns in order
    EXECUTE format(
      'CREATE INDEX %I ON %I.%I (%s);',
      idx_name,
      r.child_schema,
      r.child_table,
      (
        SELECT string_agg(quote_ident(col), ', ')
        FROM unnest(r.child_cols) AS col
      )
    );

    RAISE NOTICE 'Created FK index % on %.% (%).',
      idx_name, r.child_schema, r.child_table, array_to_string(r.child_cols, ', ');
  END LOOP;
END
$$;


--
-- Name: ensure_soft_delete_cols(regclass); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ensure_soft_delete_cols(_tbl regclass) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  col_exists bool;
begin
  select exists (
    select 1 from pg_attribute 
     where attrelid = _tbl
       and attname  = 'deleted_at'
       and not attisdropped)
  into col_exists;

  if not col_exists then
    execute format('alter table %s add column deleted_at timestamptz', _tbl);
  end if;
end;
$$;


--
-- Name: accounts_payable; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.accounts_payable (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    amount_due numeric,
    due_date date,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.accounts_payable FORCE ROW LEVEL SECURITY;


--
-- Name: filter_accounts_payable(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_accounts_payable(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.accounts_payable
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','accounts_payable', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='accounts_payable'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='accounts_payable'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='accounts_payable'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.accounts_payable WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: accounts_receivable; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.accounts_receivable (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    amount_due numeric,
    due_date date,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.accounts_receivable FORCE ROW LEVEL SECURITY;


--
-- Name: filter_accounts_receivable(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_accounts_receivable(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.accounts_receivable
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','accounts_receivable', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='accounts_receivable'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='accounts_receivable'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='accounts_receivable'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.accounts_receivable WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: activity_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.activity_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    activity_type text,
    activity_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.activity_logs FORCE ROW LEVEL SECURITY;


--
-- Name: filter_activity_logs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_activity_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.activity_logs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','activity_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='activity_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='activity_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='activity_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.activity_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: asphalt_types; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.asphalt_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.asphalt_types FORCE ROW LEVEL SECURITY;


--
-- Name: filter_asphalt_types(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_asphalt_types(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.asphalt_types
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','asphalt_types', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='asphalt_types'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='asphalt_types'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='asphalt_types'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.asphalt_types WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: audit_log; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.audit_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    table_name text NOT NULL,
    action text NOT NULL,
    row_id uuid,
    before_data jsonb,
    after_data jsonb,
    changed_by uuid DEFAULT auth.uid(),
    changed_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone
);


--
-- Name: filter_audit_log(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_audit_log(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _where           text := 'deleted_at IS NULL';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      -- Normalize filters to an object
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      -- Authorization gate (RLS still applies)
      PERFORM check_access('select','audit_log', _project_id, _organization_id);

      -- Build WHERE from filters
      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='audit_log'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='audit_log'
            AND column_name <> 'deleted_at';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='audit_log'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.audit_log WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- Name: audit_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.audit_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    action text,
    performed_by uuid,
    performed_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.audit_logs FORCE ROW LEVEL SECURITY;


--
-- Name: filter_audit_logs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_audit_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.audit_logs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','audit_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='audit_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='audit_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='audit_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.audit_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: avatars; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.avatars (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    url text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    is_preset boolean DEFAULT false NOT NULL
);

ALTER TABLE ONLY public.avatars FORCE ROW LEVEL SECURITY;


--
-- Name: filter_avatars(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_avatars(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.avatars
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','avatars', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='avatars'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='avatars'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='avatars'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.avatars WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: bid_packages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bid_packages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    status text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.bid_packages FORCE ROW LEVEL SECURITY;


--
-- Name: filter_bid_packages(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_bid_packages(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.bid_packages
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bid_packages', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bid_packages'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bid_packages'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bid_packages'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bid_packages WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: bid_vendors; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bid_vendors (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bid_package_id uuid,
    vendor_id uuid,
    invited_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.bid_vendors FORCE ROW LEVEL SECURITY;


--
-- Name: filter_bid_vendors(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_bid_vendors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.bid_vendors
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bid_vendors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bid_vendors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bid_vendors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bid_vendors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bid_vendors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: bids; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bids (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bid_package_id uuid,
    vendor_id uuid,
    amount numeric,
    submitted_at timestamp with time zone DEFAULT now(),
    status public.general_status DEFAULT 'pending'::public.general_status,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.bids FORCE ROW LEVEL SECURITY;


--
-- Name: filter_bids(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_bids(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.bids
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bids', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bids'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bids'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bids'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bids WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: bim_models; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.bim_models (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.bim_models FORCE ROW LEVEL SECURITY;


--
-- Name: filter_bim_models(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_bim_models(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.bim_models
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','bim_models', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='bim_models'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='bim_models'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='bim_models'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.bim_models WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: certifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.certifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid,
    certification_type text,
    issue_date date,
    expiry_date date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.certifications FORCE ROW LEVEL SECURITY;


--
-- Name: filter_certifications(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_certifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.certifications
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','certifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='certifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='certifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='certifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.certifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: change_orders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.change_orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    number text NOT NULL,
    description text,
    status text,
    amount numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.change_orders FORCE ROW LEVEL SECURITY;


--
-- Name: filter_change_orders(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_change_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.change_orders
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','change_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='change_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='change_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='change_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.change_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: commitments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.commitments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    vendor_id uuid,
    type public.commitment_type,
    amount numeric,
    status text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.commitments FORCE ROW LEVEL SECURITY;


--
-- Name: filter_commitments(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_commitments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.commitments
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','commitments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='commitments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='commitments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='commitments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.commitments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: compliance_checks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.compliance_checks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    check_date date,
    description text,
    result text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.compliance_checks FORCE ROW LEVEL SECURITY;


--
-- Name: filter_compliance_checks(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_compliance_checks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.compliance_checks
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','compliance_checks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='compliance_checks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='compliance_checks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='compliance_checks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.compliance_checks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: compliance_tracking; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.compliance_tracking (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    tracking_type text,
    status text,
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.compliance_tracking FORCE ROW LEVEL SECURITY;


--
-- Name: filter_compliance_tracking(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_compliance_tracking(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.compliance_tracking
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','compliance_tracking', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='compliance_tracking'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='compliance_tracking'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='compliance_tracking'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.compliance_tracking WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: cost_codes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cost_codes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    code text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.cost_codes FORCE ROW LEVEL SECURITY;


--
-- Name: filter_cost_codes(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_cost_codes(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.cost_codes
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','cost_codes', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='cost_codes'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='cost_codes'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='cost_codes'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.cost_codes WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: crew_assignments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crew_assignments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    crew_id uuid,
    profile_id uuid,
    assigned_date date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.crew_assignments FORCE ROW LEVEL SECURITY;


--
-- Name: filter_crew_assignments(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_crew_assignments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.crew_assignments
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crew_assignments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crew_assignments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crew_assignments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crew_assignments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crew_assignments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: crew_members; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crew_members (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    crew_id uuid,
    profile_id uuid,
    role text,
    start_date date,
    end_date date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.crew_members FORCE ROW LEVEL SECURITY;


--
-- Name: filter_crew_members(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_crew_members(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.crew_members
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crew_members', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crew_members'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crew_members'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crew_members'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crew_members WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: crews; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crews (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.crews FORCE ROW LEVEL SECURITY;


--
-- Name: filter_crews(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_crews(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.crews
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','crews', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='crews'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='crews'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='crews'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.crews WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: daily_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.daily_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    date date NOT NULL,
    weather jsonb,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.daily_logs FORCE ROW LEVEL SECURITY;


--
-- Name: filter_daily_logs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_daily_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.daily_logs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','daily_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='daily_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='daily_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='daily_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.daily_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: dashboard_configs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.dashboard_configs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    config jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.dashboard_configs FORCE ROW LEVEL SECURITY;


--
-- Name: filter_dashboard_configs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_dashboard_configs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.dashboard_configs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','dashboard_configs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='dashboard_configs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='dashboard_configs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='dashboard_configs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.dashboard_configs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: document_references; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.document_references (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_id uuid,
    reference_type text,
    reference_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.document_references FORCE ROW LEVEL SECURITY;


--
-- Name: filter_document_references(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_document_references(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.document_references
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','document_references', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='document_references'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='document_references'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='document_references'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.document_references WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    type text,
    url text,
    uploaded_by uuid,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.documents FORCE ROW LEVEL SECURITY;


--
-- Name: filter_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: drawing_versions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.drawing_versions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    document_id uuid,
    version text,
    uploaded_by uuid,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.drawing_versions FORCE ROW LEVEL SECURITY;


--
-- Name: filter_drawing_versions(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_drawing_versions(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.drawing_versions
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','drawing_versions', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='drawing_versions'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='drawing_versions'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='drawing_versions'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.drawing_versions WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: dump_trucks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.dump_trucks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    make text,
    model text,
    capacity numeric,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.dump_trucks FORCE ROW LEVEL SECURITY;


--
-- Name: filter_dump_trucks(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_dump_trucks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.dump_trucks
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','dump_trucks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='dump_trucks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='dump_trucks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='dump_trucks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.dump_trucks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: employees; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.employees (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    profile_id uuid,
    hire_date date,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.employees FORCE ROW LEVEL SECURITY;


--
-- Name: filter_employees(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_employees(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.employees
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','employees', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='employees'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='employees'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='employees'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.employees WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: equipment; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.equipment (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    name text NOT NULL,
    type public.equipment_type,
    model text,
    serial_number text,
    status text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.equipment FORCE ROW LEVEL SECURITY;


--
-- Name: filter_equipment(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_equipment(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.equipment
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: equipment_assignments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.equipment_assignments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    equipment_id uuid,
    project_id uuid,
    assigned_to uuid,
    assigned_date date,
    released_date date,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.equipment_assignments FORCE ROW LEVEL SECURITY;


--
-- Name: filter_equipment_assignments(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_equipment_assignments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.equipment_assignments
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_assignments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_assignments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_assignments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_assignments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_assignments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: equipment_maintenance; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.equipment_maintenance (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    equipment_id uuid,
    maintenance_date date,
    type text,
    description text,
    performed_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.equipment_maintenance FORCE ROW LEVEL SECURITY;


--
-- Name: filter_equipment_maintenance(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_equipment_maintenance(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.equipment_maintenance
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_maintenance', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_maintenance'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_maintenance'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_maintenance'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_maintenance WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: equipment_usage; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.equipment_usage (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    equipment_id uuid,
    date date NOT NULL,
    hours_used numeric,
    quantity numeric,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.equipment_usage FORCE ROW LEVEL SECURITY;


--
-- Name: filter_equipment_usage(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_equipment_usage(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.equipment_usage
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','equipment_usage', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='equipment_usage'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='equipment_usage'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='equipment_usage'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.equipment_usage WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: estimate_line_items; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.estimate_line_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    estimate_id uuid,
    cost_code_id uuid,
    name text,
    unit_measure text,
    quantity numeric,
    unit_price numeric,
    total_cost numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.estimate_line_items FORCE ROW LEVEL SECURITY;


--
-- Name: filter_estimate_line_items(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_estimate_line_items(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.estimate_line_items
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','estimate_line_items', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='estimate_line_items'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='estimate_line_items'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='estimate_line_items'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.estimate_line_items WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: estimates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.estimates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    status text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.estimates FORCE ROW LEVEL SECURITY;


--
-- Name: filter_estimates(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_estimates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.estimates
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','estimates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='estimates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='estimates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='estimates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.estimates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: financial_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.financial_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    document_type text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.financial_documents FORCE ROW LEVEL SECURITY;


--
-- Name: filter_financial_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_financial_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.financial_documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','financial_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='financial_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='financial_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='financial_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.financial_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: general_ledger; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.general_ledger (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    entry_date date,
    description text,
    debit numeric,
    credit numeric,
    balance numeric,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.general_ledger FORCE ROW LEVEL SECURITY;


--
-- Name: filter_general_ledger(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_general_ledger(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.general_ledger
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','general_ledger', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='general_ledger'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='general_ledger'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='general_ledger'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.general_ledger WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: hr_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.hr_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid,
    document_type text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.hr_documents FORCE ROW LEVEL SECURITY;


--
-- Name: filter_hr_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_hr_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.hr_documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','hr_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='hr_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='hr_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='hr_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.hr_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: inspections; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inspections (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    inspection_type text,
    date date,
    status text,
    result jsonb,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.inspections FORCE ROW LEVEL SECURITY;


--
-- Name: filter_inspections(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_inspections(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.inspections
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','inspections', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='inspections'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='inspections'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='inspections'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.inspections WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: integration_tokens; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.integration_tokens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    service_name text,
    token text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.integration_tokens FORCE ROW LEVEL SECURITY;


--
-- Name: filter_integration_tokens(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_integration_tokens(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.integration_tokens
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','integration_tokens', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='integration_tokens'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='integration_tokens'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='integration_tokens'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.integration_tokens WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: inventory_transactions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inventory_transactions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_id uuid,
    transaction_type text,
    quantity numeric,
    transaction_date date,
    notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.inventory_transactions FORCE ROW LEVEL SECURITY;


--
-- Name: filter_inventory_transactions(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_inventory_transactions(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.inventory_transactions
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','inventory_transactions', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='inventory_transactions'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='inventory_transactions'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='inventory_transactions'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.inventory_transactions WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: issues; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.issues (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    type text,
    status text,
    reported_by uuid,
    description text,
    resolved boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.issues FORCE ROW LEVEL SECURITY;


--
-- Name: filter_issues(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_issues(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.issues
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','issues', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='issues'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='issues'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='issues'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.issues WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: job_titles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.job_titles (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.job_titles FORCE ROW LEVEL SECURITY;


--
-- Name: filter_job_titles(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_job_titles(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.job_titles
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','job_titles', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='job_titles'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='job_titles'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='job_titles'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.job_titles WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: labor_records; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.labor_records (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    line_item_id uuid,
    worker_count integer,
    hours_worked numeric,
    work_date date,
    work_type text,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.labor_records FORCE ROW LEVEL SECURITY;


--
-- Name: filter_labor_records(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_labor_records(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.labor_records
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','labor_records', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='labor_records'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='labor_records'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='labor_records'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.labor_records WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: line_item_entries; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.line_item_entries (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    line_item_id uuid,
    date date NOT NULL,
    quantity_completed numeric,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.line_item_entries FORCE ROW LEVEL SECURITY;


--
-- Name: filter_line_item_entries(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_line_item_entries(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.line_item_entries
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_item_entries', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_item_entries'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_item_entries'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_item_entries'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_item_entries WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: line_item_templates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.line_item_templates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    formula jsonb,
    variables jsonb,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.line_item_templates FORCE ROW LEVEL SECURITY;


--
-- Name: filter_line_item_templates(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_line_item_templates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.line_item_templates
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_item_templates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_item_templates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_item_templates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_item_templates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_item_templates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: line_items; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.line_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    map_id uuid,
    wbs_id uuid,
    project_id uuid,
    cost_code_id uuid,
    template_id uuid,
    name text NOT NULL,
    description text,
    unit_measure text NOT NULL,
    quantity numeric,
    unit_price numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.line_items FORCE ROW LEVEL SECURITY;


--
-- Name: filter_line_items(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_line_items(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.line_items
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','line_items', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='line_items'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='line_items'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='line_items'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.line_items WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: maps; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.maps (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    wbs_id uuid,
    project_id uuid,
    name text NOT NULL,
    description text,
    coordinates text,
    scope text,
    order_num integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.maps FORCE ROW LEVEL SECURITY;


--
-- Name: filter_maps(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_maps(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.maps
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','maps', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='maps'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='maps'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='maps'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.maps WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: material_inventory; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.material_inventory (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_id uuid,
    organization_id uuid,
    quantity numeric,
    last_updated timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.material_inventory FORCE ROW LEVEL SECURITY;


--
-- Name: filter_material_inventory(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_material_inventory(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.material_inventory
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_inventory', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_inventory'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_inventory'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_inventory'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_inventory WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: material_orders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.material_orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_id uuid,
    project_id uuid,
    order_date date,
    quantity numeric,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.material_orders FORCE ROW LEVEL SECURITY;


--
-- Name: filter_material_orders(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_material_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.material_orders
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: material_receipts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.material_receipts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_order_id uuid,
    received_date date,
    quantity numeric,
    received_by uuid,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.material_receipts FORCE ROW LEVEL SECURITY;


--
-- Name: filter_material_receipts(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_material_receipts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.material_receipts
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','material_receipts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='material_receipts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='material_receipts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='material_receipts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.material_receipts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: materials; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.materials (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    name text NOT NULL,
    description text,
    unit text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.materials FORCE ROW LEVEL SECURITY;


--
-- Name: filter_materials(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_materials(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.materials
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','materials', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='materials'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='materials'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='materials'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.materials WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: meeting_minutes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.meeting_minutes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    meeting_date date,
    notes text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.meeting_minutes FORCE ROW LEVEL SECURITY;


--
-- Name: filter_meeting_minutes(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_meeting_minutes(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.meeting_minutes
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','meeting_minutes', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='meeting_minutes'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='meeting_minutes'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='meeting_minutes'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.meeting_minutes WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: notifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    category public.notification_category DEFAULT 'general'::public.notification_category NOT NULL,
    message text NOT NULL,
    payload jsonb DEFAULT '{}'::jsonb,
    is_read boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.notifications FORCE ROW LEVEL SECURITY;


--
-- Name: filter_notifications(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_notifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.notifications
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
declare
  _project_id uuid := nullif(_filters->>'project_id', '')::uuid;
  _organization_id uuid := nullif(_filters->>'organization_id', '')::uuid;
  _where text := 'deleted_at IS NULL';
  kv record;
  _sel text;
  _order_clause text;
  sqltxt text;
  dir text := lower(coalesce(_direction, 'asc'));
begin
  if _filters is null or jsonb_typeof(_filters) <> 'object' then
    _filters := '{}'::jsonb;
  end if;

  perform check_access('select','notifications', _project_id, _organization_id);

  for kv in select * from jsonb_each(_filters) loop
    if kv.key not in ('project_id','organization_id') then
      if jsonb_typeof(kv.value) = 'object' then
        if (kv.value ? '$gte') then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' >= ' || quote_literal(kv.value->>'$gte');
        end if;
        if (kv.value ? '$lte') then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' <= ' || quote_literal(kv.value->>'$lte');
        end if;
        if (kv.value ? '$ilike') then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        end if;
        if (kv.value ? '$in') then
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'SELECT value FROM jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)'
            || ' AS t(value))';
        end if;
      else
        if jsonb_typeof(kv.value) = 'null' then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' IS NULL';
        elsif jsonb_typeof(kv.value) = 'string' then
          _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(kv.value #>> '{}');
        else
          _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(kv.value::text);
        end if;
      end if;
    end if;
  end loop;

  if _order_by is null or trim(_order_by) = '' then
    _order_by := 'id';
  end if;

  if not exists (
    select 1
    from information_schema.columns
    where table_schema='public'
      and table_name='notifications'
      and column_name=_order_by
  ) then
    if exists (
      select 1 from information_schema.columns
      where table_schema='public' and table_name='notifications' and column_name='created_at'
    ) then
      _order_by := 'created_at';
    elsif exists (
      select 1 from information_schema.columns
      where table_schema='public' and table_name='notifications' and column_name='updated_at'
    ) then
      _order_by := 'updated_at';
    else
      _order_by := 'id';
    end if;
  end if;

  if dir not in ('asc','desc') then
    dir := 'asc';
  end if;

  if _select_cols is null then
    _sel := '*';
  elsif _select_cols = array['*'] then
    _sel := '*';
  else
    if exists (
      select unnest(_select_cols)
      except
      select column_name
        from information_schema.columns
        where table_schema='public' and table_name='notifications'
    ) then
      raise exception 'unknown column in select_cols'
        using detail = jsonb_build_object('columns', _select_cols);
    end if;

    select string_agg(quote_ident(c), ', ')
      into _sel
      from unnest(_select_cols) c;

    if _sel is null or btrim(_sel) = '' then
      _sel := '*';
    end if;
  end if;

  if _order_by = 'is_read' then
    _order_clause := 'is_read asc';
  else
    _order_clause := 'is_read asc, ' || quote_ident(_order_by) || ' ' || dir;
  end if;

  sqltxt := 'SELECT ' || _sel
         || ' FROM public.notifications WHERE ' || _where
         || ' ORDER BY ' || _order_clause;

  if _limit is not null then
    sqltxt := sqltxt || ' LIMIT ' || greatest(_limit, 0);
  end if;
  if _offset is not null then
    sqltxt := sqltxt || ' OFFSET ' || greatest(_offset, 0);
  end if;

  return query execute sqltxt;
end;
$_$;


--
-- Name: organization_invites; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_invites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid NOT NULL,
    invited_profile_id uuid NOT NULL,
    invited_by_profile_id uuid NOT NULL,
    status text NOT NULL,
    comment text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    responded_at timestamp with time zone,
    role uuid,
    requested_job_title_id uuid,
    requested_permission_role public.org_role,
    reviewed_permission_role public.org_role,
    reviewed_job_title_id uuid,
    CONSTRAINT organization_invites_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'declined'::text, 'cancelled'::text])))
);

ALTER TABLE ONLY public.organization_invites FORCE ROW LEVEL SECURITY;


--
-- Name: filter_organization_invites(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_invites(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_invites
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
DECLARE
  _organization_id uuid := nullif(_filters->>'organization_id', '')::uuid;
  _where text := 'true';
  kv record;
  _sel text;
  sqltxt text;
  dir text := lower(coalesce(_direction, 'asc'));
BEGIN
  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
    _filters := '{}'::jsonb;
  END IF;

  PERFORM check_access('select', 'organization_invites', NULL, _organization_id);

  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
    IF kv.key NOT IN ('organization_id') THEN
      IF jsonb_typeof(kv.value) = 'object' THEN
        IF (kv.value ? '$gte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' >= ' || quote_literal(kv.value->>'$gte');
        END IF;
        IF (kv.value ? '$lte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' <= ' || quote_literal(kv.value->>'$lte');
        END IF;
        IF (kv.value ? '$ilike') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        END IF;
        IF (kv.value ? '$in') THEN
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'SELECT value FROM jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)'
            || ' AS t(value))';
        END IF;
      ELSE
        IF jsonb_typeof(kv.value) = 'null' THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' IS NULL';
        ELSIF jsonb_typeof(kv.value) = 'string' THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(kv.value #>> '{}');
        ELSE
          _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(kv.value::text);
        END IF;
      END IF;
    END IF;
  END LOOP;

  IF _order_by IS NULL OR trim(_order_by) = '' THEN
    _order_by := 'id';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'organization_invites'
      AND column_name = _order_by
  ) THEN
    IF EXISTS (
      SELECT 1
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name = 'organization_invites'
        AND column_name = 'created_at'
    ) THEN
      _order_by := 'created_at';
    ELSIF EXISTS (
      SELECT 1
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name = 'organization_invites'
        AND column_name = 'updated_at'
    ) THEN
      _order_by := 'updated_at';
    ELSE
      _order_by := 'id';
    END IF;
  END IF;

  IF dir NOT IN ('asc', 'desc') THEN
    dir := 'asc';
  END IF;

  IF _select_cols IS NULL OR _select_cols = array['*'] THEN
    _sel := '*';
  ELSE
    IF EXISTS (
      SELECT unnest(_select_cols)
      EXCEPT
      SELECT column_name
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name = 'organization_invites'
    ) THEN
      RAISE EXCEPTION 'unknown column in select_cols'
        USING DETAIL = jsonb_build_object('columns', _select_cols);
    END IF;

    SELECT string_agg(quote_ident(c), ', ')
      INTO _sel
      FROM unnest(_select_cols) c;

    IF _sel IS NULL OR btrim(_sel) = '' THEN
      _sel := '*';
    END IF;
  END IF;

  sqltxt := 'SELECT ' || _sel
         || ' FROM public.organization_invites WHERE ' || _where
         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

  IF _limit IS NOT NULL THEN
    sqltxt := sqltxt || ' LIMIT ' || greatest(_limit, 0);
  END IF;
  IF _offset IS NOT NULL THEN
    sqltxt := sqltxt || ' OFFSET ' || greatest(_offset, 0);
  END IF;

  RETURN QUERY EXECUTE sqltxt;
END;
$_$;


--
-- Name: organization_member_rates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_member_rates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    membership_id uuid NOT NULL,
    rate_type text NOT NULL,
    rate_amount numeric NOT NULL,
    effective_start timestamp with time zone NOT NULL,
    effective_end timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT organization_member_rates_rate_type_check CHECK ((rate_type = ANY (ARRAY['pay_rate'::text, 'bill_rate'::text])))
);

ALTER TABLE ONLY public.organization_member_rates FORCE ROW LEVEL SECURITY;


--
-- Name: filter_organization_member_rates(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_member_rates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_member_rates
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _membership_id   uuid := (_filters->>'membership_id')::uuid;
      _where           text := 'true';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      IF _organization_id IS NULL AND _membership_id IS NOT NULL THEN
        SELECT organization_id INTO _organization_id
          FROM public.organization_members
         WHERE id = _membership_id;
      END IF;

      PERFORM check_access('select','organization_member_rates', _project_id, _organization_id);

      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='organization_member_rates'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organization_member_rates';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='organization_member_rates'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.organization_member_rates WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- Name: organization_members; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_members (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid,
    organization_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    job_title_id uuid,
    permission_role public.org_role
);

ALTER TABLE ONLY public.organization_members FORCE ROW LEVEL SECURITY;


--
-- Name: filter_organization_members(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_members(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_members
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
DECLARE
  _project_id      uuid := (_filters->>'project_id')::uuid;
  _organization_id uuid := (_filters->>'organization_id')::uuid;
  _where           text := 'deleted_at IS NULL';
  kv               record;
  _sel             text;
  sqltxt           text;
  dir              text := lower(coalesce(_direction, 'asc'));
BEGIN
  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
    _filters := '{}'::jsonb;
  END IF;

  PERFORM check_access('select','organization_members', _project_id, _organization_id);

  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
    IF kv.key NOT IN ('project_id','organization_id') THEN
      IF jsonb_typeof(kv.value) = 'object' THEN
        IF (kv.value ? '$gte') THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' >= '  || quote_literal(kv.value->>'$gte');
        END IF;
        IF (kv.value ? '$lte') THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' <= '  || quote_literal(kv.value->>'$lte');
        END IF;
        IF (kv.value ? '$ilike') THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        END IF;
        IF (kv.value ? '$in') THEN
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'SELECT value FROM jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)'
            || ' AS t(value))';
        END IF;
      ELSE
        IF jsonb_typeof(kv.value) = 'null' THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' IS NULL';
        ELSIF jsonb_typeof(kv.value) = 'string' THEN
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' = '   || quote_literal(kv.value #>> '{}');
        ELSE
          _where := _where
            || ' AND ' || quote_ident(kv.key)
            || ' = '   || quote_literal(kv.value::text);
        END IF;
      END IF;
    END IF;
  END LOOP;

  IF _order_by IS NULL OR trim(_order_by) = '' THEN
    _order_by := 'id';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema='public'
      AND table_name='organization_members'
      AND column_name=_order_by
  ) THEN
    IF EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema='public' AND table_name='organization_members' AND column_name='created_at'
    ) THEN
      _order_by := 'created_at';
    ELSE
      _order_by := 'id';
    END IF;
  END IF;

  IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

  IF _select_cols IS NOT NULL AND _select_cols <> array['*'] THEN
    IF EXISTS (
      SELECT UNNEST(_select_cols)
      EXCEPT
      SELECT column_name
        FROM information_schema.columns
        WHERE table_schema='public' AND table_name='organization_members'
    ) THEN
      RAISE EXCEPTION 'unknown column in select_cols'
        USING DETAIL = jsonb_build_object('columns', _select_cols);
    END IF;
  END IF;

  _sel := '*';

  sqltxt := 'SELECT ' || _sel
         || ' FROM public.organization_members WHERE ' || _where
         || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

  IF _limit  IS NOT NULL THEN
    sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
  END IF;
  IF _offset IS NOT NULL THEN
    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
  END IF;

  RETURN QUERY EXECUTE sqltxt;
END;
$_$;


--
-- Name: organization_notification_settings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_notification_settings (
    organization_id uuid NOT NULL,
    enabled_categories public.notification_category[] DEFAULT ARRAY['workflow_update'::public.notification_category, 'approval_needed'::public.notification_category, 'bid_received'::public.notification_category] NOT NULL,
    enabled_events text[] DEFAULT ARRAY['member_added'::text, 'member_removed'::text, 'contract_completed'::text, 'bid_accepted'::text, 'new_project_created'::text, 'member_job_title_changed'::text, 'member_permission_role_changed'::text] NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid
);

ALTER TABLE ONLY public.organization_notification_settings FORCE ROW LEVEL SECURITY;


--
-- Name: filter_organization_notification_settings(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_notification_settings(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'updated_at'::text, _direction text DEFAULT 'desc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_notification_settings
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_org_id uuid := NULLIF(_filters->>'organization_id','')::uuid;
BEGIN
  IF v_org_id IS NULL THEN
    SELECT p.organization_id
    INTO v_org_id
    FROM public.profiles p
    WHERE p.id = auth.uid();
  END IF;

  IF v_org_id IS NULL THEN
    RETURN;
  END IF;

  PERFORM public.check_access('select', 'organizations', NULL::uuid, v_org_id);

  RETURN QUERY
  SELECT ons.*
  FROM public.organization_notification_settings ons
  WHERE ons.organization_id = v_org_id
  ORDER BY ons.updated_at DESC
  LIMIT COALESCE(_limit, 1000)
  OFFSET COALESCE(_offset, 0);
END;
$$;


--
-- Name: organization_projects; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    project_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.organization_projects FORCE ROW LEVEL SECURITY;


--
-- Name: filter_organization_projects(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_projects
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','organization_projects', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organization_projects'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='organization_projects'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='organization_projects'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.organization_projects WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: organization_service_areas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organization_service_areas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid NOT NULL,
    service_area_text text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

ALTER TABLE ONLY public.organization_service_areas FORCE ROW LEVEL SECURITY;


--
-- Name: filter_organization_service_areas(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organization_service_areas(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organization_service_areas
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _where           text := 'true';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      PERFORM check_access('select','organization_service_areas', _project_id, _organization_id);

      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='organization_service_areas'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organization_service_areas';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='organization_service_areas'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.organization_service_areas WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- Name: organizations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.organizations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    mission_statement text,
    headquarters text,
    logo_url text
);

ALTER TABLE ONLY public.organizations FORCE ROW LEVEL SECURITY;


--
-- Name: filter_organizations(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_organizations(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.organizations
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','organizations', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='organizations'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='organizations'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='organizations'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.organizations WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: payments; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.payments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    commitment_id uuid,
    amount numeric,
    paid_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.payments FORCE ROW LEVEL SECURITY;


--
-- Name: filter_payments(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_payments(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.payments
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','payments', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='payments'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='payments'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='payments'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.payments WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: payroll; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.payroll (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid,
    pay_period_start date,
    pay_period_end date,
    gross_pay numeric,
    net_pay numeric,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.payroll FORCE ROW LEVEL SECURITY;


--
-- Name: filter_payroll(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_payroll(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.payroll
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','payroll', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='payroll'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='payroll'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='payroll'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.payroll WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: photos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.photos (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    url text NOT NULL,
    caption text,
    uploaded_by uuid,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.photos FORCE ROW LEVEL SECURITY;


--
-- Name: filter_photos(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_photos(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.photos
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','photos', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='photos'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='photos'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='photos'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.photos WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: prequalifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.prequalifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid,
    status text,
    reviewed_by uuid,
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.prequalifications FORCE ROW LEVEL SECURITY;


--
-- Name: filter_prequalifications(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_prequalifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.prequalifications
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','prequalifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='prequalifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='prequalifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='prequalifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.prequalifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: procurement_workflows; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.procurement_workflows (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text,
    status text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.procurement_workflows FORCE ROW LEVEL SECURITY;


--
-- Name: filter_procurement_workflows(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_procurement_workflows(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.procurement_workflows
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','procurement_workflows', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='procurement_workflows'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='procurement_workflows'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='procurement_workflows'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.procurement_workflows WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: filter_profiles(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_profiles(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.profiles
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','profiles', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='profiles'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='profiles'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='profiles'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.profiles WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: progress_billings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.progress_billings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    billing_number text,
    amount numeric,
    status text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.progress_billings FORCE ROW LEVEL SECURITY;


--
-- Name: filter_progress_billings(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_progress_billings(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.progress_billings
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','progress_billings', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='progress_billings'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='progress_billings'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='progress_billings'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.progress_billings WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: project_inspectors; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_inspectors (
    project_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    assigned_by uuid,
    assigned_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.project_inspectors FORCE ROW LEVEL SECURITY;


--
-- Name: filter_project_inspectors(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_project_inspectors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.project_inspectors
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','project_inspectors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='project_inspectors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='project_inspectors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='project_inspectors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.project_inspectors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: project_invites; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_invites (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid NOT NULL,
    invited_profile_id uuid NOT NULL,
    invited_by_profile_id uuid NOT NULL,
    status text NOT NULL,
    comment text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    responded_at timestamp with time zone,
    CONSTRAINT project_invites_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'declined'::text, 'cancelled'::text])))
);

ALTER TABLE ONLY public.project_invites FORCE ROW LEVEL SECURITY;


--
-- Name: filter_project_invites(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_project_invites(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.project_invites
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _where           text := 'true';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      PERFORM check_access('select','project_invites', _project_id, _organization_id);

      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='project_invites'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='project_invites';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='project_invites'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.project_invites WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- Name: project_service_areas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.project_service_areas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid NOT NULL,
    service_area_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

ALTER TABLE ONLY public.project_service_areas FORCE ROW LEVEL SECURITY;


--
-- Name: filter_project_service_areas(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_project_service_areas(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.project_service_areas
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_filters->>'project_id')::uuid;
      _organization_id uuid := (_filters->>'organization_id')::uuid;
      _where           text := 'true';
      kv               record;
      _sel             text;
      sqltxt           text;
      dir              text := lower(coalesce(_direction, 'asc'));
    BEGIN
      IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
        _filters := '{}'::jsonb;
      END IF;

      PERFORM check_access('select','project_service_areas', _project_id, _organization_id);

      FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
        IF kv.key NOT IN ('project_id','organization_id') THEN
          IF jsonb_typeof(kv.value) = 'object' THEN
            IF (kv.value ? '$gte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' >= '  || quote_literal(kv.value->>'$gte');
            END IF;

            IF (kv.value ? '$lte') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' <= '  || quote_literal(kv.value->>'$lte');
            END IF;

            IF (kv.value ? '$ilike') THEN
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
            END IF;

            IF (kv.value ? '$in') THEN
              _where := _where
                || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                || 'SELECT value FROM jsonb_array_elements_text('
                || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                || ' AS t(value))';
            END IF;
          ELSE
            _where := _where
              || ' AND ' || quote_ident(kv.key)
              || ' = '   || quote_literal(kv.value::text);
          END IF;
        END IF;
      END LOOP;

      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='project_service_areas'
          AND column_name=_order_by
      ) THEN
        RAISE EXCEPTION 'unknown order_by column'
          USING DETAIL = jsonb_build_object('column', _order_by);
      END IF;

      IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

      IF _select_cols IS NULL THEN
        SELECT string_agg(quote_ident(column_name),', ')
          INTO _sel
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='project_service_areas';
      ELSIF _select_cols = array['*'] THEN
        _sel := '*';
      ELSE
        IF EXISTS (
          SELECT UNNEST(_select_cols)
          EXCEPT
          SELECT column_name
            FROM information_schema.columns
            WHERE table_schema='public' AND table_name='project_service_areas'
        ) THEN
          RAISE EXCEPTION 'unknown column in select_cols'
            USING DETAIL = jsonb_build_object('columns', _select_cols);
        END IF;
        SELECT string_agg(quote_ident(c),', ') INTO _sel
          FROM UNNEST(_select_cols) c;
      END IF;

      sqltxt := 'SELECT ' || _sel
             || ' FROM public.project_service_areas WHERE ' || _where
             || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

      IF _limit  IS NOT NULL THEN
        sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
      END IF;
      IF _offset IS NOT NULL THEN
        sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
      END IF;

      RETURN QUERY EXECUTE sqltxt;
    END;
    $_$;


--
-- Name: filter_projects(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.projects
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
DECLARE
  _project_id      uuid;
  _organization_id uuid;
  _where           text := 'deleted_at IS NULL';
  kv               record;
  sqltxt           text;
  dir              text := lower(coalesce(_direction, 'asc'));
  order_col        text := coalesce(nullif(_order_by, ''), 'id');
  v_text           text;
BEGIN
  -- normalize filters
  IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
    _filters := '{}'::jsonb;
  END IF;

  _project_id      := NULLIF(_filters->>'project_id', '')::uuid;
  _organization_id := NULLIF(_filters->>'organization_id', '')::uuid;

  IF NOT public.check_access_bool('select','projects', _project_id, _organization_id) THEN
    RETURN;
  END IF;

  -- safe order_by (fallback instead of raising)
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema='public'
      AND table_name='projects'
      AND column_name=order_col
  ) THEN
    order_col := 'id';
  END IF;

  IF dir NOT IN ('asc','desc') THEN
    dir := 'asc';
  END IF;

  -- build WHERE
  FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
    IF kv.key NOT IN ('project_id','organization_id') THEN

      -- ignore unknown columns instead of erroring
      IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema='public'
          AND table_name='projects'
          AND column_name=kv.key
      ) THEN
        CONTINUE;
      END IF;

      IF kv.value = 'null'::jsonb THEN
        _where := _where || ' AND ' || quote_ident(kv.key) || ' IS NULL';

      ELSIF jsonb_typeof(kv.value) = 'object' THEN
        IF (kv.value ? '$gte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' >= ' || quote_literal(kv.value->>'$gte');
        END IF;

        IF (kv.value ? '$lte') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' <= ' || quote_literal(kv.value->>'$lte');
        END IF;

        IF (kv.value ? '$ilike') THEN
          _where := _where || ' AND ' || quote_ident(kv.key) || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
        END IF;

        IF (kv.value ? '$in') THEN
          _where := _where
            || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
            || 'ARRAY(SELECT jsonb_array_elements_text('
            || quote_literal((kv.value->'$in')::text) || '::jsonb)))';
        END IF;

      ELSE
        v_text := kv.value #>> '{}';
        _where := _where || ' AND ' || quote_ident(kv.key) || ' = ' || quote_literal(v_text);
      END IF;
    END IF;
  END LOOP;

  sqltxt := 'SELECT * FROM public.projects WHERE ' || _where
         || ' ORDER BY ' || quote_ident(order_col) || ' ' || dir;

  IF _limit IS NOT NULL THEN
    sqltxt := sqltxt || ' LIMIT ' || GREATEST(_limit, 0);
  END IF;

  IF _offset IS NOT NULL THEN
    sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset, 0);
  END IF;

  RETURN QUERY EXECUTE sqltxt;
END;
$_$;


--
-- Name: punch_lists; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.punch_lists (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    item text,
    status text,
    assigned_to uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.punch_lists FORCE ROW LEVEL SECURITY;


--
-- Name: filter_punch_lists(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_punch_lists(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.punch_lists
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','punch_lists', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='punch_lists'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='punch_lists'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='punch_lists'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.punch_lists WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: purchase_orders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.purchase_orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    vendor_id uuid,
    order_number text,
    order_date date,
    amount numeric,
    status text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.purchase_orders FORCE ROW LEVEL SECURITY;


--
-- Name: filter_purchase_orders(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_purchase_orders(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.purchase_orders
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','purchase_orders', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='purchase_orders'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='purchase_orders'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='purchase_orders'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.purchase_orders WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: quality_reviews; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.quality_reviews (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    review_date date,
    reviewer uuid,
    findings jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.quality_reviews FORCE ROW LEVEL SECURITY;


--
-- Name: filter_quality_reviews(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_quality_reviews(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.quality_reviews
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','quality_reviews', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='quality_reviews'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='quality_reviews'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='quality_reviews'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.quality_reviews WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: regulatory_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.regulatory_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    document_type text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.regulatory_documents FORCE ROW LEVEL SECURITY;


--
-- Name: filter_regulatory_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_regulatory_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.regulatory_documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','regulatory_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='regulatory_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='regulatory_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='regulatory_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.regulatory_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: reports; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.reports (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    report_type text,
    generated_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.reports FORCE ROW LEVEL SECURITY;


--
-- Name: filter_reports(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_reports(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.reports
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','reports', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='reports'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='reports'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='reports'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.reports WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: rfis; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.rfis (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    subject text,
    status text,
    question text,
    answer text,
    submitted_by uuid,
    reviewed_by uuid,
    submitted_at timestamp with time zone DEFAULT now(),
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.rfis FORCE ROW LEVEL SECURITY;


--
-- Name: filter_rfis(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_rfis(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.rfis
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','rfis', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='rfis'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='rfis'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='rfis'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.rfis WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: safety_incidents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.safety_incidents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    incident_date date,
    description text,
    reported_by uuid,
    severity text,
    resolved boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.safety_incidents FORCE ROW LEVEL SECURITY;


--
-- Name: filter_safety_incidents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_safety_incidents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.safety_incidents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','safety_incidents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='safety_incidents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='safety_incidents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='safety_incidents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.safety_incidents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: sensor_data; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.sensor_data (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    data jsonb,
    collected_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.sensor_data FORCE ROW LEVEL SECURITY;


--
-- Name: filter_sensor_data(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_sensor_data(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.sensor_data
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','sensor_data', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='sensor_data'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='sensor_data'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='sensor_data'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.sensor_data WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: subcontractor_agreements; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.subcontractor_agreements (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    subcontract_id uuid,
    agreement_url text,
    signed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.subcontractor_agreements FORCE ROW LEVEL SECURITY;


--
-- Name: filter_subcontractor_agreements(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_subcontractor_agreements(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.subcontractor_agreements
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','subcontractor_agreements', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='subcontractor_agreements'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='subcontractor_agreements'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='subcontractor_agreements'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.subcontractor_agreements WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: subcontracts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.subcontracts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    vendor_id uuid,
    amount numeric,
    status text,
    signed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.subcontracts FORCE ROW LEVEL SECURITY;


--
-- Name: filter_subcontracts(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_subcontracts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.subcontracts
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','subcontracts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='subcontracts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='subcontracts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='subcontracts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.subcontracts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: submittals; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.submittals (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text,
    status public.general_status,
    submitted_by uuid,
    reviewed_by uuid,
    submitted_at timestamp with time zone DEFAULT now(),
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.submittals FORCE ROW LEVEL SECURITY;


--
-- Name: filter_submittals(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_submittals(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.submittals
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','submittals', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='submittals'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='submittals'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='submittals'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.submittals WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: tack_rates; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tack_rates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    rate numeric,
    material_type text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.tack_rates FORCE ROW LEVEL SECURITY;


--
-- Name: filter_tack_rates(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_tack_rates(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.tack_rates
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','tack_rates', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='tack_rates'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='tack_rates'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='tack_rates'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.tack_rates WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: task_dependencies; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.task_dependencies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    task_id uuid NOT NULL,
    depends_on_task_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.task_dependencies FORCE ROW LEVEL SECURITY;


--
-- Name: filter_task_dependencies(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_task_dependencies(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.task_dependencies
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','task_dependencies', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='task_dependencies'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='task_dependencies'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='task_dependencies'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.task_dependencies WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: task_status_logs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.task_status_logs (
    task_id uuid NOT NULL,
    status public.task_status NOT NULL,
    changed_at timestamp without time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);

ALTER TABLE ONLY public.task_status_logs FORCE ROW LEVEL SECURITY;


--
-- Name: filter_task_status_logs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_task_status_logs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.task_status_logs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','task_status_logs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='task_status_logs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='task_status_logs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='task_status_logs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.task_status_logs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: tasks; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tasks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid NOT NULL,
    name text NOT NULL,
    description text,
    start_date date,
    end_date date,
    status public.task_status DEFAULT 'not_started'::public.task_status NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.tasks FORCE ROW LEVEL SECURITY;


--
-- Name: filter_tasks(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_tasks(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.tasks
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','tasks', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='tasks'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='tasks'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='tasks'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.tasks WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: training_records; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.training_records (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid,
    training_type text,
    completion_date date,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.training_records FORCE ROW LEVEL SECURITY;


--
-- Name: filter_training_records(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_training_records(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.training_records
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','training_records', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='training_records'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='training_records'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='training_records'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.training_records WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: user_notification_settings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_notification_settings (
    user_id uuid NOT NULL,
    silenced_categories public.notification_category[] DEFAULT '{}'::public.notification_category[] NOT NULL,
    silenced_events text[] DEFAULT '{}'::text[] NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

ALTER TABLE ONLY public.user_notification_settings FORCE ROW LEVEL SECURITY;


--
-- Name: filter_user_notification_settings(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_user_notification_settings(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'updated_at'::text, _direction text DEFAULT 'desc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.user_notification_settings
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated' USING errcode = '42501';
  END IF;

  RETURN QUERY
  SELECT uns.*
  FROM public.user_notification_settings uns
  WHERE uns.user_id = v_user_id
  ORDER BY uns.updated_at DESC
  LIMIT COALESCE(_limit, 1000)
  OFFSET COALESCE(_offset, 0);
END;
$$;


--
-- Name: user_projects; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.user_projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    project_id uuid,
    role text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.user_projects FORCE ROW LEVEL SECURITY;


--
-- Name: filter_user_projects(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_user_projects(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.user_projects
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','user_projects', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='user_projects'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='user_projects'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='user_projects'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.user_projects WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: vendor_bid_packages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendor_bid_packages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bid_package_id uuid,
    vendor_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendor_bid_packages FORCE ROW LEVEL SECURITY;


--
-- Name: filter_vendor_bid_packages(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendor_bid_packages(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendor_bid_packages
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_bid_packages', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_bid_packages'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_bid_packages'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_bid_packages'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_bid_packages WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: vendor_contacts; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendor_contacts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid,
    name text,
    email text,
    phone text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendor_contacts FORCE ROW LEVEL SECURITY;


--
-- Name: filter_vendor_contacts(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendor_contacts(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendor_contacts
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_contacts', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_contacts'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_contacts'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_contacts'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_contacts WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: vendor_documents; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendor_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid,
    document_type text,
    url text,
    uploaded_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendor_documents FORCE ROW LEVEL SECURITY;


--
-- Name: filter_vendor_documents(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendor_documents(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendor_documents
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_documents', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_documents'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_documents'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_documents'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_documents WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: vendor_qualifications; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendor_qualifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vendor_id uuid,
    qualification_type text,
    status text,
    reviewed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendor_qualifications FORCE ROW LEVEL SECURITY;


--
-- Name: filter_vendor_qualifications(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendor_qualifications(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendor_qualifications
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendor_qualifications', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendor_qualifications'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendor_qualifications'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendor_qualifications'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendor_qualifications WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: vendors; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.vendors (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    organization_id uuid,
    name text NOT NULL,
    status public.general_status,
    contact_email text,
    contact_phone text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.vendors FORCE ROW LEVEL SECURITY;


--
-- Name: filter_vendors(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_vendors(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.vendors
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','vendors', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='vendors'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='vendors'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='vendors'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.vendors WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: wbs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.wbs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    project_id uuid,
    name text NOT NULL,
    location text,
    order_num integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone
);

ALTER TABLE ONLY public.wbs FORCE ROW LEVEL SECURITY;


--
-- Name: filter_wbs(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_wbs(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.wbs
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','wbs', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='wbs'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='wbs'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='wbs'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.wbs WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: filter_workflows(jsonb, text[], text, text, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.filter_workflows(_filters jsonb DEFAULT '{}'::jsonb, _select_cols text[] DEFAULT NULL::text[], _order_by text DEFAULT 'id'::text, _direction text DEFAULT 'asc'::text, _limit integer DEFAULT NULL::integer, _offset integer DEFAULT NULL::integer) RETURNS SETOF public.workflows
    LANGUAGE plpgsql STABLE
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_filters->>'project_id')::uuid;
        _organization_id uuid := (_filters->>'organization_id')::uuid;
        _where           text := 'deleted_at IS NULL';
        kv               record;
        _sel             text;
        sqltxt           text;
        dir              text := lower(coalesce(_direction, 'asc'));
      BEGIN
        -- Tweak #3: normalize filters to an object
        IF _filters IS NULL OR jsonb_typeof(_filters) <> 'object' THEN
          _filters := '{}'::jsonb;
        END IF;

        -- Pre-check; RLS still applies
        PERFORM check_access('select','workflows', _project_id, _organization_id);

        -- Build WHERE from filters
        FOR kv IN SELECT * FROM jsonb_each(_filters) LOOP
          IF kv.key NOT IN ('project_id','organization_id') THEN
            IF jsonb_typeof(kv.value) = 'object' THEN
              IF (kv.value ? '$gte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' >= '  || quote_literal(kv.value->>'$gte');
              END IF;

              IF (kv.value ? '$lte') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' <= '  || quote_literal(kv.value->>'$lte');
              END IF;

              IF (kv.value ? '$ilike') THEN
                _where := _where
                  || ' AND ' || quote_ident(kv.key)
                  || ' ILIKE ' || quote_literal(kv.value->>'$ilike');
              END IF;

              IF (kv.value ? '$in') THEN
                -- Generic "IN": cast column to text & compare to JSON array of text values
                _where := _where
                  || ' AND (' || quote_ident(kv.key) || ')::text = ANY ('
                  || 'SELECT value FROM jsonb_array_elements_text('
                  || quote_literal((kv.value->'$in')::text) || '::jsonb)'
                  || ' AS t(value))';
              END IF;
            ELSE
              _where := _where
                || ' AND ' || quote_ident(kv.key)
                || ' = '   || quote_literal(kv.value::text);
            END IF;
          END IF;
        END LOOP;

        -- Validate order_by
        IF NOT EXISTS (
          SELECT 1
          FROM information_schema.columns
          WHERE table_schema='public'
            AND table_name='workflows'
            AND column_name=_order_by
        ) THEN
          RAISE EXCEPTION 'unknown order_by column'
            USING DETAIL = jsonb_build_object('column', _order_by);
        END IF;

        -- Clamp direction
        IF dir NOT IN ('asc','desc') THEN dir := 'asc'; END IF;

        -- Build select list
        IF _select_cols IS NULL THEN
          SELECT string_agg(quote_ident(column_name),', ')
            INTO _sel
            FROM information_schema.columns
            WHERE table_schema='public'
              AND table_name='workflows'
              AND column_name <> 'deleted_at';
        ELSIF _select_cols = array['*'] THEN
          _sel := '*';
        ELSE
          IF EXISTS (
            SELECT UNNEST(_select_cols)
            EXCEPT
            SELECT column_name
              FROM information_schema.columns
              WHERE table_schema='public' AND table_name='workflows'
          ) THEN
            RAISE EXCEPTION 'unknown column in select_cols'
              USING DETAIL = jsonb_build_object('columns', _select_cols);
          END IF;
          SELECT string_agg(quote_ident(c),', ') INTO _sel
            FROM UNNEST(_select_cols) c;
        END IF;

        -- Final SQL (table name baked in at creation)
        sqltxt := 'SELECT ' || _sel
               || ' FROM public.workflows WHERE ' || _where
               || ' ORDER BY ' || quote_ident(_order_by) || ' ' || dir;

        IF _limit  IS NOT NULL THEN
          sqltxt := sqltxt || ' LIMIT '  || GREATEST(_limit,0);
        END IF;
        IF _offset IS NOT NULL THEN
          sqltxt := sqltxt || ' OFFSET ' || GREATEST(_offset,0);
        END IF;

        RETURN QUERY EXECUTE sqltxt;
      END;
      $_$;


--
-- Name: fn_cashflow_curve(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_cashflow_curve(p_project_id uuid) RETURNS TABLE(cur_date date, billed numeric, cost numeric)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH bills AS (
    SELECT created_at::date AS d, SUM(amount) AS amt
    FROM public.progress_billings
    WHERE project_id = p_project_id
    GROUP BY 1
  ), costs AS (
    SELECT entry_date::date AS d, SUM(debit) AS amt
    FROM public.general_ledger
    WHERE project_id = p_project_id
    GROUP BY 1
  ), dates AS (
    SELECT d::date FROM bills
    UNION
    SELECT d::date FROM costs
  )
  SELECT
    dates.d AS cur_date,
    SUM(b.amt) OVER (ORDER BY dates.d
                     ROWS UNBOUNDED PRECEDING) AS billed,
    SUM(c.amt) OVER (ORDER BY dates.d
                     ROWS UNBOUNDED PRECEDING) AS cost
  FROM dates
  LEFT JOIN bills b ON b.d = dates.d
  LEFT JOIN costs c ON c.d = dates.d
  ORDER BY cur_date;
$$;


--
-- Name: fn_eqp_7d_avg_hours(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_eqp_7d_avg_hours(p_equipment_id uuid) RETURNS TABLE(day date, avg_hours numeric)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    eu.date,
    ROUND(
      AVG(eu.hours_used)
      OVER (
        ORDER BY eu.date
        RANGE BETWEEN INTERVAL '6 days' PRECEDING 
              AND CURRENT ROW
      ), 2
    ) AS avg_hours
  FROM public.equipment_usage eu
  WHERE eu.equipment_id = p_equipment_id
  ORDER BY eu.date;
$$;


--
-- Name: fn_find_rpc_dupes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_find_rpc_dupes() RETURNS TABLE(fname text, args text, cnt integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    p.proname             AS fname,
    pg_catalog.pg_get_function_arguments(p.oid) AS args,
    COUNT(*) OVER (PARTITION BY p.proname)     AS cnt
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
  ORDER BY cnt DESC, fname;
$$;


--
-- Name: fn_inventory_balance(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_inventory_balance(_material_id uuid) RETURNS TABLE(day date, balance numeric)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH tx AS (
    SELECT
      (transaction_date::date) AS day,
      CASE
        WHEN transaction_type IN ('receive', 'in', 'purchase') THEN quantity
        WHEN transaction_type IN ('issue', 'out', 'usage')     THEN -quantity
        ELSE 0
      END AS qty
    FROM public.inventory_transactions
    WHERE material_id = _material_id
  )
  SELECT
    day,
    SUM(qty) OVER (
      ORDER BY day
      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS balance
  FROM tx
  ORDER BY day;
$$;


--
-- Name: fn_list_tables_and_columns(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_list_tables_and_columns() RETURNS TABLE(table_name text, column_name text)
    LANGUAGE sql IMMUTABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT table_name, column_name
  FROM information_schema.columns
  WHERE table_schema = 'public'
  ORDER BY table_name, ordinal_position;
$$;


--
-- Name: fn_materials_on_hand(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_materials_on_hand(p_material_id uuid) RETURNS TABLE(trans_date date, on_hand bigint)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    it.transaction_date::date                           AS trans_date,
    SUM((it.transaction_type = 'receipt')::int
      - (it.transaction_type = 'issue')::int)
      OVER (ORDER BY it.transaction_date::date
            ROWS UNBOUNDED PRECEDING)                   AS on_hand
  FROM public.inventory_transactions it
  WHERE it.material_id = p_material_id
  ORDER BY trans_date;
$$;


--
-- Name: fn_task_cycle_time(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_task_cycle_time(p_task_id uuid) RETURNS TABLE(status text, days_in_phase integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH logs AS (
    SELECT
      status,
      changed_at,
      LEAD(changed_at) OVER (ORDER BY changed_at) AS next_change
    FROM public.task_status_logs
    WHERE task_id = p_task_id
  )
  SELECT
    status,
    EXTRACT(epoch FROM (next_change - changed_at))/86400::int AS days_in_phase
  FROM logs
  WHERE next_change IS NOT NULL;
$$;


--
-- Name: fn_top5_cost_codes(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_top5_cost_codes(p_project_id uuid) RETURNS TABLE(cost_code_id uuid, total_spend numeric, rank integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    eli.cost_code_id,
    SUM(eli.total_cost)             AS total_spend,
    RANK() OVER (ORDER BY SUM(eli.total_cost) DESC) AS rank
  FROM public.estimate_line_items eli
  JOIN public.estimates e ON e.id = eli.estimate_id
  WHERE e.project_id = p_project_id
  GROUP BY eli.cost_code_id
  ORDER BY total_spend DESC
  LIMIT 5;
$$;


--
-- Name: fn_weekly_receipt_perf(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_weekly_receipt_perf(p_project_id uuid) RETURNS TABLE(week_start date, on_time_count integer, late_count integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH rec AS (
    SELECT
      mr.material_order_id,
      mr.received_date,
      mo.project_id,
      mo.order_date,
      date_trunc('week', mr.received_date)::date AS wk
    FROM public.material_receipts mr
    JOIN public.material_orders  mo ON mo.id = mr.material_order_id
    WHERE mo.project_id = p_project_id
  )
  SELECT
    wk                  AS week_start,
    SUM((received_date <= order_date)::int) AS on_time_count,
    SUM((received_date >  order_date)::int) AS late_count
  FROM rec
  GROUP BY wk
  ORDER BY wk;
$$;


--
-- Name: fn_worst10_crews_by_incidents(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fn_worst10_crews_by_incidents() RETURNS TABLE(crew_id uuid, incident_count integer, rank integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  SELECT
    ca.crew_id,
    COUNT(si.*)                      AS incident_count,
    RANK() OVER (ORDER BY COUNT(si.*) DESC) AS rank
  FROM public.safety_incidents si
  JOIN public.crew_assignments ca
    ON ca.profile_id = si.reported_by
  GROUP BY ca.crew_id
  ORDER BY incident_count DESC
  LIMIT 10;
$$;


--
-- Name: get_avatar_by_id_public(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_avatar_by_id_public(p_avatar_id uuid) RETURNS public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_row public.avatars;
begin
  select *
  into v_row
  from public.avatars
  where id = p_avatar_id
    and deleted_at is null;

  return v_row;
end;
$$;


--
-- Name: get_avatar_storage_paths(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_avatar_storage_paths() RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    BEGIN
      IF COALESCE(auth.role(), '') NOT IN ('service_role', 'supabase_admin') THEN
        RAISE EXCEPTION 'not authorized';
      END IF;

      RETURN QUERY
      SELECT regexp_replace(url, '^.*?/storage/v1/object/public/avatars-personal/', '')
        FROM public.avatars
       WHERE deleted_at IS NULL
         AND url LIKE '%/storage/v1/object/public/avatars-personal/%';
    END;
    $$;


--
-- Name: get_contract_with_wkt(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_contract_with_wkt(p_contract_id uuid) RETURNS TABLE(id uuid, project_id uuid, contract_number text, title text, description text, start_date date, end_date date, budget numeric, status public.project_status, created_at timestamp with time zone, updated_at timestamp with time zone, coordinates_wkt text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  perform check_access('select','projects', p_contract_id, null);

  return query
  select
    p.id,
    p.id as project_id,
    ''::text as contract_number,
    p.name as title,
    p.description,
    p.start_date,
    p.end_date,
    null::numeric as budget,
    p.status,
    p.created_at,
    p.updated_at,
    null::text as coordinates_wkt
  from public.projects p
  where p.id = p_contract_id
    and p.deleted_at is null;
end;
$$;


--
-- Name: get_job_titles_public(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_job_titles_public() RETURNS SETOF public.job_titles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  return query
  select *
  from public.job_titles
  where deleted_at is null
  order by name asc;
end;
$$;


--
-- Name: get_my_member_organizations(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_member_organizations() RETURNS TABLE(id uuid, name text, role text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id uuid;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  RETURN QUERY
  WITH my_profile AS (
    SELECT p.id, p.organization_id
    FROM public.profiles p
    WHERE p.id = v_user_id
      AND p.deleted_at IS NULL
  ),
  membership_orgs AS (
    SELECT
      o.id,
      o.name,
      COALESCE(om.permission_role::text, 'worker') AS role
    FROM public.organization_members om
    JOIN public.organizations o
      ON o.id = om.organization_id
    WHERE om.profile_id = v_user_id
      AND om.deleted_at IS NULL
      AND o.deleted_at IS NULL
  ),
  primary_org_fallback AS (
    SELECT
      o.id,
      o.name,
      NULL::text AS role
    FROM my_profile p
    JOIN public.organizations o
      ON o.id = p.organization_id
    LEFT JOIN public.organization_members om
      ON om.organization_id = p.organization_id
     AND om.profile_id = p.id
     AND om.deleted_at IS NULL
    WHERE p.organization_id IS NOT NULL
      AND o.deleted_at IS NULL
      AND om.id IS NULL
  )
  SELECT DISTINCT r.id, r.name, r.role
  FROM (
    SELECT * FROM membership_orgs
    UNION ALL
    SELECT * FROM primary_org_fallback
  ) r
  ORDER BY r.name ASC;
END;
$$;


--
-- Name: get_my_notification_settings(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_notification_settings() RETURNS TABLE(silenced_categories public.notification_category[], silenced_events text[], updated_at timestamp with time zone)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH current_row AS (
    SELECT
      uns.silenced_categories,
      uns.silenced_events,
      uns.updated_at
    FROM public.user_notification_settings uns
    WHERE uns.user_id = auth.uid()
  )
  SELECT * FROM current_row
  UNION ALL
  SELECT '{}'::public.notification_category[], '{}'::text[], NULL::timestamptz
  WHERE NOT EXISTS (SELECT 1 FROM current_row)
  LIMIT 1;
$$;


--
-- Name: get_my_org_profiles_minimal(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_org_profiles_minimal() RETURNS TABLE(id uuid, full_name text, email text, avatar_id uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_org_id uuid;
begin
  v_org_id := (
    select organization_id
    from public.profiles
    where id = auth.uid()
  );

  return query
  select p.id, p.full_name, p.email, p.avatar_id
  from public.profiles p
  where p.organization_id = v_org_id
    and p.deleted_at is null;
end;
$$;


--
-- Name: get_my_profile(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_my_profile() RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    return null;
  end if;

  select *
  into v_profile
  from public.profiles
  where id = v_user_id;

  return v_profile;
end;
$$;


--
-- Name: get_org_notification_settings(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_org_notification_settings(p_organization_id uuid) RETURNS TABLE(enabled_categories public.notification_category[], enabled_events text[], updated_at timestamp with time zone)
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
BEGIN
  PERFORM public.check_access('select', 'organizations', NULL::uuid, p_organization_id);

  RETURN QUERY
  SELECT
    ons.enabled_categories,
    ons.enabled_events,
    ons.updated_at
  FROM public.organization_notification_settings ons
  WHERE ons.organization_id = p_organization_id;

  IF NOT FOUND THEN
    RETURN QUERY
    SELECT
      ARRAY[
        'workflow_update'::public.notification_category,
        'approval_needed'::public.notification_category,
        'bid_received'::public.notification_category
      ],
      ARRAY[
        'member_added',
        'member_removed',
        'member_left_organization',
        'contract_completed',
        'bid_accepted',
        'new_project_created',
        'member_job_title_changed',
        'member_job_title_changed_broadcast',
        'member_permission_role_changed'
      ]::text[],
      NULL::timestamptz;
  END IF;
END;
$$;


--
-- Name: get_organization_by_id(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_organization_by_id(p_organization_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_role text;
  v_has_membership boolean := false;
  v_org jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select role into v_role
  from public.profiles
  where id = v_user_id;

  if v_role is null then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  if v_role = 'system_admin' then
    v_has_membership := true;
  else
    select exists (
      select 1
      from public.organization_members
      where organization_id = p_organization_id
        and profile_id = v_user_id
        and deleted_at is null
    ) into v_has_membership;
  end if;

  if v_has_membership is not true then
    raise exception 'Access denied: not a member of organization %', p_organization_id;
  end if;

  select jsonb_build_object(
    'id', id,
    'name', name,
    'description', description,
    'mission_statement', mission_statement,
    'headquarters', headquarters,
    'logo_url', logo_url,
    'created_at', created_at,
    'updated_at', updated_at
  )
  into v_org
  from public.organizations
  where id = p_organization_id
    and deleted_at is null;

  if v_org is null then
    raise exception 'Organization not found: %', p_organization_id;
  end if;

  return v_org;
end;
$$;


--
-- Name: get_organizations_public(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_organizations_public(p_query text) RETURNS TABLE(id uuid, name text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  return query
  select o.id, o.name
  from public.organizations o
  where o.deleted_at is null
    and o.name ilike '%' || coalesce(p_query, '') || '%'
  order by o.name asc
  limit 10;
end;
$$;


--
-- Name: get_pending_organization_invites_with_profiles(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_pending_organization_invites_with_profiles(p_organization_id uuid) RETURNS TABLE(id uuid, organization_id uuid, invited_profile_id uuid, invited_by_profile_id uuid, status text, role text, comment text, created_at timestamp with time zone, responded_at timestamp with time zone, requester_full_name text, requester_email text, requester_phone text, requester_location text, requester_avatar_url text, requester_avatar_id uuid, requested_permission_role public.org_role, requested_job_title_id uuid, requested_job_title_name text, reviewed_permission_role public.org_role, reviewed_job_title_id uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
declare
  v_user_id uuid := auth.uid();
  v_global_role public.user_role_type;
  v_is_member boolean := false;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if p_organization_id is null then
    raise exception 'organization_id is required';
  end if;

  select p.role
    into v_global_role
  from public.profiles p
  where p.id = v_user_id
    and p.deleted_at is null;

  if v_global_role is null then
    raise exception 'Access denied'
      using errcode = '42501';
  end if;

  if v_global_role <> 'system_admin' then
    select exists (
      select 1
      from public.organization_members om
      where om.organization_id = p_organization_id
        and om.profile_id = v_user_id
        and om.deleted_at is null
    ) into v_is_member;

    if not v_is_member then
      raise exception 'Access denied'
        using errcode = '42501';
    end if;
  end if;

  if v_global_role::text not in ('system_admin', 'org_admin') then
    raise exception 'Access denied'
      using errcode = '42501';
  end if;

  return query
  select
    oi.id,
    oi.organization_id,
    oi.invited_profile_id,
    oi.invited_by_profile_id,
    oi.status,
    oi.role::text,
    oi.comment,
    oi.created_at,
    oi.responded_at,
    pr.full_name as requester_full_name,
    pr.email as requester_email,
    pr.phone as requester_phone,
    pr.location as requester_location,
    av.url as requester_avatar_url,
    pr.avatar_id as requester_avatar_id,
    oi.requested_permission_role,
    oi.requested_job_title_id,
    jt_requested.name as requested_job_title_name,
    oi.reviewed_permission_role,
    oi.reviewed_job_title_id
  from public.organization_invites oi
  left join public.profiles pr
    on pr.id = oi.invited_profile_id
   and pr.deleted_at is null
  left join public.avatars av
    on av.id = pr.avatar_id
   and av.deleted_at is null
  left join public.job_titles jt_requested
    on jt_requested.id = oi.requested_job_title_id
   and jt_requested.deleted_at is null
  where oi.organization_id = p_organization_id
    and oi.status = 'pending'
  order by oi.created_at asc;
end;
$$;


--
-- Name: get_preset_avatars_public(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_preset_avatars_public() RETURNS SETOF public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  return query
  select *
  from public.avatars
  where deleted_at is null
    and coalesce(is_preset, false) = true
  order by created_at asc;
end;
$$;


--
-- Name: get_profiles_by_contract(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_profiles_by_contract(p_contract_id uuid) RETURNS TABLE(id uuid, full_name text, email text, role public.user_role_type, contract_role text, assigned_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  perform check_access('select','user_projects', p_contract_id, null);

  return query
  select
    pr.id,
    pr.full_name,
    pr.email,
    pr.role,
    up.role as contract_role,
    up.created_at as assigned_at
  from public.user_projects up
  join public.profiles pr on pr.id = up.user_id
  where up.project_id = p_contract_id
    and up.deleted_at is null
  order by pr.full_name nulls last, pr.email;
end;
$$;


--
-- Name: get_rpc_error_debug(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_rpc_error_debug(p_limit integer DEFAULT 100) RETURNS TABLE(id bigint, created_at timestamp with time zone, rpc_name text, operation text, sqlstate text, error_message text, error_detail text, error_hint text, auth_user_id uuid, request_context jsonb)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_uid uuid := auth.uid();
  v_role public.user_role_type;
  v_limit integer := LEAST(GREATEST(COALESCE(p_limit, 100), 1), 500);
  v_jwt_role text := current_setting('request.jwt.claim.role', true);
  v_is_privileged_session boolean := false;
BEGIN
  v_is_privileged_session :=
    current_user IN ('postgres', 'supabase_admin', 'service_role')
    OR COALESCE(v_jwt_role, '') IN ('service_role', 'supabase_admin');

  IF v_uid IS NULL THEN
    IF NOT v_is_privileged_session THEN
      RAISE EXCEPTION 'Not authenticated';
    END IF;
  ELSE
    SELECT p.role INTO v_role
    FROM public.profiles p
    WHERE p.id = v_uid
      AND p.deleted_at IS NULL;

    IF v_role IS NULL OR v_role::text NOT IN ('system_admin', 'org_admin') THEN
      RAISE EXCEPTION 'Access denied' USING errcode = '42501';
    END IF;
  END IF;

  RETURN QUERY
  SELECT
    d.id,
    d.created_at,
    d.rpc_name,
    d.operation,
    d.sqlstate,
    d.error_message,
    d.error_detail,
    d.error_hint,
    d.auth_user_id,
    d.request_context
  FROM public.rpc_error_debug d
  ORDER BY d.created_at DESC
  LIMIT v_limit;
END;
$$;


--
-- Name: handle_auth_user_profile_sync(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.handle_auth_user_profile_sync() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'auth'
    SET row_security TO 'off'
    AS $$
begin
  -- Ensure a profile row exists, and keep email in sync.
  -- Do NOT touch role/org/full_name/phone here.
  insert into public.profiles as p
    (id, email, created_at, updated_at)
  values
    (new.id, new.email, now(), now())
  on conflict (id) do update
    set email = excluded.email,
        updated_at = now();

  return new;
end;
$$;


--
-- Name: insert_accounts_payable(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_accounts_payable(_input jsonb) RETURNS SETOF public.accounts_payable
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.accounts_payable;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.accounts_payable;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','accounts_payable', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.accounts_payable, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'amount_due' THEN
    _insert_columns := array_append(_insert_columns, 'amount_due');
  END IF;

  IF _input_sanitized ? 'due_date' THEN
    _insert_columns := array_append(_insert_columns, 'due_date');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.accounts_payable DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.accounts_payable (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_accounts_receivable(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_accounts_receivable(_input jsonb) RETURNS SETOF public.accounts_receivable
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.accounts_receivable;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.accounts_receivable;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','accounts_receivable', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.accounts_receivable, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'amount_due' THEN
    _insert_columns := array_append(_insert_columns, 'amount_due');
  END IF;

  IF _input_sanitized ? 'due_date' THEN
    _insert_columns := array_append(_insert_columns, 'due_date');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.accounts_receivable DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.accounts_receivable (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_activity_logs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_activity_logs(_input jsonb) RETURNS SETOF public.activity_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.activity_logs;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.activity_logs;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','activity_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.activity_logs, _input_sanitized);

  IF _input_sanitized ? 'profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'profile_id');
  END IF;

  IF _input_sanitized ? 'activity_type' THEN
    _insert_columns := array_append(_insert_columns, 'activity_type');
  END IF;

  IF _input_sanitized ? 'activity_at' THEN
    _insert_columns := array_append(_insert_columns, 'activity_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.activity_logs DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.activity_logs (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_asphalt_types(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_asphalt_types(_input jsonb) RETURNS SETOF public.asphalt_types
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.asphalt_types;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.asphalt_types;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','asphalt_types', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.asphalt_types, _input_sanitized);

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.asphalt_types DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.asphalt_types (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_audit_log(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_audit_log(_input jsonb) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _new_row         public.audit_log;
      _input_sanitized jsonb := '{}'::jsonb;
      _insert_columns text[] := ARRAY[]::text[];
      _insert_column_list text;
      _insert_value_list text;
      _r public.audit_log;

    BEGIN
      PERFORM check_access('insert','audit_log', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'changed_at' - 'changed_by' - 'deleted_at';

        _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.audit_log, _input_sanitized);

  IF _input_sanitized ? 'table_name' THEN
    _insert_columns := array_append(_insert_columns, 'table_name');
  END IF;

  IF _input_sanitized ? 'action' THEN
    _insert_columns := array_append(_insert_columns, 'action');
  END IF;

  IF _input_sanitized ? 'row_id' THEN
    _insert_columns := array_append(_insert_columns, 'row_id');
  END IF;

  IF _input_sanitized ? 'before_data' THEN
    _insert_columns := array_append(_insert_columns, 'before_data');
  END IF;

  IF _input_sanitized ? 'after_data' THEN
    _insert_columns := array_append(_insert_columns, 'after_data');
  END IF;

  IF _input_sanitized ? 'changed_by' THEN
    _insert_columns := array_append(_insert_columns, 'changed_by');
  END IF;

  IF _input_sanitized ? 'changed_at' THEN
    _insert_columns := array_append(_insert_columns, 'changed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.audit_log DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.audit_log (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

      RETURN NEXT _new_row;
    END;
    $_$;


--
-- Name: insert_audit_logs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_audit_logs(_input jsonb) RETURNS SETOF public.audit_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.audit_logs;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.audit_logs;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','audit_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.audit_logs, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'action' THEN
    _insert_columns := array_append(_insert_columns, 'action');
  END IF;

  IF _input_sanitized ? 'performed_by' THEN
    _insert_columns := array_append(_insert_columns, 'performed_by');
  END IF;

  IF _input_sanitized ? 'performed_at' THEN
    _insert_columns := array_append(_insert_columns, 'performed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.audit_logs DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.audit_logs (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_avatars(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_avatars(_input jsonb) RETURNS SETOF public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $_$
    DECLARE
      _new_row public.avatars;
      _input_sanitized jsonb := '{}'::jsonb;
      _insert_columns text[] := ARRAY[]::text[];
      _insert_column_list text;
      _insert_value_list text;
      _r public.avatars;

    BEGIN
      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

      IF (_input ? 'id') IS FALSE OR (_input->>'id') IS NULL THEN
        _input := jsonb_set(_input, '{id}', to_jsonb(gen_random_uuid()), true);
      END IF;

      IF (_input ? 'created_at') IS FALSE OR (_input->>'created_at') IS NULL THEN
        _input := jsonb_set(_input, '{created_at}', to_jsonb(now()), true);
      END IF;

      IF (_input ? 'updated_at') IS FALSE OR (_input->>'updated_at') IS NULL THEN
        _input := jsonb_set(_input, '{updated_at}', to_jsonb(now()), true);
      END IF;

        _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.avatars, _input_sanitized);

  IF _input_sanitized ? 'url' THEN
    _insert_columns := array_append(_insert_columns, 'url');
  END IF;

  IF _input_sanitized ? 'is_preset' THEN
    _insert_columns := array_append(_insert_columns, 'is_preset');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.avatars DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.avatars (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

      RETURN NEXT _new_row;
    END;
    $_$;


--
-- Name: insert_bid_packages(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_bid_packages(_input jsonb) RETURNS SETOF public.bid_packages
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bid_packages;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.bid_packages;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bid_packages', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.bid_packages, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'created_by' THEN
    _insert_columns := array_append(_insert_columns, 'created_by');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.bid_packages DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.bid_packages (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_bid_vendors(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_bid_vendors(_input jsonb) RETURNS SETOF public.bid_vendors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bid_vendors;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.bid_vendors;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bid_vendors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.bid_vendors, _input_sanitized);

  IF _input_sanitized ? 'bid_package_id' THEN
    _insert_columns := array_append(_insert_columns, 'bid_package_id');
  END IF;

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'invited_at' THEN
    _insert_columns := array_append(_insert_columns, 'invited_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.bid_vendors DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.bid_vendors (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_bids(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_bids(_input jsonb) RETURNS SETOF public.bids
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bids;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.bids;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bids', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.bids, _input_sanitized);

  IF _input_sanitized ? 'bid_package_id' THEN
    _insert_columns := array_append(_insert_columns, 'bid_package_id');
  END IF;

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'amount' THEN
    _insert_columns := array_append(_insert_columns, 'amount');
  END IF;

  IF _input_sanitized ? 'submitted_at' THEN
    _insert_columns := array_append(_insert_columns, 'submitted_at');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.bids DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.bids (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_bim_models(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_bim_models(_input jsonb) RETURNS SETOF public.bim_models
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.bim_models;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.bim_models;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','bim_models', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.bim_models, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'url' THEN
    _insert_columns := array_append(_insert_columns, 'url');
  END IF;

  IF _input_sanitized ? 'uploaded_at' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.bim_models DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.bim_models (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_certifications(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_certifications(_input jsonb) RETURNS SETOF public.certifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.certifications;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.certifications;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','certifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.certifications, _input_sanitized);

  IF _input_sanitized ? 'employee_id' THEN
    _insert_columns := array_append(_insert_columns, 'employee_id');
  END IF;

  IF _input_sanitized ? 'certification_type' THEN
    _insert_columns := array_append(_insert_columns, 'certification_type');
  END IF;

  IF _input_sanitized ? 'issue_date' THEN
    _insert_columns := array_append(_insert_columns, 'issue_date');
  END IF;

  IF _input_sanitized ? 'expiry_date' THEN
    _insert_columns := array_append(_insert_columns, 'expiry_date');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.certifications DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.certifications (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_change_orders(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_change_orders(_input jsonb) RETURNS SETOF public.change_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.change_orders;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.change_orders;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','change_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.change_orders, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'number' THEN
    _insert_columns := array_append(_insert_columns, 'number');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'amount' THEN
    _insert_columns := array_append(_insert_columns, 'amount');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.change_orders DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.change_orders (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_commitments(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_commitments(_input jsonb) RETURNS SETOF public.commitments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.commitments;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.commitments;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','commitments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.commitments, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'type' THEN
    _insert_columns := array_append(_insert_columns, 'type');
  END IF;

  IF _input_sanitized ? 'amount' THEN
    _insert_columns := array_append(_insert_columns, 'amount');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.commitments DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.commitments (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_compliance_checks(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_compliance_checks(_input jsonb) RETURNS SETOF public.compliance_checks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.compliance_checks;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.compliance_checks;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','compliance_checks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.compliance_checks, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'check_date' THEN
    _insert_columns := array_append(_insert_columns, 'check_date');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'result' THEN
    _insert_columns := array_append(_insert_columns, 'result');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.compliance_checks DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.compliance_checks (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_compliance_tracking(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_compliance_tracking(_input jsonb) RETURNS SETOF public.compliance_tracking
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.compliance_tracking;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.compliance_tracking;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','compliance_tracking', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.compliance_tracking, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'tracking_type' THEN
    _insert_columns := array_append(_insert_columns, 'tracking_type');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.compliance_tracking DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.compliance_tracking (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_cost_codes(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_cost_codes(_input jsonb) RETURNS SETOF public.cost_codes
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.cost_codes;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.cost_codes;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','cost_codes', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.cost_codes, _input_sanitized);

  IF _input_sanitized ? 'code' THEN
    _insert_columns := array_append(_insert_columns, 'code');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.cost_codes DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.cost_codes (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_crew_assignments(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_crew_assignments(_input jsonb) RETURNS SETOF public.crew_assignments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crew_assignments;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.crew_assignments;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crew_assignments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.crew_assignments, _input_sanitized);

  IF _input_sanitized ? 'crew_id' THEN
    _insert_columns := array_append(_insert_columns, 'crew_id');
  END IF;

  IF _input_sanitized ? 'profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'profile_id');
  END IF;

  IF _input_sanitized ? 'assigned_date' THEN
    _insert_columns := array_append(_insert_columns, 'assigned_date');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.crew_assignments DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.crew_assignments (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_crew_members(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_crew_members(_input jsonb) RETURNS SETOF public.crew_members
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crew_members;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.crew_members;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crew_members', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.crew_members, _input_sanitized);

  IF _input_sanitized ? 'crew_id' THEN
    _insert_columns := array_append(_insert_columns, 'crew_id');
  END IF;

  IF _input_sanitized ? 'profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'profile_id');
  END IF;

  IF _input_sanitized ? 'role' THEN
    _insert_columns := array_append(_insert_columns, 'role');
  END IF;

  IF _input_sanitized ? 'start_date' THEN
    _insert_columns := array_append(_insert_columns, 'start_date');
  END IF;

  IF _input_sanitized ? 'end_date' THEN
    _insert_columns := array_append(_insert_columns, 'end_date');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.crew_members DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.crew_members (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_crews(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_crews(_input jsonb) RETURNS SETOF public.crews
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.crews;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.crews;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','crews', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.crews, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.crews DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.crews (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_daily_logs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_daily_logs(_input jsonb) RETURNS SETOF public.daily_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.daily_logs;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.daily_logs;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','daily_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.daily_logs, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'date' THEN
    _insert_columns := array_append(_insert_columns, 'date');
  END IF;

  IF _input_sanitized ? 'weather' THEN
    _insert_columns := array_append(_insert_columns, 'weather');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.daily_logs DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.daily_logs (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_dashboard_configs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_dashboard_configs(_input jsonb) RETURNS SETOF public.dashboard_configs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.dashboard_configs;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.dashboard_configs;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','dashboard_configs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.dashboard_configs, _input_sanitized);

  IF _input_sanitized ? 'profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'profile_id');
  END IF;

  IF _input_sanitized ? 'config' THEN
    _insert_columns := array_append(_insert_columns, 'config');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.dashboard_configs DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.dashboard_configs (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_document_references(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_document_references(_input jsonb) RETURNS SETOF public.document_references
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.document_references;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.document_references;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','document_references', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.document_references, _input_sanitized);

  IF _input_sanitized ? 'document_id' THEN
    _insert_columns := array_append(_insert_columns, 'document_id');
  END IF;

  IF _input_sanitized ? 'reference_type' THEN
    _insert_columns := array_append(_insert_columns, 'reference_type');
  END IF;

  IF _input_sanitized ? 'reference_id' THEN
    _insert_columns := array_append(_insert_columns, 'reference_id');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.document_references DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.document_references (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_documents(_input jsonb) RETURNS SETOF public.documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.documents;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.documents;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.documents, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'type' THEN
    _insert_columns := array_append(_insert_columns, 'type');
  END IF;

  IF _input_sanitized ? 'url' THEN
    _insert_columns := array_append(_insert_columns, 'url');
  END IF;

  IF _input_sanitized ? 'uploaded_by' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_by');
  END IF;

  IF _input_sanitized ? 'uploaded_at' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.documents DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.documents (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_drawing_versions(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_drawing_versions(_input jsonb) RETURNS SETOF public.drawing_versions
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.drawing_versions;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.drawing_versions;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','drawing_versions', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.drawing_versions, _input_sanitized);

  IF _input_sanitized ? 'document_id' THEN
    _insert_columns := array_append(_insert_columns, 'document_id');
  END IF;

  IF _input_sanitized ? 'version' THEN
    _insert_columns := array_append(_insert_columns, 'version');
  END IF;

  IF _input_sanitized ? 'uploaded_by' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_by');
  END IF;

  IF _input_sanitized ? 'uploaded_at' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.drawing_versions DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.drawing_versions (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_dump_trucks(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_dump_trucks(_input jsonb) RETURNS SETOF public.dump_trucks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.dump_trucks;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.dump_trucks;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','dump_trucks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.dump_trucks, _input_sanitized);

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'make' THEN
    _insert_columns := array_append(_insert_columns, 'make');
  END IF;

  IF _input_sanitized ? 'model' THEN
    _insert_columns := array_append(_insert_columns, 'model');
  END IF;

  IF _input_sanitized ? 'capacity' THEN
    _insert_columns := array_append(_insert_columns, 'capacity');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.dump_trucks DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.dump_trucks (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_employees(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_employees(_input jsonb) RETURNS SETOF public.employees
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.employees;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.employees;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','employees', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.employees, _input_sanitized);

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'profile_id');
  END IF;

  IF _input_sanitized ? 'hire_date' THEN
    _insert_columns := array_append(_insert_columns, 'hire_date');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.employees DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.employees (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_equipment(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_equipment(_input jsonb) RETURNS SETOF public.equipment
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.equipment;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.equipment, _input_sanitized);

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'type' THEN
    _insert_columns := array_append(_insert_columns, 'type');
  END IF;

  IF _input_sanitized ? 'model' THEN
    _insert_columns := array_append(_insert_columns, 'model');
  END IF;

  IF _input_sanitized ? 'serial_number' THEN
    _insert_columns := array_append(_insert_columns, 'serial_number');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.equipment DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.equipment (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_equipment_assignments(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_equipment_assignments(_input jsonb) RETURNS SETOF public.equipment_assignments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_assignments;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.equipment_assignments;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_assignments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.equipment_assignments, _input_sanitized);

  IF _input_sanitized ? 'equipment_id' THEN
    _insert_columns := array_append(_insert_columns, 'equipment_id');
  END IF;

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'assigned_to' THEN
    _insert_columns := array_append(_insert_columns, 'assigned_to');
  END IF;

  IF _input_sanitized ? 'assigned_date' THEN
    _insert_columns := array_append(_insert_columns, 'assigned_date');
  END IF;

  IF _input_sanitized ? 'released_date' THEN
    _insert_columns := array_append(_insert_columns, 'released_date');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.equipment_assignments DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.equipment_assignments (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_equipment_maintenance(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_equipment_maintenance(_input jsonb) RETURNS SETOF public.equipment_maintenance
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_maintenance;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.equipment_maintenance;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_maintenance', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.equipment_maintenance, _input_sanitized);

  IF _input_sanitized ? 'equipment_id' THEN
    _insert_columns := array_append(_insert_columns, 'equipment_id');
  END IF;

  IF _input_sanitized ? 'maintenance_date' THEN
    _insert_columns := array_append(_insert_columns, 'maintenance_date');
  END IF;

  IF _input_sanitized ? 'type' THEN
    _insert_columns := array_append(_insert_columns, 'type');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'performed_by' THEN
    _insert_columns := array_append(_insert_columns, 'performed_by');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.equipment_maintenance DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.equipment_maintenance (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_equipment_usage(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_equipment_usage(_input jsonb) RETURNS SETOF public.equipment_usage
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.equipment_usage;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.equipment_usage;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','equipment_usage', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.equipment_usage, _input_sanitized);

  IF _input_sanitized ? 'equipment_id' THEN
    _insert_columns := array_append(_insert_columns, 'equipment_id');
  END IF;

  IF _input_sanitized ? 'date' THEN
    _insert_columns := array_append(_insert_columns, 'date');
  END IF;

  IF _input_sanitized ? 'hours_used' THEN
    _insert_columns := array_append(_insert_columns, 'hours_used');
  END IF;

  IF _input_sanitized ? 'quantity' THEN
    _insert_columns := array_append(_insert_columns, 'quantity');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.equipment_usage DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.equipment_usage (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_estimate_line_items(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_estimate_line_items(_input jsonb) RETURNS SETOF public.estimate_line_items
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.estimate_line_items;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.estimate_line_items;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','estimate_line_items', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.estimate_line_items, _input_sanitized);

  IF _input_sanitized ? 'estimate_id' THEN
    _insert_columns := array_append(_insert_columns, 'estimate_id');
  END IF;

  IF _input_sanitized ? 'cost_code_id' THEN
    _insert_columns := array_append(_insert_columns, 'cost_code_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'unit_measure' THEN
    _insert_columns := array_append(_insert_columns, 'unit_measure');
  END IF;

  IF _input_sanitized ? 'quantity' THEN
    _insert_columns := array_append(_insert_columns, 'quantity');
  END IF;

  IF _input_sanitized ? 'unit_price' THEN
    _insert_columns := array_append(_insert_columns, 'unit_price');
  END IF;

  IF _input_sanitized ? 'total_cost' THEN
    _insert_columns := array_append(_insert_columns, 'total_cost');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.estimate_line_items DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.estimate_line_items (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_estimates(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_estimates(_input jsonb) RETURNS SETOF public.estimates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.estimates;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.estimates;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','estimates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.estimates, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'created_by' THEN
    _insert_columns := array_append(_insert_columns, 'created_by');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.estimates DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.estimates (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_financial_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_financial_documents(_input jsonb) RETURNS SETOF public.financial_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.financial_documents;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.financial_documents;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','financial_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.financial_documents, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'document_type' THEN
    _insert_columns := array_append(_insert_columns, 'document_type');
  END IF;

  IF _input_sanitized ? 'url' THEN
    _insert_columns := array_append(_insert_columns, 'url');
  END IF;

  IF _input_sanitized ? 'uploaded_at' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.financial_documents DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.financial_documents (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_general_ledger(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_general_ledger(_input jsonb) RETURNS SETOF public.general_ledger
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.general_ledger;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.general_ledger;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','general_ledger', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.general_ledger, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'entry_date' THEN
    _insert_columns := array_append(_insert_columns, 'entry_date');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'debit' THEN
    _insert_columns := array_append(_insert_columns, 'debit');
  END IF;

  IF _input_sanitized ? 'credit' THEN
    _insert_columns := array_append(_insert_columns, 'credit');
  END IF;

  IF _input_sanitized ? 'balance' THEN
    _insert_columns := array_append(_insert_columns, 'balance');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.general_ledger DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.general_ledger (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_hr_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_hr_documents(_input jsonb) RETURNS SETOF public.hr_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.hr_documents;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.hr_documents;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','hr_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.hr_documents, _input_sanitized);

  IF _input_sanitized ? 'employee_id' THEN
    _insert_columns := array_append(_insert_columns, 'employee_id');
  END IF;

  IF _input_sanitized ? 'document_type' THEN
    _insert_columns := array_append(_insert_columns, 'document_type');
  END IF;

  IF _input_sanitized ? 'url' THEN
    _insert_columns := array_append(_insert_columns, 'url');
  END IF;

  IF _input_sanitized ? 'uploaded_at' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.hr_documents DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.hr_documents (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_inspections(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_inspections(_input jsonb) RETURNS SETOF public.inspections
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.inspections;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.inspections;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','inspections', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.inspections, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'inspection_type' THEN
    _insert_columns := array_append(_insert_columns, 'inspection_type');
  END IF;

  IF _input_sanitized ? 'date' THEN
    _insert_columns := array_append(_insert_columns, 'date');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'result' THEN
    _insert_columns := array_append(_insert_columns, 'result');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.inspections DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.inspections (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_integration_tokens(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_integration_tokens(_input jsonb) RETURNS SETOF public.integration_tokens
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.integration_tokens;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.integration_tokens;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','integration_tokens', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.integration_tokens, _input_sanitized);

  IF _input_sanitized ? 'profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'profile_id');
  END IF;

  IF _input_sanitized ? 'service_name' THEN
    _insert_columns := array_append(_insert_columns, 'service_name');
  END IF;

  IF _input_sanitized ? 'token' THEN
    _insert_columns := array_append(_insert_columns, 'token');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.integration_tokens DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.integration_tokens (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_inventory_transactions(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_inventory_transactions(_input jsonb) RETURNS SETOF public.inventory_transactions
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.inventory_transactions;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.inventory_transactions;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','inventory_transactions', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.inventory_transactions, _input_sanitized);

  IF _input_sanitized ? 'material_id' THEN
    _insert_columns := array_append(_insert_columns, 'material_id');
  END IF;

  IF _input_sanitized ? 'transaction_type' THEN
    _insert_columns := array_append(_insert_columns, 'transaction_type');
  END IF;

  IF _input_sanitized ? 'quantity' THEN
    _insert_columns := array_append(_insert_columns, 'quantity');
  END IF;

  IF _input_sanitized ? 'transaction_date' THEN
    _insert_columns := array_append(_insert_columns, 'transaction_date');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.inventory_transactions DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.inventory_transactions (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_issues(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_issues(_input jsonb) RETURNS SETOF public.issues
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.issues;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.issues;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','issues', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.issues, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'type' THEN
    _insert_columns := array_append(_insert_columns, 'type');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'reported_by' THEN
    _insert_columns := array_append(_insert_columns, 'reported_by');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'resolved' THEN
    _insert_columns := array_append(_insert_columns, 'resolved');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.issues DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.issues (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_job_title_public(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_job_title_public(p_name text) RETURNS public.job_titles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_name text;
  v_existing public.job_titles;
  v_row public.job_titles;
begin
  v_name := nullif(btrim(p_name), '');
  if v_name is null then
    raise exception 'Job title cannot be empty';
  end if;

  select * into v_existing
  from public.job_titles
  where lower(name) = lower(v_name)
    and deleted_at is null
  limit 1;

  if v_existing.id is not null then
    return v_existing;
  end if;

  insert into public.job_titles (name, created_at, updated_at)
  values (v_name, now(), now())
  returning * into v_row;

  return v_row;
end;
$$;


--
-- Name: insert_job_titles(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_job_titles(_input jsonb) RETURNS SETOF public.job_titles
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.job_titles;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.job_titles;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','job_titles', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.job_titles, _input_sanitized);

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.job_titles DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.job_titles (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_labor_records(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_labor_records(_input jsonb) RETURNS SETOF public.labor_records
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.labor_records;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.labor_records;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','labor_records', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.labor_records, _input_sanitized);

  IF _input_sanitized ? 'line_item_id' THEN
    _insert_columns := array_append(_insert_columns, 'line_item_id');
  END IF;

  IF _input_sanitized ? 'worker_count' THEN
    _insert_columns := array_append(_insert_columns, 'worker_count');
  END IF;

  IF _input_sanitized ? 'hours_worked' THEN
    _insert_columns := array_append(_insert_columns, 'hours_worked');
  END IF;

  IF _input_sanitized ? 'work_date' THEN
    _insert_columns := array_append(_insert_columns, 'work_date');
  END IF;

  IF _input_sanitized ? 'work_type' THEN
    _insert_columns := array_append(_insert_columns, 'work_type');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.labor_records DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.labor_records (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_line_item_entries(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_line_item_entries(_input jsonb) RETURNS SETOF public.line_item_entries
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_item_entries;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.line_item_entries;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_item_entries', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.line_item_entries, _input_sanitized);

  IF _input_sanitized ? 'line_item_id' THEN
    _insert_columns := array_append(_insert_columns, 'line_item_id');
  END IF;

  IF _input_sanitized ? 'date' THEN
    _insert_columns := array_append(_insert_columns, 'date');
  END IF;

  IF _input_sanitized ? 'quantity_completed' THEN
    _insert_columns := array_append(_insert_columns, 'quantity_completed');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.line_item_entries DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.line_item_entries (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_line_item_templates(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_line_item_templates(_input jsonb) RETURNS SETOF public.line_item_templates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_item_templates;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.line_item_templates;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_item_templates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.line_item_templates, _input_sanitized);

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'formula' THEN
    _insert_columns := array_append(_insert_columns, 'formula');
  END IF;

  IF _input_sanitized ? 'variables' THEN
    _insert_columns := array_append(_insert_columns, 'variables');
  END IF;

  IF _input_sanitized ? 'created_by' THEN
    _insert_columns := array_append(_insert_columns, 'created_by');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.line_item_templates DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.line_item_templates (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_line_items(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_line_items(_input jsonb) RETURNS SETOF public.line_items
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.line_items;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.line_items;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','line_items', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.line_items, _input_sanitized);

  IF _input_sanitized ? 'map_id' THEN
    _insert_columns := array_append(_insert_columns, 'map_id');
  END IF;

  IF _input_sanitized ? 'wbs_id' THEN
    _insert_columns := array_append(_insert_columns, 'wbs_id');
  END IF;

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'cost_code_id' THEN
    _insert_columns := array_append(_insert_columns, 'cost_code_id');
  END IF;

  IF _input_sanitized ? 'template_id' THEN
    _insert_columns := array_append(_insert_columns, 'template_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'unit_measure' THEN
    _insert_columns := array_append(_insert_columns, 'unit_measure');
  END IF;

  IF _input_sanitized ? 'quantity' THEN
    _insert_columns := array_append(_insert_columns, 'quantity');
  END IF;

  IF _input_sanitized ? 'unit_price' THEN
    _insert_columns := array_append(_insert_columns, 'unit_price');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.line_items DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.line_items (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_maps(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_maps(_input jsonb) RETURNS SETOF public.maps
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.maps;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.maps;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','maps', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.maps, _input_sanitized);

  IF _input_sanitized ? 'wbs_id' THEN
    _insert_columns := array_append(_insert_columns, 'wbs_id');
  END IF;

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'coordinates' THEN
    _insert_columns := array_append(_insert_columns, 'coordinates');
  END IF;

  IF _input_sanitized ? 'scope' THEN
    _insert_columns := array_append(_insert_columns, 'scope');
  END IF;

  IF _input_sanitized ? 'order_num' THEN
    _insert_columns := array_append(_insert_columns, 'order_num');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.maps DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.maps (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_material_inventory(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_material_inventory(_input jsonb) RETURNS SETOF public.material_inventory
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_inventory;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.material_inventory;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_inventory', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.material_inventory, _input_sanitized);

  IF _input_sanitized ? 'material_id' THEN
    _insert_columns := array_append(_insert_columns, 'material_id');
  END IF;

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'quantity' THEN
    _insert_columns := array_append(_insert_columns, 'quantity');
  END IF;

  IF _input_sanitized ? 'last_updated' THEN
    _insert_columns := array_append(_insert_columns, 'last_updated');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.material_inventory DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.material_inventory (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_material_orders(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_material_orders(_input jsonb) RETURNS SETOF public.material_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_orders;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.material_orders;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.material_orders, _input_sanitized);

  IF _input_sanitized ? 'material_id' THEN
    _insert_columns := array_append(_insert_columns, 'material_id');
  END IF;

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'order_date' THEN
    _insert_columns := array_append(_insert_columns, 'order_date');
  END IF;

  IF _input_sanitized ? 'quantity' THEN
    _insert_columns := array_append(_insert_columns, 'quantity');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.material_orders DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.material_orders (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_material_receipts(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_material_receipts(_input jsonb) RETURNS SETOF public.material_receipts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.material_receipts;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.material_receipts;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','material_receipts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.material_receipts, _input_sanitized);

  IF _input_sanitized ? 'material_order_id' THEN
    _insert_columns := array_append(_insert_columns, 'material_order_id');
  END IF;

  IF _input_sanitized ? 'received_date' THEN
    _insert_columns := array_append(_insert_columns, 'received_date');
  END IF;

  IF _input_sanitized ? 'quantity' THEN
    _insert_columns := array_append(_insert_columns, 'quantity');
  END IF;

  IF _input_sanitized ? 'received_by' THEN
    _insert_columns := array_append(_insert_columns, 'received_by');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.material_receipts DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.material_receipts (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_materials(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_materials(_input jsonb) RETURNS SETOF public.materials
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.materials;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.materials;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','materials', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.materials, _input_sanitized);

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'unit' THEN
    _insert_columns := array_append(_insert_columns, 'unit');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.materials DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.materials (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_meeting_minutes(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_meeting_minutes(_input jsonb) RETURNS SETOF public.meeting_minutes
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.meeting_minutes;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.meeting_minutes;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','meeting_minutes', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.meeting_minutes, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'meeting_date' THEN
    _insert_columns := array_append(_insert_columns, 'meeting_date');
  END IF;

  IF _input_sanitized ? 'notes' THEN
    _insert_columns := array_append(_insert_columns, 'notes');
  END IF;

  IF _input_sanitized ? 'created_by' THEN
    _insert_columns := array_append(_insert_columns, 'created_by');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.meeting_minutes DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.meeting_minutes (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_notifications(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_notifications(_input jsonb) RETURNS SETOF public.notifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
declare
  _project_id uuid := (_input->>'project_id')::uuid;
  _organization_id uuid := (_input->>'organization_id')::uuid;
  _new_row public.notifications;
  _row public.notifications;
begin
  perform check_access('insert','notifications', _project_id, _organization_id);

  _input := coalesce(_input, '{}'::jsonb)
            - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _row := jsonb_populate_record(null::public.notifications, _input);

  insert into public.notifications (
    user_id,
    category,
    message,
    payload,
    is_read,
    created_at,
    updated_at,
    deleted_at
  )
  values (
    _row.user_id,
    coalesce(_row.category, 'general'::public.notification_category),
    _row.message,
    coalesce(_row.payload, '{}'::jsonb),
    coalesce(_row.is_read, false),
    coalesce(_row.created_at, now()),
    coalesce(_row.updated_at, now()),
    _row.deleted_at
  )
  returning * into _new_row;

  return next _new_row;

exception
  when others then
    perform public.log_rpc_error(
      'insert_notifications',
      'insert',
      jsonb_build_object(
        'input', _input,
        'project_id', _project_id,
        'organization_id', _organization_id
      )
    );
    raise;
end;
$$;


--
-- Name: insert_organization_invites(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_invites(_input jsonb) RETURNS SETOF public.organization_invites
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $_$
DECLARE
  v_id uuid := COALESCE(NULLIF(_input->>'id', '')::uuid, gen_random_uuid());
  v_organization_id uuid := NULLIF(_input->>'organization_id', '')::uuid;
  v_invited_profile_id uuid := NULLIF(_input->>'invited_profile_id', '')::uuid;
  v_invited_by_profile_id uuid := NULLIF(_input->>'invited_by_profile_id', '')::uuid;
  v_status text := COALESCE(NULLIF(_input->>'status', ''), 'pending');
  v_comment text := NULLIF(_input->>'comment', '');
  v_created_at timestamptz := COALESCE(NULLIF(_input->>'created_at', '')::timestamptz, now());
  v_responded_at timestamptz := NULLIF(_input->>'responded_at', '')::timestamptz;
  v_requested_permission_role public.org_role := NULLIF(_input->>'requested_permission_role', '')::public.org_role;
  v_requested_job_title_id uuid := NULLIF(_input->>'requested_job_title_id', '')::uuid;
  v_legacy_role_text text := NULLIF(TRIM(_input->>'role'), '');
  v_legacy_role_uuid uuid := NULL;
  _new_row public.organization_invites;
  _admin record;
BEGIN
  IF v_legacy_role_text IS NOT NULL THEN
    IF v_requested_permission_role IS NULL
       AND v_legacy_role_text IN ('admin','manager','superintendent','foreman','worker','viewer','accountant','hr','estimator','guest','owner') THEN
      v_requested_permission_role := v_legacy_role_text::public.org_role;
    END IF;

    IF v_requested_job_title_id IS NULL
       AND v_legacy_role_text ~* '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$' THEN
      v_requested_job_title_id := v_legacy_role_text::uuid;
    END IF;
  END IF;

  v_legacy_role_uuid := v_requested_job_title_id;

  PERFORM check_access('insert','organization_invites', NULL, v_organization_id);

  INSERT INTO public.organization_invites (
    id, organization_id, invited_profile_id, invited_by_profile_id, status, comment,
    created_at, responded_at, requested_permission_role, requested_job_title_id, role,
    reviewed_permission_role, reviewed_job_title_id
  )
  VALUES (
    v_id, v_organization_id, v_invited_profile_id, v_invited_by_profile_id, 'pending', v_comment,
    v_created_at, NULL, v_requested_permission_role, v_requested_job_title_id, v_legacy_role_uuid,
    NULL, NULL
  )
  ON CONFLICT (organization_id, invited_profile_id) DO UPDATE
  SET
    invited_by_profile_id = EXCLUDED.invited_by_profile_id,
    status = 'pending',
    comment = EXCLUDED.comment,
    created_at = now(),
    responded_at = NULL,
    requested_permission_role = COALESCE(EXCLUDED.requested_permission_role, public.organization_invites.requested_permission_role),
    requested_job_title_id = COALESCE(EXCLUDED.requested_job_title_id, public.organization_invites.requested_job_title_id),
    role = COALESCE(EXCLUDED.role, public.organization_invites.role),
    reviewed_permission_role = NULL,
    reviewed_job_title_id = NULL
  RETURNING * INTO _new_row;

  FOR _admin IN
    SELECT om.profile_id
    FROM public.organization_members om
    JOIN public.profiles p ON p.id = om.profile_id
    WHERE om.organization_id = _new_row.organization_id
      AND om.deleted_at IS NULL
      AND p.deleted_at IS NULL
      AND om.permission_role IN ('admin', 'hr', 'owner')
  LOOP
    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', _admin.profile_id,
        'organization_id', _new_row.organization_id,
        'category', 'general',
        'message', 'Membership request submitted',
        'payload', jsonb_build_object(
          'invite_id', _new_row.id,
          'organization_id', _new_row.organization_id,
          'invited_profile_id', _new_row.invited_profile_id,
          'requested_permission_role', _new_row.requested_permission_role,
          'requested_job_title_id', _new_row.requested_job_title_id
        )
      )
    );
  END LOOP;

  RETURN NEXT _new_row;
END;
$_$;


--
-- Name: insert_organization_member_rates(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_member_rates(_input jsonb) RETURNS SETOF public.organization_member_rates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _membership_id   uuid := (_input->>'membership_id')::uuid;
      _new_row         public.organization_member_rates;
      _input_sanitized jsonb := '{}'::jsonb;
      _insert_columns text[] := ARRAY[]::text[];
      _insert_column_list text;
      _insert_value_list text;
      _r public.organization_member_rates;

    BEGIN
      IF _organization_id IS NULL AND _membership_id IS NOT NULL THEN
        SELECT organization_id INTO _organization_id
          FROM public.organization_members
         WHERE id = _membership_id;
      END IF;

      PERFORM check_access('insert','organization_member_rates', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at' - 'updated_at';

        _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.organization_member_rates, _input_sanitized);

  IF _input_sanitized ? 'membership_id' THEN
    _insert_columns := array_append(_insert_columns, 'membership_id');
  END IF;

  IF _input_sanitized ? 'rate_type' THEN
    _insert_columns := array_append(_insert_columns, 'rate_type');
  END IF;

  IF _input_sanitized ? 'rate_amount' THEN
    _insert_columns := array_append(_insert_columns, 'rate_amount');
  END IF;

  IF _input_sanitized ? 'effective_start' THEN
    _insert_columns := array_append(_insert_columns, 'effective_start');
  END IF;

  IF _input_sanitized ? 'effective_end' THEN
    _insert_columns := array_append(_insert_columns, 'effective_end');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.organization_member_rates DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.organization_member_rates (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

      RETURN NEXT _new_row;
    END;
    $_$;


--
-- Name: insert_organization_members(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_members(_input jsonb) RETURNS SETOF public.organization_members
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organization_members;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.organization_members;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organization_members', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.organization_members, _input_sanitized);

  IF _input_sanitized ? 'profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'profile_id');
  END IF;

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'job_title_id' THEN
    _insert_columns := array_append(_insert_columns, 'job_title_id');
  END IF;

  IF _input_sanitized ? 'permission_role' THEN
    _insert_columns := array_append(_insert_columns, 'permission_role');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.organization_members DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.organization_members (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_organization_notification_settings(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_notification_settings(_input jsonb) RETURNS SETOF public.organization_notification_settings
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_org_id uuid := NULLIF(_input->>'organization_id','')::uuid;
  v_categories public.notification_category[] := COALESCE(
    ARRAY(
      SELECT value::public.notification_category
      FROM jsonb_array_elements_text(COALESCE(_input->'enabled_categories', '[]'::jsonb))
    ),
    '{}'::public.notification_category[]
  );
  v_events text[] := COALESCE(
    ARRAY(
      SELECT value
      FROM jsonb_array_elements_text(COALESCE(_input->'enabled_events', '[]'::jsonb))
    ),
    '{}'::text[]
  );
  v_row public.organization_notification_settings;
BEGIN
  IF v_org_id IS NULL THEN
    RAISE EXCEPTION 'organization_id is required';
  END IF;

  IF NOT public.can_edit_org_notification_settings(v_org_id) THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  INSERT INTO public.organization_notification_settings (
    organization_id, enabled_categories, enabled_events, updated_by, updated_at
  )
  VALUES (
    v_org_id, v_categories, v_events, auth.uid(), now()
  )
  ON CONFLICT (organization_id) DO UPDATE
  SET
    enabled_categories = EXCLUDED.enabled_categories,
    enabled_events = EXCLUDED.enabled_events,
    updated_by = auth.uid(),
    updated_at = now()
  RETURNING * INTO v_row;

  RETURN NEXT v_row;
END;
$$;


--
-- Name: insert_organization_projects(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_projects(_input jsonb) RETURNS SETOF public.organization_projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organization_projects;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.organization_projects;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organization_projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.organization_projects, _input_sanitized);

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.organization_projects DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.organization_projects (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_organization_service_areas(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organization_service_areas(_input jsonb) RETURNS SETOF public.organization_service_areas
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _new_row         public.organization_service_areas;
      _input_sanitized jsonb := '{}'::jsonb;
      _insert_columns text[] := ARRAY[]::text[];
      _insert_column_list text;
      _insert_value_list text;
      _r public.organization_service_areas;

    BEGIN
      PERFORM check_access('insert','organization_service_areas', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at' - 'updated_at';

        _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.organization_service_areas, _input_sanitized);

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'service_area_text' THEN
    _insert_columns := array_append(_insert_columns, 'service_area_text');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.organization_service_areas DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.organization_service_areas (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

      RETURN NEXT _new_row;
    END;
    $_$;


--
-- Name: insert_organizations(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_organizations(_input jsonb) RETURNS SETOF public.organizations
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.organizations;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.organizations;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','organizations', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.organizations, _input_sanitized);

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'mission_statement' THEN
    _insert_columns := array_append(_insert_columns, 'mission_statement');
  END IF;

  IF _input_sanitized ? 'headquarters' THEN
    _insert_columns := array_append(_insert_columns, 'headquarters');
  END IF;

  IF _input_sanitized ? 'logo_url' THEN
    _insert_columns := array_append(_insert_columns, 'logo_url');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.organizations DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.organizations (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_payments(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_payments(_input jsonb) RETURNS SETOF public.payments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.payments;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.payments;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','payments', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.payments, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'commitment_id' THEN
    _insert_columns := array_append(_insert_columns, 'commitment_id');
  END IF;

  IF _input_sanitized ? 'amount' THEN
    _insert_columns := array_append(_insert_columns, 'amount');
  END IF;

  IF _input_sanitized ? 'paid_at' THEN
    _insert_columns := array_append(_insert_columns, 'paid_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.payments DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.payments (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_payroll(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_payroll(_input jsonb) RETURNS SETOF public.payroll
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.payroll;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.payroll;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','payroll', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.payroll, _input_sanitized);

  IF _input_sanitized ? 'employee_id' THEN
    _insert_columns := array_append(_insert_columns, 'employee_id');
  END IF;

  IF _input_sanitized ? 'pay_period_start' THEN
    _insert_columns := array_append(_insert_columns, 'pay_period_start');
  END IF;

  IF _input_sanitized ? 'pay_period_end' THEN
    _insert_columns := array_append(_insert_columns, 'pay_period_end');
  END IF;

  IF _input_sanitized ? 'gross_pay' THEN
    _insert_columns := array_append(_insert_columns, 'gross_pay');
  END IF;

  IF _input_sanitized ? 'net_pay' THEN
    _insert_columns := array_append(_insert_columns, 'net_pay');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.payroll DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.payroll (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_photos(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_photos(_input jsonb) RETURNS SETOF public.photos
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.photos;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.photos;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','photos', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.photos, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'url' THEN
    _insert_columns := array_append(_insert_columns, 'url');
  END IF;

  IF _input_sanitized ? 'caption' THEN
    _insert_columns := array_append(_insert_columns, 'caption');
  END IF;

  IF _input_sanitized ? 'uploaded_by' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_by');
  END IF;

  IF _input_sanitized ? 'uploaded_at' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.photos DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.photos (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_prequalifications(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_prequalifications(_input jsonb) RETURNS SETOF public.prequalifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.prequalifications;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.prequalifications;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','prequalifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.prequalifications, _input_sanitized);

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'reviewed_by' THEN
    _insert_columns := array_append(_insert_columns, 'reviewed_by');
  END IF;

  IF _input_sanitized ? 'reviewed_at' THEN
    _insert_columns := array_append(_insert_columns, 'reviewed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.prequalifications DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.prequalifications (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_procurement_workflows(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_procurement_workflows(_input jsonb) RETURNS SETOF public.procurement_workflows
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.procurement_workflows;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.procurement_workflows;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','procurement_workflows', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.procurement_workflows, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.procurement_workflows DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.procurement_workflows (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_profiles(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_profiles(_input jsonb) RETURNS SETOF public.profiles
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.profiles;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.profiles;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','profiles', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.profiles, _input_sanitized);

  IF _input_sanitized ? 'email' THEN
    _insert_columns := array_append(_insert_columns, 'email');
  END IF;

  IF _input_sanitized ? 'full_name' THEN
    _insert_columns := array_append(_insert_columns, 'full_name');
  END IF;

  IF _input_sanitized ? 'phone' THEN
    _insert_columns := array_append(_insert_columns, 'phone');
  END IF;

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'role' THEN
    _insert_columns := array_append(_insert_columns, 'role');
  END IF;

  IF _input_sanitized ? 'profile_completed_at' THEN
    _insert_columns := array_append(_insert_columns, 'profile_completed_at');
  END IF;

  IF _input_sanitized ? 'avatar_id' THEN
    _insert_columns := array_append(_insert_columns, 'avatar_id');
  END IF;

  IF _input_sanitized ? 'location' THEN
    _insert_columns := array_append(_insert_columns, 'location');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.profiles DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.profiles (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_progress_billings(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_progress_billings(_input jsonb) RETURNS SETOF public.progress_billings
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.progress_billings;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.progress_billings;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','progress_billings', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.progress_billings, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'billing_number' THEN
    _insert_columns := array_append(_insert_columns, 'billing_number');
  END IF;

  IF _input_sanitized ? 'amount' THEN
    _insert_columns := array_append(_insert_columns, 'amount');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.progress_billings DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.progress_billings (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_project_inspectors(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_project_inspectors(_input jsonb) RETURNS SETOF public.project_inspectors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.project_inspectors;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.project_inspectors;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','project_inspectors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.project_inspectors, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'profile_id');
  END IF;

  IF _input_sanitized ? 'assigned_by' THEN
    _insert_columns := array_append(_insert_columns, 'assigned_by');
  END IF;

  IF _input_sanitized ? 'assigned_at' THEN
    _insert_columns := array_append(_insert_columns, 'assigned_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.project_inspectors DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.project_inspectors (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_project_invites(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_project_invites(_input jsonb) RETURNS SETOF public.project_invites
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _new_row         public.project_invites;
      _input_sanitized jsonb := '{}'::jsonb;
      _insert_columns text[] := ARRAY[]::text[];
      _insert_column_list text;
      _insert_value_list text;
      _r public.project_invites;

    BEGIN
      PERFORM check_access('insert','project_invites', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at';

        _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.project_invites, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'invited_profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'invited_profile_id');
  END IF;

  IF _input_sanitized ? 'invited_by_profile_id' THEN
    _insert_columns := array_append(_insert_columns, 'invited_by_profile_id');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'comment' THEN
    _insert_columns := array_append(_insert_columns, 'comment');
  END IF;

  IF _input_sanitized ? 'responded_at' THEN
    _insert_columns := array_append(_insert_columns, 'responded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.project_invites DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.project_invites (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

      RETURN NEXT _new_row;
    END;
    $_$;


--
-- Name: insert_project_service_areas(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_project_service_areas(_input jsonb) RETURNS SETOF public.project_service_areas
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
    DECLARE
      _project_id      uuid := (_input->>'project_id')::uuid;
      _organization_id uuid := (_input->>'organization_id')::uuid;
      _new_row         public.project_service_areas;
      _input_sanitized jsonb := '{}'::jsonb;
      _insert_columns text[] := ARRAY[]::text[];
      _insert_column_list text;
      _insert_value_list text;
      _r public.project_service_areas;

    BEGIN
      PERFORM check_access('insert','project_service_areas', _project_id, _organization_id);

      _input := COALESCE(_input, '{}'::jsonb)
                - 'id' - 'created_at' - 'updated_at';

        _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.project_service_areas, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'service_area_id' THEN
    _insert_columns := array_append(_insert_columns, 'service_area_id');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.project_service_areas DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.project_service_areas (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

      RETURN NEXT _new_row;
    END;
    $_$;


--
-- Name: insert_projects(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_projects(_input jsonb) RETURNS SETOF public.projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.projects;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.projects;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.projects, _input_sanitized);

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'start_date' THEN
    _insert_columns := array_append(_insert_columns, 'start_date');
  END IF;

  IF _input_sanitized ? 'end_date' THEN
    _insert_columns := array_append(_insert_columns, 'end_date');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.projects DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.projects (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_punch_lists(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_punch_lists(_input jsonb) RETURNS SETOF public.punch_lists
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.punch_lists;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.punch_lists;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','punch_lists', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.punch_lists, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'item' THEN
    _insert_columns := array_append(_insert_columns, 'item');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'assigned_to' THEN
    _insert_columns := array_append(_insert_columns, 'assigned_to');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.punch_lists DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.punch_lists (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_purchase_orders(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_purchase_orders(_input jsonb) RETURNS SETOF public.purchase_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.purchase_orders;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.purchase_orders;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','purchase_orders', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.purchase_orders, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'order_number' THEN
    _insert_columns := array_append(_insert_columns, 'order_number');
  END IF;

  IF _input_sanitized ? 'order_date' THEN
    _insert_columns := array_append(_insert_columns, 'order_date');
  END IF;

  IF _input_sanitized ? 'amount' THEN
    _insert_columns := array_append(_insert_columns, 'amount');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.purchase_orders DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.purchase_orders (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_quality_reviews(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_quality_reviews(_input jsonb) RETURNS SETOF public.quality_reviews
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.quality_reviews;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.quality_reviews;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','quality_reviews', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.quality_reviews, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'review_date' THEN
    _insert_columns := array_append(_insert_columns, 'review_date');
  END IF;

  IF _input_sanitized ? 'reviewer' THEN
    _insert_columns := array_append(_insert_columns, 'reviewer');
  END IF;

  IF _input_sanitized ? 'findings' THEN
    _insert_columns := array_append(_insert_columns, 'findings');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.quality_reviews DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.quality_reviews (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_regulatory_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_regulatory_documents(_input jsonb) RETURNS SETOF public.regulatory_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.regulatory_documents;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.regulatory_documents;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','regulatory_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.regulatory_documents, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'document_type' THEN
    _insert_columns := array_append(_insert_columns, 'document_type');
  END IF;

  IF _input_sanitized ? 'url' THEN
    _insert_columns := array_append(_insert_columns, 'url');
  END IF;

  IF _input_sanitized ? 'uploaded_at' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.regulatory_documents DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.regulatory_documents (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_reports(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_reports(_input jsonb) RETURNS SETOF public.reports
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.reports;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.reports;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','reports', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.reports, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'report_type' THEN
    _insert_columns := array_append(_insert_columns, 'report_type');
  END IF;

  IF _input_sanitized ? 'generated_at' THEN
    _insert_columns := array_append(_insert_columns, 'generated_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.reports DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.reports (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_rfis(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_rfis(_input jsonb) RETURNS SETOF public.rfis
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.rfis;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.rfis;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','rfis', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.rfis, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'subject' THEN
    _insert_columns := array_append(_insert_columns, 'subject');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'question' THEN
    _insert_columns := array_append(_insert_columns, 'question');
  END IF;

  IF _input_sanitized ? 'answer' THEN
    _insert_columns := array_append(_insert_columns, 'answer');
  END IF;

  IF _input_sanitized ? 'submitted_by' THEN
    _insert_columns := array_append(_insert_columns, 'submitted_by');
  END IF;

  IF _input_sanitized ? 'reviewed_by' THEN
    _insert_columns := array_append(_insert_columns, 'reviewed_by');
  END IF;

  IF _input_sanitized ? 'submitted_at' THEN
    _insert_columns := array_append(_insert_columns, 'submitted_at');
  END IF;

  IF _input_sanitized ? 'reviewed_at' THEN
    _insert_columns := array_append(_insert_columns, 'reviewed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.rfis DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.rfis (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_safety_incidents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_safety_incidents(_input jsonb) RETURNS SETOF public.safety_incidents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.safety_incidents;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.safety_incidents;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','safety_incidents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.safety_incidents, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'incident_date' THEN
    _insert_columns := array_append(_insert_columns, 'incident_date');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'reported_by' THEN
    _insert_columns := array_append(_insert_columns, 'reported_by');
  END IF;

  IF _input_sanitized ? 'severity' THEN
    _insert_columns := array_append(_insert_columns, 'severity');
  END IF;

  IF _input_sanitized ? 'resolved' THEN
    _insert_columns := array_append(_insert_columns, 'resolved');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.safety_incidents DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.safety_incidents (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_sensor_data(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_sensor_data(_input jsonb) RETURNS SETOF public.sensor_data
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.sensor_data;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.sensor_data;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','sensor_data', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.sensor_data, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'data' THEN
    _insert_columns := array_append(_insert_columns, 'data');
  END IF;

  IF _input_sanitized ? 'collected_at' THEN
    _insert_columns := array_append(_insert_columns, 'collected_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.sensor_data DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.sensor_data (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_subcontractor_agreements(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_subcontractor_agreements(_input jsonb) RETURNS SETOF public.subcontractor_agreements
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.subcontractor_agreements;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.subcontractor_agreements;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','subcontractor_agreements', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.subcontractor_agreements, _input_sanitized);

  IF _input_sanitized ? 'subcontract_id' THEN
    _insert_columns := array_append(_insert_columns, 'subcontract_id');
  END IF;

  IF _input_sanitized ? 'agreement_url' THEN
    _insert_columns := array_append(_insert_columns, 'agreement_url');
  END IF;

  IF _input_sanitized ? 'signed_at' THEN
    _insert_columns := array_append(_insert_columns, 'signed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.subcontractor_agreements DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.subcontractor_agreements (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_subcontracts(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_subcontracts(_input jsonb) RETURNS SETOF public.subcontracts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.subcontracts;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.subcontracts;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','subcontracts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.subcontracts, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'amount' THEN
    _insert_columns := array_append(_insert_columns, 'amount');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'signed_at' THEN
    _insert_columns := array_append(_insert_columns, 'signed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.subcontracts DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.subcontracts (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_submittals(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_submittals(_input jsonb) RETURNS SETOF public.submittals
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.submittals;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.submittals;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','submittals', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.submittals, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'submitted_by' THEN
    _insert_columns := array_append(_insert_columns, 'submitted_by');
  END IF;

  IF _input_sanitized ? 'reviewed_by' THEN
    _insert_columns := array_append(_insert_columns, 'reviewed_by');
  END IF;

  IF _input_sanitized ? 'submitted_at' THEN
    _insert_columns := array_append(_insert_columns, 'submitted_at');
  END IF;

  IF _input_sanitized ? 'reviewed_at' THEN
    _insert_columns := array_append(_insert_columns, 'reviewed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.submittals DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.submittals (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_tack_rates(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_tack_rates(_input jsonb) RETURNS SETOF public.tack_rates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.tack_rates;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.tack_rates;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','tack_rates', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.tack_rates, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'rate' THEN
    _insert_columns := array_append(_insert_columns, 'rate');
  END IF;

  IF _input_sanitized ? 'material_type' THEN
    _insert_columns := array_append(_insert_columns, 'material_type');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.tack_rates DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.tack_rates (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_task_dependencies(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_task_dependencies(_input jsonb) RETURNS SETOF public.task_dependencies
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.task_dependencies;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.task_dependencies;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','task_dependencies', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.task_dependencies, _input_sanitized);

  IF _input_sanitized ? 'task_id' THEN
    _insert_columns := array_append(_insert_columns, 'task_id');
  END IF;

  IF _input_sanitized ? 'depends_on_task_id' THEN
    _insert_columns := array_append(_insert_columns, 'depends_on_task_id');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.task_dependencies DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.task_dependencies (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_task_status_logs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_task_status_logs(_input jsonb) RETURNS SETOF public.task_status_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.task_status_logs;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.task_status_logs;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','task_status_logs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.task_status_logs, _input_sanitized);

  IF _input_sanitized ? 'task_id' THEN
    _insert_columns := array_append(_insert_columns, 'task_id');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'changed_at' THEN
    _insert_columns := array_append(_insert_columns, 'changed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.task_status_logs DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.task_status_logs (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_tasks(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_tasks(_input jsonb) RETURNS SETOF public.tasks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.tasks;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.tasks;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','tasks', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.tasks, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'description' THEN
    _insert_columns := array_append(_insert_columns, 'description');
  END IF;

  IF _input_sanitized ? 'start_date' THEN
    _insert_columns := array_append(_insert_columns, 'start_date');
  END IF;

  IF _input_sanitized ? 'end_date' THEN
    _insert_columns := array_append(_insert_columns, 'end_date');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.tasks DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.tasks (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_training_records(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_training_records(_input jsonb) RETURNS SETOF public.training_records
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.training_records;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.training_records;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','training_records', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.training_records, _input_sanitized);

  IF _input_sanitized ? 'employee_id' THEN
    _insert_columns := array_append(_insert_columns, 'employee_id');
  END IF;

  IF _input_sanitized ? 'training_type' THEN
    _insert_columns := array_append(_insert_columns, 'training_type');
  END IF;

  IF _input_sanitized ? 'completion_date' THEN
    _insert_columns := array_append(_insert_columns, 'completion_date');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.training_records DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.training_records (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_user_notification_settings(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_user_notification_settings(_input jsonb) RETURNS SETOF public.user_notification_settings
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_categories public.notification_category[] := COALESCE(
    ARRAY(
      SELECT value::public.notification_category
      FROM jsonb_array_elements_text(COALESCE(_input->'silenced_categories', '[]'::jsonb))
    ),
    '{}'::public.notification_category[]
  );
  v_events text[] := COALESCE(
    ARRAY(
      SELECT value
      FROM jsonb_array_elements_text(COALESCE(_input->'silenced_events', '[]'::jsonb))
    ),
    '{}'::text[]
  );
  v_row public.user_notification_settings;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated' USING errcode = '42501';
  END IF;

  INSERT INTO public.user_notification_settings (
    user_id, silenced_categories, silenced_events, updated_at
  )
  VALUES (
    v_user_id, v_categories, v_events, now()
  )
  ON CONFLICT (user_id) DO UPDATE
  SET
    silenced_categories = EXCLUDED.silenced_categories,
    silenced_events = EXCLUDED.silenced_events,
    updated_at = now()
  RETURNING * INTO v_row;

  RETURN NEXT v_row;
END;
$$;


--
-- Name: insert_user_projects(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_user_projects(_input jsonb) RETURNS SETOF public.user_projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.user_projects;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.user_projects;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','user_projects', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.user_projects, _input_sanitized);

  IF _input_sanitized ? 'user_id' THEN
    _insert_columns := array_append(_insert_columns, 'user_id');
  END IF;

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'role' THEN
    _insert_columns := array_append(_insert_columns, 'role');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.user_projects DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.user_projects (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_vendor_bid_packages(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendor_bid_packages(_input jsonb) RETURNS SETOF public.vendor_bid_packages
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_bid_packages;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.vendor_bid_packages;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_bid_packages', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.vendor_bid_packages, _input_sanitized);

  IF _input_sanitized ? 'bid_package_id' THEN
    _insert_columns := array_append(_insert_columns, 'bid_package_id');
  END IF;

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.vendor_bid_packages DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.vendor_bid_packages (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_vendor_contacts(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendor_contacts(_input jsonb) RETURNS SETOF public.vendor_contacts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_contacts;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.vendor_contacts;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_contacts', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.vendor_contacts, _input_sanitized);

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'email' THEN
    _insert_columns := array_append(_insert_columns, 'email');
  END IF;

  IF _input_sanitized ? 'phone' THEN
    _insert_columns := array_append(_insert_columns, 'phone');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.vendor_contacts DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.vendor_contacts (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_vendor_documents(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendor_documents(_input jsonb) RETURNS SETOF public.vendor_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_documents;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.vendor_documents;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_documents', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.vendor_documents, _input_sanitized);

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'document_type' THEN
    _insert_columns := array_append(_insert_columns, 'document_type');
  END IF;

  IF _input_sanitized ? 'url' THEN
    _insert_columns := array_append(_insert_columns, 'url');
  END IF;

  IF _input_sanitized ? 'uploaded_at' THEN
    _insert_columns := array_append(_insert_columns, 'uploaded_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.vendor_documents DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.vendor_documents (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_vendor_qualifications(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendor_qualifications(_input jsonb) RETURNS SETOF public.vendor_qualifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendor_qualifications;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.vendor_qualifications;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendor_qualifications', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.vendor_qualifications, _input_sanitized);

  IF _input_sanitized ? 'vendor_id' THEN
    _insert_columns := array_append(_insert_columns, 'vendor_id');
  END IF;

  IF _input_sanitized ? 'qualification_type' THEN
    _insert_columns := array_append(_insert_columns, 'qualification_type');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'reviewed_at' THEN
    _insert_columns := array_append(_insert_columns, 'reviewed_at');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.vendor_qualifications DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.vendor_qualifications (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_vendors(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_vendors(_input jsonb) RETURNS SETOF public.vendors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.vendors;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.vendors;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','vendors', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.vendors, _input_sanitized);

  IF _input_sanitized ? 'organization_id' THEN
    _insert_columns := array_append(_insert_columns, 'organization_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'status' THEN
    _insert_columns := array_append(_insert_columns, 'status');
  END IF;

  IF _input_sanitized ? 'contact_email' THEN
    _insert_columns := array_append(_insert_columns, 'contact_email');
  END IF;

  IF _input_sanitized ? 'contact_phone' THEN
    _insert_columns := array_append(_insert_columns, 'contact_phone');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.vendors DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.vendors (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_wbs(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_wbs(_input jsonb) RETURNS SETOF public.wbs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.wbs;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.wbs;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','wbs', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.wbs, _input_sanitized);

  IF _input_sanitized ? 'project_id' THEN
    _insert_columns := array_append(_insert_columns, 'project_id');
  END IF;

  IF _input_sanitized ? 'name' THEN
    _insert_columns := array_append(_insert_columns, 'name');
  END IF;

  IF _input_sanitized ? 'location' THEN
    _insert_columns := array_append(_insert_columns, 'location');
  END IF;

  IF _input_sanitized ? 'order_num' THEN
    _insert_columns := array_append(_insert_columns, 'order_num');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.wbs DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.wbs (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: insert_workflows(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.insert_workflows(_input jsonb) RETURNS SETOF public.workflows
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $_$
      DECLARE
        _project_id      uuid := (_input->>'project_id')::uuid;
        _organization_id uuid := (_input->>'organization_id')::uuid;
        _new_row         public.workflows;

        _input_sanitized jsonb := '{}'::jsonb;

        _insert_columns text[] := ARRAY[]::text[];

        _insert_column_list text;

        _insert_value_list text;

        _r public.workflows;

      BEGIN
        -- Authorization gate (RLS still applies)
        PERFORM check_access('insert','workflows', _project_id, _organization_id);

        -- Tweak #1: strip DB-owned/reserved fields so clients can't spoof them
        _input := COALESCE(_input, '{}'::jsonb)
                  - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

          _input_sanitized := COALESCE(_input, '{}'::jsonb) - 'id' - 'created_at' - 'updated_at' - 'deleted_at';

  _r := jsonb_populate_record(NULL::public.workflows, _input_sanitized);

  IF _input_sanitized ? 'entity_schema' THEN
    _insert_columns := array_append(_insert_columns, 'entity_schema');
  END IF;

  IF _input_sanitized ? 'entity_table' THEN
    _insert_columns := array_append(_insert_columns, 'entity_table');
  END IF;

  IF _input_sanitized ? 'entity_id' THEN
    _insert_columns := array_append(_insert_columns, 'entity_id');
  END IF;

  IF _input_sanitized ? 'workflow_name' THEN
    _insert_columns := array_append(_insert_columns, 'workflow_name');
  END IF;

  IF _input_sanitized ? 'current_state' THEN
    _insert_columns := array_append(_insert_columns, 'current_state');
  END IF;

  IF COALESCE(array_length(_insert_columns, 1), 0) = 0 THEN
    INSERT INTO public.workflows DEFAULT VALUES
    RETURNING * INTO _new_row;
  ELSE
    SELECT string_agg(format('%I', c), ', ')
    INTO _insert_column_list
    FROM unnest(_insert_columns) AS c;

    SELECT string_agg(format('($1).%I', c), ', ')
    INTO _insert_value_list
    FROM unnest(_insert_columns) AS c;

    EXECUTE format(
      'INSERT INTO public.workflows (%s) VALUES (%s) RETURNING *',
      _insert_column_list,
      _insert_value_list
    )
    USING _r
    INTO _new_row;
  END IF;

        RETURN NEXT _new_row;
      END;
      $_$;


--
-- Name: log_rpc_error(text, text, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_rpc_error(p_rpc_name text, p_operation text DEFAULT NULL::text, p_request_context jsonb DEFAULT '{}'::jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_sqlstate text;
  v_message text;
  v_detail text;
  v_hint text;
BEGIN
  GET STACKED DIAGNOSTICS
    v_sqlstate = RETURNED_SQLSTATE,
    v_message = MESSAGE_TEXT,
    v_detail = PG_EXCEPTION_DETAIL,
    v_hint = PG_EXCEPTION_HINT;

  INSERT INTO public.rpc_error_debug (
    rpc_name,
    operation,
    sqlstate,
    error_message,
    error_detail,
    error_hint,
    auth_user_id,
    request_context
  ) VALUES (
    COALESCE(p_rpc_name, 'unknown_rpc'),
    p_operation,
    v_sqlstate,
    COALESCE(v_message, 'unknown error'),
    v_detail,
    v_hint,
    auth.uid(),
    COALESCE(p_request_context, '{}'::jsonb)
  );
EXCEPTION
  WHEN OTHERS THEN
    -- logger must never break caller flow
    RETURN;
END;
$$;


--
-- Name: notifications_broadcast_trigger(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notifications_broadcast_trigger() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
BEGIN
  PERFORM realtime.broadcast_changes(
    'user:notifications:' || NEW.user_id::text,
    TG_OP,
    TG_OP,
    TG_TABLE_NAME,
    TG_TABLE_SCHEMA,
    NEW,
    NULL
  );
  RETURN NEW;
END;
$$;


--
-- Name: notifications_enforce_delivery_policy(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notifications_enforce_delivery_policy() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_payload jsonb := COALESCE(NEW.payload, '{}'::jsonb);
  v_event text := NULLIF(v_payload->>'event', '');
  v_scope text := NULLIF(v_payload->>'scope', '');
  v_org_id uuid := public.try_parse_uuid(v_payload->>'organization_id');
  v_affected_profile_id uuid := public.try_parse_uuid(v_payload->>'affected_profile_id');
  v_enabled_categories public.notification_category[];
  v_enabled_events text[];
BEGIN
  -- Infer scope if not explicitly provided.
  -- Personal-by-default; org-wide for known org events when row is not target-user specific.
  IF v_scope IS NULL THEN
    IF v_event IN (
      'member_added',
      'member_removed',
      'member_left_organization',
      'contract_completed',
      'bid_accepted',
      'new_project_created',
      'member_job_title_changed',
      'member_job_title_changed_broadcast',
      'member_permission_role_changed'
    )
    AND (v_affected_profile_id IS NULL OR v_affected_profile_id <> NEW.user_id) THEN
      v_scope := 'org_wide';
    ELSE
      v_scope := 'personal';
    END IF;
  END IF;

  IF v_scope NOT IN ('personal', 'org_wide') THEN
    v_scope := 'personal';
  END IF;

  -- Org-wide policy enforcement: skip inserts disallowed by org settings.
  IF v_scope = 'org_wide' THEN
    IF v_org_id IS NULL THEN
      RETURN NULL;
    END IF;

    SELECT
      ons.enabled_categories,
      ons.enabled_events
    INTO
      v_enabled_categories,
      v_enabled_events
    FROM public.organization_notification_settings ons
    WHERE ons.organization_id = v_org_id;

    IF v_enabled_categories IS NULL THEN
      v_enabled_categories := ARRAY[
        'workflow_update'::public.notification_category,
        'approval_needed'::public.notification_category,
        'bid_received'::public.notification_category
      ];
    END IF;

    IF v_enabled_events IS NULL THEN
      v_enabled_events := ARRAY[
        'member_added',
        'member_removed',
        'member_left_organization',
        'contract_completed',
        'bid_accepted',
        'new_project_created',
        'member_job_title_changed',
        'member_job_title_changed_broadcast',
        'member_permission_role_changed'
      ]::text[];
    END IF;

    IF NOT (NEW.category = ANY (v_enabled_categories)) THEN
      RETURN NULL;
    END IF;

    IF v_event IS NOT NULL AND NOT (v_event = ANY (v_enabled_events)) THEN
      RETURN NULL;
    END IF;
  END IF;

  -- User-level silencing enforcement: skip delivery to users who muted category/event.
  IF EXISTS (
    SELECT 1
    FROM public.user_notification_settings uns
    WHERE uns.user_id = NEW.user_id
      AND (
        NEW.category = ANY (uns.silenced_categories)
        OR (v_event IS NOT NULL AND v_event = ANY (uns.silenced_events))
      )
  ) THEN
    RETURN NULL;
  END IF;

  -- Persist resolved scope into payload for policy checks and read semantics.
  NEW.payload := jsonb_set(v_payload, '{scope}', to_jsonb(v_scope), true);

  RETURN NEW;
END;
$$;


--
-- Name: notify_bid_accepted_on_update(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_bid_accepted_on_update() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_org_id uuid;
  v_project_name text;
BEGIN
  IF COALESCE(OLD.status::text, '') = 'approved'
     OR COALESCE(NEW.status::text, '') <> 'approved' THEN
    RETURN NEW;
  END IF;

  SELECT p.organization_id, p.name
  INTO v_org_id, v_project_name
  FROM public.projects p
  WHERE p.id = NEW.project_id
    AND p.deleted_at IS NULL;

  IF v_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  PERFORM public.emit_org_notification(
    v_org_id,
    'workflow_update',
    'A bid was accepted for ' || COALESCE(v_project_name, 'a project') || '.',
    jsonb_build_object(
      'event', 'bid_accepted',
      'organization_id', v_org_id,
      'project_id', NEW.project_id,
      'project_name', v_project_name,
      'bid_id', NEW.id,
      'vendor_id', NEW.vendor_id,
      'scope', 'org_wide'
    )
  );

  RETURN NEW;
END;
$$;


--
-- Name: notify_new_bid(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.notify_new_bid() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_org_id uuid;
  v_project_name text;
  v_member record;
BEGIN
  SELECT p.organization_id, p.name
  INTO v_org_id, v_project_name
  FROM public.projects p
  WHERE p.id = NEW.project_id
    AND p.deleted_at IS NULL;

  IF v_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  FOR v_member IN
    SELECT om.profile_id
    FROM public.organization_members om
    WHERE om.organization_id = v_org_id
      AND om.deleted_at IS NULL
  LOOP
    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', v_member.profile_id,
        'organization_id', v_org_id,
        'category', 'bid_received',
        'message', 'A new bid was submitted for ' || COALESCE(v_project_name, 'a project') || '.',
        'payload', jsonb_build_object(
          'event', 'bid_received',
          'organization_id', v_org_id,
          'project_id', NEW.project_id,
          'project_name', v_project_name,
          'bid_id', NEW.id,
          'vendor_id', NEW.vendor_id,
          'scope', 'org_wide'
        )
      )
    );
  END LOOP;

  RETURN NEW;
END;
$$;


--
-- Name: on_create_function_pin_search_path(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.on_create_function_pin_search_path() RETURNS event_trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
DECLARE
  r record;
  regproc text;
BEGIN
  FOR r IN
    SELECT *
    FROM pg_event_trigger_ddl_commands()
  LOOP
    -- Only act on CREATE FUNCTION and ALTER FUNCTION
    IF r.command_tag IN ('CREATE FUNCTION', 'ALTER FUNCTION') THEN
      regproc := (r.objid::regprocedure)::text;

      IF EXISTS (
        SELECT 1
        FROM pg_proc p
        WHERE p.oid = r.objid
          AND p.prosecdef = TRUE
          AND NOT EXISTS (
            SELECT 1
            FROM unnest(coalesce(p.proconfig, '{}'::text[])) kv
            WHERE split_part(kv, '=', 1) = 'search_path'
          )
      ) THEN
        EXECUTE format(
          'ALTER FUNCTION %s SET search_path = pg_catalog, public;',
          regproc
        );
        RAISE NOTICE 'Pinned search_path for %', regproc;
      END IF;
    END IF;
  END LOOP;
END
$$;


--
-- Name: on_ddl_ensure_fk_indexes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.on_ddl_ensure_fk_indexes() RETURNS event_trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'pg_catalog', 'public'
    AS $$
BEGIN
  PERFORM public.ensure_fk_indexes_for_schema('public');
END
$$;


--
-- Name: purge_orphaned_avatars(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.purge_orphaned_avatars() RETURNS SETOF public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    BEGIN
      IF COALESCE(auth.role(), '') NOT IN ('service_role', 'supabase_admin') THEN
        RAISE EXCEPTION 'not authorized';
      END IF;

      RETURN QUERY
      DELETE FROM public.avatars AS a
       WHERE a.is_preset = false
         AND NOT EXISTS (
           SELECT 1
             FROM public.profiles AS p
            WHERE p.avatar_id = a.id
              AND p.deleted_at IS NULL
         )
       RETURNING *;
    END;
    $$;


--
-- Name: rank_equipment_usage(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rank_equipment_usage(p_project_id uuid) RETURNS TABLE(equipment_id uuid, total_hours numeric, usage_rank integer)
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  WITH usage AS (
    SELECT ea.equipment_id, SUM(eu.hours_used) AS total_hours
      FROM public.equipment_usage eu
      JOIN public.equipment_assignments ea
        ON eu.equipment_id = ea.equipment_id
     WHERE ea.project_id = p_project_id
     GROUP BY ea.equipment_id
  )
  SELECT
    equipment_id,
    total_hours,
    RANK() OVER (ORDER BY total_hours DESC) AS usage_rank
  FROM usage;
$$;


--
-- Name: refresh_project_cost_summary(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.refresh_project_cost_summary() RETURNS void
    LANGUAGE sql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
  REFRESH MATERIALIZED VIEW public.project_cost_summary;
$$;


--
-- Name: remove_org_member_with_reason(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.remove_org_member_with_reason(p_org_id uuid, p_profile_id uuid, p_reason text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_actor_id uuid := auth.uid();
  v_actor_role public.user_role_type;
  v_actor_permission_role public.org_role;
  v_target_permission_role public.org_role;
  v_actor_name text;
  v_target_name text;
  v_org_name text;
  v_membership_id uuid;
  v_is_self_leave boolean;
  v_actor_is_member boolean := false;
  v_admin record;
BEGIN
  IF v_actor_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_org_id IS NULL OR p_profile_id IS NULL THEN
    RAISE EXCEPTION 'Missing required inputs';
  END IF;

  IF COALESCE(TRIM(p_reason), '') = '' THEN
    RAISE EXCEPTION 'Reason is required';
  END IF;

  v_is_self_leave := (p_profile_id = v_actor_id);

  SELECT p.role
  INTO v_actor_role
  FROM public.profiles p
  WHERE p.id = v_actor_id
    AND p.deleted_at IS NULL;

  IF v_actor_role IS NULL THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  -- Safeguards for removing OTHER members only.
  IF NOT v_is_self_leave THEN
    SELECT EXISTS (
      SELECT 1
      FROM public.organization_members om
      WHERE om.organization_id = p_org_id
        AND om.profile_id = v_actor_id
        AND om.deleted_at IS NULL
    ) INTO v_actor_is_member;

    IF NOT v_actor_is_member AND v_actor_role <> 'system_admin' THEN
      RAISE EXCEPTION 'Access denied' USING errcode = '42501';
    END IF;

    IF v_actor_is_member THEN
      SELECT om.permission_role
      INTO v_actor_permission_role
      FROM public.organization_members om
      WHERE om.organization_id = p_org_id
        AND om.profile_id = v_actor_id
        AND om.deleted_at IS NULL
      ORDER BY om.created_at DESC
      LIMIT 1;
    END IF;

    IF NOT (
      v_actor_role = 'system_admin'
      OR COALESCE(v_actor_permission_role::text, '') IN ('admin', 'hr', 'owner')
    ) THEN
      RAISE EXCEPTION 'Access denied' USING errcode = '42501';
    END IF;
  END IF;

  SELECT om.permission_role
  INTO v_target_permission_role
  FROM public.organization_members om
  WHERE om.organization_id = p_org_id
    AND om.profile_id = p_profile_id
    AND om.deleted_at IS NULL
  ORDER BY om.created_at DESC
  LIMIT 1;

  -- Self-leave is idempotent: if membership already absent, just clear profile org pointer and exit.
  IF v_target_permission_role IS NULL THEN
    IF v_is_self_leave THEN
      UPDATE public.profiles
      SET organization_id = NULL,
          updated_at = now()
      WHERE id = v_actor_id
        AND organization_id = p_org_id;
      RETURN;
    END IF;

    RAISE EXCEPTION 'Target is not an active member of this organization' USING errcode = 'P0001';
  END IF;

  IF NOT v_is_self_leave
     AND v_target_permission_role = 'owner'
     AND v_actor_role <> 'system_admin'
     AND COALESCE(v_actor_permission_role::text, '') <> 'owner' THEN
    RAISE EXCEPTION 'Access denied: only owners can remove owners' USING errcode = '42501';
  END IF;

  SELECT om.id
  INTO v_membership_id
  FROM public.organization_members om
  WHERE om.organization_id = p_org_id
    AND om.profile_id = p_profile_id
    AND om.deleted_at IS NULL
  ORDER BY om.created_at DESC
  LIMIT 1;

  IF v_membership_id IS NULL THEN
    IF v_is_self_leave THEN
      UPDATE public.profiles
      SET organization_id = NULL,
          updated_at = now()
      WHERE id = v_actor_id
        AND organization_id = p_org_id;
      RETURN;
    END IF;

    RAISE EXCEPTION 'Target is not an active member of this organization' USING errcode = 'P0001';
  END IF;

  -- Do NOT call delete_organization_members here; self-leave must bypass generic member-management gate.
  UPDATE public.organization_members
  SET deleted_at = now(),
      updated_at = now()
  WHERE id = v_membership_id
    AND deleted_at IS NULL;

  -- Keep profile pointer consistent for self-leave.
  IF v_is_self_leave THEN
    UPDATE public.profiles
    SET organization_id = NULL,
        updated_at = now()
    WHERE id = p_profile_id
      AND organization_id = p_org_id;
  END IF;

  SELECT p.full_name INTO v_actor_name FROM public.profiles p WHERE p.id = v_actor_id;
  SELECT p.full_name INTO v_target_name FROM public.profiles p WHERE p.id = p_profile_id;
  SELECT o.name INTO v_org_name FROM public.organizations o WHERE o.id = p_org_id;

  IF NOT v_is_self_leave THEN
    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', p_profile_id,
        'organization_id', p_org_id,
        'category', 'workflow_update',
        'message', 'You have been removed from ' || COALESCE(v_org_name, 'this organization') || '. Reason: ' || TRIM(p_reason),
        'payload', jsonb_build_object(
          'event', 'member_removed',
          'organization_id', p_org_id,
          'organization_name', v_org_name,
          'affected_profile_id', p_profile_id,
          'removed_by_profile_id', v_actor_id,
          'removed_by_name', COALESCE(v_actor_name, 'Organization Admin'),
          'reason', TRIM(p_reason),
          'removed_at', now()
        )
      )
    );
  END IF;

  FOR v_admin IN
    SELECT om.profile_id
    FROM public.organization_members om
    WHERE om.organization_id = p_org_id
      AND om.deleted_at IS NULL
      AND om.permission_role IN ('admin', 'hr', 'owner')
  LOOP
    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', v_admin.profile_id,
        'organization_id', p_org_id,
        'category', 'workflow_update',
        'message',
          CASE
            WHEN v_is_self_leave THEN
              COALESCE(v_target_name, p_profile_id::text) || ' left ' || COALESCE(v_org_name, 'the organization') || '.'
            ELSE
              COALESCE(v_target_name, p_profile_id::text) || ' was removed from ' || COALESCE(v_org_name, 'the organization') || '.'
          END,
        'payload', jsonb_build_object(
          'event', CASE WHEN v_is_self_leave THEN 'member_left_organization' ELSE 'member_removed' END,
          'organization_id', p_org_id,
          'organization_name', v_org_name,
          'affected_profile_id', p_profile_id,
          'affected_profile_name', v_target_name,
          'actor_profile_id', v_actor_id,
          'actor_name', COALESCE(v_actor_name, 'Organization Admin'),
          'reason', TRIM(p_reason),
          'occurred_at', now()
        )
      )
    );
  END LOOP;
END;
$$;


--
-- Name: remove_profile_from_contract(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.remove_profile_from_contract(p_contract_id uuid, p_profile_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  perform check_access('delete','user_projects', p_contract_id, null);

  update public.user_projects
  set deleted_at = now(),
      updated_at = now()
  where project_id = p_contract_id
    and user_id = p_profile_id
    and deleted_at is null;
end;
$$;


--
-- Name: review_organization_invite(uuid, text, timestamp with time zone, uuid, public.org_role); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.review_organization_invite(p_invite_id uuid, p_decision text, p_responded_at timestamp with time zone DEFAULT now(), p_selected_job_title_id uuid DEFAULT NULL::uuid, p_selected_permission_role public.org_role DEFAULT NULL::public.org_role) RETURNS SETOF public.organization_invites
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _old_row public.organization_invites;
  _new_row public.organization_invites;
  _reviewer_id uuid := auth.uid();
  _reviewer_role public.user_role_type;
  _reviewer_is_member boolean := false;
  _selected_permission_role public.org_role;
  _organization_name text;
  _selected_job_title_name text;
  _decision_word text;
  _existing_membership_id uuid;
  _existing_membership_deleted_at timestamptz;
  _was_rejoin boolean := false;
  _member record;
BEGIN
  IF p_decision NOT IN ('accepted', 'declined') THEN
    RAISE EXCEPTION 'invalid decision' USING detail = jsonb_build_object('decision', p_decision);
  END IF;

  SELECT * INTO _old_row FROM public.organization_invites WHERE id = p_invite_id;
  IF _old_row IS NULL THEN
    RAISE EXCEPTION 'row not found' USING detail = jsonb_build_object('id', p_invite_id);
  END IF;

  SELECT p.role INTO _reviewer_role
  FROM public.profiles p
  WHERE p.id = _reviewer_id
    AND p.deleted_at IS NULL;

  IF _reviewer_role IS NULL THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  IF _reviewer_role <> 'system_admin' THEN
    SELECT EXISTS (
      SELECT 1
      FROM public.organization_members om
      WHERE om.organization_id = _old_row.organization_id
        AND om.profile_id = _reviewer_id
        AND om.deleted_at IS NULL
    ) INTO _reviewer_is_member;

    IF NOT _reviewer_is_member THEN
      RAISE EXCEPTION 'Access denied' USING errcode = '42501';
    END IF;
  END IF;

  IF _reviewer_role::text NOT IN ('system_admin', 'org_admin') THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  IF _old_row.status <> 'pending' THEN
    RAISE EXCEPTION 'status is not pending'
      USING detail = jsonb_build_object('id', p_invite_id, 'status', _old_row.status);
  END IF;

  UPDATE public.organization_invites
  SET status = p_decision,
      responded_at = COALESCE(p_responded_at, now()),
      reviewed_permission_role = COALESCE(
        p_selected_permission_role,
        reviewed_permission_role,
        requested_permission_role
      ),
      reviewed_job_title_id = COALESCE(
        p_selected_job_title_id,
        reviewed_job_title_id,
        requested_job_title_id
      ),
      role = COALESCE(
        p_selected_job_title_id,
        role,
        requested_job_title_id
      )
  WHERE id = p_invite_id
  RETURNING * INTO _new_row;

  IF _new_row.status = 'accepted' THEN
    _selected_permission_role := COALESCE(
      p_selected_permission_role,
      _new_row.reviewed_permission_role,
      _new_row.requested_permission_role,
      'worker'::public.org_role
    );

    SELECT m.id, m.deleted_at
    INTO _existing_membership_id, _existing_membership_deleted_at
    FROM public.organization_members m
    WHERE m.organization_id = _new_row.organization_id
      AND m.profile_id = _new_row.invited_profile_id
    LIMIT 1;

    IF _existing_membership_id IS NULL THEN
      INSERT INTO public.organization_members (
        organization_id, profile_id, permission_role, job_title_id, created_at, updated_at
      )
      VALUES (
        _new_row.organization_id,
        _new_row.invited_profile_id,
        _selected_permission_role,
        COALESCE(p_selected_job_title_id, _new_row.requested_job_title_id),
        now(),
        now()
      );
    ELSIF _existing_membership_deleted_at IS NOT NULL THEN
      _was_rejoin := true;
      UPDATE public.organization_members m
      SET deleted_at = NULL,
          permission_role = COALESCE(_selected_permission_role, m.permission_role),
          job_title_id = COALESCE(
            p_selected_job_title_id,
            _new_row.requested_job_title_id,
            m.job_title_id
          ),
          updated_at = now()
      WHERE m.id = _existing_membership_id;
    ELSE
      UPDATE public.organization_members m
      SET permission_role = COALESCE(_selected_permission_role, m.permission_role),
          job_title_id = COALESCE(
            p_selected_job_title_id,
            _new_row.requested_job_title_id,
            m.job_title_id
          ),
          updated_at = now()
      WHERE m.id = _existing_membership_id;
    END IF;

    UPDATE public.profiles
    SET organization_id = _new_row.organization_id,
        updated_at = now()
    WHERE id = _new_row.invited_profile_id;

    -- Notify org members when this is specifically a rejoin
    IF _was_rejoin THEN
      SELECT o.name INTO _organization_name
      FROM public.organizations o
      WHERE o.id = _new_row.organization_id;

      FOR _member IN
        SELECT om.profile_id
        FROM public.organization_members om
        WHERE om.organization_id = _new_row.organization_id
          AND om.deleted_at IS NULL
          AND om.profile_id <> _new_row.invited_profile_id
      LOOP
        PERFORM public.insert_notifications(
          jsonb_build_object(
            'user_id', _member.profile_id,
            'organization_id', _new_row.organization_id,
            'category', 'workflow_update',
            'message', 'A team member rejoined ' || COALESCE(_organization_name, 'the organization') || '.',
            'payload', jsonb_build_object(
              'event', 'member_rejoined_organization',
              'organization_id', _new_row.organization_id,
              'organization_name', _organization_name,
              'affected_profile_id', _new_row.invited_profile_id,
              'affected_profile_name', (SELECT p.full_name FROM public.profiles p WHERE p.id = _new_row.invited_profile_id),
              'actor_profile_id', _reviewer_id,
              'actor_name', (SELECT p.full_name FROM public.profiles p WHERE p.id = _reviewer_id),
              'occurred_at', now()
            )
          )
        );
      END LOOP;
    END IF;
  END IF;

  SELECT o.name INTO _organization_name FROM public.organizations o WHERE o.id = _new_row.organization_id;

  IF COALESCE(p_selected_job_title_id, _new_row.reviewed_job_title_id, _new_row.requested_job_title_id) IS NOT NULL THEN
    SELECT jt.name INTO _selected_job_title_name
    FROM public.job_titles jt
    WHERE jt.id = COALESCE(p_selected_job_title_id, _new_row.reviewed_job_title_id, _new_row.requested_job_title_id);
  END IF;

  _decision_word := CASE WHEN _new_row.status = 'accepted' THEN 'approved' ELSE 'denied' END;

  PERFORM public.insert_notifications(
    jsonb_build_object(
      'user_id', _new_row.invited_profile_id,
      'organization_id', _new_row.organization_id,
      'category', 'workflow_update',
      'message',
        CASE
          WHEN _selected_job_title_name IS NOT NULL THEN
            'Your request to join ' || COALESCE(_organization_name, 'this organization')
            || ' has been ' || _decision_word
            || ' for the position of ' || _selected_job_title_name || '.'
          ELSE
            'Your request to join ' || COALESCE(_organization_name, 'this organization')
            || ' has been ' || _decision_word || '.'
        END,
      'payload', jsonb_build_object(
        'event', 'membership_request_reviewed',
        'invite_id', _new_row.id,
        'organization_id', _new_row.organization_id,
        'organization_name', _organization_name,
        'status', _new_row.status,
        'decision_word', _decision_word,
        'requested_role', COALESCE(_new_row.reviewed_permission_role, _new_row.requested_permission_role)::text,
        'position_label', _selected_job_title_name,
        'selected_job_title_name', _selected_job_title_name,
        'reviewed_by_profile_id', _reviewer_id,
        'reviewed_at', _new_row.responded_at
      )
    )
  );

  RETURN NEXT _new_row;
END;
$$;


--
-- Name: rpc_calculator_template_payload(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_calculator_template_payload(p_template_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_template jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','line_item_templates', null, v_org_id);

  select jsonb_build_object(
    'id', t.id,
    'name', t.name,
    'formula', t.formula,
    'variables', t.variables,
    'created_at', t.created_at,
    'updated_at', t.updated_at
  )
  into v_template
  from public.line_item_templates t
  where t.id = p_template_id
    and t.deleted_at is null;

  if v_template is null then
    raise exception 'Template not found: %', p_template_id;
  end if;

  return jsonb_build_object(
    'template', v_template
  );
end;
$$;


--
-- Name: rpc_calculators_payload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_calculators_payload() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_templates jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','line_item_templates', null, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', t.id,
        'name', t.name,
        'formula', t.formula,
        'variables', t.variables,
        'created_at', t.created_at,
        'updated_at', t.updated_at
      )
      order by t.updated_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_templates
  from public.line_item_templates t
  where t.deleted_at is null;

  return jsonb_build_object(
    'templates', v_templates
  );
end;
$$;


--
-- Name: rpc_equipment_log_payload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_equipment_log_payload() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_logs jsonb;
  v_equipment jsonb;
  v_operators jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','equipment_usage', null, v_org_id);
  perform check_access('select','equipment', null, v_org_id);
  perform check_access('select','profiles', null, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', eu.id,
        'equipment_id', eu.equipment_id,
        'usage_date', eu.date,
        'hours_used', eu.hours_used,
        'notes', eu.notes
      )
      order by eu.date desc nulls last
    ),
    '[]'::jsonb
  )
  into v_logs
  from public.equipment_usage eu
  join public.equipment e on e.id = eu.equipment_id
  where eu.deleted_at is null
    and e.deleted_at is null
    and (v_org_id is null or e.organization_id = v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', e.id,
        'name', e.name,
        'serial_number', e.serial_number,
        'model', e.model
      )
      order by e.name
    ),
    '[]'::jsonb
  )
  into v_equipment
  from public.equipment e
  where e.deleted_at is null
    and (v_org_id is null or e.organization_id = v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', p.id,
        'full_name', p.full_name,
        'email', p.email
      )
      order by p.full_name nulls last, p.email
    ),
    '[]'::jsonb
  )
  into v_operators
  from public.profiles p
  where p.deleted_at is null
    and (v_org_id is null or p.organization_id = v_org_id);

  return jsonb_build_object(
    'logs', v_logs,
    'equipment', v_equipment,
    'operators', v_operators
  );
end;
$$;


--
-- Name: rpc_equipment_maintenance_payload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_equipment_maintenance_payload() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_records jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','equipment_maintenance', null, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', em.id,
        'equipment_id', em.equipment_id,
        'description', em.description,
        'maintenance_date', em.maintenance_date,
        'performed_by', em.performed_by,
        'type', em.type,
        'created_at', em.created_at,
        'updated_at', em.updated_at
      )
      order by em.maintenance_date desc nulls last
    ),
    '[]'::jsonb
  )
  into v_records
  from public.equipment_maintenance em
  join public.equipment e on e.id = em.equipment_id
  where em.deleted_at is null
    and e.deleted_at is null
    and (v_org_id is null or e.organization_id = v_org_id);

  return jsonb_build_object(
    'records', v_records
  );
end;
$$;


--
-- Name: rpc_estimates_payload(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_estimates_payload() RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_estimates jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','estimates', null, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', e.id,
        'project_id', e.project_id,
        'name', e.name,
        'status', e.status,
        'created_at', e.created_at,
        'updated_at', e.updated_at
      )
      order by e.updated_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_estimates
  from public.estimates e
  join public.projects p on p.id = e.project_id
  where e.deleted_at is null
    and p.deleted_at is null
    and (v_org_id is null or p.organization_id = v_org_id);

  return jsonb_build_object(
    'estimates', v_estimates
  );
end;
$$;


--
-- Name: rpc_inspections_payload(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_inspections_payload(p_project_id uuid DEFAULT NULL::uuid, p_wbs_id uuid DEFAULT NULL::uuid, p_map_id uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_project_id uuid := p_project_id;
  v_wbs_id uuid := p_wbs_id;
  v_map_id uuid := p_map_id;
  v_projects jsonb;
  v_wbs jsonb;
  v_maps jsonb;
  v_line_items jsonb;
  v_inspections jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select *
  into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;

  if v_project_id is null and v_wbs_id is not null then
    select project_id into v_project_id
    from public.wbs
    where id = v_wbs_id
      and deleted_at is null;
  end if;

  if v_project_id is null and v_map_id is not null then
    select project_id into v_project_id
    from public.maps
    where id = v_map_id
      and deleted_at is null;
  end if;

  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  perform check_access('select','projects', v_project_id, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name
      )
      order by name
    ),
    '[]'::jsonb
  )
  into v_projects
  from public.projects
  where deleted_at is null
    and (v_org_id is null or organization_id = v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name
      )
      order by order_num nulls last, name
    ),
    '[]'::jsonb
  )
  into v_wbs
  from public.wbs
  where deleted_at is null
    and v_project_id is not null
    and project_id = v_project_id;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name,
        'wbs_id', wbs_id
      )
      order by order_num nulls last, name
    ),
    '[]'::jsonb
  )
  into v_maps
  from public.maps
  where deleted_at is null
    and v_wbs_id is not null
    and wbs_id = v_wbs_id;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', coalesce(description, name)
      )
      order by updated_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_line_items
  from public.line_items
  where deleted_at is null
    and v_map_id is not null
    and map_id = v_map_id;

  if v_project_id is not null then
    select coalesce(
      jsonb_agg(
        jsonb_build_object(
          'id', id,
          'name', name,
          'notes', notes,
          'project_id', project_id,
          'result', result,
          'created_at', created_at,
          'updated_at', updated_at
        )
        order by created_at desc nulls last
      ),
      '[]'::jsonb
    )
    into v_inspections
    from public.inspections
    where deleted_at is null
      and project_id = v_project_id;
  else
    select coalesce(
      jsonb_agg(
        jsonb_build_object(
          'id', i.id,
          'name', i.name,
          'notes', i.notes,
          'project_id', i.project_id,
          'result', i.result,
          'created_at', i.created_at,
          'updated_at', i.updated_at
        )
        order by i.created_at desc nulls last
      ),
      '[]'::jsonb
    )
    into v_inspections
    from public.inspections i
    join public.projects p on p.id = i.project_id
    where i.deleted_at is null
      and p.deleted_at is null
      and (v_org_id is null or p.organization_id = v_org_id);
  end if;

  return jsonb_build_object(
    'projects', v_projects,
    'wbs', v_wbs,
    'maps', v_maps,
    'line_items', v_line_items,
    'inspections', v_inspections
  );
end;
$$;


--
-- Name: rpc_issues_payload(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_issues_payload(p_project_id uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_org_id uuid;
  v_issues jsonb;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_org_id := v_profile.organization_id;
  if v_org_id is null and v_profile.role <> 'system_admin' then
    raise exception 'Access denied: organization not set for user %', v_user_id;
  end if;

  if p_project_id is null then
    raise exception 'Project id is required';
  end if;

  perform check_access('select','issues', p_project_id, v_org_id);

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', i.id,
        'project_id', i.project_id,
        'name', i.name,
        'description', i.description,
        'type', i.type,
        'status', i.status,
        'resolved', i.resolved,
        'reported_by', i.reported_by,
        'created_at', i.created_at,
        'updated_at', i.updated_at,
        'deleted_at', i.deleted_at,
        'profiles', jsonb_build_object(
          'full_name', p.full_name,
          'email', p.email
        )
      )
      order by i.created_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_issues
  from public.issues i
  left join public.profiles p on p.id = i.reported_by
  where i.project_id = p_project_id
    and i.deleted_at is null;

  return jsonb_build_object(
    'issues', v_issues
  );
end;
$$;


--
-- Name: rpc_org_dashboard_payload(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_org_dashboard_payload(p_organization_id uuid, p_members_page integer DEFAULT 1, p_page_size integer DEFAULT 10) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id uuid;
  v_role text;
  v_has_membership boolean := false;
  v_page int := GREATEST(COALESCE(p_members_page, 1), 1);
  v_page_size int := GREATEST(COALESCE(p_page_size, 10), 1);
  v_offset int := (v_page - 1) * v_page_size;
  v_organization jsonb;
  v_service_areas jsonb;
  v_members_items jsonb;
  v_members_total int := 0;
  v_total_members int := 0;
  v_total_projects int := 0;
  v_members_yoy int := 0;
  v_projects_yoy int := 0;
  v_members_last_year int := 0;
  v_projects_last_year int := 0;
  v_open_issues int := 0;
  v_pending_inspections int := 0;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  SELECT role INTO v_role
  FROM public.profiles
  WHERE id = v_user_id;

  IF v_role IS NULL THEN
    RAISE EXCEPTION 'Access denied: profile not found for user %', v_user_id;
  END IF;

  IF v_role = 'system_admin' THEN
    v_has_membership := true;
  ELSE
    SELECT EXISTS (
      SELECT 1
      FROM public.organization_members
      WHERE organization_id = p_organization_id
        AND profile_id = v_user_id
        AND deleted_at IS NULL
    ) INTO v_has_membership;
  END IF;

  IF v_has_membership IS NOT TRUE THEN
    RAISE EXCEPTION 'Access denied: not a member of organization %', p_organization_id;
  END IF;

  SELECT jsonb_build_object(
    'id', id,
    'name', name,
    'description', description,
    'mission_statement', mission_statement,
    'headquarters', headquarters,
    'logo_url', logo_url
  )
  INTO v_organization
  FROM public.organizations
  WHERE id = p_organization_id
    AND deleted_at IS NULL;

  IF v_organization IS NULL THEN
    RAISE EXCEPTION 'Organization not found: %', p_organization_id;
  END IF;

  SELECT COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'service_area_text', service_area_text
      )
      ORDER BY service_area_text
    ),
    '[]'::jsonb
  )
  INTO v_service_areas
  FROM public.organization_service_areas
  WHERE organization_id = p_organization_id;

  SELECT COUNT(*)
  INTO v_members_total
  FROM public.organization_members
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  SELECT COALESCE(jsonb_agg(to_jsonb(member_row)), '[]'::jsonb)
  INTO v_members_items
  FROM (
    SELECT
      p.id AS profile_id,
      p.full_name,
      p.email,
      p.role AS global_role,
      om.permission_role::text AS membership_permission_role,
      om.job_title_id AS membership_job_title_id,
      jt.name AS membership_job_title_name
    FROM public.organization_members om
    JOIN public.profiles p ON p.id = om.profile_id
    LEFT JOIN public.job_titles jt ON jt.id = om.job_title_id
    WHERE om.organization_id = p_organization_id
      AND om.deleted_at IS NULL
    ORDER BY p.full_name NULLS LAST, p.email
    LIMIT v_page_size
    OFFSET v_offset
  ) member_row;

  SELECT COUNT(*) INTO v_total_members
  FROM public.organization_members
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  SELECT COUNT(*) INTO v_total_projects
  FROM public.projects
  WHERE organization_id = p_organization_id
    AND deleted_at IS NULL;

  SELECT COUNT(*) INTO v_open_issues
  FROM public.issues i
  JOIN public.projects p ON p.id = i.project_id
  WHERE p.organization_id = p_organization_id
    AND i.deleted_at IS NULL
    AND COALESCE(i.resolved, false) = false;

  SELECT COUNT(*) INTO v_pending_inspections
  FROM public.inspections ins
  JOIN public.projects p ON p.id = ins.project_id
  WHERE p.organization_id = p_organization_id
    AND ins.deleted_at IS NULL
    AND (ins.status IS NULL OR lower(ins.status) NOT IN ('completed', 'complete', 'closed', 'passed'));

  SELECT COUNT(*) INTO v_members_last_year
  FROM public.organization_members
  WHERE organization_id = p_organization_id
    AND created_at <= NOW() - INTERVAL '1 year'
    AND (deleted_at IS NULL OR deleted_at > NOW() - INTERVAL '1 year');

  SELECT COUNT(*) INTO v_projects_last_year
  FROM public.projects
  WHERE organization_id = p_organization_id
    AND created_at <= NOW() - INTERVAL '1 year'
    AND (deleted_at IS NULL OR deleted_at > NOW() - INTERVAL '1 year');

  v_members_yoy := v_total_members - v_members_last_year;
  v_projects_yoy := v_total_projects - v_projects_last_year;

  RETURN jsonb_build_object(
    'organization', v_organization,
    'service_areas', v_service_areas,
    'members', jsonb_build_object(
      'total_count', v_members_total,
      'items', v_members_items
    ),
    'metrics', jsonb_build_object(
      'total_members', v_total_members,
      'total_projects', v_total_projects,
      'members_yoy', v_members_yoy,
      'projects_yoy', v_projects_yoy,
      'open_issues', v_open_issues,
      'pending_inspections', v_pending_inspections
    )
  );
END;
$$;


--
-- Name: rpc_profile_dashboard_payload(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_profile_dashboard_payload(p_projects_page integer DEFAULT 1, p_page_size integer DEFAULT 10) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_profile public.profiles%rowtype;
  v_role text;
  v_org_id uuid;
  v_has_membership boolean := false;
  v_page int := greatest(coalesce(p_projects_page, 1), 1);
  v_page_size int := greatest(coalesce(p_page_size, 10), 1);
  v_offset int := (v_page - 1) * v_page_size;
  v_org jsonb;
  v_job_titles jsonb;
  v_projects jsonb := '[]'::jsonb;
  v_projects_total int := 0;
  v_active_projects int := 0;
  v_open_issues int := 0;
  v_pending_inspections int := 0;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select *
  into v_profile
  from public.profiles
  where id = v_user_id;

  if not found then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  v_role := v_profile.role;
  v_org_id := v_profile.organization_id;

  if v_org_id is not null then
    if v_role = 'system_admin' then
      v_has_membership := true;
    else
      select exists (
        select 1
        from public.organization_members
        where organization_id = v_org_id
          and profile_id = v_user_id
          and deleted_at is null
      ) into v_has_membership;
    end if;

    if v_has_membership is not true then
      raise exception 'Access denied: not a member of organization %', v_org_id;
    end if;

    select jsonb_build_object(
      'id', id,
      'name', name,
      'description', description,
      'mission_statement', mission_statement,
      'headquarters', headquarters,
      'logo_url', logo_url,
      'created_at', created_at,
      'updated_at', updated_at
    )
    into v_org
    from public.organizations
    where id = v_org_id
      and deleted_at is null;

    select count(*)
    into v_projects_total
    from public.projects
    where organization_id = v_org_id
      and deleted_at is null;

    select coalesce(
      jsonb_agg(
        jsonb_build_object(
          'id', id,
          'organization_id', organization_id,
          'name', name,
          'description', description,
          'status', status,
          'start_date', start_date,
          'end_date', end_date,
          'created_at', created_at,
          'updated_at', updated_at
        )
        order by updated_at desc nulls last
      ),
      '[]'::jsonb
    )
    into v_projects
    from (
      select *
      from public.projects
      where organization_id = v_org_id
        and deleted_at is null
      order by updated_at desc nulls last
      limit v_page_size
      offset v_offset
    ) p;

    select count(*)
    into v_active_projects
    from public.projects
    where organization_id = v_org_id
      and deleted_at is null
      and status = 'active';

    select count(*)
    into v_open_issues
    from public.issues i
    join public.projects p on p.id = i.project_id
    where p.organization_id = v_org_id
      and i.deleted_at is null
      and coalesce(i.resolved, false) = false;

    select count(*)
    into v_pending_inspections
    from public.inspections ins
    join public.projects p on p.id = ins.project_id
    where p.organization_id = v_org_id
      and ins.deleted_at is null
      and (ins.status is null or lower(ins.status) not in ('completed', 'complete', 'closed', 'passed'));
  else
    v_org := null;
    v_projects := '[]'::jsonb;
  end if;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'name', name
      )
      order by name
    ),
    '[]'::jsonb
  )
  into v_job_titles
  from public.job_titles
  where deleted_at is null;

  return jsonb_build_object(
    'profile', jsonb_build_object(
      'id', v_profile.id,
      'full_name', v_profile.full_name,
      'email', v_profile.email,
      'phone', v_profile.phone,
      'avatar_id', v_profile.avatar_id,
      'role', v_profile.role,
      'job_title_id', nullif(to_jsonb(v_profile)->>'job_title_id', '')::uuid,
      'organization_id', v_profile.organization_id,
      'created_at', v_profile.created_at,
      'updated_at', v_profile.updated_at,
      'deleted_at', v_profile.deleted_at,
      'profile_completed_at', v_profile.profile_completed_at
    ),
    'organization', v_org,
    'job_titles', v_job_titles,
    'projects', jsonb_build_object(
      'total_count', v_projects_total,
      'items', v_projects
    ),
    'metrics', jsonb_build_object(
      'active_projects', v_active_projects,
      'open_issues', v_open_issues,
      'pending_inspections', v_pending_inspections
    )
  );
end;
$$;


--
-- Name: rpc_project_dashboard_payload(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.rpc_project_dashboard_payload(p_project_id uuid, p_line_items_page integer DEFAULT 1, p_page_size integer DEFAULT 50) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  v_user_id uuid;
  v_role text;
  v_project public.projects%rowtype;
  v_has_membership boolean := false;
  v_page int := greatest(coalesce(p_line_items_page, 1), 1);
  v_page_size int := greatest(coalesce(p_page_size, 50), 1);
  v_offset int := (v_page - 1) * v_page_size;
  v_wbs jsonb := '[]'::jsonb;
  v_wbs_total int := 0;
  v_line_items jsonb := '[]'::jsonb;
  v_line_items_total int := 0;
  v_issues_count int := 0;
  v_change_orders_count int := 0;
  v_inspections_count int := 0;
begin
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if p_project_id is null then
    raise exception 'Project id is required';
  end if;

  select role into v_role
  from public.profiles
  where id = v_user_id;

  if v_role is null then
    raise exception 'Access denied: profile not found for user %', v_user_id;
  end if;

  select *
  into v_project
  from public.projects
  where id = p_project_id
    and deleted_at is null;

  if not found then
    raise exception 'Project not found: %', p_project_id;
  end if;

  if v_role = 'system_admin' then
    v_has_membership := true;
  else
    select exists (
      select 1
      from public.organization_members
      where organization_id = v_project.organization_id
        and profile_id = v_user_id
        and deleted_at is null
    ) into v_has_membership;
  end if;

  if v_has_membership is not true then
    raise exception 'Access denied: not a member of organization %', v_project.organization_id;
  end if;

  select count(*)
  into v_wbs_total
  from public.wbs
  where project_id = p_project_id
    and deleted_at is null;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'project_id', project_id,
        'name', name,
        'location', location,
        'order_num', order_num,
        'created_at', created_at,
        'updated_at', updated_at
      )
      order by order_num nulls last, name
    ),
    '[]'::jsonb
  )
  into v_wbs
  from public.wbs
  where project_id = p_project_id
    and deleted_at is null;

  select count(*)
  into v_line_items_total
  from public.line_items
  where project_id = p_project_id
    and deleted_at is null;

  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'id', id,
        'project_id', project_id,
        'wbs_id', wbs_id,
        'map_id', map_id,
        'cost_code_id', cost_code_id,
        'template_id', template_id,
        'name', name,
        'description', description,
        'unit_measure', unit_measure,
        'quantity', quantity,
        'unit_price', unit_price,
        'created_at', created_at,
        'updated_at', updated_at
      )
      order by updated_at desc nulls last
    ),
    '[]'::jsonb
  )
  into v_line_items
  from (
    select *
    from public.line_items
    where project_id = p_project_id
      and deleted_at is null
    order by updated_at desc nulls last
    limit v_page_size
    offset v_offset
  ) li;

  select count(*)
  into v_issues_count
  from public.issues
  where project_id = p_project_id
    and deleted_at is null;

  select count(*)
  into v_change_orders_count
  from public.change_orders
  where project_id = p_project_id
    and deleted_at is null;

  select count(*)
  into v_inspections_count
  from public.inspections
  where project_id = p_project_id
    and deleted_at is null;

  return jsonb_build_object(
    'project', jsonb_build_object(
      'id', v_project.id,
      'organization_id', v_project.organization_id,
      'name', v_project.name,
      'description', v_project.description,
      'status', v_project.status,
      'start_date', v_project.start_date,
      'end_date', v_project.end_date,
      'created_at', v_project.created_at,
      'updated_at', v_project.updated_at
    ),
    'wbs', jsonb_build_object(
      'total_count', v_wbs_total,
      'items', v_wbs
    ),
    'line_items', jsonb_build_object(
      'total_count', v_line_items_total,
      'items', v_line_items
    ),
    'counts', jsonb_build_object(
      'issues', v_issues_count,
      'change_orders', v_change_orders_count,
      'inspections', v_inspections_count
    )
  );
end;
$$;


--
-- Name: set_my_notification_settings(public.notification_category[], text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_my_notification_settings(p_silenced_categories public.notification_category[] DEFAULT '{}'::public.notification_category[], p_silenced_events text[] DEFAULT '{}'::text[]) RETURNS SETOF public.user_notification_settings
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_row public.user_notification_settings;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated' USING errcode = '42501';
  END IF;

  INSERT INTO public.user_notification_settings (
    user_id,
    silenced_categories,
    silenced_events,
    updated_at
  )
  VALUES (
    v_user_id,
    COALESCE(p_silenced_categories, '{}'::public.notification_category[]),
    COALESCE(p_silenced_events, '{}'::text[]),
    now()
  )
  ON CONFLICT (user_id) DO UPDATE
  SET
    silenced_categories = EXCLUDED.silenced_categories,
    silenced_events = EXCLUDED.silenced_events,
    updated_at = now()
  RETURNING * INTO v_row;

  RETURN NEXT v_row;
END;
$$;


--
-- Name: set_my_primary_organization(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_my_primary_organization(p_organization_id uuid) RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_profile public.profiles;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_organization_id IS NULL THEN
    RAISE EXCEPTION 'organization_id is required';
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.profile_id = v_user_id
      AND om.organization_id = p_organization_id
      AND om.deleted_at IS NULL
  ) THEN
    RAISE EXCEPTION 'Not a member of the selected organization'
      USING ERRCODE = '42501';
  END IF;

  UPDATE public.profiles p
  SET
    organization_id = p_organization_id,
    updated_at = now()
  WHERE p.id = v_user_id
  RETURNING * INTO v_profile;

  RETURN v_profile;
END;
$$;


--
-- Name: set_org_member_job_title(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_org_member_job_title(p_org_id uuid, p_profile_id uuid, p_job_title_id uuid) RETURNS public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_global_role public.user_role_type;
  v_actor_permission_role public.org_role;
  v_membership_id uuid;
  v_profile public.profiles;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_org_id IS NULL OR p_profile_id IS NULL OR p_job_title_id IS NULL THEN
    RAISE EXCEPTION 'Missing required inputs';
  END IF;

  SELECT p.role
  INTO v_global_role
  FROM public.profiles p
  WHERE p.id = v_user_id
    AND p.deleted_at IS NULL;

  IF v_global_role IS NULL THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  IF v_global_role <> 'system_admin' THEN
    SELECT om.permission_role
    INTO v_actor_permission_role
    FROM public.organization_members om
    WHERE om.organization_id = p_org_id
      AND om.profile_id = v_user_id
      AND om.deleted_at IS NULL
    ORDER BY om.created_at DESC
    LIMIT 1;

    IF v_actor_permission_role IS NULL THEN
      RAISE EXCEPTION 'Access denied' USING errcode = '42501';
    END IF;

    IF v_actor_permission_role::text NOT IN ('admin', 'hr', 'owner') THEN
      RAISE EXCEPTION 'Access denied' USING errcode = '42501';
    END IF;
  END IF;

  IF NOT EXISTS (
    SELECT 1
    FROM public.job_titles jt
    WHERE jt.id = p_job_title_id
      AND jt.deleted_at IS NULL
  ) THEN
    RAISE EXCEPTION 'Job title not found' USING errcode = 'P0001';
  END IF;

  SELECT om.id
  INTO v_membership_id
  FROM public.organization_members om
  WHERE om.organization_id = p_org_id
    AND om.profile_id = p_profile_id
    AND om.deleted_at IS NULL
  ORDER BY om.created_at DESC
  LIMIT 1;

  IF v_membership_id IS NULL THEN
    RAISE EXCEPTION 'Target is not an active member of this organization' USING errcode = 'P0001';
  END IF;

  UPDATE public.organization_members om
  SET job_title_id = p_job_title_id,
      updated_at = now()
  WHERE om.id = v_membership_id;

  SELECT *
  INTO v_profile
  FROM public.profiles p
  WHERE p.id = p_profile_id
    AND p.deleted_at IS NULL;

  IF v_profile.id IS NULL THEN
    RAISE EXCEPTION 'Target profile not found' USING errcode = 'P0001';
  END IF;

  RETURN v_profile;
END;
$$;


--
-- Name: set_org_member_role(uuid, uuid, public.org_role); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_org_member_role(p_org_id uuid, p_profile_id uuid, p_role public.org_role) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_global_role public.user_role_type;
  v_actor_permission_role public.org_role;
  v_target_permission_role public.org_role;
  v_actor_name text;
  v_target_name text;
  v_org_name text;
  v_member record;
BEGIN
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  IF p_org_id IS NULL OR p_profile_id IS NULL OR p_role IS NULL THEN
    RAISE EXCEPTION 'Missing required inputs';
  END IF;

  SELECT p.role
  INTO v_global_role
  FROM public.profiles p
  WHERE p.id = v_user_id
    AND p.deleted_at IS NULL;

  IF v_global_role IS NULL THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  IF v_global_role <> 'system_admin' THEN
    SELECT om.permission_role
    INTO v_actor_permission_role
    FROM public.organization_members om
    WHERE om.organization_id = p_org_id
      AND om.profile_id = v_user_id
      AND om.deleted_at IS NULL
    ORDER BY om.created_at DESC
    LIMIT 1;

    IF v_actor_permission_role IS NULL
       OR v_actor_permission_role::text NOT IN ('admin', 'hr', 'owner') THEN
      RAISE EXCEPTION 'Access denied' USING errcode = '42501';
    END IF;
  END IF;

  SELECT om.permission_role
  INTO v_target_permission_role
  FROM public.organization_members om
  WHERE om.organization_id = p_org_id
    AND om.profile_id = p_profile_id
    AND om.deleted_at IS NULL
  ORDER BY om.created_at DESC
  LIMIT 1;

  IF v_target_permission_role IS NULL THEN
    RAISE EXCEPTION 'Target is not an active member of this organization' USING errcode = 'P0001';
  END IF;

  IF v_target_permission_role = 'owner'
     AND v_global_role <> 'system_admin'
     AND COALESCE(v_actor_permission_role::text, '') <> 'owner' THEN
    RAISE EXCEPTION 'Access denied: only owners can change owner roles' USING errcode = '42501';
  END IF;

  IF v_target_permission_role = p_role THEN
    RETURN;
  END IF;

  UPDATE public.organization_members
  SET permission_role = p_role,
      updated_at = now()
  WHERE organization_id = p_org_id
    AND profile_id = p_profile_id
    AND deleted_at IS NULL;

  SELECT p.full_name INTO v_actor_name FROM public.profiles p WHERE p.id = v_user_id;
  SELECT p.full_name INTO v_target_name FROM public.profiles p WHERE p.id = p_profile_id;
  SELECT o.name INTO v_org_name FROM public.organizations o WHERE o.id = p_org_id;

  -- Personal notification to affected member.
  PERFORM public.insert_notifications(
    jsonb_build_object(
      'user_id', p_profile_id,
      'organization_id', p_org_id,
      'category', 'workflow_update',
      'message',
        'Your role in ' || COALESCE(v_org_name, 'this organization')
        || ' has been changed from '
        || INITCAP(REPLACE(v_target_permission_role::text, '_', ' '))
        || ' to '
        || INITCAP(REPLACE(p_role::text, '_', ' '))
        || '.',
      'payload', jsonb_build_object(
        'event', 'member_permission_role_changed',
        'organization_id', p_org_id,
        'organization_name', v_org_name,
        'affected_profile_id', p_profile_id,
        'affected_profile_name', v_target_name,
        'previous_permission_role', v_target_permission_role,
        'updated_permission_role', p_role,
        'changed_by_profile_id', v_user_id,
        'changed_by_name', COALESCE(v_actor_name, 'Organization Admin'),
        'changed_at', now()
      )
    )
  );

  -- Org-wide notifications to everyone else (including acting owner when different from target).
  FOR v_member IN
    SELECT om.profile_id
    FROM public.organization_members om
    WHERE om.organization_id = p_org_id
      AND om.deleted_at IS NULL
      AND om.profile_id <> p_profile_id
  LOOP
    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', v_member.profile_id,
        'organization_id', p_org_id,
        'category', 'workflow_update',
        'message',
          COALESCE(v_target_name, p_profile_id::text)
          || '''s role was changed from '
          || INITCAP(REPLACE(v_target_permission_role::text, '_', ' '))
          || ' to '
          || INITCAP(REPLACE(p_role::text, '_', ' '))
          || '.',
        'payload', jsonb_build_object(
          'event', 'member_permission_role_changed',
          'organization_id', p_org_id,
          'organization_name', v_org_name,
          'affected_profile_id', p_profile_id,
          'affected_profile_name', v_target_name,
          'previous_permission_role', v_target_permission_role,
          'updated_permission_role', p_role,
          'changed_by_profile_id', v_user_id,
          'changed_by_name', COALESCE(v_actor_name, 'Organization Admin'),
          'changed_at', now()
        )
      )
    );
  END LOOP;
END;
$$;


--
-- Name: set_org_notification_settings(uuid, public.notification_category[], text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_org_notification_settings(p_organization_id uuid, p_enabled_categories public.notification_category[] DEFAULT ARRAY['workflow_update'::public.notification_category, 'approval_needed'::public.notification_category, 'bid_received'::public.notification_category], p_enabled_events text[] DEFAULT ARRAY['member_added'::text, 'member_removed'::text, 'member_left_organization'::text, 'member_rejoined_organization'::text, 'contract_completed'::text, 'bid_accepted'::text, 'new_project_created'::text, 'member_job_title_changed'::text, 'member_job_title_changed_broadcast'::text, 'member_permission_role_changed'::text]) RETURNS SETOF public.organization_notification_settings
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_row public.organization_notification_settings;
BEGIN
  IF NOT public.can_edit_org_notification_settings(p_organization_id) THEN
    RAISE EXCEPTION 'Access denied for organization notification settings'
      USING errcode = '42501';
  END IF;

  INSERT INTO public.organization_notification_settings (
    organization_id,
    enabled_categories,
    enabled_events,
    updated_by,
    updated_at
  )
  VALUES (
    p_organization_id,
    COALESCE(p_enabled_categories, '{}'::public.notification_category[]),
    COALESCE(p_enabled_events, '{}'::text[]),
    auth.uid(),
    now()
  )
  ON CONFLICT (organization_id) DO UPDATE
  SET
    enabled_categories = EXCLUDED.enabled_categories,
    enabled_events = EXCLUDED.enabled_events,
    updated_by = auth.uid(),
    updated_at = now()
  RETURNING * INTO v_row;

  RETURN NEXT v_row;
END;
$$;


--
-- Name: set_updated_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.set_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'pg_catalog', 'public'
    AS $$
BEGIN
  IF TG_OP = 'UPDATE' THEN
    NEW.updated_at := now();
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: touch_created_at(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.touch_created_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO 'pg_catalog', 'public'
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    NEW.created_at := now();
  END IF;
  RETURN NEW;
END;
$$;


--
-- Name: try_parse_uuid(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.try_parse_uuid(p_text text) RETURNS uuid
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  v_uuid uuid;
BEGIN
  IF p_text IS NULL OR btrim(p_text) = '' THEN
    RETURN NULL;
  END IF;

  BEGIN
    v_uuid := p_text::uuid;
    RETURN v_uuid;
  EXCEPTION WHEN others THEN
    RETURN NULL;
  END;
END;
$$;


--
-- Name: update_accounts_payable(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_accounts_payable(_id uuid, _input jsonb) RETURNS SETOF public.accounts_payable
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.accounts_payable;
        _new_row public.accounts_payable;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.accounts_payable := (jsonb_populate_record(NULL::public.accounts_payable, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.accounts_payable WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','accounts_payable', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.accounts_payable
           SET amount_due = COALESCE(_row.amount_due, amount_due), due_date = COALESCE(_row.due_date, due_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_accounts_receivable(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_accounts_receivable(_id uuid, _input jsonb) RETURNS SETOF public.accounts_receivable
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.accounts_receivable;
        _new_row public.accounts_receivable;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.accounts_receivable := (jsonb_populate_record(NULL::public.accounts_receivable, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.accounts_receivable WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','accounts_receivable', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.accounts_receivable
           SET amount_due = COALESCE(_row.amount_due, amount_due), due_date = COALESCE(_row.due_date, due_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_activity_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_activity_logs(_id uuid, _input jsonb) RETURNS SETOF public.activity_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.activity_logs;
        _new_row public.activity_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.activity_logs := (jsonb_populate_record(NULL::public.activity_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.activity_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','activity_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.activity_logs
           SET profile_id = COALESCE(_row.profile_id, profile_id), activity_type = COALESCE(_row.activity_type, activity_type), activity_at = COALESCE(_row.activity_at, activity_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_asphalt_types(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_asphalt_types(_id uuid, _input jsonb) RETURNS SETOF public.asphalt_types
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.asphalt_types;
        _new_row public.asphalt_types;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.asphalt_types := (jsonb_populate_record(NULL::public.asphalt_types, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.asphalt_types WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','asphalt_types', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.asphalt_types
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_audit_log(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_audit_log(_id uuid, _input jsonb) RETURNS SETOF public.audit_log
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.audit_log;
      _new_row public.audit_log;
      _row     public.audit_log := (jsonb_populate_record(NULL::public.audit_log, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      SELECT * INTO _old_row FROM public.audit_log WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('update','audit_log', NULL, NULL);

      UPDATE public.audit_log
         SET table_name = COALESCE(_row.table_name, table_name),
             action = COALESCE(_row.action, action),
             row_id = COALESCE(_row.row_id, row_id),
             before_data = COALESCE(_row.before_data, before_data),
             after_data = COALESCE(_row.after_data, after_data)
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- Name: update_audit_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_audit_logs(_id uuid, _input jsonb) RETURNS SETOF public.audit_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.audit_logs;
        _new_row public.audit_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.audit_logs := (jsonb_populate_record(NULL::public.audit_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.audit_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','audit_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.audit_logs
           SET action = COALESCE(_row.action, action), performed_by = COALESCE(_row.performed_by, performed_by), performed_at = COALESCE(_row.performed_at, performed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_avatars(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_avatars(_id uuid, _input jsonb) RETURNS SETOF public.avatars
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.avatars;
        _new_row public.avatars;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.avatars := (jsonb_populate_record(NULL::public.avatars, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.avatars WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','avatars', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.avatars
           SET url = COALESCE(_row.url, url), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_bid_packages(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bid_packages(_id uuid, _input jsonb) RETURNS SETOF public.bid_packages
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.bid_packages;
        _new_row public.bid_packages;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bid_packages := (jsonb_populate_record(NULL::public.bid_packages, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bid_packages WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bid_packages', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bid_packages
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_bid_vendors(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bid_vendors(_id uuid, _input jsonb) RETURNS SETOF public.bid_vendors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.bid_vendors;
        _new_row public.bid_vendors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bid_vendors := (jsonb_populate_record(NULL::public.bid_vendors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bid_vendors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bid_vendors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bid_vendors
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), invited_at = COALESCE(_row.invited_at, invited_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_bids(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bids(_id uuid, _input jsonb) RETURNS SETOF public.bids
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.bids;
        _new_row public.bids;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bids := (jsonb_populate_record(NULL::public.bids, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bids WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bids', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bids
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), amount = COALESCE(_row.amount, amount), submitted_at = COALESCE(_row.submitted_at, submitted_at), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_bim_models(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_bim_models(_id uuid, _input jsonb) RETURNS SETOF public.bim_models
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.bim_models;
        _new_row public.bim_models;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.bim_models := (jsonb_populate_record(NULL::public.bim_models, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.bim_models WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','bim_models', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.bim_models
           SET name = COALESCE(_row.name, name), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_certifications(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_certifications(_id uuid, _input jsonb) RETURNS SETOF public.certifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.certifications;
        _new_row public.certifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.certifications := (jsonb_populate_record(NULL::public.certifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.certifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','certifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.certifications
           SET employee_id = COALESCE(_row.employee_id, employee_id), certification_type = COALESCE(_row.certification_type, certification_type), issue_date = COALESCE(_row.issue_date, issue_date), expiry_date = COALESCE(_row.expiry_date, expiry_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_change_orders(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_change_orders(_id uuid, _input jsonb) RETURNS SETOF public.change_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.change_orders;
        _new_row public.change_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.change_orders := (jsonb_populate_record(NULL::public.change_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.change_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','change_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.change_orders
           SET number = COALESCE(_row.number, number), description = COALESCE(_row.description, description), status = COALESCE(_row.status, status), amount = COALESCE(_row.amount, amount), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_commitments(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_commitments(_id uuid, _input jsonb) RETURNS SETOF public.commitments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.commitments;
        _new_row public.commitments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.commitments := (jsonb_populate_record(NULL::public.commitments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.commitments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','commitments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.commitments
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), type = COALESCE(_row.type, type), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_compliance_checks(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_compliance_checks(_id uuid, _input jsonb) RETURNS SETOF public.compliance_checks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.compliance_checks;
        _new_row public.compliance_checks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.compliance_checks := (jsonb_populate_record(NULL::public.compliance_checks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.compliance_checks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','compliance_checks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.compliance_checks
           SET check_date = COALESCE(_row.check_date, check_date), description = COALESCE(_row.description, description), result = COALESCE(_row.result, result), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_compliance_tracking(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_compliance_tracking(_id uuid, _input jsonb) RETURNS SETOF public.compliance_tracking
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.compliance_tracking;
        _new_row public.compliance_tracking;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.compliance_tracking := (jsonb_populate_record(NULL::public.compliance_tracking, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.compliance_tracking WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','compliance_tracking', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.compliance_tracking
           SET tracking_type = COALESCE(_row.tracking_type, tracking_type), status = COALESCE(_row.status, status), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_cost_codes(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_cost_codes(_id uuid, _input jsonb) RETURNS SETOF public.cost_codes
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.cost_codes;
        _new_row public.cost_codes;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.cost_codes := (jsonb_populate_record(NULL::public.cost_codes, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.cost_codes WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','cost_codes', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.cost_codes
           SET code = COALESCE(_row.code, code), description = COALESCE(_row.description, description), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_crew_assignments(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_crew_assignments(_id uuid, _input jsonb) RETURNS SETOF public.crew_assignments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.crew_assignments;
        _new_row public.crew_assignments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crew_assignments := (jsonb_populate_record(NULL::public.crew_assignments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crew_assignments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crew_assignments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crew_assignments
           SET crew_id = COALESCE(_row.crew_id, crew_id), profile_id = COALESCE(_row.profile_id, profile_id), assigned_date = COALESCE(_row.assigned_date, assigned_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_crew_members(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_crew_members(_id uuid, _input jsonb) RETURNS SETOF public.crew_members
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.crew_members;
        _new_row public.crew_members;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crew_members := (jsonb_populate_record(NULL::public.crew_members, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crew_members WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crew_members', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crew_members
           SET crew_id = COALESCE(_row.crew_id, crew_id), profile_id = COALESCE(_row.profile_id, profile_id), role = COALESCE(_row.role, role), start_date = COALESCE(_row.start_date, start_date), end_date = COALESCE(_row.end_date, end_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_crews(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_crews(_id uuid, _input jsonb) RETURNS SETOF public.crews
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.crews;
        _new_row public.crews;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.crews := (jsonb_populate_record(NULL::public.crews, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.crews WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','crews', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.crews
           SET name = COALESCE(_row.name, name), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_daily_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_daily_logs(_id uuid, _input jsonb) RETURNS SETOF public.daily_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.daily_logs;
        _new_row public.daily_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.daily_logs := (jsonb_populate_record(NULL::public.daily_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.daily_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','daily_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.daily_logs
           SET date = COALESCE(_row.date, date), weather = COALESCE(_row.weather, weather), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_dashboard_configs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_dashboard_configs(_id uuid, _input jsonb) RETURNS SETOF public.dashboard_configs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.dashboard_configs;
        _new_row public.dashboard_configs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.dashboard_configs := (jsonb_populate_record(NULL::public.dashboard_configs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.dashboard_configs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','dashboard_configs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.dashboard_configs
           SET profile_id = COALESCE(_row.profile_id, profile_id), config = COALESCE(_row.config, config), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_document_references(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_document_references(_id uuid, _input jsonb) RETURNS SETOF public.document_references
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.document_references;
        _new_row public.document_references;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.document_references := (jsonb_populate_record(NULL::public.document_references, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.document_references WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','document_references', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.document_references
           SET document_id = COALESCE(_row.document_id, document_id), reference_type = COALESCE(_row.reference_type, reference_type), reference_id = COALESCE(_row.reference_id, reference_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_documents(_id uuid, _input jsonb) RETURNS SETOF public.documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.documents;
        _new_row public.documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.documents := (jsonb_populate_record(NULL::public.documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.documents
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), url = COALESCE(_row.url, url), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_drawing_versions(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_drawing_versions(_id uuid, _input jsonb) RETURNS SETOF public.drawing_versions
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.drawing_versions;
        _new_row public.drawing_versions;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.drawing_versions := (jsonb_populate_record(NULL::public.drawing_versions, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.drawing_versions WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','drawing_versions', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.drawing_versions
           SET document_id = COALESCE(_row.document_id, document_id), version = COALESCE(_row.version, version), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_dump_trucks(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_dump_trucks(_id uuid, _input jsonb) RETURNS SETOF public.dump_trucks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.dump_trucks;
        _new_row public.dump_trucks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.dump_trucks := (jsonb_populate_record(NULL::public.dump_trucks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.dump_trucks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','dump_trucks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.dump_trucks
           SET make = COALESCE(_row.make, make), model = COALESCE(_row.model, model), capacity = COALESCE(_row.capacity, capacity), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_employees(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_employees(_id uuid, _input jsonb) RETURNS SETOF public.employees
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.employees;
        _new_row public.employees;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.employees := (jsonb_populate_record(NULL::public.employees, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.employees WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','employees', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.employees
           SET profile_id = COALESCE(_row.profile_id, profile_id), hire_date = COALESCE(_row.hire_date, hire_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_equipment(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_equipment(_id uuid, _input jsonb) RETURNS SETOF public.equipment
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.equipment;
        _new_row public.equipment;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment := (jsonb_populate_record(NULL::public.equipment, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), model = COALESCE(_row.model, model), serial_number = COALESCE(_row.serial_number, serial_number), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_equipment_assignments(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_equipment_assignments(_id uuid, _input jsonb) RETURNS SETOF public.equipment_assignments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.equipment_assignments;
        _new_row public.equipment_assignments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_assignments := (jsonb_populate_record(NULL::public.equipment_assignments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_assignments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_assignments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_assignments
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), assigned_to = COALESCE(_row.assigned_to, assigned_to), assigned_date = COALESCE(_row.assigned_date, assigned_date), released_date = COALESCE(_row.released_date, released_date), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_equipment_maintenance(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_equipment_maintenance(_id uuid, _input jsonb) RETURNS SETOF public.equipment_maintenance
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.equipment_maintenance;
        _new_row public.equipment_maintenance;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_maintenance := (jsonb_populate_record(NULL::public.equipment_maintenance, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_maintenance WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_maintenance', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_maintenance
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), maintenance_date = COALESCE(_row.maintenance_date, maintenance_date), type = COALESCE(_row.type, type), description = COALESCE(_row.description, description), performed_by = COALESCE(_row.performed_by, performed_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_equipment_usage(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_equipment_usage(_id uuid, _input jsonb) RETURNS SETOF public.equipment_usage
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.equipment_usage;
        _new_row public.equipment_usage;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.equipment_usage := (jsonb_populate_record(NULL::public.equipment_usage, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.equipment_usage WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','equipment_usage', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.equipment_usage
           SET equipment_id = COALESCE(_row.equipment_id, equipment_id), date = COALESCE(_row.date, date), hours_used = COALESCE(_row.hours_used, hours_used), quantity = COALESCE(_row.quantity, quantity), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_estimate_line_items(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_estimate_line_items(_id uuid, _input jsonb) RETURNS SETOF public.estimate_line_items
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.estimate_line_items;
        _new_row public.estimate_line_items;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.estimate_line_items := (jsonb_populate_record(NULL::public.estimate_line_items, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.estimate_line_items WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','estimate_line_items', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.estimate_line_items
           SET estimate_id = COALESCE(_row.estimate_id, estimate_id), cost_code_id = COALESCE(_row.cost_code_id, cost_code_id), name = COALESCE(_row.name, name), unit_measure = COALESCE(_row.unit_measure, unit_measure), quantity = COALESCE(_row.quantity, quantity), unit_price = COALESCE(_row.unit_price, unit_price), total_cost = COALESCE(_row.total_cost, total_cost), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_estimates(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_estimates(_id uuid, _input jsonb) RETURNS SETOF public.estimates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.estimates;
        _new_row public.estimates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.estimates := (jsonb_populate_record(NULL::public.estimates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.estimates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','estimates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.estimates
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_financial_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_financial_documents(_id uuid, _input jsonb) RETURNS SETOF public.financial_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.financial_documents;
        _new_row public.financial_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.financial_documents := (jsonb_populate_record(NULL::public.financial_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.financial_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','financial_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.financial_documents
           SET document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_general_ledger(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_general_ledger(_id uuid, _input jsonb) RETURNS SETOF public.general_ledger
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.general_ledger;
        _new_row public.general_ledger;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.general_ledger := (jsonb_populate_record(NULL::public.general_ledger, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.general_ledger WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','general_ledger', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.general_ledger
           SET entry_date = COALESCE(_row.entry_date, entry_date), description = COALESCE(_row.description, description), debit = COALESCE(_row.debit, debit), credit = COALESCE(_row.credit, credit), balance = COALESCE(_row.balance, balance), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_hr_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_hr_documents(_id uuid, _input jsonb) RETURNS SETOF public.hr_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.hr_documents;
        _new_row public.hr_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.hr_documents := (jsonb_populate_record(NULL::public.hr_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.hr_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','hr_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.hr_documents
           SET employee_id = COALESCE(_row.employee_id, employee_id), document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_inspections(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_inspections(_id uuid, _input jsonb) RETURNS SETOF public.inspections
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.inspections;
        _new_row public.inspections;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.inspections := (jsonb_populate_record(NULL::public.inspections, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.inspections WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','inspections', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.inspections
           SET name = COALESCE(_row.name, name), inspection_type = COALESCE(_row.inspection_type, inspection_type), date = COALESCE(_row.date, date), status = COALESCE(_row.status, status), result = COALESCE(_row.result, result), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_integration_tokens(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_integration_tokens(_id uuid, _input jsonb) RETURNS SETOF public.integration_tokens
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.integration_tokens;
        _new_row public.integration_tokens;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.integration_tokens := (jsonb_populate_record(NULL::public.integration_tokens, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.integration_tokens WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','integration_tokens', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.integration_tokens
           SET profile_id = COALESCE(_row.profile_id, profile_id), service_name = COALESCE(_row.service_name, service_name), token = COALESCE(_row.token, token), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_inventory_transactions(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_inventory_transactions(_id uuid, _input jsonb) RETURNS SETOF public.inventory_transactions
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.inventory_transactions;
        _new_row public.inventory_transactions;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.inventory_transactions := (jsonb_populate_record(NULL::public.inventory_transactions, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.inventory_transactions WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','inventory_transactions', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.inventory_transactions
           SET material_id = COALESCE(_row.material_id, material_id), transaction_type = COALESCE(_row.transaction_type, transaction_type), quantity = COALESCE(_row.quantity, quantity), transaction_date = COALESCE(_row.transaction_date, transaction_date), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_issues(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_issues(_id uuid, _input jsonb) RETURNS SETOF public.issues
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.issues;
        _new_row public.issues;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.issues := (jsonb_populate_record(NULL::public.issues, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.issues WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','issues', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.issues
           SET name = COALESCE(_row.name, name), type = COALESCE(_row.type, type), status = COALESCE(_row.status, status), reported_by = COALESCE(_row.reported_by, reported_by), description = COALESCE(_row.description, description), resolved = COALESCE(_row.resolved, resolved), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_job_titles(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_job_titles(_id uuid, _input jsonb) RETURNS SETOF public.job_titles
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.job_titles;
        _new_row public.job_titles;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.job_titles := (jsonb_populate_record(NULL::public.job_titles, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.job_titles WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','job_titles', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.job_titles
           SET name = COALESCE(_row.name, name), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_labor_records(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_labor_records(_id uuid, _input jsonb) RETURNS SETOF public.labor_records
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.labor_records;
        _new_row public.labor_records;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.labor_records := (jsonb_populate_record(NULL::public.labor_records, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.labor_records WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','labor_records', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.labor_records
           SET line_item_id = COALESCE(_row.line_item_id, line_item_id), worker_count = COALESCE(_row.worker_count, worker_count), hours_worked = COALESCE(_row.hours_worked, hours_worked), work_date = COALESCE(_row.work_date, work_date), work_type = COALESCE(_row.work_type, work_type), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_line_item_entries(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_line_item_entries(_id uuid, _input jsonb) RETURNS SETOF public.line_item_entries
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.line_item_entries;
        _new_row public.line_item_entries;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_item_entries := (jsonb_populate_record(NULL::public.line_item_entries, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_item_entries WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_item_entries', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_item_entries
           SET line_item_id = COALESCE(_row.line_item_id, line_item_id), date = COALESCE(_row.date, date), quantity_completed = COALESCE(_row.quantity_completed, quantity_completed), notes = COALESCE(_row.notes, notes), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_line_item_templates(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_line_item_templates(_id uuid, _input jsonb) RETURNS SETOF public.line_item_templates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.line_item_templates;
        _new_row public.line_item_templates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_item_templates := (jsonb_populate_record(NULL::public.line_item_templates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_item_templates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_item_templates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_item_templates
           SET name = COALESCE(_row.name, name), formula = COALESCE(_row.formula, formula), variables = COALESCE(_row.variables, variables), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_line_items(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_line_items(_id uuid, _input jsonb) RETURNS SETOF public.line_items
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.line_items;
        _new_row public.line_items;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.line_items := (jsonb_populate_record(NULL::public.line_items, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.line_items WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','line_items', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.line_items
           SET map_id = COALESCE(_row.map_id, map_id), wbs_id = COALESCE(_row.wbs_id, wbs_id), cost_code_id = COALESCE(_row.cost_code_id, cost_code_id), template_id = COALESCE(_row.template_id, template_id), name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), unit_measure = COALESCE(_row.unit_measure, unit_measure), quantity = COALESCE(_row.quantity, quantity), unit_price = COALESCE(_row.unit_price, unit_price), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_maps(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_maps(_id uuid, _input jsonb) RETURNS SETOF public.maps
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.maps;
        _new_row public.maps;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.maps := (jsonb_populate_record(NULL::public.maps, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.maps WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','maps', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.maps
           SET wbs_id = COALESCE(_row.wbs_id, wbs_id), name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), coordinates = COALESCE(_row.coordinates, coordinates), scope = COALESCE(_row.scope, scope), order_num = COALESCE(_row.order_num, order_num), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_material_inventory(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_material_inventory(_id uuid, _input jsonb) RETURNS SETOF public.material_inventory
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.material_inventory;
        _new_row public.material_inventory;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_inventory := (jsonb_populate_record(NULL::public.material_inventory, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_inventory WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_inventory', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_inventory
           SET material_id = COALESCE(_row.material_id, material_id), quantity = COALESCE(_row.quantity, quantity), last_updated = COALESCE(_row.last_updated, last_updated), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_material_orders(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_material_orders(_id uuid, _input jsonb) RETURNS SETOF public.material_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.material_orders;
        _new_row public.material_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_orders := (jsonb_populate_record(NULL::public.material_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_orders
           SET material_id = COALESCE(_row.material_id, material_id), order_date = COALESCE(_row.order_date, order_date), quantity = COALESCE(_row.quantity, quantity), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_material_receipts(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_material_receipts(_id uuid, _input jsonb) RETURNS SETOF public.material_receipts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.material_receipts;
        _new_row public.material_receipts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.material_receipts := (jsonb_populate_record(NULL::public.material_receipts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.material_receipts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','material_receipts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.material_receipts
           SET material_order_id = COALESCE(_row.material_order_id, material_order_id), received_date = COALESCE(_row.received_date, received_date), quantity = COALESCE(_row.quantity, quantity), received_by = COALESCE(_row.received_by, received_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_materials(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_materials(_id uuid, _input jsonb) RETURNS SETOF public.materials
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.materials;
        _new_row public.materials;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.materials := (jsonb_populate_record(NULL::public.materials, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.materials WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','materials', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.materials
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), unit = COALESCE(_row.unit, unit), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_meeting_minutes(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_meeting_minutes(_id uuid, _input jsonb) RETURNS SETOF public.meeting_minutes
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.meeting_minutes;
        _new_row public.meeting_minutes;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.meeting_minutes := (jsonb_populate_record(NULL::public.meeting_minutes, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.meeting_minutes WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','meeting_minutes', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.meeting_minutes
           SET meeting_date = COALESCE(_row.meeting_date, meeting_date), notes = COALESCE(_row.notes, notes), created_by = COALESCE(_row.created_by, created_by), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_my_organization(jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_my_organization(_input jsonb) RETURNS SETOF public.organizations
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    DECLARE
      v_profile public.profiles;
      v_org public.organizations;
      v_row public.organizations := (jsonb_populate_record(NULL::public.organizations, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      IF auth.uid() IS NULL THEN
        RAISE EXCEPTION 'not authenticated';
      END IF;

      SELECT * INTO v_profile FROM public.profiles WHERE id = auth.uid();
      IF v_profile IS NULL THEN
        RAISE EXCEPTION 'profile not found' USING DETAIL = jsonb_build_object('id', auth.uid());
      END IF;

      IF v_profile.role IS DISTINCT FROM 'system_admin' AND v_profile.role IS DISTINCT FROM 'org_admin' AND v_profile.role IS DISTINCT FROM 'org_supervisor' THEN
        RAISE EXCEPTION 'Access denied: role % cannot update organizations', v_profile.role;
      END IF;

      IF v_profile.organization_id IS NULL THEN
        RAISE EXCEPTION 'organization not found for user %', auth.uid();
      END IF;

      SELECT * INTO v_org FROM public.organizations WHERE id = v_profile.organization_id;
      IF v_org IS NULL THEN
        RAISE EXCEPTION 'organization not found' USING DETAIL = jsonb_build_object('id', v_profile.organization_id);
      END IF;

      UPDATE public.organizations
         SET name = CASE WHEN _input ? 'name' THEN v_row.name ELSE name END,
             description = CASE WHEN _input ? 'description' THEN v_row.description ELSE description END,
             mission_statement = CASE WHEN _input ? 'mission_statement' THEN v_row.mission_statement ELSE mission_statement END,
             headquarters = CASE WHEN _input ? 'headquarters' THEN v_row.headquarters ELSE headquarters END,
             logo_url = CASE WHEN _input ? 'logo_url' THEN v_row.logo_url ELSE logo_url END,
             updated_at = now()
       WHERE id = v_profile.organization_id
       RETURNING * INTO v_org;

      RETURN NEXT v_org;
    END;
    $$;


--
-- Name: update_my_profile(text, text, uuid, public.user_role_type); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_my_profile(p_full_name text DEFAULT NULL::text, p_phone text DEFAULT NULL::text, p_avatar_id uuid DEFAULT NULL::uuid, p_role public.user_role_type DEFAULT NULL::public.user_role_type) RETURNS SETOF public.profiles
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
declare
  v_profile public.profiles;
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  select * into v_profile
  from public.profiles
  where id = auth.uid();

  if v_profile is null then
    raise exception 'profile not found' using detail = jsonb_build_object('id', auth.uid());
  end if;

  if p_role is not null and p_role = 'system_admin' and v_profile.role <> 'system_admin' then
    raise exception 'system_admin role cannot be assigned via onboarding';
  end if;

  update public.profiles
     set full_name = coalesce(p_full_name, full_name),
         phone = coalesce(p_phone, phone),
         avatar_id = coalesce(p_avatar_id, avatar_id),
         role = coalesce(p_role, role),
         updated_at = now()
   where id = v_profile.id
   returning * into v_profile;

  return next v_profile;
end;
$$;


--
-- Name: update_notifications(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_notifications(_id uuid, _input jsonb) RETURNS SETOF public.notifications
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _old_row public.notifications;
  _new_row public.notifications;
  _row public.notifications := (jsonb_populate_record(NULL::public.notifications, COALESCE(_input, '{}'::jsonb)));
BEGIN
  SELECT *
  INTO _old_row
  FROM public.notifications
  WHERE id = _id
    AND deleted_at IS NULL;

  IF _old_row IS NULL THEN
    RAISE EXCEPTION 'row not found'
      USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  IF _old_row.user_id <> auth.uid() THEN
    RAISE EXCEPTION 'Access denied for notification update'
      USING errcode = '42501';
  END IF;

  UPDATE public.notifications
  SET
    is_read = COALESCE(_row.is_read, is_read),
    category = COALESCE(_row.category, category),
    message = COALESCE(_row.message, message),
    payload = COALESCE(_row.payload, payload),
    updated_at = now()
  WHERE id = _id
    AND user_id = auth.uid()
    AND deleted_at IS NULL
  RETURNING * INTO _new_row;

  IF _new_row IS NULL THEN
    RAISE EXCEPTION 'row not found'
      USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  RETURN NEXT _new_row;
END;
$$;


--
-- Name: update_organization_invites(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_invites(_id uuid, _input jsonb) RETURNS SETOF public.organization_invites
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _old_row public.organization_invites;
  _new_row public.organization_invites;
  _row public.organization_invites := (jsonb_populate_record(NULL::public.organization_invites, COALESCE(_input, '{}'::jsonb)));
  _existing_membership_id uuid;
  _existing_membership_deleted_at timestamptz;
BEGIN
  SELECT * INTO _old_row FROM public.organization_invites WHERE id = _id;
  IF _old_row IS NULL THEN
    RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  PERFORM check_access('update','organization_invites', NULL, _old_row.organization_id);

  UPDATE public.organization_invites
     SET organization_id = COALESCE(_row.organization_id, organization_id),
         invited_profile_id = COALESCE(_row.invited_profile_id, invited_profile_id),
         invited_by_profile_id = COALESCE(_row.invited_by_profile_id, invited_by_profile_id),
         role = COALESCE(_row.role, role),
         status = COALESCE(_row.status, status),
         comment = COALESCE(_row.comment, comment),
         responded_at = COALESCE(_row.responded_at, now())
   WHERE id = _id
   RETURNING * INTO _new_row;

  IF _new_row.status = 'accepted' THEN
    SELECT m.id, m.deleted_at
    INTO _existing_membership_id, _existing_membership_deleted_at
    FROM public.organization_members m
    WHERE m.organization_id = _new_row.organization_id
      AND m.profile_id = _new_row.invited_profile_id
    LIMIT 1;

    IF _existing_membership_id IS NULL THEN
      INSERT INTO public.organization_members (
        organization_id, profile_id, permission_role, job_title_id, created_at, updated_at
      )
      VALUES (
        _new_row.organization_id,
        _new_row.invited_profile_id,
        COALESCE(_new_row.reviewed_permission_role, _new_row.requested_permission_role, 'worker'::public.org_role),
        COALESCE(_new_row.reviewed_job_title_id, _new_row.requested_job_title_id, _new_row.role),
        now(), now()
      );
    ELSIF _existing_membership_deleted_at IS NOT NULL THEN
      UPDATE public.organization_members m
      SET deleted_at = NULL,
          permission_role = COALESCE(COALESCE(_new_row.reviewed_permission_role, _new_row.requested_permission_role, 'worker'::public.org_role), m.permission_role),
          job_title_id = COALESCE(_new_row.reviewed_job_title_id, _new_row.requested_job_title_id, _new_row.role, m.job_title_id),
          updated_at = now()
      WHERE m.id = _existing_membership_id;
    ELSE
      UPDATE public.organization_members m
      SET permission_role = COALESCE(COALESCE(_new_row.reviewed_permission_role, _new_row.requested_permission_role, 'worker'::public.org_role), m.permission_role),
          job_title_id = COALESCE(_new_row.reviewed_job_title_id, _new_row.requested_job_title_id, _new_row.role, m.job_title_id),
          updated_at = now()
      WHERE m.id = _existing_membership_id;
    END IF;

    UPDATE public.profiles
    SET organization_id = _new_row.organization_id, updated_at = now()
    WHERE id = _new_row.invited_profile_id;

    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', _new_row.invited_profile_id,
        'organization_id', _new_row.organization_id,
        'category', 'general',
        'message', ('Your request to join organization ' || _new_row.organization_id || ' was approved'),
        'payload', jsonb_build_object(
          'invite_id', _new_row.id,
          'organization_id', _new_row.organization_id,
          'status', _new_row.status
        )
      )
    );
  ELSIF _new_row.status = 'declined' THEN
    PERFORM public.insert_notifications(
      jsonb_build_object(
        'user_id', _new_row.invited_profile_id,
        'organization_id', _new_row.organization_id,
        'category', 'general',
        'message', ('Your request to join organization ' || _new_row.organization_id || ' was declined'),
        'payload', jsonb_build_object(
          'invite_id', _new_row.id,
          'organization_id', _new_row.organization_id,
          'status', _new_row.status,
          'reason', _new_row.comment
        )
      )
    );
  END IF;

  RETURN NEXT _new_row;
END;
$$;


--
-- Name: update_organization_member_rates(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_member_rates(_id uuid, _input jsonb) RETURNS SETOF public.organization_member_rates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.organization_member_rates;
      _new_row public.organization_member_rates;
      _row     public.organization_member_rates := (jsonb_populate_record(NULL::public.organization_member_rates, COALESCE(_input, '{}'::jsonb)));
      _organization_id uuid;
    BEGIN
      SELECT * INTO _old_row FROM public.organization_member_rates WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      SELECT organization_id INTO _organization_id
        FROM public.organization_members
       WHERE id = _old_row.membership_id;

      PERFORM check_access('update','organization_member_rates', NULL, _organization_id);

      UPDATE public.organization_member_rates
         SET membership_id = COALESCE(_row.membership_id, membership_id),
             rate_type = COALESCE(_row.rate_type, rate_type),
             rate_amount = COALESCE(_row.rate_amount, rate_amount),
             effective_start = COALESCE(_row.effective_start, effective_start),
             effective_end = COALESCE(_row.effective_end, effective_end),
             updated_at = now()
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- Name: update_organization_members(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_members(_id uuid, _input jsonb) RETURNS SETOF public.organization_members
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _old_row public.organization_members;
  _new_row public.organization_members;
  _row     public.organization_members := (jsonb_populate_record(NULL::public.organization_members, COALESCE(_input, '{}'::jsonb)));
BEGIN
  SELECT * INTO _old_row FROM public.organization_members WHERE id = _id;
  IF _old_row IS NULL THEN
    RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  -- organization_members is org-scoped (no project_id column)
  PERFORM check_access('update','organization_members', NULL, _old_row.organization_id);

  UPDATE public.organization_members
     SET profile_id = COALESCE(_row.profile_id, profile_id),
         permission_role = COALESCE(_row.permission_role, permission_role),
         job_title_id = COALESCE(_row.job_title_id, job_title_id),
         updated_at = now()
   WHERE id = _id
   RETURNING * INTO _new_row;

  RETURN NEXT _new_row;
END;
$$;


--
-- Name: update_organization_notification_settings(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_notification_settings(_id uuid, _input jsonb) RETURNS SETOF public.organization_notification_settings
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_old public.organization_notification_settings;
  v_row public.organization_notification_settings;
BEGIN
  IF NOT public.can_edit_org_notification_settings(_id) THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  SELECT * INTO v_old
  FROM public.organization_notification_settings
  WHERE organization_id = _id;

  IF v_old IS NULL THEN
    RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  UPDATE public.organization_notification_settings
  SET
    enabled_categories = COALESCE(
      (SELECT ARRAY(
        SELECT value::public.notification_category
        FROM jsonb_array_elements_text(COALESCE(_input->'enabled_categories', to_jsonb(v_old.enabled_categories)))
      )),
      v_old.enabled_categories
    ),
    enabled_events = COALESCE(
      (SELECT ARRAY(
        SELECT value
        FROM jsonb_array_elements_text(COALESCE(_input->'enabled_events', to_jsonb(v_old.enabled_events)))
      )),
      v_old.enabled_events
    ),
    updated_by = auth.uid(),
    updated_at = now()
  WHERE organization_id = _id
  RETURNING * INTO v_row;

  RETURN NEXT v_row;
END;
$$;


--
-- Name: update_organization_projects(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_projects(_id uuid, _input jsonb) RETURNS SETOF public.organization_projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.organization_projects;
        _new_row public.organization_projects;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.organization_projects := (jsonb_populate_record(NULL::public.organization_projects, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.organization_projects WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','organization_projects', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.organization_projects
           SET updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_organization_service_areas(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organization_service_areas(_id uuid, _input jsonb) RETURNS SETOF public.organization_service_areas
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.organization_service_areas;
      _new_row public.organization_service_areas;
      _row     public.organization_service_areas := (jsonb_populate_record(NULL::public.organization_service_areas, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      SELECT * INTO _old_row FROM public.organization_service_areas WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('update','organization_service_areas', NULL, _old_row.organization_id);

      UPDATE public.organization_service_areas
         SET organization_id = COALESCE(_row.organization_id, organization_id),
             service_area_text = COALESCE(_row.service_area_text, service_area_text),
             updated_at = now()
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- Name: update_organizations(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_organizations(_id uuid, _input jsonb) RETURNS SETOF public.organizations
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    DECLARE
      _old_row public.organizations;
      _new_row public.organizations;
      _row     public.organizations := (jsonb_populate_record(NULL::public.organizations, COALESCE(_input, '{}'::jsonb)));
      _caller_role text;
      _caller_org_id uuid;
    BEGIN
      IF auth.uid() IS NULL THEN
        RAISE EXCEPTION 'not authenticated';
      END IF;

      SELECT role, organization_id INTO _caller_role, _caller_org_id
      FROM public.profiles
      WHERE id = auth.uid();

      IF _caller_role IS NULL THEN
        RAISE EXCEPTION 'Access denied: profile not found for user %', auth.uid();
      END IF;

      SELECT * INTO _old_row FROM public.organizations WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      IF _caller_role <> 'system_admin' THEN
        IF _caller_role <> 'org_admin' THEN
          RAISE EXCEPTION 'Access denied: role % cannot update organizations', _caller_role;
        END IF;
        IF _caller_org_id IS NULL OR _caller_org_id <> _old_row.id THEN
          RAISE EXCEPTION 'Access denied: you do not belong to organization %', _old_row.id;
        END IF;
      END IF;

        UPDATE public.organizations
         SET name = CASE WHEN _input ? 'name' THEN _row.name ELSE name END,
           description = CASE WHEN _input ? 'description' THEN _row.description ELSE description END,
           mission_statement = CASE WHEN _input ? 'mission_statement' THEN _row.mission_statement ELSE mission_statement END,
           headquarters = CASE WHEN _input ? 'headquarters' THEN _row.headquarters ELSE headquarters END,
           logo_url = CASE WHEN _input ? 'logo_url' THEN _row.logo_url ELSE logo_url END,
           updated_at = now()
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- Name: update_payments(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_payments(_id uuid, _input jsonb) RETURNS SETOF public.payments
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.payments;
        _new_row public.payments;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.payments := (jsonb_populate_record(NULL::public.payments, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.payments WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','payments', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.payments
           SET commitment_id = COALESCE(_row.commitment_id, commitment_id), amount = COALESCE(_row.amount, amount), paid_at = COALESCE(_row.paid_at, paid_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_payroll(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_payroll(_id uuid, _input jsonb) RETURNS SETOF public.payroll
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.payroll;
        _new_row public.payroll;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.payroll := (jsonb_populate_record(NULL::public.payroll, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.payroll WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','payroll', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.payroll
           SET employee_id = COALESCE(_row.employee_id, employee_id), pay_period_start = COALESCE(_row.pay_period_start, pay_period_start), pay_period_end = COALESCE(_row.pay_period_end, pay_period_end), gross_pay = COALESCE(_row.gross_pay, gross_pay), net_pay = COALESCE(_row.net_pay, net_pay), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_photos(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_photos(_id uuid, _input jsonb) RETURNS SETOF public.photos
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.photos;
        _new_row public.photos;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.photos := (jsonb_populate_record(NULL::public.photos, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.photos WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','photos', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.photos
           SET url = COALESCE(_row.url, url), caption = COALESCE(_row.caption, caption), uploaded_by = COALESCE(_row.uploaded_by, uploaded_by), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_prequalifications(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_prequalifications(_id uuid, _input jsonb) RETURNS SETOF public.prequalifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.prequalifications;
        _new_row public.prequalifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.prequalifications := (jsonb_populate_record(NULL::public.prequalifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.prequalifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','prequalifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.prequalifications
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), status = COALESCE(_row.status, status), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_procurement_workflows(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_procurement_workflows(_id uuid, _input jsonb) RETURNS SETOF public.procurement_workflows
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.procurement_workflows;
        _new_row public.procurement_workflows;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.procurement_workflows := (jsonb_populate_record(NULL::public.procurement_workflows, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.procurement_workflows WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','procurement_workflows', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.procurement_workflows
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_profile_contract_role(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_profile_contract_role(p_contract_id uuid, p_profile_id uuid, p_role text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
begin
  if auth.uid() is null then
    raise exception 'Not authenticated';
  end if;

  perform check_access('update','user_projects', p_contract_id, null);

  if p_role is null or trim(p_role) = '' then
    raise exception 'Role is required';
  end if;

  if lower(p_role) not in ('project_manager', 'admin', 'member', 'viewer') then
    raise exception 'Invalid contract role: %', p_role;
  end if;

  update public.user_projects
  set role = p_role,
      updated_at = now()
  where project_id = p_contract_id
    and user_id = p_profile_id
    and deleted_at is null;
end;
$$;


--
-- Name: update_profiles(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_profiles(_id uuid, _input jsonb) RETURNS SETOF public.profiles
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _old_row public.profiles;
  _new_row public.profiles;
  _row     public.profiles := (jsonb_populate_record(NULL::public.profiles, COALESCE(_input, '{}'::jsonb)));
BEGIN
  SELECT * INTO _old_row
  FROM public.profiles
  WHERE id = _id;

  IF _old_row IS NULL THEN
    RAISE EXCEPTION 'row not found'
      USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  -- FIX: profiles has no project_id; scope access by organization only.
  PERFORM check_access('update', 'profiles', NULL, _old_row.organization_id);

  UPDATE public.profiles
  SET
    email = COALESCE(_row.email, email),
    full_name = COALESCE(_row.full_name, full_name),
    phone = COALESCE(_row.phone, phone),
    job_title_id = COALESCE(_row.job_title_id, job_title_id),
    avatar_url = COALESCE(_row.avatar_url, avatar_url),
    role = COALESCE(_row.role, role),
    updated_at = now()
  WHERE id = _id
  RETURNING * INTO _new_row;

  RETURN NEXT _new_row;
END;
$$;


--
-- Name: update_progress_billings(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_progress_billings(_id uuid, _input jsonb) RETURNS SETOF public.progress_billings
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.progress_billings;
        _new_row public.progress_billings;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.progress_billings := (jsonb_populate_record(NULL::public.progress_billings, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.progress_billings WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','progress_billings', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.progress_billings
           SET billing_number = COALESCE(_row.billing_number, billing_number), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_project_inspectors(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_project_inspectors(_id uuid, _input jsonb) RETURNS SETOF public.project_inspectors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.project_inspectors;
        _new_row public.project_inspectors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.project_inspectors := (jsonb_populate_record(NULL::public.project_inspectors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.project_inspectors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','project_inspectors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.project_inspectors
           SET profile_id = COALESCE(_row.profile_id, profile_id), assigned_by = COALESCE(_row.assigned_by, assigned_by), assigned_at = COALESCE(_row.assigned_at, assigned_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_project_invites(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_project_invites(_id uuid, _input jsonb) RETURNS SETOF public.project_invites
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.project_invites;
      _new_row public.project_invites;
      _row     public.project_invites := (jsonb_populate_record(NULL::public.project_invites, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      SELECT * INTO _old_row FROM public.project_invites WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('update','project_invites', _old_row.project_id, NULL);

      UPDATE public.project_invites
         SET project_id = COALESCE(_row.project_id, project_id),
             invited_profile_id = COALESCE(_row.invited_profile_id, invited_profile_id),
             invited_by_profile_id = COALESCE(_row.invited_by_profile_id, invited_by_profile_id),
             status = COALESCE(_row.status, status),
             comment = COALESCE(_row.comment, comment),
             responded_at = COALESCE(_row.responded_at, responded_at)
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- Name: update_project_service_areas(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_project_service_areas(_id uuid, _input jsonb) RETURNS SETOF public.project_service_areas
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
    DECLARE
      _old_row public.project_service_areas;
      _new_row public.project_service_areas;
      _row     public.project_service_areas := (jsonb_populate_record(NULL::public.project_service_areas, COALESCE(_input, '{}'::jsonb)));
    BEGIN
      SELECT * INTO _old_row FROM public.project_service_areas WHERE id = _id;
      IF _old_row IS NULL THEN
        RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
      END IF;

      PERFORM check_access('update','project_service_areas', _old_row.project_id, NULL);

      UPDATE public.project_service_areas
         SET project_id = COALESCE(_row.project_id, project_id),
             service_area_id = COALESCE(_row.service_area_id, service_area_id),
             updated_at = now()
       WHERE id = _id
       RETURNING * INTO _new_row;

      RETURN NEXT _new_row;
    END;
    $$;


--
-- Name: update_projects(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_projects(_id uuid, _input jsonb) RETURNS SETOF public.projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  _old_row public.projects;
  _new_row public.projects;
  _row public.projects := (jsonb_populate_record(NULL::public.projects, COALESCE(_input, '{}'::jsonb)));
BEGIN
  SELECT * INTO _old_row FROM public.projects WHERE id = _id;
  IF _old_row IS NULL THEN
    RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  -- fixed: projects table has no project_id column; use row id as project context
  PERFORM check_access('update','projects', _old_row.id, _old_row.organization_id);

  UPDATE public.projects
     SET name = COALESCE(_row.name, name),
         description = COALESCE(_row.description, description),
         status = COALESCE(_row.status, status),
         start_date = COALESCE(_row.start_date, start_date),
         end_date = COALESCE(_row.end_date, end_date),
         updated_at = now()
   WHERE id = _id
   RETURNING * INTO _new_row;

  RETURN NEXT _new_row;
END;
$$;


--
-- Name: update_punch_lists(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_punch_lists(_id uuid, _input jsonb) RETURNS SETOF public.punch_lists
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.punch_lists;
        _new_row public.punch_lists;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.punch_lists := (jsonb_populate_record(NULL::public.punch_lists, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.punch_lists WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','punch_lists', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.punch_lists
           SET item = COALESCE(_row.item, item), status = COALESCE(_row.status, status), assigned_to = COALESCE(_row.assigned_to, assigned_to), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_purchase_orders(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_purchase_orders(_id uuid, _input jsonb) RETURNS SETOF public.purchase_orders
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.purchase_orders;
        _new_row public.purchase_orders;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.purchase_orders := (jsonb_populate_record(NULL::public.purchase_orders, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.purchase_orders WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','purchase_orders', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.purchase_orders
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), order_number = COALESCE(_row.order_number, order_number), order_date = COALESCE(_row.order_date, order_date), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_quality_reviews(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_quality_reviews(_id uuid, _input jsonb) RETURNS SETOF public.quality_reviews
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.quality_reviews;
        _new_row public.quality_reviews;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.quality_reviews := (jsonb_populate_record(NULL::public.quality_reviews, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.quality_reviews WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','quality_reviews', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.quality_reviews
           SET review_date = COALESCE(_row.review_date, review_date), reviewer = COALESCE(_row.reviewer, reviewer), findings = COALESCE(_row.findings, findings), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_regulatory_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_regulatory_documents(_id uuid, _input jsonb) RETURNS SETOF public.regulatory_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.regulatory_documents;
        _new_row public.regulatory_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.regulatory_documents := (jsonb_populate_record(NULL::public.regulatory_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.regulatory_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','regulatory_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.regulatory_documents
           SET document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_reports(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_reports(_id uuid, _input jsonb) RETURNS SETOF public.reports
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.reports;
        _new_row public.reports;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.reports := (jsonb_populate_record(NULL::public.reports, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.reports WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','reports', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.reports
           SET report_type = COALESCE(_row.report_type, report_type), generated_at = COALESCE(_row.generated_at, generated_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_rfis(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_rfis(_id uuid, _input jsonb) RETURNS SETOF public.rfis
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.rfis;
        _new_row public.rfis;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.rfis := (jsonb_populate_record(NULL::public.rfis, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.rfis WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','rfis', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.rfis
           SET subject = COALESCE(_row.subject, subject), status = COALESCE(_row.status, status), question = COALESCE(_row.question, question), answer = COALESCE(_row.answer, answer), submitted_by = COALESCE(_row.submitted_by, submitted_by), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), submitted_at = COALESCE(_row.submitted_at, submitted_at), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_safety_incidents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_safety_incidents(_id uuid, _input jsonb) RETURNS SETOF public.safety_incidents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.safety_incidents;
        _new_row public.safety_incidents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.safety_incidents := (jsonb_populate_record(NULL::public.safety_incidents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.safety_incidents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','safety_incidents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.safety_incidents
           SET incident_date = COALESCE(_row.incident_date, incident_date), description = COALESCE(_row.description, description), reported_by = COALESCE(_row.reported_by, reported_by), severity = COALESCE(_row.severity, severity), resolved = COALESCE(_row.resolved, resolved), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_sensor_data(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_sensor_data(_id uuid, _input jsonb) RETURNS SETOF public.sensor_data
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.sensor_data;
        _new_row public.sensor_data;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.sensor_data := (jsonb_populate_record(NULL::public.sensor_data, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.sensor_data WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','sensor_data', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.sensor_data
           SET data = COALESCE(_row.data, data), collected_at = COALESCE(_row.collected_at, collected_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_subcontractor_agreements(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_subcontractor_agreements(_id uuid, _input jsonb) RETURNS SETOF public.subcontractor_agreements
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.subcontractor_agreements;
        _new_row public.subcontractor_agreements;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.subcontractor_agreements := (jsonb_populate_record(NULL::public.subcontractor_agreements, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.subcontractor_agreements WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','subcontractor_agreements', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.subcontractor_agreements
           SET subcontract_id = COALESCE(_row.subcontract_id, subcontract_id), agreement_url = COALESCE(_row.agreement_url, agreement_url), signed_at = COALESCE(_row.signed_at, signed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_subcontracts(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_subcontracts(_id uuid, _input jsonb) RETURNS SETOF public.subcontracts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.subcontracts;
        _new_row public.subcontracts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.subcontracts := (jsonb_populate_record(NULL::public.subcontracts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.subcontracts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','subcontracts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.subcontracts
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), amount = COALESCE(_row.amount, amount), status = COALESCE(_row.status, status), signed_at = COALESCE(_row.signed_at, signed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_submittals(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_submittals(_id uuid, _input jsonb) RETURNS SETOF public.submittals
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.submittals;
        _new_row public.submittals;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.submittals := (jsonb_populate_record(NULL::public.submittals, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.submittals WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','submittals', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.submittals
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), submitted_by = COALESCE(_row.submitted_by, submitted_by), reviewed_by = COALESCE(_row.reviewed_by, reviewed_by), submitted_at = COALESCE(_row.submitted_at, submitted_at), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_tack_rates(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_tack_rates(_id uuid, _input jsonb) RETURNS SETOF public.tack_rates
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.tack_rates;
        _new_row public.tack_rates;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.tack_rates := (jsonb_populate_record(NULL::public.tack_rates, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.tack_rates WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','tack_rates', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.tack_rates
           SET rate = COALESCE(_row.rate, rate), material_type = COALESCE(_row.material_type, material_type), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_task_dependencies(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_task_dependencies(_id uuid, _input jsonb) RETURNS SETOF public.task_dependencies
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.task_dependencies;
        _new_row public.task_dependencies;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.task_dependencies := (jsonb_populate_record(NULL::public.task_dependencies, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.task_dependencies WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','task_dependencies', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.task_dependencies
           SET task_id = COALESCE(_row.task_id, task_id), depends_on_task_id = COALESCE(_row.depends_on_task_id, depends_on_task_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_task_status_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_task_status_logs(_id uuid, _input jsonb) RETURNS SETOF public.task_status_logs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.task_status_logs;
        _new_row public.task_status_logs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.task_status_logs := (jsonb_populate_record(NULL::public.task_status_logs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.task_status_logs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','task_status_logs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.task_status_logs
           SET task_id = COALESCE(_row.task_id, task_id), status = COALESCE(_row.status, status), changed_at = COALESCE(_row.changed_at, changed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_tasks(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_tasks(_id uuid, _input jsonb) RETURNS SETOF public.tasks
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.tasks;
        _new_row public.tasks;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.tasks := (jsonb_populate_record(NULL::public.tasks, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.tasks WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','tasks', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.tasks
           SET name = COALESCE(_row.name, name), description = COALESCE(_row.description, description), start_date = COALESCE(_row.start_date, start_date), end_date = COALESCE(_row.end_date, end_date), status = COALESCE(_row.status, status), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_training_records(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_training_records(_id uuid, _input jsonb) RETURNS SETOF public.training_records
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.training_records;
        _new_row public.training_records;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.training_records := (jsonb_populate_record(NULL::public.training_records, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.training_records WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','training_records', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.training_records
           SET employee_id = COALESCE(_row.employee_id, employee_id), training_type = COALESCE(_row.training_type, training_type), completion_date = COALESCE(_row.completion_date, completion_date), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_user_notification_settings(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_notification_settings(_id uuid, _input jsonb) RETURNS SETOF public.user_notification_settings
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    AS $$
DECLARE
  v_user_id uuid := auth.uid();
  v_old public.user_notification_settings;
  v_row public.user_notification_settings;
BEGIN
  IF v_user_id IS NULL OR _id IS DISTINCT FROM v_user_id THEN
    RAISE EXCEPTION 'Access denied' USING errcode = '42501';
  END IF;

  SELECT * INTO v_old
  FROM public.user_notification_settings
  WHERE user_id = _id;

  IF v_old IS NULL THEN
    RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
  END IF;

  UPDATE public.user_notification_settings
  SET
    silenced_categories = COALESCE(
      (SELECT ARRAY(
        SELECT value::public.notification_category
        FROM jsonb_array_elements_text(COALESCE(_input->'silenced_categories', to_jsonb(v_old.silenced_categories)))
      )),
      v_old.silenced_categories
    ),
    silenced_events = COALESCE(
      (SELECT ARRAY(
        SELECT value
        FROM jsonb_array_elements_text(COALESCE(_input->'silenced_events', to_jsonb(v_old.silenced_events)))
      )),
      v_old.silenced_events
    ),
    updated_at = now()
  WHERE user_id = _id
  RETURNING * INTO v_row;

  RETURN NEXT v_row;
END;
$$;


--
-- Name: update_user_projects(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_user_projects(_id uuid, _input jsonb) RETURNS SETOF public.user_projects
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.user_projects;
        _new_row public.user_projects;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.user_projects := (jsonb_populate_record(NULL::public.user_projects, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.user_projects WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','user_projects', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.user_projects
           SET user_id = COALESCE(_row.user_id, user_id), role = COALESCE(_row.role, role), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_vendor_bid_packages(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendor_bid_packages(_id uuid, _input jsonb) RETURNS SETOF public.vendor_bid_packages
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendor_bid_packages;
        _new_row public.vendor_bid_packages;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_bid_packages := (jsonb_populate_record(NULL::public.vendor_bid_packages, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_bid_packages WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_bid_packages', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_bid_packages
           SET bid_package_id = COALESCE(_row.bid_package_id, bid_package_id), vendor_id = COALESCE(_row.vendor_id, vendor_id), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_vendor_contacts(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendor_contacts(_id uuid, _input jsonb) RETURNS SETOF public.vendor_contacts
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendor_contacts;
        _new_row public.vendor_contacts;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_contacts := (jsonb_populate_record(NULL::public.vendor_contacts, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_contacts WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_contacts', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_contacts
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), name = COALESCE(_row.name, name), email = COALESCE(_row.email, email), phone = COALESCE(_row.phone, phone), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_vendor_documents(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendor_documents(_id uuid, _input jsonb) RETURNS SETOF public.vendor_documents
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendor_documents;
        _new_row public.vendor_documents;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_documents := (jsonb_populate_record(NULL::public.vendor_documents, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_documents WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_documents', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_documents
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), document_type = COALESCE(_row.document_type, document_type), url = COALESCE(_row.url, url), uploaded_at = COALESCE(_row.uploaded_at, uploaded_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_vendor_qualifications(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendor_qualifications(_id uuid, _input jsonb) RETURNS SETOF public.vendor_qualifications
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendor_qualifications;
        _new_row public.vendor_qualifications;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendor_qualifications := (jsonb_populate_record(NULL::public.vendor_qualifications, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendor_qualifications WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendor_qualifications', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendor_qualifications
           SET vendor_id = COALESCE(_row.vendor_id, vendor_id), qualification_type = COALESCE(_row.qualification_type, qualification_type), status = COALESCE(_row.status, status), reviewed_at = COALESCE(_row.reviewed_at, reviewed_at), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_vendors(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_vendors(_id uuid, _input jsonb) RETURNS SETOF public.vendors
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.vendors;
        _new_row public.vendors;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.vendors := (jsonb_populate_record(NULL::public.vendors, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.vendors WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','vendors', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.vendors
           SET name = COALESCE(_row.name, name), status = COALESCE(_row.status, status), contact_email = COALESCE(_row.contact_email, contact_email), contact_phone = COALESCE(_row.contact_phone, contact_phone), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_wbs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_wbs(_id uuid, _input jsonb) RETURNS SETOF public.wbs
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.wbs;
        _new_row public.wbs;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.wbs := (jsonb_populate_record(NULL::public.wbs, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.wbs WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','wbs', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.wbs
           SET name = COALESCE(_row.name, name), location = COALESCE(_row.location, location), order_num = COALESCE(_row.order_num, order_num), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: update_workflows(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.update_workflows(_id uuid, _input jsonb) RETURNS SETOF public.workflows
    LANGUAGE plpgsql
    SET search_path TO 'public', 'pg_temp'
    AS $$
      DECLARE
        _old_row public.workflows;
        _new_row public.workflows;
        -- Map only known columns; keys not in the table are ignored safely
        _row     public.workflows := (jsonb_populate_record(NULL::public.workflows, COALESCE(_input, '{}'::jsonb)));
      BEGIN
        -- Fetch row (RLS decides visibility)
        SELECT * INTO _old_row FROM public.workflows WHERE id = _id;
        IF _old_row IS NULL THEN
          RAISE EXCEPTION 'row not found' USING DETAIL = jsonb_build_object('id', _id);
        END IF;

        -- Authorization gate with existing row scope (prevents privilege escalation)
        PERFORM check_access('update','workflows', _old_row.project_id, _old_row.organization_id);

        -- Tweak #2: scope columns are excluded from set_list, so they cannot be changed here
        UPDATE public.workflows
           SET entity_schema = COALESCE(_row.entity_schema, entity_schema), entity_table = COALESCE(_row.entity_table, entity_table), entity_id = COALESCE(_row.entity_id, entity_id), workflow_name = COALESCE(_row.workflow_name, workflow_name), current_state = COALESCE(_row.current_state, current_state), updated_at = now()
         WHERE id = _id
         RETURNING * INTO _new_row;

        RETURN NEXT _new_row;
      END;
      $$;


--
-- Name: upsert_my_avatar(text, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.upsert_my_avatar(p_url text, p_is_preset boolean DEFAULT false) RETURNS SETOF public.avatars
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public', 'pg_temp'
    SET row_security TO 'off'
    AS $$
    DECLARE
      v_profile public.profiles;
      v_avatar public.avatars;
    BEGIN
      IF auth.uid() IS NULL THEN
        RAISE EXCEPTION 'not authenticated';
      END IF;

      SELECT * INTO v_profile FROM public.profiles WHERE id = auth.uid();
      IF v_profile IS NULL THEN
        RAISE EXCEPTION 'profile not found' USING DETAIL = jsonb_build_object('id', auth.uid());
      END IF;

      IF v_profile.avatar_id IS NOT NULL THEN
        SELECT * INTO v_avatar FROM public.avatars WHERE id = v_profile.avatar_id;
      END IF;

      IF v_avatar.id IS NOT NULL AND v_avatar.is_preset = false THEN
        UPDATE public.avatars
           SET url = p_url,
           is_preset = false,
               updated_at = now()
         WHERE id = v_avatar.id
         RETURNING * INTO v_avatar;
      ELSE
        INSERT INTO public.avatars (url, is_preset, created_at, updated_at)
        VALUES (p_url, COALESCE(p_is_preset, false), now(), now())
        RETURNING * INTO v_avatar;

        UPDATE public.profiles
           SET avatar_id = v_avatar.id,
               updated_at = now()
         WHERE id = v_profile.id;
      END IF;

      RETURN NEXT v_avatar;
    END;
    $$;


--
-- Name: accounts_payable_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.accounts_payable_active AS
 SELECT id,
    project_id,
    amount_due,
    due_date,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.accounts_payable
  WHERE (deleted_at IS NULL);


--
-- Name: accounts_receivable_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.accounts_receivable_active AS
 SELECT id,
    project_id,
    amount_due,
    due_date,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.accounts_receivable
  WHERE (deleted_at IS NULL);


--
-- Name: activity_logs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.activity_logs_active AS
 SELECT id,
    profile_id,
    activity_type,
    activity_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.activity_logs
  WHERE (deleted_at IS NULL);


--
-- Name: asphalt_types_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.asphalt_types_active AS
 SELECT id,
    name,
    description,
    created_at,
    updated_at,
    deleted_at
   FROM public.asphalt_types
  WHERE (deleted_at IS NULL);


--
-- Name: audit_log_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.audit_log_active AS
 SELECT id,
    table_name,
    action,
    row_id,
    before_data,
    after_data,
    changed_by,
    changed_at,
    deleted_at
   FROM public.audit_log
  WHERE (deleted_at IS NULL);


--
-- Name: audit_logs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.audit_logs_active AS
 SELECT id,
    project_id,
    action,
    performed_by,
    performed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.audit_logs
  WHERE (deleted_at IS NULL);


--
-- Name: avatars_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.avatars_active AS
 SELECT id,
    url,
    created_at,
    updated_at,
    deleted_at
   FROM public.avatars
  WHERE (deleted_at IS NULL);


--
-- Name: bid_packages_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.bid_packages_active AS
 SELECT id,
    project_id,
    name,
    status,
    created_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.bid_packages
  WHERE (deleted_at IS NULL);


--
-- Name: bid_vendors_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.bid_vendors_active AS
 SELECT id,
    bid_package_id,
    vendor_id,
    invited_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.bid_vendors
  WHERE (deleted_at IS NULL);


--
-- Name: bids_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.bids_active AS
 SELECT id,
    bid_package_id,
    vendor_id,
    amount,
    submitted_at,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.bids
  WHERE (deleted_at IS NULL);


--
-- Name: bim_models_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.bim_models_active AS
 SELECT id,
    project_id,
    name,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.bim_models
  WHERE (deleted_at IS NULL);


--
-- Name: certifications_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.certifications_active AS
 SELECT id,
    employee_id,
    certification_type,
    issue_date,
    expiry_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.certifications
  WHERE (deleted_at IS NULL);


--
-- Name: change_orders_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.change_orders_active AS
 SELECT id,
    project_id,
    number,
    description,
    status,
    amount,
    created_at,
    updated_at,
    deleted_at
   FROM public.change_orders
  WHERE (deleted_at IS NULL);


--
-- Name: commitments_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.commitments_active AS
 SELECT id,
    project_id,
    vendor_id,
    type,
    amount,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.commitments
  WHERE (deleted_at IS NULL);


--
-- Name: compliance_checks_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.compliance_checks_active AS
 SELECT id,
    project_id,
    check_date,
    description,
    result,
    created_at,
    updated_at,
    deleted_at
   FROM public.compliance_checks
  WHERE (deleted_at IS NULL);


--
-- Name: compliance_tracking_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.compliance_tracking_active AS
 SELECT id,
    project_id,
    tracking_type,
    status,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.compliance_tracking
  WHERE (deleted_at IS NULL);


--
-- Name: cost_codes_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.cost_codes_active AS
 SELECT id,
    code,
    description,
    created_at,
    updated_at,
    deleted_at
   FROM public.cost_codes
  WHERE (deleted_at IS NULL);


--
-- Name: crew_assignments_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.crew_assignments_active AS
 SELECT id,
    crew_id,
    profile_id,
    assigned_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.crew_assignments
  WHERE (deleted_at IS NULL);


--
-- Name: crew_members_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.crew_members_active AS
 SELECT id,
    crew_id,
    profile_id,
    role,
    start_date,
    end_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.crew_members
  WHERE (deleted_at IS NULL);


--
-- Name: crews_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.crews_active AS
 SELECT id,
    project_id,
    name,
    created_at,
    updated_at,
    deleted_at
   FROM public.crews
  WHERE (deleted_at IS NULL);


--
-- Name: daily_logs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.daily_logs_active AS
 SELECT id,
    project_id,
    date,
    weather,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.daily_logs
  WHERE (deleted_at IS NULL);


--
-- Name: dashboard_configs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.dashboard_configs_active AS
 SELECT id,
    profile_id,
    config,
    created_at,
    updated_at,
    deleted_at
   FROM public.dashboard_configs
  WHERE (deleted_at IS NULL);


--
-- Name: document_references_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.document_references_active AS
 SELECT id,
    document_id,
    reference_type,
    reference_id,
    created_at,
    updated_at,
    deleted_at
   FROM public.document_references
  WHERE (deleted_at IS NULL);


--
-- Name: documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.documents_active AS
 SELECT id,
    project_id,
    name,
    type,
    url,
    uploaded_by,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.documents
  WHERE (deleted_at IS NULL);


--
-- Name: drawing_versions_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.drawing_versions_active AS
 SELECT id,
    document_id,
    version,
    uploaded_by,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.drawing_versions
  WHERE (deleted_at IS NULL);


--
-- Name: dump_trucks_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.dump_trucks_active AS
 SELECT id,
    organization_id,
    make,
    model,
    capacity,
    created_at,
    updated_at,
    deleted_at
   FROM public.dump_trucks
  WHERE (deleted_at IS NULL);


--
-- Name: employees_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.employees_active AS
 SELECT id,
    organization_id,
    profile_id,
    hire_date,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.employees
  WHERE (deleted_at IS NULL);


--
-- Name: equipment_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.equipment_active AS
 SELECT id,
    organization_id,
    name,
    type,
    model,
    serial_number,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.equipment
  WHERE (deleted_at IS NULL);


--
-- Name: equipment_assignments_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.equipment_assignments_active AS
 SELECT id,
    equipment_id,
    project_id,
    assigned_to,
    assigned_date,
    released_date,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.equipment_assignments
  WHERE (deleted_at IS NULL);


--
-- Name: equipment_maintenance_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.equipment_maintenance_active AS
 SELECT id,
    equipment_id,
    maintenance_date,
    type,
    description,
    performed_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.equipment_maintenance
  WHERE (deleted_at IS NULL);


--
-- Name: equipment_usage_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.equipment_usage_active AS
 SELECT id,
    equipment_id,
    date,
    hours_used,
    quantity,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.equipment_usage
  WHERE (deleted_at IS NULL);


--
-- Name: estimate_line_items_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.estimate_line_items_active AS
 SELECT id,
    estimate_id,
    cost_code_id,
    name,
    unit_measure,
    quantity,
    unit_price,
    total_cost,
    created_at,
    updated_at,
    deleted_at
   FROM public.estimate_line_items
  WHERE (deleted_at IS NULL);


--
-- Name: estimates_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.estimates_active AS
 SELECT id,
    project_id,
    name,
    status,
    created_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.estimates
  WHERE (deleted_at IS NULL);


--
-- Name: financial_documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.financial_documents_active AS
 SELECT id,
    project_id,
    document_type,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.financial_documents
  WHERE (deleted_at IS NULL);


--
-- Name: general_ledger_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.general_ledger_active AS
 SELECT id,
    project_id,
    entry_date,
    description,
    debit,
    credit,
    balance,
    created_at,
    updated_at,
    deleted_at
   FROM public.general_ledger
  WHERE (deleted_at IS NULL);


--
-- Name: hr_documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.hr_documents_active AS
 SELECT id,
    employee_id,
    document_type,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.hr_documents
  WHERE (deleted_at IS NULL);


--
-- Name: inspections_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.inspections_active AS
 SELECT id,
    project_id,
    name,
    inspection_type,
    date,
    status,
    result,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.inspections
  WHERE (deleted_at IS NULL);


--
-- Name: integration_tokens_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.integration_tokens_active AS
 SELECT id,
    profile_id,
    service_name,
    token,
    created_at,
    updated_at,
    deleted_at
   FROM public.integration_tokens
  WHERE (deleted_at IS NULL);


--
-- Name: inventory_transactions_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.inventory_transactions_active AS
 SELECT id,
    material_id,
    transaction_type,
    quantity,
    transaction_date,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.inventory_transactions
  WHERE (deleted_at IS NULL);


--
-- Name: issues_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.issues_active AS
 SELECT id,
    project_id,
    name,
    type,
    status,
    reported_by,
    description,
    resolved,
    created_at,
    updated_at,
    deleted_at
   FROM public.issues
  WHERE (deleted_at IS NULL);


--
-- Name: job_titles_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.job_titles_active AS
 SELECT id,
    name,
    created_at,
    updated_at,
    deleted_at
   FROM public.job_titles
  WHERE (deleted_at IS NULL);


--
-- Name: labor_records_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.labor_records_active AS
 SELECT id,
    line_item_id,
    worker_count,
    hours_worked,
    work_date,
    work_type,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.labor_records
  WHERE (deleted_at IS NULL);


--
-- Name: line_item_entries_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.line_item_entries_active AS
 SELECT id,
    line_item_id,
    date,
    quantity_completed,
    notes,
    created_at,
    updated_at,
    deleted_at
   FROM public.line_item_entries
  WHERE (deleted_at IS NULL);


--
-- Name: line_item_templates_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.line_item_templates_active AS
 SELECT id,
    name,
    formula,
    variables,
    created_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.line_item_templates
  WHERE (deleted_at IS NULL);


--
-- Name: line_items_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.line_items_active AS
 SELECT id,
    map_id,
    wbs_id,
    project_id,
    cost_code_id,
    template_id,
    name,
    description,
    unit_measure,
    quantity,
    unit_price,
    created_at,
    updated_at,
    deleted_at
   FROM public.line_items
  WHERE (deleted_at IS NULL);


--
-- Name: maps_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.maps_active AS
 SELECT id,
    wbs_id,
    project_id,
    name,
    description,
    coordinates,
    scope,
    order_num,
    created_at,
    updated_at,
    deleted_at
   FROM public.maps
  WHERE (deleted_at IS NULL);


--
-- Name: material_inventory_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.material_inventory_active AS
 SELECT id,
    material_id,
    organization_id,
    quantity,
    last_updated,
    created_at,
    updated_at,
    deleted_at
   FROM public.material_inventory
  WHERE (deleted_at IS NULL);


--
-- Name: material_orders_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.material_orders_active AS
 SELECT id,
    material_id,
    project_id,
    order_date,
    quantity,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.material_orders
  WHERE (deleted_at IS NULL);


--
-- Name: material_receipts_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.material_receipts_active AS
 SELECT id,
    material_order_id,
    received_date,
    quantity,
    received_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.material_receipts
  WHERE (deleted_at IS NULL);


--
-- Name: materials_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.materials_active AS
 SELECT id,
    organization_id,
    name,
    description,
    unit,
    created_at,
    updated_at,
    deleted_at
   FROM public.materials
  WHERE (deleted_at IS NULL);


--
-- Name: meeting_minutes_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.meeting_minutes_active AS
 SELECT id,
    project_id,
    meeting_date,
    notes,
    created_by,
    created_at,
    updated_at,
    deleted_at
   FROM public.meeting_minutes
  WHERE (deleted_at IS NULL);


--
-- Name: notifications_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.notifications_active AS
 SELECT id,
    user_id,
    category,
    message,
    payload,
    is_read,
    created_at,
    updated_at,
    deleted_at
   FROM public.notifications
  WHERE (deleted_at IS NULL);


--
-- Name: organization_members_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.organization_members_active AS
 SELECT id,
    profile_id,
    organization_id,
    job_title_id,
    permission_role,
    created_at,
    updated_at,
    deleted_at
   FROM public.organization_members
  WHERE (deleted_at IS NULL);


--
-- Name: organization_projects_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.organization_projects_active AS
 SELECT id,
    organization_id,
    project_id,
    created_at,
    updated_at,
    deleted_at
   FROM public.organization_projects
  WHERE (deleted_at IS NULL);


--
-- Name: organizations_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.organizations_active AS
 SELECT id,
    name,
    description,
    created_at,
    updated_at,
    deleted_at
   FROM public.organizations
  WHERE (deleted_at IS NULL);


--
-- Name: payments_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.payments_active AS
 SELECT id,
    project_id,
    commitment_id,
    amount,
    paid_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.payments
  WHERE (deleted_at IS NULL);


--
-- Name: payroll_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.payroll_active AS
 SELECT id,
    employee_id,
    pay_period_start,
    pay_period_end,
    gross_pay,
    net_pay,
    created_at,
    updated_at,
    deleted_at
   FROM public.payroll
  WHERE (deleted_at IS NULL);


--
-- Name: photos_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.photos_active AS
 SELECT id,
    project_id,
    url,
    caption,
    uploaded_by,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.photos
  WHERE (deleted_at IS NULL);


--
-- Name: prequalifications_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.prequalifications_active AS
 SELECT id,
    vendor_id,
    status,
    reviewed_by,
    reviewed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.prequalifications
  WHERE (deleted_at IS NULL);


--
-- Name: procurement_workflows_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.procurement_workflows_active AS
 SELECT id,
    project_id,
    name,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.procurement_workflows
  WHERE (deleted_at IS NULL);


--
-- Name: profiles_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.profiles_active AS
 SELECT id,
    email,
    full_name,
    phone,
    organization_id,
    created_at,
    updated_at,
    role,
    deleted_at,
    profile_completed_at,
    avatar_id
   FROM public.profiles
  WHERE (deleted_at IS NULL);


--
-- Name: progress_billings_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.progress_billings_active AS
 SELECT id,
    project_id,
    billing_number,
    amount,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.progress_billings
  WHERE (deleted_at IS NULL);


--
-- Name: project_cost_summary; Type: MATERIALIZED VIEW; Schema: public; Owner: -
--

CREATE MATERIALIZED VIEW public.project_cost_summary AS
 SELECT p.id AS project_id,
    p.name AS project_name,
    COALESCE(sum((li.quantity * li.unit_price)), (0)::numeric) AS total_estimated_cost,
    COALESCE(sum(po.amount), (0)::numeric) AS total_commitment_amount,
    COALESCE(sum(pb.amount), (0)::numeric) AS total_billed_amount
   FROM (((public.projects p
     LEFT JOIN public.line_items li ON ((li.project_id = p.id)))
     LEFT JOIN public.purchase_orders po ON ((po.project_id = p.id)))
     LEFT JOIN public.progress_billings pb ON ((pb.project_id = p.id)))
  GROUP BY p.id, p.name
  WITH NO DATA;


--
-- Name: project_inspectors_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.project_inspectors_active AS
 SELECT project_id,
    profile_id,
    assigned_by,
    assigned_at,
    deleted_at
   FROM public.project_inspectors
  WHERE (deleted_at IS NULL);


--
-- Name: projects_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.projects_active AS
 SELECT id,
    organization_id,
    name,
    description,
    status,
    start_date,
    end_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.projects
  WHERE (deleted_at IS NULL);


--
-- Name: punch_lists_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.punch_lists_active AS
 SELECT id,
    project_id,
    item,
    status,
    assigned_to,
    created_at,
    updated_at,
    deleted_at
   FROM public.punch_lists
  WHERE (deleted_at IS NULL);


--
-- Name: purchase_orders_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.purchase_orders_active AS
 SELECT id,
    project_id,
    vendor_id,
    order_number,
    order_date,
    amount,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.purchase_orders
  WHERE (deleted_at IS NULL);


--
-- Name: quality_reviews_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.quality_reviews_active AS
 SELECT id,
    project_id,
    review_date,
    reviewer,
    findings,
    created_at,
    updated_at,
    deleted_at
   FROM public.quality_reviews
  WHERE (deleted_at IS NULL);


--
-- Name: regulatory_documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.regulatory_documents_active AS
 SELECT id,
    project_id,
    document_type,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.regulatory_documents
  WHERE (deleted_at IS NULL);


--
-- Name: reports_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.reports_active AS
 SELECT id,
    project_id,
    report_type,
    generated_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.reports
  WHERE (deleted_at IS NULL);


--
-- Name: rfis_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.rfis_active AS
 SELECT id,
    project_id,
    subject,
    status,
    question,
    answer,
    submitted_by,
    reviewed_by,
    submitted_at,
    reviewed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.rfis
  WHERE (deleted_at IS NULL);


--
-- Name: rpc_error_debug; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.rpc_error_debug (
    id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    rpc_name text NOT NULL,
    operation text,
    sqlstate text,
    error_message text NOT NULL,
    error_detail text,
    error_hint text,
    auth_user_id uuid,
    request_context jsonb DEFAULT '{}'::jsonb NOT NULL
);


--
-- Name: rpc_error_debug_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

ALTER TABLE public.rpc_error_debug ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME public.rpc_error_debug_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: safety_incidents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.safety_incidents_active AS
 SELECT id,
    project_id,
    incident_date,
    description,
    reported_by,
    severity,
    resolved,
    created_at,
    updated_at,
    deleted_at
   FROM public.safety_incidents
  WHERE (deleted_at IS NULL);


--
-- Name: sensor_data_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.sensor_data_active AS
 SELECT id,
    project_id,
    data,
    collected_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.sensor_data
  WHERE (deleted_at IS NULL);


--
-- Name: subcontractor_agreements_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.subcontractor_agreements_active AS
 SELECT id,
    subcontract_id,
    agreement_url,
    signed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.subcontractor_agreements
  WHERE (deleted_at IS NULL);


--
-- Name: subcontracts_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.subcontracts_active AS
 SELECT id,
    project_id,
    vendor_id,
    amount,
    status,
    signed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.subcontracts
  WHERE (deleted_at IS NULL);


--
-- Name: submittals_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.submittals_active AS
 SELECT id,
    project_id,
    name,
    status,
    submitted_by,
    reviewed_by,
    submitted_at,
    reviewed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.submittals
  WHERE (deleted_at IS NULL);


--
-- Name: tack_rates_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.tack_rates_active AS
 SELECT id,
    project_id,
    rate,
    material_type,
    created_at,
    updated_at,
    deleted_at
   FROM public.tack_rates
  WHERE (deleted_at IS NULL);


--
-- Name: task_dependencies_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.task_dependencies_active AS
 SELECT id,
    task_id,
    depends_on_task_id,
    created_at,
    deleted_at
   FROM public.task_dependencies
  WHERE (deleted_at IS NULL);


--
-- Name: task_status_logs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.task_status_logs_active AS
 SELECT task_id,
    status,
    changed_at,
    deleted_at
   FROM public.task_status_logs
  WHERE (deleted_at IS NULL);


--
-- Name: tasks_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.tasks_active AS
 SELECT id,
    project_id,
    name,
    description,
    start_date,
    end_date,
    status,
    created_at,
    updated_at,
    deleted_at
   FROM public.tasks
  WHERE (deleted_at IS NULL);


--
-- Name: training_records_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.training_records_active AS
 SELECT id,
    employee_id,
    training_type,
    completion_date,
    created_at,
    updated_at,
    deleted_at
   FROM public.training_records
  WHERE (deleted_at IS NULL);


--
-- Name: user_projects_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.user_projects_active AS
 SELECT id,
    user_id,
    project_id,
    role,
    created_at,
    updated_at,
    deleted_at
   FROM public.user_projects
  WHERE (deleted_at IS NULL);


--
-- Name: vendor_bid_packages_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendor_bid_packages_active AS
 SELECT id,
    bid_package_id,
    vendor_id,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendor_bid_packages
  WHERE (deleted_at IS NULL);


--
-- Name: vendor_contacts_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendor_contacts_active AS
 SELECT id,
    vendor_id,
    name,
    email,
    phone,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendor_contacts
  WHERE (deleted_at IS NULL);


--
-- Name: vendor_documents_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendor_documents_active AS
 SELECT id,
    vendor_id,
    document_type,
    url,
    uploaded_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendor_documents
  WHERE (deleted_at IS NULL);


--
-- Name: vendor_qualifications_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendor_qualifications_active AS
 SELECT id,
    vendor_id,
    qualification_type,
    status,
    reviewed_at,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendor_qualifications
  WHERE (deleted_at IS NULL);


--
-- Name: vendors_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.vendors_active AS
 SELECT id,
    organization_id,
    name,
    status,
    contact_email,
    contact_phone,
    created_at,
    updated_at,
    deleted_at
   FROM public.vendors
  WHERE (deleted_at IS NULL);


--
-- Name: wbs_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.wbs_active AS
 SELECT id,
    project_id,
    name,
    location,
    order_num,
    created_at,
    updated_at,
    deleted_at
   FROM public.wbs
  WHERE (deleted_at IS NULL);


--
-- Name: workflows_active; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.workflows_active AS
 SELECT id,
    entity_schema,
    entity_table,
    entity_id,
    workflow_name,
    current_state,
    created_at,
    updated_at,
    deleted_at
   FROM public.workflows
  WHERE (deleted_at IS NULL);


--
-- Name: accounts_payable accounts_payable_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.accounts_payable
    ADD CONSTRAINT accounts_payable_pkey PRIMARY KEY (id);


--
-- Name: accounts_receivable accounts_receivable_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.accounts_receivable
    ADD CONSTRAINT accounts_receivable_pkey PRIMARY KEY (id);


--
-- Name: activity_logs activity_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.activity_logs
    ADD CONSTRAINT activity_logs_pkey PRIMARY KEY (id);


--
-- Name: asphalt_types asphalt_types_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.asphalt_types
    ADD CONSTRAINT asphalt_types_pkey PRIMARY KEY (id);


--
-- Name: audit_log audit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_log
    ADD CONSTRAINT audit_log_pkey PRIMARY KEY (id);


--
-- Name: audit_logs audit_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT audit_logs_pkey PRIMARY KEY (id);


--
-- Name: avatars avatars_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.avatars
    ADD CONSTRAINT avatars_pkey PRIMARY KEY (id);


--
-- Name: bid_packages bid_packages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_packages
    ADD CONSTRAINT bid_packages_pkey PRIMARY KEY (id);


--
-- Name: bid_vendors bid_vendors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_vendors
    ADD CONSTRAINT bid_vendors_pkey PRIMARY KEY (id);


--
-- Name: bids bids_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bids
    ADD CONSTRAINT bids_pkey PRIMARY KEY (id);


--
-- Name: bim_models bim_models_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bim_models
    ADD CONSTRAINT bim_models_pkey PRIMARY KEY (id);


--
-- Name: certifications certifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.certifications
    ADD CONSTRAINT certifications_pkey PRIMARY KEY (id);


--
-- Name: change_orders change_orders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.change_orders
    ADD CONSTRAINT change_orders_pkey PRIMARY KEY (id);


--
-- Name: commitments commitments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.commitments
    ADD CONSTRAINT commitments_pkey PRIMARY KEY (id);


--
-- Name: compliance_checks compliance_checks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compliance_checks
    ADD CONSTRAINT compliance_checks_pkey PRIMARY KEY (id);


--
-- Name: compliance_tracking compliance_tracking_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compliance_tracking
    ADD CONSTRAINT compliance_tracking_pkey PRIMARY KEY (id);


--
-- Name: cost_codes cost_codes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_codes
    ADD CONSTRAINT cost_codes_pkey PRIMARY KEY (id);


--
-- Name: crew_assignments crew_assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_assignments
    ADD CONSTRAINT crew_assignments_pkey PRIMARY KEY (id);


--
-- Name: crew_members crew_members_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_members
    ADD CONSTRAINT crew_members_pkey PRIMARY KEY (id);


--
-- Name: crews crews_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crews
    ADD CONSTRAINT crews_pkey PRIMARY KEY (id);


--
-- Name: daily_logs daily_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.daily_logs
    ADD CONSTRAINT daily_logs_pkey PRIMARY KEY (id);


--
-- Name: dashboard_configs dashboard_configs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dashboard_configs
    ADD CONSTRAINT dashboard_configs_pkey PRIMARY KEY (id);


--
-- Name: document_references document_references_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.document_references
    ADD CONSTRAINT document_references_pkey PRIMARY KEY (id);


--
-- Name: documents documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT documents_pkey PRIMARY KEY (id);


--
-- Name: drawing_versions drawing_versions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.drawing_versions
    ADD CONSTRAINT drawing_versions_pkey PRIMARY KEY (id);


--
-- Name: dump_trucks dump_trucks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dump_trucks
    ADD CONSTRAINT dump_trucks_pkey PRIMARY KEY (id);


--
-- Name: employees employees_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.employees
    ADD CONSTRAINT employees_pkey PRIMARY KEY (id);


--
-- Name: equipment_assignments equipment_assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_assignments
    ADD CONSTRAINT equipment_assignments_pkey PRIMARY KEY (id);


--
-- Name: equipment_maintenance equipment_maintenance_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_maintenance
    ADD CONSTRAINT equipment_maintenance_pkey PRIMARY KEY (id);


--
-- Name: equipment equipment_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment
    ADD CONSTRAINT equipment_pkey PRIMARY KEY (id);


--
-- Name: equipment_usage equipment_usage_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_usage
    ADD CONSTRAINT equipment_usage_pkey PRIMARY KEY (id);


--
-- Name: estimate_line_items estimate_line_items_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimate_line_items
    ADD CONSTRAINT estimate_line_items_pkey PRIMARY KEY (id);


--
-- Name: estimates estimates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimates
    ADD CONSTRAINT estimates_pkey PRIMARY KEY (id);


--
-- Name: financial_documents financial_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.financial_documents
    ADD CONSTRAINT financial_documents_pkey PRIMARY KEY (id);


--
-- Name: general_ledger general_ledger_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.general_ledger
    ADD CONSTRAINT general_ledger_pkey PRIMARY KEY (id);


--
-- Name: hr_documents hr_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.hr_documents
    ADD CONSTRAINT hr_documents_pkey PRIMARY KEY (id);


--
-- Name: inspections inspections_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inspections
    ADD CONSTRAINT inspections_pkey PRIMARY KEY (id);


--
-- Name: integration_tokens integration_tokens_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.integration_tokens
    ADD CONSTRAINT integration_tokens_pkey PRIMARY KEY (id);


--
-- Name: inventory_transactions inventory_transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inventory_transactions
    ADD CONSTRAINT inventory_transactions_pkey PRIMARY KEY (id);


--
-- Name: issues issues_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.issues
    ADD CONSTRAINT issues_pkey PRIMARY KEY (id);


--
-- Name: job_titles job_titles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.job_titles
    ADD CONSTRAINT job_titles_pkey PRIMARY KEY (id);


--
-- Name: labor_records labor_records_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.labor_records
    ADD CONSTRAINT labor_records_pkey PRIMARY KEY (id);


--
-- Name: line_item_entries line_item_entries_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_item_entries
    ADD CONSTRAINT line_item_entries_pkey PRIMARY KEY (id);


--
-- Name: line_item_templates line_item_templates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_item_templates
    ADD CONSTRAINT line_item_templates_pkey PRIMARY KEY (id);


--
-- Name: line_items line_items_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT line_items_pkey PRIMARY KEY (id);


--
-- Name: maps maps_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.maps
    ADD CONSTRAINT maps_pkey PRIMARY KEY (id);


--
-- Name: material_inventory material_inventory_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_inventory
    ADD CONSTRAINT material_inventory_pkey PRIMARY KEY (id);


--
-- Name: material_orders material_orders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_orders
    ADD CONSTRAINT material_orders_pkey PRIMARY KEY (id);


--
-- Name: material_receipts material_receipts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_receipts
    ADD CONSTRAINT material_receipts_pkey PRIMARY KEY (id);


--
-- Name: materials materials_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.materials
    ADD CONSTRAINT materials_pkey PRIMARY KEY (id);


--
-- Name: meeting_minutes meeting_minutes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.meeting_minutes
    ADD CONSTRAINT meeting_minutes_pkey PRIMARY KEY (id);


--
-- Name: notifications notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_pkey PRIMARY KEY (id);


--
-- Name: organization_invites organization_invites_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_invites
    ADD CONSTRAINT organization_invites_pkey PRIMARY KEY (id);


--
-- Name: organization_member_rates organization_member_rates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_member_rates
    ADD CONSTRAINT organization_member_rates_pkey PRIMARY KEY (id);


--
-- Name: organization_members organization_members_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT organization_members_pkey PRIMARY KEY (id);


--
-- Name: organization_notification_settings organization_notification_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_notification_settings
    ADD CONSTRAINT organization_notification_settings_pkey PRIMARY KEY (organization_id);


--
-- Name: organization_projects organization_projects_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_projects
    ADD CONSTRAINT organization_projects_pkey PRIMARY KEY (id);


--
-- Name: organization_service_areas organization_service_areas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_service_areas
    ADD CONSTRAINT organization_service_areas_pkey PRIMARY KEY (id);


--
-- Name: organizations organizations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT organizations_pkey PRIMARY KEY (id);


--
-- Name: payments payments_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT payments_pkey PRIMARY KEY (id);


--
-- Name: payroll payroll_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payroll
    ADD CONSTRAINT payroll_pkey PRIMARY KEY (id);


--
-- Name: photos photos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.photos
    ADD CONSTRAINT photos_pkey PRIMARY KEY (id);


--
-- Name: prequalifications prequalifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.prequalifications
    ADD CONSTRAINT prequalifications_pkey PRIMARY KEY (id);


--
-- Name: procurement_workflows procurement_workflows_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procurement_workflows
    ADD CONSTRAINT procurement_workflows_pkey PRIMARY KEY (id);


--
-- Name: profiles profiles_email_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_email_key UNIQUE (email);


--
-- Name: profiles profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_pkey PRIMARY KEY (id);


--
-- Name: progress_billings progress_billings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.progress_billings
    ADD CONSTRAINT progress_billings_pkey PRIMARY KEY (id);


--
-- Name: project_inspectors project_inspectors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_inspectors
    ADD CONSTRAINT project_inspectors_pkey PRIMARY KEY (project_id, profile_id);


--
-- Name: project_invites project_invites_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_invites
    ADD CONSTRAINT project_invites_pkey PRIMARY KEY (id);


--
-- Name: project_service_areas project_service_areas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_service_areas
    ADD CONSTRAINT project_service_areas_pkey PRIMARY KEY (id);


--
-- Name: projects projects_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_pkey PRIMARY KEY (id);


--
-- Name: punch_lists punch_lists_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.punch_lists
    ADD CONSTRAINT punch_lists_pkey PRIMARY KEY (id);


--
-- Name: purchase_orders purchase_orders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.purchase_orders
    ADD CONSTRAINT purchase_orders_pkey PRIMARY KEY (id);


--
-- Name: quality_reviews quality_reviews_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.quality_reviews
    ADD CONSTRAINT quality_reviews_pkey PRIMARY KEY (id);


--
-- Name: regulatory_documents regulatory_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regulatory_documents
    ADD CONSTRAINT regulatory_documents_pkey PRIMARY KEY (id);


--
-- Name: reports reports_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reports
    ADD CONSTRAINT reports_pkey PRIMARY KEY (id);


--
-- Name: rfis rfis_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rfis
    ADD CONSTRAINT rfis_pkey PRIMARY KEY (id);


--
-- Name: rpc_error_debug rpc_error_debug_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rpc_error_debug
    ADD CONSTRAINT rpc_error_debug_pkey PRIMARY KEY (id);


--
-- Name: safety_incidents safety_incidents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.safety_incidents
    ADD CONSTRAINT safety_incidents_pkey PRIMARY KEY (id);


--
-- Name: sensor_data sensor_data_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.sensor_data
    ADD CONSTRAINT sensor_data_pkey PRIMARY KEY (id);


--
-- Name: subcontractor_agreements subcontractor_agreements_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontractor_agreements
    ADD CONSTRAINT subcontractor_agreements_pkey PRIMARY KEY (id);


--
-- Name: subcontracts subcontracts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontracts
    ADD CONSTRAINT subcontracts_pkey PRIMARY KEY (id);


--
-- Name: submittals submittals_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.submittals
    ADD CONSTRAINT submittals_pkey PRIMARY KEY (id);


--
-- Name: tack_rates tack_rates_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tack_rates
    ADD CONSTRAINT tack_rates_pkey PRIMARY KEY (id);


--
-- Name: task_dependencies task_dependencies_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.task_dependencies
    ADD CONSTRAINT task_dependencies_pkey PRIMARY KEY (id);


--
-- Name: task_status_logs task_status_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.task_status_logs
    ADD CONSTRAINT task_status_logs_pkey PRIMARY KEY (id);


--
-- Name: tasks tasks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tasks
    ADD CONSTRAINT tasks_pkey PRIMARY KEY (id);


--
-- Name: training_records training_records_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.training_records
    ADD CONSTRAINT training_records_pkey PRIMARY KEY (id);


--
-- Name: cost_codes uq_cost_codes_code; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cost_codes
    ADD CONSTRAINT uq_cost_codes_code UNIQUE (code);


--
-- Name: organization_members uq_organization_members; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT uq_organization_members UNIQUE (profile_id, organization_id);


--
-- Name: organizations uq_organizations_name; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organizations
    ADD CONSTRAINT uq_organizations_name UNIQUE (name);


--
-- Name: projects uq_projects_name; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT uq_projects_name UNIQUE (name, organization_id);


--
-- Name: user_projects uq_user_projects; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_projects
    ADD CONSTRAINT uq_user_projects UNIQUE (user_id, project_id);


--
-- Name: vendors uq_vendors_name; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendors
    ADD CONSTRAINT uq_vendors_name UNIQUE (name, organization_id);


--
-- Name: user_notification_settings user_notification_settings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_notification_settings
    ADD CONSTRAINT user_notification_settings_pkey PRIMARY KEY (user_id);


--
-- Name: user_projects user_projects_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_projects
    ADD CONSTRAINT user_projects_pkey PRIMARY KEY (id);


--
-- Name: vendor_bid_packages vendor_bid_packages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_bid_packages
    ADD CONSTRAINT vendor_bid_packages_pkey PRIMARY KEY (id);


--
-- Name: vendor_contacts vendor_contacts_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_contacts
    ADD CONSTRAINT vendor_contacts_pkey PRIMARY KEY (id);


--
-- Name: vendor_documents vendor_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_documents
    ADD CONSTRAINT vendor_documents_pkey PRIMARY KEY (id);


--
-- Name: vendor_qualifications vendor_qualifications_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_qualifications
    ADD CONSTRAINT vendor_qualifications_pkey PRIMARY KEY (id);


--
-- Name: vendors vendors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendors
    ADD CONSTRAINT vendors_pkey PRIMARY KEY (id);


--
-- Name: wbs wbs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wbs
    ADD CONSTRAINT wbs_pkey PRIMARY KEY (id);


--
-- Name: workflows workflows_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.workflows
    ADD CONSTRAINT workflows_pkey PRIMARY KEY (id);


--
-- Name: idx_documents_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_documents_project_id ON public.documents USING btree (project_id);


--
-- Name: idx_inspections_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_inspections_project_id ON public.inspections USING btree (project_id);


--
-- Name: idx_issues_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_issues_project_id ON public.issues USING btree (project_id);


--
-- Name: idx_line_items_map_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_line_items_map_id ON public.line_items USING btree (map_id);


--
-- Name: idx_line_items_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_line_items_project_id ON public.line_items USING btree (project_id);


--
-- Name: idx_line_items_wbs_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_line_items_wbs_id ON public.line_items USING btree (wbs_id);


--
-- Name: idx_maps_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_maps_project_id ON public.maps USING btree (project_id);


--
-- Name: idx_maps_wbs_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_maps_wbs_id ON public.maps USING btree (wbs_id);


--
-- Name: idx_notifications_user_created_at_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notifications_user_created_at_active ON public.notifications USING btree (user_id, created_at DESC) WHERE (deleted_at IS NULL);


--
-- Name: idx_notifications_user_unread_active; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_notifications_user_unread_active ON public.notifications USING btree (user_id) WHERE ((deleted_at IS NULL) AND (is_read = false));


--
-- Name: idx_organization_invites_role; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_organization_invites_role ON public.organization_invites USING btree (role);


--
-- Name: idx_projects_organization_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_projects_organization_id ON public.projects USING btree (organization_id);


--
-- Name: idx_rpc_error_debug_created_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_rpc_error_debug_created_at ON public.rpc_error_debug USING btree (created_at DESC);


--
-- Name: idx_rpc_error_debug_rpc_name; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_rpc_error_debug_rpc_name ON public.rpc_error_debug USING btree (rpc_name);


--
-- Name: idx_task_status_logs_task_changed; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_task_status_logs_task_changed ON public.task_status_logs USING btree (task_id, changed_at DESC);


--
-- Name: idx_task_status_logs_task_changed_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_task_status_logs_task_changed_at ON public.task_status_logs USING btree (task_id, changed_at DESC);


--
-- Name: idx_user_projects_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_projects_project_id ON public.user_projects USING btree (project_id);


--
-- Name: idx_user_projects_user_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_user_projects_user_id ON public.user_projects USING btree (user_id);


--
-- Name: idx_wbs_project_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wbs_project_id ON public.wbs USING btree (project_id);


--
-- Name: ix_accounts_payable__fk_fk_ap_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_accounts_payable__fk_fk_ap_project ON public.accounts_payable USING btree (project_id);


--
-- Name: ix_accounts_receivable__fk_fk_ar_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_accounts_receivable__fk_fk_ar_project ON public.accounts_receivable USING btree (project_id);


--
-- Name: ix_activity_logs__fk_fk_activity_logs_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_activity_logs__fk_fk_activity_logs_profile ON public.activity_logs USING btree (profile_id);


--
-- Name: ix_audit_logs__fk_fk_audit_logs_performed_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_audit_logs__fk_fk_audit_logs_performed_by ON public.audit_logs USING btree (performed_by);


--
-- Name: ix_audit_logs__fk_fk_audit_logs_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_audit_logs__fk_fk_audit_logs_project ON public.audit_logs USING btree (project_id);


--
-- Name: ix_bid_packages__fk_fk_bid_packages_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bid_packages__fk_fk_bid_packages_created_by ON public.bid_packages USING btree (created_by);


--
-- Name: ix_bid_packages__fk_fk_bid_packages_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bid_packages__fk_fk_bid_packages_project ON public.bid_packages USING btree (project_id);


--
-- Name: ix_bid_vendors__fk_fk_bid_vendors_bid_package; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bid_vendors__fk_fk_bid_vendors_bid_package ON public.bid_vendors USING btree (bid_package_id);


--
-- Name: ix_bid_vendors__fk_fk_bid_vendors_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bid_vendors__fk_fk_bid_vendors_vendor ON public.bid_vendors USING btree (vendor_id);


--
-- Name: ix_bids__fk_fk_bids_bid_package; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bids__fk_fk_bids_bid_package ON public.bids USING btree (bid_package_id);


--
-- Name: ix_bids__fk_fk_bids_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bids__fk_fk_bids_vendor ON public.bids USING btree (vendor_id);


--
-- Name: ix_bim_models__fk_fk_bim_models_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_bim_models__fk_fk_bim_models_project ON public.bim_models USING btree (project_id);


--
-- Name: ix_certifications__fk_fk_certifications_employee; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_certifications__fk_fk_certifications_employee ON public.certifications USING btree (employee_id);


--
-- Name: ix_change_orders__fk_fk_change_orders_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_change_orders__fk_fk_change_orders_project ON public.change_orders USING btree (project_id);


--
-- Name: ix_commitments__fk_fk_commitments_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_commitments__fk_fk_commitments_project ON public.commitments USING btree (project_id);


--
-- Name: ix_commitments__fk_fk_commitments_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_commitments__fk_fk_commitments_vendor ON public.commitments USING btree (vendor_id);


--
-- Name: ix_compliance_checks__fk_fk_compliance_checks_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_compliance_checks__fk_fk_compliance_checks_project ON public.compliance_checks USING btree (project_id);


--
-- Name: ix_compliance_tracking__fk_fk_compliance_tracking_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_compliance_tracking__fk_fk_compliance_tracking_project ON public.compliance_tracking USING btree (project_id);


--
-- Name: ix_crew_assignments__fk_fk_crew_assignments_crew; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crew_assignments__fk_fk_crew_assignments_crew ON public.crew_assignments USING btree (crew_id);


--
-- Name: ix_crew_assignments__fk_fk_crew_assignments_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crew_assignments__fk_fk_crew_assignments_profile ON public.crew_assignments USING btree (profile_id);


--
-- Name: ix_crew_members__fk_fk_crew_members_crew; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crew_members__fk_fk_crew_members_crew ON public.crew_members USING btree (crew_id);


--
-- Name: ix_crew_members__fk_fk_crew_members_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crew_members__fk_fk_crew_members_profile ON public.crew_members USING btree (profile_id);


--
-- Name: ix_crews__fk_fk_crews_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_crews__fk_fk_crews_project ON public.crews USING btree (project_id);


--
-- Name: ix_daily_logs__fk_fk_daily_logs_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_daily_logs__fk_fk_daily_logs_project ON public.daily_logs USING btree (project_id);


--
-- Name: ix_dashboard_configs__fk_fk_dashboard_configs_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_dashboard_configs__fk_fk_dashboard_configs_profile ON public.dashboard_configs USING btree (profile_id);


--
-- Name: ix_document_references__fk_fk_document_references_document; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_document_references__fk_fk_document_references_document ON public.document_references USING btree (document_id);


--
-- Name: ix_documents__fk_fk_documents_uploaded_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_documents__fk_fk_documents_uploaded_by ON public.documents USING btree (uploaded_by);


--
-- Name: ix_drawing_versions__fk_fk_drawing_versions_document; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_drawing_versions__fk_fk_drawing_versions_document ON public.drawing_versions USING btree (document_id);


--
-- Name: ix_drawing_versions__fk_fk_drawing_versions_uploaded_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_drawing_versions__fk_fk_drawing_versions_uploaded_by ON public.drawing_versions USING btree (uploaded_by);


--
-- Name: ix_dump_trucks__fk_fk_dump_trucks_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_dump_trucks__fk_fk_dump_trucks_organization ON public.dump_trucks USING btree (organization_id);


--
-- Name: ix_employees__fk_fk_employees_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_employees__fk_fk_employees_organization ON public.employees USING btree (organization_id);


--
-- Name: ix_employees__fk_fk_employees_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_employees__fk_fk_employees_profile ON public.employees USING btree (profile_id);


--
-- Name: ix_equipment__fk_fk_equipment_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment__fk_fk_equipment_organization ON public.equipment USING btree (organization_id);


--
-- Name: ix_equipment_assignments__fk_fk_equipment_assignments_assigned_; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_assignments__fk_fk_equipment_assignments_assigned_ ON public.equipment_assignments USING btree (assigned_to);


--
-- Name: ix_equipment_assignments__fk_fk_equipment_assignments_equipment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_assignments__fk_fk_equipment_assignments_equipment ON public.equipment_assignments USING btree (equipment_id);


--
-- Name: ix_equipment_assignments__fk_fk_equipment_assignments_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_assignments__fk_fk_equipment_assignments_project ON public.equipment_assignments USING btree (project_id);


--
-- Name: ix_equipment_maintenance__fk_fk_equipment_maintenance_equipment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_maintenance__fk_fk_equipment_maintenance_equipment ON public.equipment_maintenance USING btree (equipment_id);


--
-- Name: ix_equipment_maintenance__fk_fk_equipment_maintenance_performed; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_maintenance__fk_fk_equipment_maintenance_performed ON public.equipment_maintenance USING btree (performed_by);


--
-- Name: ix_equipment_usage__fk_fk_equipment_usage_equipment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_equipment_usage__fk_fk_equipment_usage_equipment ON public.equipment_usage USING btree (equipment_id);


--
-- Name: ix_estimate_line_items__fk_fk_estimate_line_items_cost_code; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_estimate_line_items__fk_fk_estimate_line_items_cost_code ON public.estimate_line_items USING btree (cost_code_id);


--
-- Name: ix_estimate_line_items__fk_fk_estimate_line_items_estimate; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_estimate_line_items__fk_fk_estimate_line_items_estimate ON public.estimate_line_items USING btree (estimate_id);


--
-- Name: ix_estimates__fk_fk_estimates_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_estimates__fk_fk_estimates_created_by ON public.estimates USING btree (created_by);


--
-- Name: ix_estimates__fk_fk_estimates_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_estimates__fk_fk_estimates_project ON public.estimates USING btree (project_id);


--
-- Name: ix_financial_documents__fk_fk_financial_documents_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_financial_documents__fk_fk_financial_documents_project ON public.financial_documents USING btree (project_id);


--
-- Name: ix_general_ledger__fk_fk_gl_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_general_ledger__fk_fk_gl_project ON public.general_ledger USING btree (project_id);


--
-- Name: ix_hr_documents__fk_fk_hr_documents_employee; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_hr_documents__fk_fk_hr_documents_employee ON public.hr_documents USING btree (employee_id);


--
-- Name: ix_integration_tokens__fk_fk_integration_tokens_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_integration_tokens__fk_fk_integration_tokens_profile ON public.integration_tokens USING btree (profile_id);


--
-- Name: ix_inventory_transactions__fk_fk_inventory_transactions_materia; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_inventory_transactions__fk_fk_inventory_transactions_materia ON public.inventory_transactions USING btree (material_id);


--
-- Name: ix_issues__fk_fk_issues_reported_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_issues__fk_fk_issues_reported_by ON public.issues USING btree (reported_by);


--
-- Name: ix_labor_records__fk_fk_labor_records_line_item; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_labor_records__fk_fk_labor_records_line_item ON public.labor_records USING btree (line_item_id);


--
-- Name: ix_line_item_entries__fk_fk_line_item_entries_line_item; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_line_item_entries__fk_fk_line_item_entries_line_item ON public.line_item_entries USING btree (line_item_id);


--
-- Name: ix_line_item_templates__fk_fk_line_item_templates_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_line_item_templates__fk_fk_line_item_templates_created_by ON public.line_item_templates USING btree (created_by);


--
-- Name: ix_line_items__fk_fk_line_items_cost_code; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_line_items__fk_fk_line_items_cost_code ON public.line_items USING btree (cost_code_id);


--
-- Name: ix_line_items__fk_fk_line_items_template; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_line_items__fk_fk_line_items_template ON public.line_items USING btree (template_id);


--
-- Name: ix_material_inventory__fk_fk_material_inventory_material; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_inventory__fk_fk_material_inventory_material ON public.material_inventory USING btree (material_id);


--
-- Name: ix_material_inventory__fk_fk_material_inventory_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_inventory__fk_fk_material_inventory_organization ON public.material_inventory USING btree (organization_id);


--
-- Name: ix_material_orders__fk_fk_material_orders_material; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_orders__fk_fk_material_orders_material ON public.material_orders USING btree (material_id);


--
-- Name: ix_material_orders__fk_fk_material_orders_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_orders__fk_fk_material_orders_project ON public.material_orders USING btree (project_id);


--
-- Name: ix_material_receipts__fk_fk_material_receipts_material_order; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_receipts__fk_fk_material_receipts_material_order ON public.material_receipts USING btree (material_order_id);


--
-- Name: ix_material_receipts__fk_fk_material_receipts_received_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_material_receipts__fk_fk_material_receipts_received_by ON public.material_receipts USING btree (received_by);


--
-- Name: ix_materials__fk_fk_materials_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_materials__fk_fk_materials_organization ON public.materials USING btree (organization_id);


--
-- Name: ix_meeting_minutes__fk_fk_meeting_minutes_created_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_meeting_minutes__fk_fk_meeting_minutes_created_by ON public.meeting_minutes USING btree (created_by);


--
-- Name: ix_meeting_minutes__fk_fk_meeting_minutes_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_meeting_minutes__fk_fk_meeting_minutes_project ON public.meeting_minutes USING btree (project_id);


--
-- Name: ix_organization_invites__fk_invited_profile_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_invites__fk_invited_profile_id ON public.organization_invites USING btree (invited_profile_id);


--
-- Name: ix_organization_invites__fk_org_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_invites__fk_org_id ON public.organization_invites USING btree (organization_id);


--
-- Name: ix_organization_invites__fk_organization_invites_requested_job_; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_invites__fk_organization_invites_requested_job_ ON public.organization_invites USING btree (requested_job_title_id);


--
-- Name: ix_organization_invites__fk_organization_invites_reviewed_job_t; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_invites__fk_organization_invites_reviewed_job_t ON public.organization_invites USING btree (reviewed_job_title_id);


--
-- Name: ix_organization_invites__fk_organization_invites_role_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_invites__fk_organization_invites_role_fkey ON public.organization_invites USING btree (role);


--
-- Name: ix_organization_member_rates__fk_organization_member_rates_memb; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_member_rates__fk_organization_member_rates_memb ON public.organization_member_rates USING btree (membership_id);


--
-- Name: ix_organization_members__fk_fk_org_members_org; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_members__fk_fk_org_members_org ON public.organization_members USING btree (organization_id);


--
-- Name: ix_organization_members__fk_fk_org_members_profile; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_members__fk_fk_org_members_profile ON public.organization_members USING btree (profile_id);


--
-- Name: ix_organization_members__fk_organization_members_job_title_id_f; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_members__fk_organization_members_job_title_id_f ON public.organization_members USING btree (job_title_id);


--
-- Name: ix_organization_notification_settings__fk_organization_notifica; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_notification_settings__fk_organization_notifica ON public.organization_notification_settings USING btree (updated_by);


--
-- Name: ix_organization_projects__fk_fk_org_projects_org; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_projects__fk_fk_org_projects_org ON public.organization_projects USING btree (organization_id);


--
-- Name: ix_organization_projects__fk_fk_org_projects_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_organization_projects__fk_fk_org_projects_project ON public.organization_projects USING btree (project_id);


--
-- Name: ix_payments__fk_fk_payments_commitment; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_payments__fk_fk_payments_commitment ON public.payments USING btree (commitment_id);


--
-- Name: ix_payments__fk_fk_payments_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_payments__fk_fk_payments_project ON public.payments USING btree (project_id);


--
-- Name: ix_payroll__fk_fk_payroll_employee; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_payroll__fk_fk_payroll_employee ON public.payroll USING btree (employee_id);


--
-- Name: ix_photos__fk_fk_photos_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_photos__fk_fk_photos_project ON public.photos USING btree (project_id);


--
-- Name: ix_photos__fk_fk_photos_uploaded_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_photos__fk_fk_photos_uploaded_by ON public.photos USING btree (uploaded_by);


--
-- Name: ix_prequalifications__fk_fk_prequalifications_reviewed_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_prequalifications__fk_fk_prequalifications_reviewed_by ON public.prequalifications USING btree (reviewed_by);


--
-- Name: ix_prequalifications__fk_fk_prequalifications_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_prequalifications__fk_fk_prequalifications_vendor ON public.prequalifications USING btree (vendor_id);


--
-- Name: ix_procurement_workflows__fk_fk_procurement_workflows_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_procurement_workflows__fk_fk_procurement_workflows_project ON public.procurement_workflows USING btree (project_id);


--
-- Name: ix_profiles__fk_fk_profiles_avatar_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_profiles__fk_fk_profiles_avatar_id ON public.profiles USING btree (avatar_id);


--
-- Name: ix_profiles__fk_fk_profiles_organizations; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_profiles__fk_fk_profiles_organizations ON public.profiles USING btree (organization_id);


--
-- Name: ix_progress_billings__fk_fk_progress_billings_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_progress_billings__fk_fk_progress_billings_project ON public.progress_billings USING btree (project_id);


--
-- Name: ix_project_inspectors__fk_project_inspectors_assigned_by_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_project_inspectors__fk_project_inspectors_assigned_by_fkey ON public.project_inspectors USING btree (assigned_by);


--
-- Name: ix_project_inspectors__fk_project_inspectors_profile_id_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_project_inspectors__fk_project_inspectors_profile_id_fkey ON public.project_inspectors USING btree (profile_id);


--
-- Name: ix_project_inspectors__fk_project_inspectors_project_id_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_project_inspectors__fk_project_inspectors_project_id_fkey ON public.project_inspectors USING btree (project_id);


--
-- Name: ix_project_invites__fk_project_invites_invited_by_profile_id_fk; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_project_invites__fk_project_invites_invited_by_profile_id_fk ON public.project_invites USING btree (invited_by_profile_id);


--
-- Name: ix_punch_lists__fk_fk_punch_lists_assigned_to; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_punch_lists__fk_fk_punch_lists_assigned_to ON public.punch_lists USING btree (assigned_to);


--
-- Name: ix_punch_lists__fk_fk_punch_lists_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_punch_lists__fk_fk_punch_lists_project ON public.punch_lists USING btree (project_id);


--
-- Name: ix_purchase_orders__fk_fk_purchase_orders_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_purchase_orders__fk_fk_purchase_orders_project ON public.purchase_orders USING btree (project_id);


--
-- Name: ix_purchase_orders__fk_fk_purchase_orders_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_purchase_orders__fk_fk_purchase_orders_vendor ON public.purchase_orders USING btree (vendor_id);


--
-- Name: ix_quality_reviews__fk_fk_quality_reviews_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_quality_reviews__fk_fk_quality_reviews_project ON public.quality_reviews USING btree (project_id);


--
-- Name: ix_quality_reviews__fk_fk_quality_reviews_reviewer; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_quality_reviews__fk_fk_quality_reviews_reviewer ON public.quality_reviews USING btree (reviewer);


--
-- Name: ix_regulatory_documents__fk_fk_regulatory_documents_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_regulatory_documents__fk_fk_regulatory_documents_project ON public.regulatory_documents USING btree (project_id);


--
-- Name: ix_reports__fk_fk_reports_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_reports__fk_fk_reports_project ON public.reports USING btree (project_id);


--
-- Name: ix_rfis__fk_fk_rfis_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_rfis__fk_fk_rfis_project ON public.rfis USING btree (project_id);


--
-- Name: ix_rfis__fk_fk_rfis_reviewed_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_rfis__fk_fk_rfis_reviewed_by ON public.rfis USING btree (reviewed_by);


--
-- Name: ix_rfis__fk_fk_rfis_submitted_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_rfis__fk_fk_rfis_submitted_by ON public.rfis USING btree (submitted_by);


--
-- Name: ix_safety_incidents__fk_fk_safety_incidents_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_safety_incidents__fk_fk_safety_incidents_project ON public.safety_incidents USING btree (project_id);


--
-- Name: ix_safety_incidents__fk_fk_safety_incidents_reported_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_safety_incidents__fk_fk_safety_incidents_reported_by ON public.safety_incidents USING btree (reported_by);


--
-- Name: ix_sensor_data__fk_fk_sensor_data_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_sensor_data__fk_fk_sensor_data_project ON public.sensor_data USING btree (project_id);


--
-- Name: ix_subcontractor_agreements__fk_fk_subcontractor_agreements_sub; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_subcontractor_agreements__fk_fk_subcontractor_agreements_sub ON public.subcontractor_agreements USING btree (subcontract_id);


--
-- Name: ix_subcontracts__fk_fk_subcontracts_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_subcontracts__fk_fk_subcontracts_project ON public.subcontracts USING btree (project_id);


--
-- Name: ix_subcontracts__fk_fk_subcontracts_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_subcontracts__fk_fk_subcontracts_vendor ON public.subcontracts USING btree (vendor_id);


--
-- Name: ix_submittals__fk_fk_submittals_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_submittals__fk_fk_submittals_project ON public.submittals USING btree (project_id);


--
-- Name: ix_submittals__fk_fk_submittals_reviewed_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_submittals__fk_fk_submittals_reviewed_by ON public.submittals USING btree (reviewed_by);


--
-- Name: ix_submittals__fk_fk_submittals_submitted_by; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_submittals__fk_fk_submittals_submitted_by ON public.submittals USING btree (submitted_by);


--
-- Name: ix_tack_rates__fk_fk_tack_rates_project; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_tack_rates__fk_fk_tack_rates_project ON public.tack_rates USING btree (project_id);


--
-- Name: ix_task_dependencies__fk_task_dependencies_depends_on_task_id_f; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_task_dependencies__fk_task_dependencies_depends_on_task_id_f ON public.task_dependencies USING btree (depends_on_task_id);


--
-- Name: ix_task_dependencies__fk_task_dependencies_task_id_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_task_dependencies__fk_task_dependencies_task_id_fkey ON public.task_dependencies USING btree (task_id);


--
-- Name: ix_tasks__fk_tasks_project_id_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_tasks__fk_tasks_project_id_fkey ON public.tasks USING btree (project_id);


--
-- Name: ix_training_records__fk_fk_training_records_employee; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_training_records__fk_fk_training_records_employee ON public.training_records USING btree (employee_id);


--
-- Name: ix_vendor_bid_packages__fk_fk_vendor_bid_packages_bid_package; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_bid_packages__fk_fk_vendor_bid_packages_bid_package ON public.vendor_bid_packages USING btree (bid_package_id);


--
-- Name: ix_vendor_bid_packages__fk_fk_vendor_bid_packages_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_bid_packages__fk_fk_vendor_bid_packages_vendor ON public.vendor_bid_packages USING btree (vendor_id);


--
-- Name: ix_vendor_contacts__fk_fk_vendor_contacts_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_contacts__fk_fk_vendor_contacts_vendor ON public.vendor_contacts USING btree (vendor_id);


--
-- Name: ix_vendor_documents__fk_fk_vendor_documents_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_documents__fk_fk_vendor_documents_vendor ON public.vendor_documents USING btree (vendor_id);


--
-- Name: ix_vendor_qualifications__fk_fk_vendor_qualifications_vendor; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendor_qualifications__fk_fk_vendor_qualifications_vendor ON public.vendor_qualifications USING btree (vendor_id);


--
-- Name: ix_vendors__fk_fk_vendors_organization; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ix_vendors__fk_fk_vendors_organization ON public.vendors USING btree (organization_id);


--
-- Name: organization_invites_org_invited_uq; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX organization_invites_org_invited_uq ON public.organization_invites USING btree (organization_id, invited_profile_id);


--
-- Name: organization_member_rates_membership_effective_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX organization_member_rates_membership_effective_idx ON public.organization_member_rates USING btree (membership_id, effective_start DESC);


--
-- Name: organization_members_org_profile_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX organization_members_org_profile_idx ON public.organization_members USING btree (organization_id, profile_id);


--
-- Name: organization_service_areas_org_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX organization_service_areas_org_id_idx ON public.organization_service_areas USING btree (organization_id);


--
-- Name: organization_service_areas_org_text_uq; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX organization_service_areas_org_text_uq ON public.organization_service_areas USING btree (organization_id, lower(service_area_text));


--
-- Name: project_invites_invited_profile_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX project_invites_invited_profile_id_idx ON public.project_invites USING btree (invited_profile_id);


--
-- Name: project_invites_project_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX project_invites_project_id_idx ON public.project_invites USING btree (project_id);


--
-- Name: project_invites_project_invited_uq; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX project_invites_project_invited_uq ON public.project_invites USING btree (project_id, invited_profile_id);


--
-- Name: project_service_areas_project_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX project_service_areas_project_id_idx ON public.project_service_areas USING btree (project_id);


--
-- Name: project_service_areas_project_service_uq; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX project_service_areas_project_service_uq ON public.project_service_areas USING btree (project_id, service_area_id);


--
-- Name: project_service_areas_service_area_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX project_service_areas_service_area_id_idx ON public.project_service_areas USING btree (service_area_id);


--
-- Name: notifications notifications_broadcast_trigger; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER notifications_broadcast_trigger AFTER INSERT ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.notifications_broadcast_trigger();


--
-- Name: notifications trg_notifications_enforce_delivery_policy; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_notifications_enforce_delivery_policy BEFORE INSERT ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.notifications_enforce_delivery_policy();


--
-- Name: bids trg_notify_bid_accepted_on_update; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_notify_bid_accepted_on_update AFTER UPDATE ON public.bids FOR EACH ROW EXECUTE FUNCTION public.notify_bid_accepted_on_update();


--
-- Name: bids trg_notify_new_bid; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_notify_new_bid AFTER INSERT ON public.bids FOR EACH ROW EXECUTE FUNCTION public.notify_new_bid();


--
-- Name: accounts_payable trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.accounts_payable FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: accounts_receivable trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.accounts_receivable FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: activity_logs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.activity_logs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: asphalt_types trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.asphalt_types FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: audit_logs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.audit_logs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: avatars trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.avatars FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: bid_packages trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.bid_packages FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: bid_vendors trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.bid_vendors FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: bids trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.bids FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: bim_models trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.bim_models FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: certifications trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.certifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: change_orders trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.change_orders FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: commitments trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.commitments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: compliance_checks trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.compliance_checks FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: compliance_tracking trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.compliance_tracking FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: cost_codes trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.cost_codes FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: crew_assignments trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.crew_assignments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: crew_members trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.crew_members FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: crews trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.crews FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: daily_logs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.daily_logs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: dashboard_configs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.dashboard_configs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: document_references trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.document_references FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: drawing_versions trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.drawing_versions FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: dump_trucks trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.dump_trucks FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: employees trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.employees FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: equipment trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.equipment FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: equipment_assignments trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.equipment_assignments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: equipment_maintenance trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.equipment_maintenance FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: equipment_usage trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.equipment_usage FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: estimate_line_items trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.estimate_line_items FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: estimates trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.estimates FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: financial_documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.financial_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: general_ledger trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.general_ledger FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: hr_documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.hr_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: inspections trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.inspections FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: integration_tokens trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.integration_tokens FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: inventory_transactions trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.inventory_transactions FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: issues trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.issues FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: job_titles trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.job_titles FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: labor_records trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.labor_records FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: line_item_entries trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.line_item_entries FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: line_item_templates trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.line_item_templates FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: line_items trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.line_items FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: maps trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.maps FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: material_inventory trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.material_inventory FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: material_orders trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.material_orders FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: material_receipts trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.material_receipts FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: materials trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.materials FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: meeting_minutes trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.meeting_minutes FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: notifications trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: organization_members trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.organization_members FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: organization_projects trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.organization_projects FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: organizations trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.organizations FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: payments trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.payments FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: payroll trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.payroll FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: photos trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.photos FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: prequalifications trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.prequalifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: procurement_workflows trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.procurement_workflows FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: profiles trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: progress_billings trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.progress_billings FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: projects trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: punch_lists trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.punch_lists FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: purchase_orders trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.purchase_orders FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: quality_reviews trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.quality_reviews FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: regulatory_documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.regulatory_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: reports trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.reports FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: rfis trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.rfis FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: safety_incidents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.safety_incidents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: sensor_data trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.sensor_data FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: subcontractor_agreements trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.subcontractor_agreements FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: subcontracts trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.subcontracts FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: submittals trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.submittals FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: tack_rates trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.tack_rates FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: tasks trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.tasks FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: training_records trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.training_records FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: user_projects trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.user_projects FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: vendor_bid_packages trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendor_bid_packages FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: vendor_contacts trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendor_contacts FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: vendor_documents trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendor_documents FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: vendor_qualifications trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendor_qualifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: vendors trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.vendors FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: wbs trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.wbs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: workflows trg_set_updated_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_set_updated_at BEFORE UPDATE ON public.workflows FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: accounts_payable trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.accounts_payable FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: accounts_receivable trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.accounts_receivable FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: activity_logs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.activity_logs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: asphalt_types trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.asphalt_types FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: audit_logs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.audit_logs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: avatars trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.avatars FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: bid_packages trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.bid_packages FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: bid_vendors trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.bid_vendors FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: bids trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.bids FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: bim_models trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.bim_models FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: certifications trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.certifications FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: change_orders trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.change_orders FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: commitments trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.commitments FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: compliance_checks trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.compliance_checks FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: compliance_tracking trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.compliance_tracking FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: cost_codes trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.cost_codes FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: crew_assignments trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.crew_assignments FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: crew_members trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.crew_members FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: crews trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.crews FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: daily_logs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.daily_logs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: dashboard_configs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.dashboard_configs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: document_references trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.document_references FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: drawing_versions trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.drawing_versions FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: dump_trucks trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.dump_trucks FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: employees trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.employees FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: equipment trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.equipment FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: equipment_assignments trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.equipment_assignments FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: equipment_maintenance trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.equipment_maintenance FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: equipment_usage trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.equipment_usage FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: estimate_line_items trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.estimate_line_items FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: estimates trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.estimates FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: financial_documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.financial_documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: general_ledger trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.general_ledger FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: hr_documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.hr_documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: inspections trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.inspections FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: integration_tokens trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.integration_tokens FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: inventory_transactions trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.inventory_transactions FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: issues trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.issues FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: job_titles trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.job_titles FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: labor_records trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.labor_records FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: line_item_entries trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.line_item_entries FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: line_item_templates trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.line_item_templates FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: line_items trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.line_items FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: maps trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.maps FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: material_inventory trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.material_inventory FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: material_orders trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.material_orders FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: material_receipts trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.material_receipts FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: materials trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.materials FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: meeting_minutes trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.meeting_minutes FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: notifications trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: organization_members trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.organization_members FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: organization_projects trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.organization_projects FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: organizations trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.organizations FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: payments trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.payments FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: payroll trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.payroll FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: photos trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.photos FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: prequalifications trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.prequalifications FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: procurement_workflows trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.procurement_workflows FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: profiles trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: progress_billings trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.progress_billings FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: projects trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.projects FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: punch_lists trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.punch_lists FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: purchase_orders trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.purchase_orders FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: quality_reviews trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.quality_reviews FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: regulatory_documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.regulatory_documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: reports trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.reports FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: rfis trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.rfis FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: safety_incidents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.safety_incidents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: sensor_data trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.sensor_data FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: subcontractor_agreements trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.subcontractor_agreements FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: subcontracts trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.subcontracts FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: submittals trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.submittals FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: tack_rates trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.tack_rates FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: task_dependencies trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.task_dependencies FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: tasks trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.tasks FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: training_records trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.training_records FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: user_projects trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.user_projects FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: vendor_bid_packages trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendor_bid_packages FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: vendor_contacts trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendor_contacts FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: vendor_documents trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendor_documents FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: vendor_qualifications trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendor_qualifications FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: vendors trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.vendors FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: wbs trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.wbs FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: workflows trg_touch_created_at; Type: TRIGGER; Schema: public; Owner: -
--

CREATE TRIGGER trg_touch_created_at BEFORE INSERT ON public.workflows FOR EACH ROW EXECUTE FUNCTION public.touch_created_at();


--
-- Name: activity_logs fk_activity_logs_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.activity_logs
    ADD CONSTRAINT fk_activity_logs_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: accounts_payable fk_ap_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.accounts_payable
    ADD CONSTRAINT fk_ap_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: accounts_receivable fk_ar_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.accounts_receivable
    ADD CONSTRAINT fk_ar_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: audit_logs fk_audit_logs_performed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT fk_audit_logs_performed_by FOREIGN KEY (performed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: audit_logs fk_audit_logs_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.audit_logs
    ADD CONSTRAINT fk_audit_logs_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: bid_packages fk_bid_packages_created_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_packages
    ADD CONSTRAINT fk_bid_packages_created_by FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: bid_packages fk_bid_packages_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_packages
    ADD CONSTRAINT fk_bid_packages_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: bid_vendors fk_bid_vendors_bid_package; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_vendors
    ADD CONSTRAINT fk_bid_vendors_bid_package FOREIGN KEY (bid_package_id) REFERENCES public.bid_packages(id) ON DELETE CASCADE;


--
-- Name: bid_vendors fk_bid_vendors_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bid_vendors
    ADD CONSTRAINT fk_bid_vendors_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- Name: bids fk_bids_bid_package; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bids
    ADD CONSTRAINT fk_bids_bid_package FOREIGN KEY (bid_package_id) REFERENCES public.bid_packages(id) ON DELETE CASCADE;


--
-- Name: bids fk_bids_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bids
    ADD CONSTRAINT fk_bids_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- Name: bim_models fk_bim_models_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.bim_models
    ADD CONSTRAINT fk_bim_models_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: certifications fk_certifications_employee; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.certifications
    ADD CONSTRAINT fk_certifications_employee FOREIGN KEY (employee_id) REFERENCES public.employees(id) ON DELETE CASCADE;


--
-- Name: change_orders fk_change_orders_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.change_orders
    ADD CONSTRAINT fk_change_orders_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: commitments fk_commitments_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.commitments
    ADD CONSTRAINT fk_commitments_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: commitments fk_commitments_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.commitments
    ADD CONSTRAINT fk_commitments_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE SET NULL;


--
-- Name: compliance_checks fk_compliance_checks_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compliance_checks
    ADD CONSTRAINT fk_compliance_checks_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: compliance_tracking fk_compliance_tracking_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.compliance_tracking
    ADD CONSTRAINT fk_compliance_tracking_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: crew_assignments fk_crew_assignments_crew; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_assignments
    ADD CONSTRAINT fk_crew_assignments_crew FOREIGN KEY (crew_id) REFERENCES public.crews(id) ON DELETE CASCADE;


--
-- Name: crew_assignments fk_crew_assignments_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_assignments
    ADD CONSTRAINT fk_crew_assignments_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: crew_members fk_crew_members_crew; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_members
    ADD CONSTRAINT fk_crew_members_crew FOREIGN KEY (crew_id) REFERENCES public.crews(id) ON DELETE CASCADE;


--
-- Name: crew_members fk_crew_members_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crew_members
    ADD CONSTRAINT fk_crew_members_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: crews fk_crews_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crews
    ADD CONSTRAINT fk_crews_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: daily_logs fk_daily_logs_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.daily_logs
    ADD CONSTRAINT fk_daily_logs_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: dashboard_configs fk_dashboard_configs_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dashboard_configs
    ADD CONSTRAINT fk_dashboard_configs_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: document_references fk_document_references_document; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.document_references
    ADD CONSTRAINT fk_document_references_document FOREIGN KEY (document_id) REFERENCES public.documents(id) ON DELETE CASCADE;


--
-- Name: documents fk_documents_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT fk_documents_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: documents fk_documents_uploaded_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.documents
    ADD CONSTRAINT fk_documents_uploaded_by FOREIGN KEY (uploaded_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: drawing_versions fk_drawing_versions_document; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.drawing_versions
    ADD CONSTRAINT fk_drawing_versions_document FOREIGN KEY (document_id) REFERENCES public.documents(id) ON DELETE CASCADE;


--
-- Name: drawing_versions fk_drawing_versions_uploaded_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.drawing_versions
    ADD CONSTRAINT fk_drawing_versions_uploaded_by FOREIGN KEY (uploaded_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: dump_trucks fk_dump_trucks_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.dump_trucks
    ADD CONSTRAINT fk_dump_trucks_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- Name: employees fk_employees_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.employees
    ADD CONSTRAINT fk_employees_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- Name: employees fk_employees_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.employees
    ADD CONSTRAINT fk_employees_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: equipment_assignments fk_equipment_assignments_assigned_to; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_assignments
    ADD CONSTRAINT fk_equipment_assignments_assigned_to FOREIGN KEY (assigned_to) REFERENCES public.crews(id) ON DELETE SET NULL;


--
-- Name: equipment_assignments fk_equipment_assignments_equipment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_assignments
    ADD CONSTRAINT fk_equipment_assignments_equipment FOREIGN KEY (equipment_id) REFERENCES public.equipment(id) ON DELETE CASCADE;


--
-- Name: equipment_assignments fk_equipment_assignments_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_assignments
    ADD CONSTRAINT fk_equipment_assignments_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: equipment_maintenance fk_equipment_maintenance_equipment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_maintenance
    ADD CONSTRAINT fk_equipment_maintenance_equipment FOREIGN KEY (equipment_id) REFERENCES public.equipment(id) ON DELETE CASCADE;


--
-- Name: equipment_maintenance fk_equipment_maintenance_performed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_maintenance
    ADD CONSTRAINT fk_equipment_maintenance_performed_by FOREIGN KEY (performed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: equipment fk_equipment_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment
    ADD CONSTRAINT fk_equipment_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- Name: equipment_usage fk_equipment_usage_equipment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.equipment_usage
    ADD CONSTRAINT fk_equipment_usage_equipment FOREIGN KEY (equipment_id) REFERENCES public.equipment(id) ON DELETE CASCADE;


--
-- Name: estimate_line_items fk_estimate_line_items_cost_code; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimate_line_items
    ADD CONSTRAINT fk_estimate_line_items_cost_code FOREIGN KEY (cost_code_id) REFERENCES public.cost_codes(id) ON DELETE SET NULL;


--
-- Name: estimate_line_items fk_estimate_line_items_estimate; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimate_line_items
    ADD CONSTRAINT fk_estimate_line_items_estimate FOREIGN KEY (estimate_id) REFERENCES public.estimates(id) ON DELETE CASCADE;


--
-- Name: estimates fk_estimates_created_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimates
    ADD CONSTRAINT fk_estimates_created_by FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: estimates fk_estimates_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.estimates
    ADD CONSTRAINT fk_estimates_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: financial_documents fk_financial_documents_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.financial_documents
    ADD CONSTRAINT fk_financial_documents_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: general_ledger fk_gl_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.general_ledger
    ADD CONSTRAINT fk_gl_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: hr_documents fk_hr_documents_employee; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.hr_documents
    ADD CONSTRAINT fk_hr_documents_employee FOREIGN KEY (employee_id) REFERENCES public.employees(id) ON DELETE CASCADE;


--
-- Name: inspections fk_inspections_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inspections
    ADD CONSTRAINT fk_inspections_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: integration_tokens fk_integration_tokens_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.integration_tokens
    ADD CONSTRAINT fk_integration_tokens_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: inventory_transactions fk_inventory_transactions_material; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inventory_transactions
    ADD CONSTRAINT fk_inventory_transactions_material FOREIGN KEY (material_id) REFERENCES public.materials(id) ON DELETE SET NULL;


--
-- Name: issues fk_issues_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.issues
    ADD CONSTRAINT fk_issues_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: issues fk_issues_reported_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.issues
    ADD CONSTRAINT fk_issues_reported_by FOREIGN KEY (reported_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: labor_records fk_labor_records_line_item; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.labor_records
    ADD CONSTRAINT fk_labor_records_line_item FOREIGN KEY (line_item_id) REFERENCES public.line_items(id) ON DELETE CASCADE;


--
-- Name: line_item_entries fk_line_item_entries_line_item; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_item_entries
    ADD CONSTRAINT fk_line_item_entries_line_item FOREIGN KEY (line_item_id) REFERENCES public.line_items(id) ON DELETE CASCADE;


--
-- Name: line_item_templates fk_line_item_templates_created_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_item_templates
    ADD CONSTRAINT fk_line_item_templates_created_by FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: line_items fk_line_items_cost_code; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_cost_code FOREIGN KEY (cost_code_id) REFERENCES public.cost_codes(id) ON DELETE SET NULL;


--
-- Name: line_items fk_line_items_map; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_map FOREIGN KEY (map_id) REFERENCES public.maps(id) ON DELETE CASCADE;


--
-- Name: line_items fk_line_items_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: line_items fk_line_items_template; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_template FOREIGN KEY (template_id) REFERENCES public.line_item_templates(id) ON DELETE SET NULL;


--
-- Name: line_items fk_line_items_wbs; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.line_items
    ADD CONSTRAINT fk_line_items_wbs FOREIGN KEY (wbs_id) REFERENCES public.wbs(id) ON DELETE CASCADE;


--
-- Name: maps fk_maps_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.maps
    ADD CONSTRAINT fk_maps_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: maps fk_maps_wbs; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.maps
    ADD CONSTRAINT fk_maps_wbs FOREIGN KEY (wbs_id) REFERENCES public.wbs(id) ON DELETE CASCADE;


--
-- Name: material_inventory fk_material_inventory_material; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_inventory
    ADD CONSTRAINT fk_material_inventory_material FOREIGN KEY (material_id) REFERENCES public.materials(id) ON DELETE CASCADE;


--
-- Name: material_inventory fk_material_inventory_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_inventory
    ADD CONSTRAINT fk_material_inventory_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- Name: material_orders fk_material_orders_material; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_orders
    ADD CONSTRAINT fk_material_orders_material FOREIGN KEY (material_id) REFERENCES public.materials(id) ON DELETE CASCADE;


--
-- Name: material_orders fk_material_orders_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_orders
    ADD CONSTRAINT fk_material_orders_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: material_receipts fk_material_receipts_material_order; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_receipts
    ADD CONSTRAINT fk_material_receipts_material_order FOREIGN KEY (material_order_id) REFERENCES public.material_orders(id) ON DELETE CASCADE;


--
-- Name: material_receipts fk_material_receipts_received_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.material_receipts
    ADD CONSTRAINT fk_material_receipts_received_by FOREIGN KEY (received_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: materials fk_materials_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.materials
    ADD CONSTRAINT fk_materials_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- Name: meeting_minutes fk_meeting_minutes_created_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.meeting_minutes
    ADD CONSTRAINT fk_meeting_minutes_created_by FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: meeting_minutes fk_meeting_minutes_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.meeting_minutes
    ADD CONSTRAINT fk_meeting_minutes_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: organization_members fk_org_members_org; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT fk_org_members_org FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE;


--
-- Name: organization_members fk_org_members_profile; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT fk_org_members_profile FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: organization_projects fk_org_projects_org; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_projects
    ADD CONSTRAINT fk_org_projects_org FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE;


--
-- Name: organization_projects fk_org_projects_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_projects
    ADD CONSTRAINT fk_org_projects_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: payments fk_payments_commitment; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT fk_payments_commitment FOREIGN KEY (commitment_id) REFERENCES public.commitments(id) ON DELETE SET NULL;


--
-- Name: payments fk_payments_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payments
    ADD CONSTRAINT fk_payments_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: payroll fk_payroll_employee; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payroll
    ADD CONSTRAINT fk_payroll_employee FOREIGN KEY (employee_id) REFERENCES public.employees(id) ON DELETE CASCADE;


--
-- Name: photos fk_photos_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.photos
    ADD CONSTRAINT fk_photos_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: photos fk_photos_uploaded_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.photos
    ADD CONSTRAINT fk_photos_uploaded_by FOREIGN KEY (uploaded_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: prequalifications fk_prequalifications_reviewed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.prequalifications
    ADD CONSTRAINT fk_prequalifications_reviewed_by FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: prequalifications fk_prequalifications_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.prequalifications
    ADD CONSTRAINT fk_prequalifications_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- Name: procurement_workflows fk_procurement_workflows_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.procurement_workflows
    ADD CONSTRAINT fk_procurement_workflows_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: profiles fk_profiles_avatar_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT fk_profiles_avatar_id FOREIGN KEY (avatar_id) REFERENCES public.avatars(id);


--
-- Name: profiles fk_profiles_organizations; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT fk_profiles_organizations FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- Name: progress_billings fk_progress_billings_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.progress_billings
    ADD CONSTRAINT fk_progress_billings_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: projects fk_projects_organizations; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT fk_projects_organizations FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- Name: punch_lists fk_punch_lists_assigned_to; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.punch_lists
    ADD CONSTRAINT fk_punch_lists_assigned_to FOREIGN KEY (assigned_to) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: punch_lists fk_punch_lists_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.punch_lists
    ADD CONSTRAINT fk_punch_lists_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: purchase_orders fk_purchase_orders_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.purchase_orders
    ADD CONSTRAINT fk_purchase_orders_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: purchase_orders fk_purchase_orders_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.purchase_orders
    ADD CONSTRAINT fk_purchase_orders_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE SET NULL;


--
-- Name: quality_reviews fk_quality_reviews_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.quality_reviews
    ADD CONSTRAINT fk_quality_reviews_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: quality_reviews fk_quality_reviews_reviewer; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.quality_reviews
    ADD CONSTRAINT fk_quality_reviews_reviewer FOREIGN KEY (reviewer) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: regulatory_documents fk_regulatory_documents_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.regulatory_documents
    ADD CONSTRAINT fk_regulatory_documents_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: reports fk_reports_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.reports
    ADD CONSTRAINT fk_reports_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: rfis fk_rfis_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rfis
    ADD CONSTRAINT fk_rfis_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: rfis fk_rfis_reviewed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rfis
    ADD CONSTRAINT fk_rfis_reviewed_by FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: rfis fk_rfis_submitted_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rfis
    ADD CONSTRAINT fk_rfis_submitted_by FOREIGN KEY (submitted_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: safety_incidents fk_safety_incidents_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.safety_incidents
    ADD CONSTRAINT fk_safety_incidents_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: safety_incidents fk_safety_incidents_reported_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.safety_incidents
    ADD CONSTRAINT fk_safety_incidents_reported_by FOREIGN KEY (reported_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: sensor_data fk_sensor_data_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.sensor_data
    ADD CONSTRAINT fk_sensor_data_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: subcontractor_agreements fk_subcontractor_agreements_subcontract; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontractor_agreements
    ADD CONSTRAINT fk_subcontractor_agreements_subcontract FOREIGN KEY (subcontract_id) REFERENCES public.subcontracts(id) ON DELETE CASCADE;


--
-- Name: subcontracts fk_subcontracts_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontracts
    ADD CONSTRAINT fk_subcontracts_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: subcontracts fk_subcontracts_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.subcontracts
    ADD CONSTRAINT fk_subcontracts_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- Name: submittals fk_submittals_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.submittals
    ADD CONSTRAINT fk_submittals_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: submittals fk_submittals_reviewed_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.submittals
    ADD CONSTRAINT fk_submittals_reviewed_by FOREIGN KEY (reviewed_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: submittals fk_submittals_submitted_by; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.submittals
    ADD CONSTRAINT fk_submittals_submitted_by FOREIGN KEY (submitted_by) REFERENCES public.profiles(id) ON DELETE SET NULL;


--
-- Name: tack_rates fk_tack_rates_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tack_rates
    ADD CONSTRAINT fk_tack_rates_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: training_records fk_training_records_employee; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.training_records
    ADD CONSTRAINT fk_training_records_employee FOREIGN KEY (employee_id) REFERENCES public.employees(id) ON DELETE CASCADE;


--
-- Name: user_projects fk_user_projects_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_projects
    ADD CONSTRAINT fk_user_projects_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: user_projects fk_user_projects_user; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_projects
    ADD CONSTRAINT fk_user_projects_user FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: vendor_bid_packages fk_vendor_bid_packages_bid_package; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_bid_packages
    ADD CONSTRAINT fk_vendor_bid_packages_bid_package FOREIGN KEY (bid_package_id) REFERENCES public.bid_packages(id) ON DELETE CASCADE;


--
-- Name: vendor_bid_packages fk_vendor_bid_packages_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_bid_packages
    ADD CONSTRAINT fk_vendor_bid_packages_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- Name: vendor_contacts fk_vendor_contacts_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_contacts
    ADD CONSTRAINT fk_vendor_contacts_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- Name: vendor_documents fk_vendor_documents_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_documents
    ADD CONSTRAINT fk_vendor_documents_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- Name: vendor_qualifications fk_vendor_qualifications_vendor; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendor_qualifications
    ADD CONSTRAINT fk_vendor_qualifications_vendor FOREIGN KEY (vendor_id) REFERENCES public.vendors(id) ON DELETE CASCADE;


--
-- Name: vendors fk_vendors_organization; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.vendors
    ADD CONSTRAINT fk_vendors_organization FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL;


--
-- Name: wbs fk_wbs_project; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.wbs
    ADD CONSTRAINT fk_wbs_project FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: notifications notifications_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id);


--
-- Name: organization_invites organization_invites_requested_job_title_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_invites
    ADD CONSTRAINT organization_invites_requested_job_title_id_fkey FOREIGN KEY (requested_job_title_id) REFERENCES public.job_titles(id);


--
-- Name: organization_invites organization_invites_reviewed_job_title_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_invites
    ADD CONSTRAINT organization_invites_reviewed_job_title_id_fkey FOREIGN KEY (reviewed_job_title_id) REFERENCES public.job_titles(id);


--
-- Name: organization_invites organization_invites_role_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_invites
    ADD CONSTRAINT organization_invites_role_fkey FOREIGN KEY (role) REFERENCES public.job_titles(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: organization_member_rates organization_member_rates_membership_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_member_rates
    ADD CONSTRAINT organization_member_rates_membership_id_fkey FOREIGN KEY (membership_id) REFERENCES public.organization_members(id) ON DELETE CASCADE;


--
-- Name: organization_members organization_members_job_title_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_members
    ADD CONSTRAINT organization_members_job_title_id_fkey FOREIGN KEY (job_title_id) REFERENCES public.job_titles(id);


--
-- Name: organization_notification_settings organization_notification_settings_organization_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_notification_settings
    ADD CONSTRAINT organization_notification_settings_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE;


--
-- Name: organization_notification_settings organization_notification_settings_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_notification_settings
    ADD CONSTRAINT organization_notification_settings_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.profiles(id);


--
-- Name: organization_service_areas organization_service_areas_organization_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.organization_service_areas
    ADD CONSTRAINT organization_service_areas_organization_id_fkey FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE;


--
-- Name: project_inspectors project_inspectors_assigned_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_inspectors
    ADD CONSTRAINT project_inspectors_assigned_by_fkey FOREIGN KEY (assigned_by) REFERENCES public.profiles(id);


--
-- Name: project_inspectors project_inspectors_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_inspectors
    ADD CONSTRAINT project_inspectors_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id);


--
-- Name: project_inspectors project_inspectors_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_inspectors
    ADD CONSTRAINT project_inspectors_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id);


--
-- Name: project_invites project_invites_invited_by_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_invites
    ADD CONSTRAINT project_invites_invited_by_profile_id_fkey FOREIGN KEY (invited_by_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: project_invites project_invites_invited_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_invites
    ADD CONSTRAINT project_invites_invited_profile_id_fkey FOREIGN KEY (invited_profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: project_invites project_invites_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_invites
    ADD CONSTRAINT project_invites_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: project_service_areas project_service_areas_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_service_areas
    ADD CONSTRAINT project_service_areas_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE;


--
-- Name: project_service_areas project_service_areas_service_area_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.project_service_areas
    ADD CONSTRAINT project_service_areas_service_area_id_fkey FOREIGN KEY (service_area_id) REFERENCES public.organization_service_areas(id) ON DELETE CASCADE;


--
-- Name: task_dependencies task_dependencies_depends_on_task_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.task_dependencies
    ADD CONSTRAINT task_dependencies_depends_on_task_id_fkey FOREIGN KEY (depends_on_task_id) REFERENCES public.tasks(id);


--
-- Name: task_dependencies task_dependencies_task_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.task_dependencies
    ADD CONSTRAINT task_dependencies_task_id_fkey FOREIGN KEY (task_id) REFERENCES public.tasks(id);


--
-- Name: tasks tasks_project_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tasks
    ADD CONSTRAINT tasks_project_id_fkey FOREIGN KEY (project_id) REFERENCES public.projects(id);


--
-- Name: user_notification_settings user_notification_settings_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.user_notification_settings
    ADD CONSTRAINT user_notification_settings_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: accounts_payable; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.accounts_payable ENABLE ROW LEVEL SECURITY;

--
-- Name: accounts_receivable; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.accounts_receivable ENABLE ROW LEVEL SECURITY;

--
-- Name: activity_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.activity_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: asphalt_types; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.asphalt_types ENABLE ROW LEVEL SECURITY;

--
-- Name: audit_log; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

--
-- Name: audit_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: avatars; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.avatars ENABLE ROW LEVEL SECURITY;

--
-- Name: bid_packages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bid_packages ENABLE ROW LEVEL SECURITY;

--
-- Name: bid_vendors; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bid_vendors ENABLE ROW LEVEL SECURITY;

--
-- Name: bids; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bids ENABLE ROW LEVEL SECURITY;

--
-- Name: bim_models; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.bim_models ENABLE ROW LEVEL SECURITY;

--
-- Name: certifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.certifications ENABLE ROW LEVEL SECURITY;

--
-- Name: change_orders; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.change_orders ENABLE ROW LEVEL SECURITY;

--
-- Name: commitments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.commitments ENABLE ROW LEVEL SECURITY;

--
-- Name: compliance_checks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;

--
-- Name: compliance_tracking; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.compliance_tracking ENABLE ROW LEVEL SECURITY;

--
-- Name: cost_codes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.cost_codes ENABLE ROW LEVEL SECURITY;

--
-- Name: crew_assignments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crew_assignments ENABLE ROW LEVEL SECURITY;

--
-- Name: crew_members; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crew_members ENABLE ROW LEVEL SECURITY;

--
-- Name: crews; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.crews ENABLE ROW LEVEL SECURITY;

--
-- Name: daily_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.daily_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: dashboard_configs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.dashboard_configs ENABLE ROW LEVEL SECURITY;

--
-- Name: document_references; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.document_references ENABLE ROW LEVEL SECURITY;

--
-- Name: documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;

--
-- Name: drawing_versions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.drawing_versions ENABLE ROW LEVEL SECURITY;

--
-- Name: dump_trucks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.dump_trucks ENABLE ROW LEVEL SECURITY;

--
-- Name: employees; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.employees ENABLE ROW LEVEL SECURITY;

--
-- Name: equipment; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.equipment ENABLE ROW LEVEL SECURITY;

--
-- Name: equipment_assignments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.equipment_assignments ENABLE ROW LEVEL SECURITY;

--
-- Name: equipment_maintenance; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.equipment_maintenance ENABLE ROW LEVEL SECURITY;

--
-- Name: equipment_usage; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.equipment_usage ENABLE ROW LEVEL SECURITY;

--
-- Name: estimate_line_items; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.estimate_line_items ENABLE ROW LEVEL SECURITY;

--
-- Name: estimates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.estimates ENABLE ROW LEVEL SECURITY;

--
-- Name: financial_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.financial_documents ENABLE ROW LEVEL SECURITY;

--
-- Name: general_ledger; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.general_ledger ENABLE ROW LEVEL SECURITY;

--
-- Name: hr_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.hr_documents ENABLE ROW LEVEL SECURITY;

--
-- Name: inspections; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.inspections ENABLE ROW LEVEL SECURITY;

--
-- Name: integration_tokens; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.integration_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: inventory_transactions; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.inventory_transactions ENABLE ROW LEVEL SECURITY;

--
-- Name: issues; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.issues ENABLE ROW LEVEL SECURITY;

--
-- Name: job_titles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.job_titles ENABLE ROW LEVEL SECURITY;

--
-- Name: labor_records; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.labor_records ENABLE ROW LEVEL SECURITY;

--
-- Name: line_item_entries; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.line_item_entries ENABLE ROW LEVEL SECURITY;

--
-- Name: line_item_templates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.line_item_templates ENABLE ROW LEVEL SECURITY;

--
-- Name: line_items; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.line_items ENABLE ROW LEVEL SECURITY;

--
-- Name: maps; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.maps ENABLE ROW LEVEL SECURITY;

--
-- Name: material_inventory; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.material_inventory ENABLE ROW LEVEL SECURITY;

--
-- Name: material_orders; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.material_orders ENABLE ROW LEVEL SECURITY;

--
-- Name: material_receipts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.material_receipts ENABLE ROW LEVEL SECURITY;

--
-- Name: materials; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.materials ENABLE ROW LEVEL SECURITY;

--
-- Name: meeting_minutes; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.meeting_minutes ENABLE ROW LEVEL SECURITY;

--
-- Name: notifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: organization_notification_settings org_notification_settings_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY org_notification_settings_select ON public.organization_notification_settings FOR SELECT USING (public.check_access_bool('select'::text, 'organizations'::text, NULL::uuid, organization_id));


--
-- Name: organization_notification_settings org_notification_settings_upsert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY org_notification_settings_upsert ON public.organization_notification_settings USING (public.can_edit_org_notification_settings(organization_id)) WITH CHECK (public.can_edit_org_notification_settings(organization_id));


--
-- Name: organization_invites; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_invites ENABLE ROW LEVEL SECURITY;

--
-- Name: organization_member_rates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_member_rates ENABLE ROW LEVEL SECURITY;

--
-- Name: organization_members; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_members ENABLE ROW LEVEL SECURITY;

--
-- Name: organization_notification_settings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_notification_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: organization_projects; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_projects ENABLE ROW LEVEL SECURITY;

--
-- Name: organization_service_areas; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organization_service_areas ENABLE ROW LEVEL SECURITY;

--
-- Name: organizations; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.organizations ENABLE ROW LEVEL SECURITY;

--
-- Name: accounts_payable p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.accounts_payable FOR DELETE USING (public.check_access_bool('delete'::text, 'accounts_payable'::text, project_id, NULL::uuid));


--
-- Name: accounts_receivable p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.accounts_receivable FOR DELETE USING (public.check_access_bool('delete'::text, 'accounts_receivable'::text, project_id, NULL::uuid));


--
-- Name: activity_logs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.activity_logs FOR DELETE USING (public.check_access_bool('delete'::text, 'activity_logs'::text, NULL::uuid, NULL::uuid));


--
-- Name: asphalt_types p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.asphalt_types FOR DELETE USING (public.check_access_bool('delete'::text, 'asphalt_types'::text, NULL::uuid, NULL::uuid));


--
-- Name: audit_log p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.audit_log FOR DELETE USING (public.check_access_bool('delete'::text, 'audit_log'::text, NULL::uuid, NULL::uuid));


--
-- Name: audit_logs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.audit_logs FOR DELETE USING (public.check_access_bool('delete'::text, 'audit_logs'::text, project_id, NULL::uuid));


--
-- Name: avatars p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.avatars FOR DELETE USING (public.check_access_bool('delete'::text, 'avatars'::text, NULL::uuid, NULL::uuid));


--
-- Name: bid_packages p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.bid_packages FOR DELETE USING (public.check_access_bool('delete'::text, 'bid_packages'::text, project_id, NULL::uuid));


--
-- Name: bid_vendors p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.bid_vendors FOR DELETE USING (public.check_access_bool('delete'::text, 'bid_vendors'::text, NULL::uuid, NULL::uuid));


--
-- Name: bids p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.bids FOR DELETE USING (public.check_access_bool('delete'::text, 'bids'::text, NULL::uuid, NULL::uuid));


--
-- Name: bim_models p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.bim_models FOR DELETE USING (public.check_access_bool('delete'::text, 'bim_models'::text, project_id, NULL::uuid));


--
-- Name: certifications p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.certifications FOR DELETE USING (public.check_access_bool('delete'::text, 'certifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: change_orders p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.change_orders FOR DELETE USING (public.check_access_bool('delete'::text, 'change_orders'::text, project_id, NULL::uuid));


--
-- Name: commitments p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.commitments FOR DELETE USING (public.check_access_bool('delete'::text, 'commitments'::text, project_id, NULL::uuid));


--
-- Name: compliance_checks p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.compliance_checks FOR DELETE USING (public.check_access_bool('delete'::text, 'compliance_checks'::text, project_id, NULL::uuid));


--
-- Name: compliance_tracking p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.compliance_tracking FOR DELETE USING (public.check_access_bool('delete'::text, 'compliance_tracking'::text, project_id, NULL::uuid));


--
-- Name: cost_codes p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.cost_codes FOR DELETE USING (public.check_access_bool('delete'::text, 'cost_codes'::text, NULL::uuid, NULL::uuid));


--
-- Name: crew_assignments p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.crew_assignments FOR DELETE USING (public.check_access_bool('delete'::text, 'crew_assignments'::text, NULL::uuid, NULL::uuid));


--
-- Name: crew_members p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.crew_members FOR DELETE USING (public.check_access_bool('delete'::text, 'crew_members'::text, NULL::uuid, NULL::uuid));


--
-- Name: crews p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.crews FOR DELETE USING (public.check_access_bool('delete'::text, 'crews'::text, project_id, NULL::uuid));


--
-- Name: daily_logs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.daily_logs FOR DELETE USING (public.check_access_bool('delete'::text, 'daily_logs'::text, project_id, NULL::uuid));


--
-- Name: dashboard_configs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.dashboard_configs FOR DELETE USING (public.check_access_bool('delete'::text, 'dashboard_configs'::text, NULL::uuid, NULL::uuid));


--
-- Name: document_references p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.document_references FOR DELETE USING (public.check_access_bool('delete'::text, 'document_references'::text, NULL::uuid, NULL::uuid));


--
-- Name: documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.documents FOR DELETE USING (public.check_access_bool('delete'::text, 'documents'::text, project_id, NULL::uuid));


--
-- Name: drawing_versions p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.drawing_versions FOR DELETE USING (public.check_access_bool('delete'::text, 'drawing_versions'::text, NULL::uuid, NULL::uuid));


--
-- Name: dump_trucks p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.dump_trucks FOR DELETE USING (public.check_access_bool('delete'::text, 'dump_trucks'::text, NULL::uuid, organization_id));


--
-- Name: employees p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.employees FOR DELETE USING (public.check_access_bool('delete'::text, 'employees'::text, NULL::uuid, organization_id));


--
-- Name: equipment p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.equipment FOR DELETE USING (public.check_access_bool('delete'::text, 'equipment'::text, NULL::uuid, organization_id));


--
-- Name: equipment_assignments p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.equipment_assignments FOR DELETE USING (public.check_access_bool('delete'::text, 'equipment_assignments'::text, project_id, NULL::uuid));


--
-- Name: equipment_maintenance p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.equipment_maintenance FOR DELETE USING (public.check_access_bool('delete'::text, 'equipment_maintenance'::text, NULL::uuid, NULL::uuid));


--
-- Name: equipment_usage p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.equipment_usage FOR DELETE USING (public.check_access_bool('delete'::text, 'equipment_usage'::text, NULL::uuid, NULL::uuid));


--
-- Name: estimate_line_items p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.estimate_line_items FOR DELETE USING (public.check_access_bool('delete'::text, 'estimate_line_items'::text, NULL::uuid, NULL::uuid));


--
-- Name: estimates p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.estimates FOR DELETE USING (public.check_access_bool('delete'::text, 'estimates'::text, project_id, NULL::uuid));


--
-- Name: financial_documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.financial_documents FOR DELETE USING (public.check_access_bool('delete'::text, 'financial_documents'::text, project_id, NULL::uuid));


--
-- Name: general_ledger p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.general_ledger FOR DELETE USING (public.check_access_bool('delete'::text, 'general_ledger'::text, project_id, NULL::uuid));


--
-- Name: hr_documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.hr_documents FOR DELETE USING (public.check_access_bool('delete'::text, 'hr_documents'::text, NULL::uuid, NULL::uuid));


--
-- Name: inspections p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.inspections FOR DELETE USING (public.check_access_bool('delete'::text, 'inspections'::text, project_id, NULL::uuid));


--
-- Name: integration_tokens p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.integration_tokens FOR DELETE USING (public.check_access_bool('delete'::text, 'integration_tokens'::text, NULL::uuid, NULL::uuid));


--
-- Name: inventory_transactions p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.inventory_transactions FOR DELETE USING (public.check_access_bool('delete'::text, 'inventory_transactions'::text, NULL::uuid, NULL::uuid));


--
-- Name: issues p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.issues FOR DELETE USING (public.check_access_bool('delete'::text, 'issues'::text, project_id, NULL::uuid));


--
-- Name: job_titles p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.job_titles FOR DELETE USING (public.check_access_bool('delete'::text, 'job_titles'::text, NULL::uuid, NULL::uuid));


--
-- Name: labor_records p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.labor_records FOR DELETE USING (public.check_access_bool('delete'::text, 'labor_records'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_item_entries p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.line_item_entries FOR DELETE USING (public.check_access_bool('delete'::text, 'line_item_entries'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_item_templates p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.line_item_templates FOR DELETE USING (public.check_access_bool('delete'::text, 'line_item_templates'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_items p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.line_items FOR DELETE USING (public.check_access_bool('delete'::text, 'line_items'::text, project_id, NULL::uuid));


--
-- Name: maps p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.maps FOR DELETE USING (public.check_access_bool('delete'::text, 'maps'::text, project_id, NULL::uuid));


--
-- Name: material_inventory p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.material_inventory FOR DELETE USING (public.check_access_bool('delete'::text, 'material_inventory'::text, NULL::uuid, organization_id));


--
-- Name: material_orders p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.material_orders FOR DELETE USING (public.check_access_bool('delete'::text, 'material_orders'::text, project_id, NULL::uuid));


--
-- Name: material_receipts p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.material_receipts FOR DELETE USING (public.check_access_bool('delete'::text, 'material_receipts'::text, NULL::uuid, NULL::uuid));


--
-- Name: materials p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.materials FOR DELETE USING (public.check_access_bool('delete'::text, 'materials'::text, NULL::uuid, organization_id));


--
-- Name: meeting_minutes p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.meeting_minutes FOR DELETE USING (public.check_access_bool('delete'::text, 'meeting_minutes'::text, project_id, NULL::uuid));


--
-- Name: notifications p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.notifications FOR DELETE USING ((user_id = auth.uid()));


--
-- Name: organization_invites p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.organization_invites FOR DELETE USING (public.check_access_bool('delete'::text, 'organization_invites'::text, NULL::uuid, organization_id));


--
-- Name: organization_members p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.organization_members FOR DELETE USING (public.check_access_bool('delete'::text, 'organization_members'::text, NULL::uuid, organization_id));


--
-- Name: organization_projects p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.organization_projects FOR DELETE USING (public.check_access_bool('delete'::text, 'organization_projects'::text, project_id, organization_id));


--
-- Name: organizations p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.organizations FOR DELETE USING (public.check_access_bool('delete'::text, 'organizations'::text, NULL::uuid, id));


--
-- Name: payments p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.payments FOR DELETE USING (public.check_access_bool('delete'::text, 'payments'::text, project_id, NULL::uuid));


--
-- Name: payroll p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.payroll FOR DELETE USING (public.check_access_bool('delete'::text, 'payroll'::text, NULL::uuid, NULL::uuid));


--
-- Name: photos p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.photos FOR DELETE USING (public.check_access_bool('delete'::text, 'photos'::text, project_id, NULL::uuid));


--
-- Name: prequalifications p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.prequalifications FOR DELETE USING (public.check_access_bool('delete'::text, 'prequalifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: procurement_workflows p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.procurement_workflows FOR DELETE USING (public.check_access_bool('delete'::text, 'procurement_workflows'::text, project_id, NULL::uuid));


--
-- Name: profiles p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.profiles AS RESTRICTIVE FOR DELETE TO authenticated USING (public.check_access_bool('delete'::text, 'profiles'::text, NULL::uuid, organization_id));


--
-- Name: progress_billings p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.progress_billings FOR DELETE USING (public.check_access_bool('delete'::text, 'progress_billings'::text, project_id, NULL::uuid));


--
-- Name: project_inspectors p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.project_inspectors FOR DELETE USING (public.check_access_bool('delete'::text, 'project_inspectors'::text, project_id, NULL::uuid));


--
-- Name: projects p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.projects FOR DELETE USING (public.check_access_bool('delete'::text, 'projects'::text, NULL::uuid, organization_id));


--
-- Name: punch_lists p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.punch_lists FOR DELETE USING (public.check_access_bool('delete'::text, 'punch_lists'::text, project_id, NULL::uuid));


--
-- Name: purchase_orders p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.purchase_orders FOR DELETE USING (public.check_access_bool('delete'::text, 'purchase_orders'::text, project_id, NULL::uuid));


--
-- Name: quality_reviews p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.quality_reviews FOR DELETE USING (public.check_access_bool('delete'::text, 'quality_reviews'::text, project_id, NULL::uuid));


--
-- Name: regulatory_documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.regulatory_documents FOR DELETE USING (public.check_access_bool('delete'::text, 'regulatory_documents'::text, project_id, NULL::uuid));


--
-- Name: reports p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.reports FOR DELETE USING (public.check_access_bool('delete'::text, 'reports'::text, project_id, NULL::uuid));


--
-- Name: rfis p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.rfis FOR DELETE USING (public.check_access_bool('delete'::text, 'rfis'::text, project_id, NULL::uuid));


--
-- Name: safety_incidents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.safety_incidents FOR DELETE USING (public.check_access_bool('delete'::text, 'safety_incidents'::text, project_id, NULL::uuid));


--
-- Name: sensor_data p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.sensor_data FOR DELETE USING (public.check_access_bool('delete'::text, 'sensor_data'::text, project_id, NULL::uuid));


--
-- Name: subcontractor_agreements p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.subcontractor_agreements FOR DELETE USING (public.check_access_bool('delete'::text, 'subcontractor_agreements'::text, NULL::uuid, NULL::uuid));


--
-- Name: subcontracts p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.subcontracts FOR DELETE USING (public.check_access_bool('delete'::text, 'subcontracts'::text, project_id, NULL::uuid));


--
-- Name: submittals p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.submittals FOR DELETE USING (public.check_access_bool('delete'::text, 'submittals'::text, project_id, NULL::uuid));


--
-- Name: tack_rates p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.tack_rates FOR DELETE USING (public.check_access_bool('delete'::text, 'tack_rates'::text, project_id, NULL::uuid));


--
-- Name: task_dependencies p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.task_dependencies FOR DELETE USING (public.check_access_bool('delete'::text, 'task_dependencies'::text, NULL::uuid, NULL::uuid));


--
-- Name: task_status_logs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.task_status_logs FOR DELETE USING (public.check_access_bool('delete'::text, 'task_status_logs'::text, NULL::uuid, NULL::uuid));


--
-- Name: tasks p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.tasks FOR DELETE USING (public.check_access_bool('delete'::text, 'tasks'::text, project_id, NULL::uuid));


--
-- Name: training_records p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.training_records FOR DELETE USING (public.check_access_bool('delete'::text, 'training_records'::text, NULL::uuid, NULL::uuid));


--
-- Name: user_projects p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.user_projects FOR DELETE USING (public.check_access_bool('delete'::text, 'user_projects'::text, project_id, NULL::uuid));


--
-- Name: vendor_bid_packages p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendor_bid_packages FOR DELETE USING (public.check_access_bool('delete'::text, 'vendor_bid_packages'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_contacts p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendor_contacts FOR DELETE USING (public.check_access_bool('delete'::text, 'vendor_contacts'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_documents p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendor_documents FOR DELETE USING (public.check_access_bool('delete'::text, 'vendor_documents'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_qualifications p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendor_qualifications FOR DELETE USING (public.check_access_bool('delete'::text, 'vendor_qualifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendors p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.vendors FOR DELETE USING (public.check_access_bool('delete'::text, 'vendors'::text, NULL::uuid, organization_id));


--
-- Name: wbs p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.wbs FOR DELETE USING (public.check_access_bool('delete'::text, 'wbs'::text, project_id, NULL::uuid));


--
-- Name: workflows p_check_access_delete; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_delete ON public.workflows FOR DELETE USING (public.check_access_bool('delete'::text, 'workflows'::text, NULL::uuid, NULL::uuid));


--
-- Name: accounts_payable p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.accounts_payable FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'accounts_payable'::text, project_id, NULL::uuid));


--
-- Name: accounts_receivable p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.accounts_receivable FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'accounts_receivable'::text, project_id, NULL::uuid));


--
-- Name: activity_logs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.activity_logs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'activity_logs'::text, NULL::uuid, NULL::uuid));


--
-- Name: asphalt_types p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.asphalt_types FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'asphalt_types'::text, NULL::uuid, NULL::uuid));


--
-- Name: audit_log p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.audit_log FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'audit_log'::text, NULL::uuid, NULL::uuid));


--
-- Name: audit_logs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.audit_logs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'audit_logs'::text, project_id, NULL::uuid));


--
-- Name: avatars p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.avatars FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'avatars'::text, NULL::uuid, NULL::uuid));


--
-- Name: bid_packages p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.bid_packages FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'bid_packages'::text, project_id, NULL::uuid));


--
-- Name: bid_vendors p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.bid_vendors FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'bid_vendors'::text, NULL::uuid, NULL::uuid));


--
-- Name: bids p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.bids FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'bids'::text, NULL::uuid, NULL::uuid));


--
-- Name: bim_models p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.bim_models FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'bim_models'::text, project_id, NULL::uuid));


--
-- Name: certifications p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.certifications FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'certifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: change_orders p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.change_orders FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'change_orders'::text, project_id, NULL::uuid));


--
-- Name: commitments p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.commitments FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'commitments'::text, project_id, NULL::uuid));


--
-- Name: compliance_checks p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.compliance_checks FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'compliance_checks'::text, project_id, NULL::uuid));


--
-- Name: compliance_tracking p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.compliance_tracking FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'compliance_tracking'::text, project_id, NULL::uuid));


--
-- Name: cost_codes p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.cost_codes FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'cost_codes'::text, NULL::uuid, NULL::uuid));


--
-- Name: crew_assignments p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.crew_assignments FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'crew_assignments'::text, NULL::uuid, NULL::uuid));


--
-- Name: crew_members p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.crew_members FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'crew_members'::text, NULL::uuid, NULL::uuid));


--
-- Name: crews p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.crews FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'crews'::text, project_id, NULL::uuid));


--
-- Name: daily_logs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.daily_logs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'daily_logs'::text, project_id, NULL::uuid));


--
-- Name: dashboard_configs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.dashboard_configs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'dashboard_configs'::text, NULL::uuid, NULL::uuid));


--
-- Name: document_references p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.document_references FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'document_references'::text, NULL::uuid, NULL::uuid));


--
-- Name: documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'documents'::text, project_id, NULL::uuid));


--
-- Name: drawing_versions p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.drawing_versions FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'drawing_versions'::text, NULL::uuid, NULL::uuid));


--
-- Name: dump_trucks p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.dump_trucks FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'dump_trucks'::text, NULL::uuid, organization_id));


--
-- Name: employees p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.employees FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'employees'::text, NULL::uuid, organization_id));


--
-- Name: equipment p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.equipment FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'equipment'::text, NULL::uuid, organization_id));


--
-- Name: equipment_assignments p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.equipment_assignments FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'equipment_assignments'::text, project_id, NULL::uuid));


--
-- Name: equipment_maintenance p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.equipment_maintenance FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'equipment_maintenance'::text, NULL::uuid, NULL::uuid));


--
-- Name: equipment_usage p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.equipment_usage FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'equipment_usage'::text, NULL::uuid, NULL::uuid));


--
-- Name: estimate_line_items p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.estimate_line_items FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'estimate_line_items'::text, NULL::uuid, NULL::uuid));


--
-- Name: estimates p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.estimates FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'estimates'::text, project_id, NULL::uuid));


--
-- Name: financial_documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.financial_documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'financial_documents'::text, project_id, NULL::uuid));


--
-- Name: general_ledger p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.general_ledger FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'general_ledger'::text, project_id, NULL::uuid));


--
-- Name: hr_documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.hr_documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'hr_documents'::text, NULL::uuid, NULL::uuid));


--
-- Name: inspections p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.inspections FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'inspections'::text, project_id, NULL::uuid));


--
-- Name: integration_tokens p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.integration_tokens FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'integration_tokens'::text, NULL::uuid, NULL::uuid));


--
-- Name: inventory_transactions p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.inventory_transactions FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'inventory_transactions'::text, NULL::uuid, NULL::uuid));


--
-- Name: issues p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.issues FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'issues'::text, project_id, NULL::uuid));


--
-- Name: job_titles p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.job_titles FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'job_titles'::text, NULL::uuid, NULL::uuid));


--
-- Name: labor_records p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.labor_records FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'labor_records'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_item_entries p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.line_item_entries FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'line_item_entries'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_item_templates p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.line_item_templates FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'line_item_templates'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_items p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.line_items FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'line_items'::text, project_id, NULL::uuid));


--
-- Name: maps p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.maps FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'maps'::text, project_id, NULL::uuid));


--
-- Name: material_inventory p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.material_inventory FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'material_inventory'::text, NULL::uuid, organization_id));


--
-- Name: material_orders p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.material_orders FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'material_orders'::text, project_id, NULL::uuid));


--
-- Name: material_receipts p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.material_receipts FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'material_receipts'::text, NULL::uuid, NULL::uuid));


--
-- Name: materials p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.materials FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'materials'::text, NULL::uuid, organization_id));


--
-- Name: meeting_minutes p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.meeting_minutes FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'meeting_minutes'::text, project_id, NULL::uuid));


--
-- Name: notifications p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.notifications FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'notifications'::text, NULL::uuid, public.try_parse_uuid((payload ->> 'organization_id'::text))));


--
-- Name: organization_invites p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.organization_invites FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'organization_invites'::text, NULL::uuid, organization_id));


--
-- Name: organization_members p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.organization_members FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'organization_members'::text, NULL::uuid, organization_id));


--
-- Name: organization_projects p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.organization_projects FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'organization_projects'::text, project_id, organization_id));


--
-- Name: organizations p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.organizations FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'organizations'::text, NULL::uuid, id));


--
-- Name: payments p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.payments FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'payments'::text, project_id, NULL::uuid));


--
-- Name: payroll p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.payroll FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'payroll'::text, NULL::uuid, NULL::uuid));


--
-- Name: photos p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.photos FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'photos'::text, project_id, NULL::uuid));


--
-- Name: prequalifications p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.prequalifications FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'prequalifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: procurement_workflows p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.procurement_workflows FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'procurement_workflows'::text, project_id, NULL::uuid));


--
-- Name: profiles p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.profiles AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK (public.check_access_bool('insert'::text, 'profiles'::text, NULL::uuid, organization_id));


--
-- Name: progress_billings p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.progress_billings FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'progress_billings'::text, project_id, NULL::uuid));


--
-- Name: project_inspectors p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.project_inspectors FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'project_inspectors'::text, project_id, NULL::uuid));


--
-- Name: projects p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.projects FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'projects'::text, NULL::uuid, organization_id));


--
-- Name: punch_lists p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.punch_lists FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'punch_lists'::text, project_id, NULL::uuid));


--
-- Name: purchase_orders p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.purchase_orders FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'purchase_orders'::text, project_id, NULL::uuid));


--
-- Name: quality_reviews p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.quality_reviews FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'quality_reviews'::text, project_id, NULL::uuid));


--
-- Name: regulatory_documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.regulatory_documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'regulatory_documents'::text, project_id, NULL::uuid));


--
-- Name: reports p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.reports FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'reports'::text, project_id, NULL::uuid));


--
-- Name: rfis p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.rfis FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'rfis'::text, project_id, NULL::uuid));


--
-- Name: safety_incidents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.safety_incidents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'safety_incidents'::text, project_id, NULL::uuid));


--
-- Name: sensor_data p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.sensor_data FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'sensor_data'::text, project_id, NULL::uuid));


--
-- Name: subcontractor_agreements p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.subcontractor_agreements FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'subcontractor_agreements'::text, NULL::uuid, NULL::uuid));


--
-- Name: subcontracts p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.subcontracts FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'subcontracts'::text, project_id, NULL::uuid));


--
-- Name: submittals p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.submittals FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'submittals'::text, project_id, NULL::uuid));


--
-- Name: tack_rates p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.tack_rates FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'tack_rates'::text, project_id, NULL::uuid));


--
-- Name: task_dependencies p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.task_dependencies FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'task_dependencies'::text, NULL::uuid, NULL::uuid));


--
-- Name: task_status_logs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.task_status_logs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'task_status_logs'::text, NULL::uuid, NULL::uuid));


--
-- Name: tasks p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.tasks FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'tasks'::text, project_id, NULL::uuid));


--
-- Name: training_records p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.training_records FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'training_records'::text, NULL::uuid, NULL::uuid));


--
-- Name: user_projects p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.user_projects FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'user_projects'::text, project_id, NULL::uuid));


--
-- Name: vendor_bid_packages p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendor_bid_packages FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendor_bid_packages'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_contacts p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendor_contacts FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendor_contacts'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_documents p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendor_documents FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendor_documents'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_qualifications p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendor_qualifications FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendor_qualifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendors p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.vendors FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'vendors'::text, NULL::uuid, organization_id));


--
-- Name: wbs p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.wbs FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'wbs'::text, project_id, NULL::uuid));


--
-- Name: workflows p_check_access_insert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_insert ON public.workflows FOR INSERT WITH CHECK (public.check_access_bool('insert'::text, 'workflows'::text, NULL::uuid, NULL::uuid));


--
-- Name: accounts_payable p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.accounts_payable FOR SELECT USING (public.check_access_bool('select'::text, 'accounts_payable'::text, project_id, NULL::uuid));


--
-- Name: accounts_receivable p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.accounts_receivable FOR SELECT USING (public.check_access_bool('select'::text, 'accounts_receivable'::text, project_id, NULL::uuid));


--
-- Name: activity_logs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.activity_logs FOR SELECT USING (public.check_access_bool('select'::text, 'activity_logs'::text, NULL::uuid, NULL::uuid));


--
-- Name: asphalt_types p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.asphalt_types FOR SELECT USING (public.check_access_bool('select'::text, 'asphalt_types'::text, NULL::uuid, NULL::uuid));


--
-- Name: audit_log p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.audit_log FOR SELECT USING (public.check_access_bool('select'::text, 'audit_log'::text, NULL::uuid, NULL::uuid));


--
-- Name: audit_logs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.audit_logs FOR SELECT USING (public.check_access_bool('select'::text, 'audit_logs'::text, project_id, NULL::uuid));


--
-- Name: avatars p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.avatars FOR SELECT USING (public.check_access_bool('select'::text, 'avatars'::text, NULL::uuid, NULL::uuid));


--
-- Name: bid_packages p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.bid_packages FOR SELECT USING (public.check_access_bool('select'::text, 'bid_packages'::text, project_id, NULL::uuid));


--
-- Name: bid_vendors p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.bid_vendors FOR SELECT USING (public.check_access_bool('select'::text, 'bid_vendors'::text, NULL::uuid, NULL::uuid));


--
-- Name: bids p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.bids FOR SELECT USING (public.check_access_bool('select'::text, 'bids'::text, NULL::uuid, NULL::uuid));


--
-- Name: bim_models p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.bim_models FOR SELECT USING (public.check_access_bool('select'::text, 'bim_models'::text, project_id, NULL::uuid));


--
-- Name: certifications p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.certifications FOR SELECT USING (public.check_access_bool('select'::text, 'certifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: change_orders p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.change_orders FOR SELECT USING (public.check_access_bool('select'::text, 'change_orders'::text, project_id, NULL::uuid));


--
-- Name: commitments p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.commitments FOR SELECT USING (public.check_access_bool('select'::text, 'commitments'::text, project_id, NULL::uuid));


--
-- Name: compliance_checks p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.compliance_checks FOR SELECT USING (public.check_access_bool('select'::text, 'compliance_checks'::text, project_id, NULL::uuid));


--
-- Name: compliance_tracking p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.compliance_tracking FOR SELECT USING (public.check_access_bool('select'::text, 'compliance_tracking'::text, project_id, NULL::uuid));


--
-- Name: cost_codes p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.cost_codes FOR SELECT USING (public.check_access_bool('select'::text, 'cost_codes'::text, NULL::uuid, NULL::uuid));


--
-- Name: crew_assignments p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.crew_assignments FOR SELECT USING (public.check_access_bool('select'::text, 'crew_assignments'::text, NULL::uuid, NULL::uuid));


--
-- Name: crew_members p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.crew_members FOR SELECT USING (public.check_access_bool('select'::text, 'crew_members'::text, NULL::uuid, NULL::uuid));


--
-- Name: crews p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.crews FOR SELECT USING (public.check_access_bool('select'::text, 'crews'::text, project_id, NULL::uuid));


--
-- Name: daily_logs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.daily_logs FOR SELECT USING (public.check_access_bool('select'::text, 'daily_logs'::text, project_id, NULL::uuid));


--
-- Name: dashboard_configs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.dashboard_configs FOR SELECT USING (public.check_access_bool('select'::text, 'dashboard_configs'::text, NULL::uuid, NULL::uuid));


--
-- Name: document_references p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.document_references FOR SELECT USING (public.check_access_bool('select'::text, 'document_references'::text, NULL::uuid, NULL::uuid));


--
-- Name: documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.documents FOR SELECT USING (public.check_access_bool('select'::text, 'documents'::text, project_id, NULL::uuid));


--
-- Name: drawing_versions p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.drawing_versions FOR SELECT USING (public.check_access_bool('select'::text, 'drawing_versions'::text, NULL::uuid, NULL::uuid));


--
-- Name: dump_trucks p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.dump_trucks FOR SELECT USING (public.check_access_bool('select'::text, 'dump_trucks'::text, NULL::uuid, organization_id));


--
-- Name: employees p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.employees FOR SELECT USING (public.check_access_bool('select'::text, 'employees'::text, NULL::uuid, organization_id));


--
-- Name: equipment p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.equipment FOR SELECT USING (public.check_access_bool('select'::text, 'equipment'::text, NULL::uuid, organization_id));


--
-- Name: equipment_assignments p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.equipment_assignments FOR SELECT USING (public.check_access_bool('select'::text, 'equipment_assignments'::text, project_id, NULL::uuid));


--
-- Name: equipment_maintenance p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.equipment_maintenance FOR SELECT USING (public.check_access_bool('select'::text, 'equipment_maintenance'::text, NULL::uuid, NULL::uuid));


--
-- Name: equipment_usage p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.equipment_usage FOR SELECT USING (public.check_access_bool('select'::text, 'equipment_usage'::text, NULL::uuid, NULL::uuid));


--
-- Name: estimate_line_items p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.estimate_line_items FOR SELECT USING (public.check_access_bool('select'::text, 'estimate_line_items'::text, NULL::uuid, NULL::uuid));


--
-- Name: estimates p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.estimates FOR SELECT USING (public.check_access_bool('select'::text, 'estimates'::text, project_id, NULL::uuid));


--
-- Name: financial_documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.financial_documents FOR SELECT USING (public.check_access_bool('select'::text, 'financial_documents'::text, project_id, NULL::uuid));


--
-- Name: general_ledger p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.general_ledger FOR SELECT USING (public.check_access_bool('select'::text, 'general_ledger'::text, project_id, NULL::uuid));


--
-- Name: hr_documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.hr_documents FOR SELECT USING (public.check_access_bool('select'::text, 'hr_documents'::text, NULL::uuid, NULL::uuid));


--
-- Name: inspections p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.inspections FOR SELECT USING (public.check_access_bool('select'::text, 'inspections'::text, project_id, NULL::uuid));


--
-- Name: integration_tokens p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.integration_tokens FOR SELECT USING (public.check_access_bool('select'::text, 'integration_tokens'::text, NULL::uuid, NULL::uuid));


--
-- Name: inventory_transactions p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.inventory_transactions FOR SELECT USING (public.check_access_bool('select'::text, 'inventory_transactions'::text, NULL::uuid, NULL::uuid));


--
-- Name: issues p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.issues FOR SELECT USING (public.check_access_bool('select'::text, 'issues'::text, project_id, NULL::uuid));


--
-- Name: job_titles p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.job_titles FOR SELECT USING (public.check_access_bool('select'::text, 'job_titles'::text, NULL::uuid, NULL::uuid));


--
-- Name: labor_records p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.labor_records FOR SELECT USING (public.check_access_bool('select'::text, 'labor_records'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_item_entries p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.line_item_entries FOR SELECT USING (public.check_access_bool('select'::text, 'line_item_entries'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_item_templates p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.line_item_templates FOR SELECT USING (public.check_access_bool('select'::text, 'line_item_templates'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_items p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.line_items FOR SELECT USING (public.check_access_bool('select'::text, 'line_items'::text, project_id, NULL::uuid));


--
-- Name: maps p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.maps FOR SELECT USING (public.check_access_bool('select'::text, 'maps'::text, project_id, NULL::uuid));


--
-- Name: material_inventory p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.material_inventory FOR SELECT USING (public.check_access_bool('select'::text, 'material_inventory'::text, NULL::uuid, organization_id));


--
-- Name: material_orders p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.material_orders FOR SELECT USING (public.check_access_bool('select'::text, 'material_orders'::text, project_id, NULL::uuid));


--
-- Name: material_receipts p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.material_receipts FOR SELECT USING (public.check_access_bool('select'::text, 'material_receipts'::text, NULL::uuid, NULL::uuid));


--
-- Name: materials p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.materials FOR SELECT USING (public.check_access_bool('select'::text, 'materials'::text, NULL::uuid, organization_id));


--
-- Name: meeting_minutes p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.meeting_minutes FOR SELECT USING (public.check_access_bool('select'::text, 'meeting_minutes'::text, project_id, NULL::uuid));


--
-- Name: notifications p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.notifications FOR SELECT USING (((user_id = auth.uid()) OR ((COALESCE((payload ->> 'scope'::text), 'personal'::text) = 'org_wide'::text) AND public.check_access_bool('select'::text, 'notifications'::text, NULL::uuid, public.try_parse_uuid((payload ->> 'organization_id'::text))))));


--
-- Name: organization_invites p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.organization_invites FOR SELECT USING (public.check_access_bool('select'::text, 'organization_invites'::text, NULL::uuid, organization_id));


--
-- Name: organization_members p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.organization_members FOR SELECT USING (public.check_access_bool('select'::text, 'organization_members'::text, NULL::uuid, organization_id));


--
-- Name: organization_projects p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.organization_projects FOR SELECT USING (public.check_access_bool('select'::text, 'organization_projects'::text, project_id, organization_id));


--
-- Name: organizations p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.organizations FOR SELECT USING (public.check_access_bool('select'::text, 'organizations'::text, NULL::uuid, id));


--
-- Name: payments p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.payments FOR SELECT USING (public.check_access_bool('select'::text, 'payments'::text, project_id, NULL::uuid));


--
-- Name: payroll p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.payroll FOR SELECT USING (public.check_access_bool('select'::text, 'payroll'::text, NULL::uuid, NULL::uuid));


--
-- Name: photos p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.photos FOR SELECT USING (public.check_access_bool('select'::text, 'photos'::text, project_id, NULL::uuid));


--
-- Name: prequalifications p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.prequalifications FOR SELECT USING (public.check_access_bool('select'::text, 'prequalifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: procurement_workflows p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.procurement_workflows FOR SELECT USING (public.check_access_bool('select'::text, 'procurement_workflows'::text, project_id, NULL::uuid));


--
-- Name: profiles p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.profiles AS RESTRICTIVE FOR SELECT TO authenticated USING (public.check_access_bool('select'::text, 'profiles'::text, NULL::uuid, organization_id));


--
-- Name: progress_billings p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.progress_billings FOR SELECT USING (public.check_access_bool('select'::text, 'progress_billings'::text, project_id, NULL::uuid));


--
-- Name: project_inspectors p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.project_inspectors FOR SELECT USING (public.check_access_bool('select'::text, 'project_inspectors'::text, project_id, NULL::uuid));


--
-- Name: projects p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.projects FOR SELECT USING (public.check_access_bool('select'::text, 'projects'::text, NULL::uuid, organization_id));


--
-- Name: punch_lists p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.punch_lists FOR SELECT USING (public.check_access_bool('select'::text, 'punch_lists'::text, project_id, NULL::uuid));


--
-- Name: purchase_orders p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.purchase_orders FOR SELECT USING (public.check_access_bool('select'::text, 'purchase_orders'::text, project_id, NULL::uuid));


--
-- Name: quality_reviews p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.quality_reviews FOR SELECT USING (public.check_access_bool('select'::text, 'quality_reviews'::text, project_id, NULL::uuid));


--
-- Name: regulatory_documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.regulatory_documents FOR SELECT USING (public.check_access_bool('select'::text, 'regulatory_documents'::text, project_id, NULL::uuid));


--
-- Name: reports p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.reports FOR SELECT USING (public.check_access_bool('select'::text, 'reports'::text, project_id, NULL::uuid));


--
-- Name: rfis p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.rfis FOR SELECT USING (public.check_access_bool('select'::text, 'rfis'::text, project_id, NULL::uuid));


--
-- Name: safety_incidents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.safety_incidents FOR SELECT USING (public.check_access_bool('select'::text, 'safety_incidents'::text, project_id, NULL::uuid));


--
-- Name: sensor_data p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.sensor_data FOR SELECT USING (public.check_access_bool('select'::text, 'sensor_data'::text, project_id, NULL::uuid));


--
-- Name: subcontractor_agreements p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.subcontractor_agreements FOR SELECT USING (public.check_access_bool('select'::text, 'subcontractor_agreements'::text, NULL::uuid, NULL::uuid));


--
-- Name: subcontracts p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.subcontracts FOR SELECT USING (public.check_access_bool('select'::text, 'subcontracts'::text, project_id, NULL::uuid));


--
-- Name: submittals p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.submittals FOR SELECT USING (public.check_access_bool('select'::text, 'submittals'::text, project_id, NULL::uuid));


--
-- Name: tack_rates p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.tack_rates FOR SELECT USING (public.check_access_bool('select'::text, 'tack_rates'::text, project_id, NULL::uuid));


--
-- Name: task_dependencies p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.task_dependencies FOR SELECT USING (public.check_access_bool('select'::text, 'task_dependencies'::text, NULL::uuid, NULL::uuid));


--
-- Name: task_status_logs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.task_status_logs FOR SELECT USING (public.check_access_bool('select'::text, 'task_status_logs'::text, NULL::uuid, NULL::uuid));


--
-- Name: tasks p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.tasks FOR SELECT USING (public.check_access_bool('select'::text, 'tasks'::text, project_id, NULL::uuid));


--
-- Name: training_records p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.training_records FOR SELECT USING (public.check_access_bool('select'::text, 'training_records'::text, NULL::uuid, NULL::uuid));


--
-- Name: user_projects p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.user_projects FOR SELECT USING (public.check_access_bool('select'::text, 'user_projects'::text, project_id, NULL::uuid));


--
-- Name: vendor_bid_packages p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendor_bid_packages FOR SELECT USING (public.check_access_bool('select'::text, 'vendor_bid_packages'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_contacts p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendor_contacts FOR SELECT USING (public.check_access_bool('select'::text, 'vendor_contacts'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_documents p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendor_documents FOR SELECT USING (public.check_access_bool('select'::text, 'vendor_documents'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_qualifications p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendor_qualifications FOR SELECT USING (public.check_access_bool('select'::text, 'vendor_qualifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendors p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.vendors FOR SELECT USING (public.check_access_bool('select'::text, 'vendors'::text, NULL::uuid, organization_id));


--
-- Name: wbs p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.wbs FOR SELECT USING (public.check_access_bool('select'::text, 'wbs'::text, project_id, NULL::uuid));


--
-- Name: workflows p_check_access_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_select ON public.workflows FOR SELECT USING (public.check_access_bool('select'::text, 'workflows'::text, NULL::uuid, NULL::uuid));


--
-- Name: accounts_payable p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.accounts_payable FOR UPDATE USING (public.check_access_bool('update'::text, 'accounts_payable'::text, project_id, NULL::uuid));


--
-- Name: accounts_receivable p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.accounts_receivable FOR UPDATE USING (public.check_access_bool('update'::text, 'accounts_receivable'::text, project_id, NULL::uuid));


--
-- Name: activity_logs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.activity_logs FOR UPDATE USING (public.check_access_bool('update'::text, 'activity_logs'::text, NULL::uuid, NULL::uuid));


--
-- Name: asphalt_types p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.asphalt_types FOR UPDATE USING (public.check_access_bool('update'::text, 'asphalt_types'::text, NULL::uuid, NULL::uuid));


--
-- Name: audit_log p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.audit_log FOR UPDATE USING (public.check_access_bool('update'::text, 'audit_log'::text, NULL::uuid, NULL::uuid));


--
-- Name: audit_logs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.audit_logs FOR UPDATE USING (public.check_access_bool('update'::text, 'audit_logs'::text, project_id, NULL::uuid));


--
-- Name: avatars p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.avatars FOR UPDATE USING (public.check_access_bool('update'::text, 'avatars'::text, NULL::uuid, NULL::uuid));


--
-- Name: bid_packages p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.bid_packages FOR UPDATE USING (public.check_access_bool('update'::text, 'bid_packages'::text, project_id, NULL::uuid));


--
-- Name: bid_vendors p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.bid_vendors FOR UPDATE USING (public.check_access_bool('update'::text, 'bid_vendors'::text, NULL::uuid, NULL::uuid));


--
-- Name: bids p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.bids FOR UPDATE USING (public.check_access_bool('update'::text, 'bids'::text, NULL::uuid, NULL::uuid));


--
-- Name: bim_models p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.bim_models FOR UPDATE USING (public.check_access_bool('update'::text, 'bim_models'::text, project_id, NULL::uuid));


--
-- Name: certifications p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.certifications FOR UPDATE USING (public.check_access_bool('update'::text, 'certifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: change_orders p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.change_orders FOR UPDATE USING (public.check_access_bool('update'::text, 'change_orders'::text, project_id, NULL::uuid));


--
-- Name: commitments p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.commitments FOR UPDATE USING (public.check_access_bool('update'::text, 'commitments'::text, project_id, NULL::uuid));


--
-- Name: compliance_checks p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.compliance_checks FOR UPDATE USING (public.check_access_bool('update'::text, 'compliance_checks'::text, project_id, NULL::uuid));


--
-- Name: compliance_tracking p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.compliance_tracking FOR UPDATE USING (public.check_access_bool('update'::text, 'compliance_tracking'::text, project_id, NULL::uuid));


--
-- Name: cost_codes p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.cost_codes FOR UPDATE USING (public.check_access_bool('update'::text, 'cost_codes'::text, NULL::uuid, NULL::uuid));


--
-- Name: crew_assignments p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.crew_assignments FOR UPDATE USING (public.check_access_bool('update'::text, 'crew_assignments'::text, NULL::uuid, NULL::uuid));


--
-- Name: crew_members p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.crew_members FOR UPDATE USING (public.check_access_bool('update'::text, 'crew_members'::text, NULL::uuid, NULL::uuid));


--
-- Name: crews p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.crews FOR UPDATE USING (public.check_access_bool('update'::text, 'crews'::text, project_id, NULL::uuid));


--
-- Name: daily_logs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.daily_logs FOR UPDATE USING (public.check_access_bool('update'::text, 'daily_logs'::text, project_id, NULL::uuid));


--
-- Name: dashboard_configs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.dashboard_configs FOR UPDATE USING (public.check_access_bool('update'::text, 'dashboard_configs'::text, NULL::uuid, NULL::uuid));


--
-- Name: document_references p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.document_references FOR UPDATE USING (public.check_access_bool('update'::text, 'document_references'::text, NULL::uuid, NULL::uuid));


--
-- Name: documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.documents FOR UPDATE USING (public.check_access_bool('update'::text, 'documents'::text, project_id, NULL::uuid));


--
-- Name: drawing_versions p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.drawing_versions FOR UPDATE USING (public.check_access_bool('update'::text, 'drawing_versions'::text, NULL::uuid, NULL::uuid));


--
-- Name: dump_trucks p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.dump_trucks FOR UPDATE USING (public.check_access_bool('update'::text, 'dump_trucks'::text, NULL::uuid, organization_id));


--
-- Name: employees p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.employees FOR UPDATE USING (public.check_access_bool('update'::text, 'employees'::text, NULL::uuid, organization_id));


--
-- Name: equipment p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.equipment FOR UPDATE USING (public.check_access_bool('update'::text, 'equipment'::text, NULL::uuid, organization_id));


--
-- Name: equipment_assignments p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.equipment_assignments FOR UPDATE USING (public.check_access_bool('update'::text, 'equipment_assignments'::text, project_id, NULL::uuid));


--
-- Name: equipment_maintenance p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.equipment_maintenance FOR UPDATE USING (public.check_access_bool('update'::text, 'equipment_maintenance'::text, NULL::uuid, NULL::uuid));


--
-- Name: equipment_usage p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.equipment_usage FOR UPDATE USING (public.check_access_bool('update'::text, 'equipment_usage'::text, NULL::uuid, NULL::uuid));


--
-- Name: estimate_line_items p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.estimate_line_items FOR UPDATE USING (public.check_access_bool('update'::text, 'estimate_line_items'::text, NULL::uuid, NULL::uuid));


--
-- Name: estimates p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.estimates FOR UPDATE USING (public.check_access_bool('update'::text, 'estimates'::text, project_id, NULL::uuid));


--
-- Name: financial_documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.financial_documents FOR UPDATE USING (public.check_access_bool('update'::text, 'financial_documents'::text, project_id, NULL::uuid));


--
-- Name: general_ledger p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.general_ledger FOR UPDATE USING (public.check_access_bool('update'::text, 'general_ledger'::text, project_id, NULL::uuid));


--
-- Name: hr_documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.hr_documents FOR UPDATE USING (public.check_access_bool('update'::text, 'hr_documents'::text, NULL::uuid, NULL::uuid));


--
-- Name: inspections p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.inspections FOR UPDATE USING (public.check_access_bool('update'::text, 'inspections'::text, project_id, NULL::uuid));


--
-- Name: integration_tokens p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.integration_tokens FOR UPDATE USING (public.check_access_bool('update'::text, 'integration_tokens'::text, NULL::uuid, NULL::uuid));


--
-- Name: inventory_transactions p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.inventory_transactions FOR UPDATE USING (public.check_access_bool('update'::text, 'inventory_transactions'::text, NULL::uuid, NULL::uuid));


--
-- Name: issues p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.issues FOR UPDATE USING (public.check_access_bool('update'::text, 'issues'::text, project_id, NULL::uuid));


--
-- Name: job_titles p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.job_titles FOR UPDATE USING (public.check_access_bool('update'::text, 'job_titles'::text, NULL::uuid, NULL::uuid));


--
-- Name: labor_records p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.labor_records FOR UPDATE USING (public.check_access_bool('update'::text, 'labor_records'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_item_entries p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.line_item_entries FOR UPDATE USING (public.check_access_bool('update'::text, 'line_item_entries'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_item_templates p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.line_item_templates FOR UPDATE USING (public.check_access_bool('update'::text, 'line_item_templates'::text, NULL::uuid, NULL::uuid));


--
-- Name: line_items p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.line_items FOR UPDATE USING (public.check_access_bool('update'::text, 'line_items'::text, project_id, NULL::uuid));


--
-- Name: maps p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.maps FOR UPDATE USING (public.check_access_bool('update'::text, 'maps'::text, project_id, NULL::uuid));


--
-- Name: material_inventory p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.material_inventory FOR UPDATE USING (public.check_access_bool('update'::text, 'material_inventory'::text, NULL::uuid, organization_id));


--
-- Name: material_orders p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.material_orders FOR UPDATE USING (public.check_access_bool('update'::text, 'material_orders'::text, project_id, NULL::uuid));


--
-- Name: material_receipts p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.material_receipts FOR UPDATE USING (public.check_access_bool('update'::text, 'material_receipts'::text, NULL::uuid, NULL::uuid));


--
-- Name: materials p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.materials FOR UPDATE USING (public.check_access_bool('update'::text, 'materials'::text, NULL::uuid, organization_id));


--
-- Name: meeting_minutes p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.meeting_minutes FOR UPDATE USING (public.check_access_bool('update'::text, 'meeting_minutes'::text, project_id, NULL::uuid));


--
-- Name: notifications p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.notifications FOR UPDATE USING ((user_id = auth.uid())) WITH CHECK ((user_id = auth.uid()));


--
-- Name: organization_invites p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.organization_invites FOR UPDATE USING (public.check_access_bool('update'::text, 'organization_invites'::text, NULL::uuid, organization_id));


--
-- Name: organization_members p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.organization_members FOR UPDATE TO authenticated USING ((public.check_access_bool('update'::text, 'organization_members'::text, NULL::uuid, organization_id) OR ((profile_id = auth.uid()) AND (deleted_at IS NULL)))) WITH CHECK ((public.check_access_bool('update'::text, 'organization_members'::text, NULL::uuid, organization_id) OR ((profile_id = auth.uid()) AND (deleted_at IS NOT NULL))));


--
-- Name: organization_projects p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.organization_projects FOR UPDATE USING (public.check_access_bool('update'::text, 'organization_projects'::text, project_id, organization_id));


--
-- Name: organizations p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.organizations FOR UPDATE USING (public.check_access_bool('update'::text, 'organizations'::text, NULL::uuid, id));


--
-- Name: payments p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.payments FOR UPDATE USING (public.check_access_bool('update'::text, 'payments'::text, project_id, NULL::uuid));


--
-- Name: payroll p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.payroll FOR UPDATE USING (public.check_access_bool('update'::text, 'payroll'::text, NULL::uuid, NULL::uuid));


--
-- Name: photos p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.photos FOR UPDATE USING (public.check_access_bool('update'::text, 'photos'::text, project_id, NULL::uuid));


--
-- Name: prequalifications p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.prequalifications FOR UPDATE USING (public.check_access_bool('update'::text, 'prequalifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: procurement_workflows p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.procurement_workflows FOR UPDATE USING (public.check_access_bool('update'::text, 'procurement_workflows'::text, project_id, NULL::uuid));


--
-- Name: profiles p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.profiles AS RESTRICTIVE FOR UPDATE TO authenticated USING (public.check_access_bool('update'::text, 'profiles'::text, NULL::uuid, organization_id));


--
-- Name: progress_billings p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.progress_billings FOR UPDATE USING (public.check_access_bool('update'::text, 'progress_billings'::text, project_id, NULL::uuid));


--
-- Name: project_inspectors p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.project_inspectors FOR UPDATE USING (public.check_access_bool('update'::text, 'project_inspectors'::text, project_id, NULL::uuid));


--
-- Name: projects p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.projects FOR UPDATE USING (public.check_access_bool('update'::text, 'projects'::text, NULL::uuid, organization_id));


--
-- Name: punch_lists p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.punch_lists FOR UPDATE USING (public.check_access_bool('update'::text, 'punch_lists'::text, project_id, NULL::uuid));


--
-- Name: purchase_orders p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.purchase_orders FOR UPDATE USING (public.check_access_bool('update'::text, 'purchase_orders'::text, project_id, NULL::uuid));


--
-- Name: quality_reviews p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.quality_reviews FOR UPDATE USING (public.check_access_bool('update'::text, 'quality_reviews'::text, project_id, NULL::uuid));


--
-- Name: regulatory_documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.regulatory_documents FOR UPDATE USING (public.check_access_bool('update'::text, 'regulatory_documents'::text, project_id, NULL::uuid));


--
-- Name: reports p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.reports FOR UPDATE USING (public.check_access_bool('update'::text, 'reports'::text, project_id, NULL::uuid));


--
-- Name: rfis p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.rfis FOR UPDATE USING (public.check_access_bool('update'::text, 'rfis'::text, project_id, NULL::uuid));


--
-- Name: safety_incidents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.safety_incidents FOR UPDATE USING (public.check_access_bool('update'::text, 'safety_incidents'::text, project_id, NULL::uuid));


--
-- Name: sensor_data p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.sensor_data FOR UPDATE USING (public.check_access_bool('update'::text, 'sensor_data'::text, project_id, NULL::uuid));


--
-- Name: subcontractor_agreements p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.subcontractor_agreements FOR UPDATE USING (public.check_access_bool('update'::text, 'subcontractor_agreements'::text, NULL::uuid, NULL::uuid));


--
-- Name: subcontracts p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.subcontracts FOR UPDATE USING (public.check_access_bool('update'::text, 'subcontracts'::text, project_id, NULL::uuid));


--
-- Name: submittals p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.submittals FOR UPDATE USING (public.check_access_bool('update'::text, 'submittals'::text, project_id, NULL::uuid));


--
-- Name: tack_rates p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.tack_rates FOR UPDATE USING (public.check_access_bool('update'::text, 'tack_rates'::text, project_id, NULL::uuid));


--
-- Name: task_dependencies p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.task_dependencies FOR UPDATE USING (public.check_access_bool('update'::text, 'task_dependencies'::text, NULL::uuid, NULL::uuid));


--
-- Name: task_status_logs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.task_status_logs FOR UPDATE USING (public.check_access_bool('update'::text, 'task_status_logs'::text, NULL::uuid, NULL::uuid));


--
-- Name: tasks p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.tasks FOR UPDATE USING (public.check_access_bool('update'::text, 'tasks'::text, project_id, NULL::uuid));


--
-- Name: training_records p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.training_records FOR UPDATE USING (public.check_access_bool('update'::text, 'training_records'::text, NULL::uuid, NULL::uuid));


--
-- Name: user_projects p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.user_projects FOR UPDATE USING (public.check_access_bool('update'::text, 'user_projects'::text, project_id, NULL::uuid));


--
-- Name: vendor_bid_packages p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendor_bid_packages FOR UPDATE USING (public.check_access_bool('update'::text, 'vendor_bid_packages'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_contacts p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendor_contacts FOR UPDATE USING (public.check_access_bool('update'::text, 'vendor_contacts'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_documents p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendor_documents FOR UPDATE USING (public.check_access_bool('update'::text, 'vendor_documents'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendor_qualifications p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendor_qualifications FOR UPDATE USING (public.check_access_bool('update'::text, 'vendor_qualifications'::text, NULL::uuid, NULL::uuid));


--
-- Name: vendors p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.vendors FOR UPDATE USING (public.check_access_bool('update'::text, 'vendors'::text, NULL::uuid, organization_id));


--
-- Name: wbs p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.wbs FOR UPDATE USING (public.check_access_bool('update'::text, 'wbs'::text, project_id, NULL::uuid));


--
-- Name: workflows p_check_access_update; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_check_access_update ON public.workflows FOR UPDATE USING (public.check_access_bool('update'::text, 'workflows'::text, NULL::uuid, NULL::uuid));


--
-- Name: organization_notification_settings p_org_notification_settings_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_org_notification_settings_select ON public.organization_notification_settings FOR SELECT USING (public.check_access_bool('select'::text, 'organizations'::text, NULL::uuid, organization_id));


--
-- Name: organization_notification_settings p_org_notification_settings_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_org_notification_settings_write ON public.organization_notification_settings USING (public.can_edit_org_notification_settings(organization_id)) WITH CHECK (public.can_edit_org_notification_settings(organization_id));


--
-- Name: user_notification_settings p_user_notification_settings_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_user_notification_settings_select ON public.user_notification_settings FOR SELECT USING ((user_id = auth.uid()));


--
-- Name: user_notification_settings p_user_notification_settings_write; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY p_user_notification_settings_write ON public.user_notification_settings USING ((user_id = auth.uid())) WITH CHECK ((user_id = auth.uid()));


--
-- Name: payments; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;

--
-- Name: payroll; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.payroll ENABLE ROW LEVEL SECURITY;

--
-- Name: photos; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.photos ENABLE ROW LEVEL SECURITY;

--
-- Name: prequalifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.prequalifications ENABLE ROW LEVEL SECURITY;

--
-- Name: procurement_workflows; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.procurement_workflows ENABLE ROW LEVEL SECURITY;

--
-- Name: profiles; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

--
-- Name: profiles profiles_insert_authenticated; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY profiles_insert_authenticated ON public.profiles FOR INSERT TO authenticated WITH CHECK ((((id = ( SELECT auth.uid() AS uid)) AND (NOT (EXISTS ( SELECT 1
   FROM public.profiles p
  WHERE (p.id = ( SELECT auth.uid() AS uid)))))) OR (id = ( SELECT auth.uid() AS uid))));


--
-- Name: profiles profiles_select_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY profiles_select_own ON public.profiles FOR SELECT TO authenticated USING ((id = ( SELECT auth.uid() AS uid)));


--
-- Name: profiles profiles_update_own; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY profiles_update_own ON public.profiles FOR UPDATE TO authenticated USING ((id = ( SELECT auth.uid() AS uid))) WITH CHECK ((id = ( SELECT auth.uid() AS uid)));


--
-- Name: progress_billings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.progress_billings ENABLE ROW LEVEL SECURITY;

--
-- Name: project_inspectors; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.project_inspectors ENABLE ROW LEVEL SECURITY;

--
-- Name: project_invites; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.project_invites ENABLE ROW LEVEL SECURITY;

--
-- Name: project_service_areas; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.project_service_areas ENABLE ROW LEVEL SECURITY;

--
-- Name: projects; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;

--
-- Name: punch_lists; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.punch_lists ENABLE ROW LEVEL SECURITY;

--
-- Name: purchase_orders; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.purchase_orders ENABLE ROW LEVEL SECURITY;

--
-- Name: quality_reviews; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.quality_reviews ENABLE ROW LEVEL SECURITY;

--
-- Name: regulatory_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.regulatory_documents ENABLE ROW LEVEL SECURITY;

--
-- Name: reports; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

--
-- Name: rfis; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.rfis ENABLE ROW LEVEL SECURITY;

--
-- Name: safety_incidents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.safety_incidents ENABLE ROW LEVEL SECURITY;

--
-- Name: sensor_data; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.sensor_data ENABLE ROW LEVEL SECURITY;

--
-- Name: subcontractor_agreements; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.subcontractor_agreements ENABLE ROW LEVEL SECURITY;

--
-- Name: subcontracts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.subcontracts ENABLE ROW LEVEL SECURITY;

--
-- Name: submittals; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.submittals ENABLE ROW LEVEL SECURITY;

--
-- Name: tack_rates; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.tack_rates ENABLE ROW LEVEL SECURITY;

--
-- Name: task_dependencies; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.task_dependencies ENABLE ROW LEVEL SECURITY;

--
-- Name: task_status_logs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.task_status_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: tasks; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;

--
-- Name: training_records; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.training_records ENABLE ROW LEVEL SECURITY;

--
-- Name: user_notification_settings; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_notification_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: user_notification_settings user_notification_settings_select; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_notification_settings_select ON public.user_notification_settings FOR SELECT USING ((user_id = auth.uid()));


--
-- Name: user_notification_settings user_notification_settings_upsert; Type: POLICY; Schema: public; Owner: -
--

CREATE POLICY user_notification_settings_upsert ON public.user_notification_settings USING ((user_id = auth.uid())) WITH CHECK ((user_id = auth.uid()));


--
-- Name: user_projects; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.user_projects ENABLE ROW LEVEL SECURITY;

--
-- Name: vendor_bid_packages; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendor_bid_packages ENABLE ROW LEVEL SECURITY;

--
-- Name: vendor_contacts; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendor_contacts ENABLE ROW LEVEL SECURITY;

--
-- Name: vendor_documents; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendor_documents ENABLE ROW LEVEL SECURITY;

--
-- Name: vendor_qualifications; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendor_qualifications ENABLE ROW LEVEL SECURITY;

--
-- Name: vendors; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.vendors ENABLE ROW LEVEL SECURITY;

--
-- Name: wbs; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.wbs ENABLE ROW LEVEL SECURITY;

--
-- Name: workflows; Type: ROW SECURITY; Schema: public; Owner: -
--

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;

--
-- PostgreSQL database dump complete
--

