# AI Contribution Guidelines for Codex

These guidelines merge repository instructions and AI contribution expectations to help agents work effectively:

- Run `npm test` and fix any failures before committing.
  - If tests cannot be run in the agent environment, explicitly state that and provide the commands that should be run locally.
- Follow the established code style and adhere to ESLint rules from `eslint.config.js`.
- Do not use `any` under any circumstance.
- All React code must be written in TypeScript `.tsx` files.
- Use clear, descriptive commit messages.
- Document new components in `README.md` and update documentation or comments when behavior changes.
- Any codebase change must be reflected in `README.md` within the same work session/PR.
- Consult `src/lib/database.types.ts` for backend types and definitions before making changes.
- Maintain strict type safety in accordance with `database.types.ts`.
- Ensure all data access uses RPC functions—avoid direct table calls in application code.
- Treat RPC contracts as the only valid boundary between frontend and backend.
- If required types or RPC contracts do not support the needed change:
  - Deliver a migration SQL.
  - Regenerate outputs with `npm run fulldb`.
  - Then update frontend code against the regenerated types.
- Add comments to code explaining the purpose of major code blocks and reasoning where appropriate.
- Network access to external resources is already granted in the environment settings.
- Supabase CLI is installed and used via Scoop in this environment; use direct `supabase ...` commands.

---

## Autogenerated Files (fulldb)

The following files are generated by `npm run fulldb` (or scripts inside that chain) and must not be manually edited:

- `src/lib/database.types.ts`
- `src/lib/rpc.definitions.ts`
- `src/lib/tables.rpc.ts`
- `src/lib/database.policies.ts`
- `src/lib/edge.functions.ts`
- `src/lib/functions.sql`
- `backend.snapshot.md`
- `backend.snapshot.sql`

When checking backend behavior, schema, RPC contracts, function bodies, or policies, treat these autogenerated files as the read-only source of truth.

If changes are required to database functions/RPC behavior/schema represented in these files, do not edit generated outputs directly.

Deliver migration SQL and then regenerate outputs with `npm run fulldb`.

---

## Migration Delivery Workflow (Project Preference)

For this project, prefer delivering migration SQL directly in chat by default.

- Default behavior: provide SQL snippets in chat code boxes for the user to apply manually.
- Only create files in `supabase/migrations/` when the user explicitly asks for a file.
- When SQL is delivered in chat, clearly label it as a migration and include a short purpose line.
- If the user sends an error report back from the query, resend a fully corrected SQL query, not just the fixed snippet.
- Do not remind the user to run migrations or `npm run fulldb` unless they explicitly ask for run steps.

---

## Migration Naming Convention

Migration filenames must follow this format:

- Format: `<brief_description>.sql`
- Keep `<brief_description>` short and focused (for example: `fix_member_filter_shape`)
- Avoid long, sentence-like migration names

---

## Error Handling

## Development Policy: Fail Loudly (No Silent Failures)

During development, **all backend data calls must fail loudly**.

Under no circumstances should any data operation:

- Fail silently
- Degrade automatically
- Substitute fallback data
- Mask RPC errors
- Pretend success when the backend did not respond successfully
- Convert backend failures into “empty state” UI that looks like success

If a database call, RPC, edge function, storage operation, or auth call fails, the system must:

1. Log a detailed error to `console.error` (always required).
2. Preserve the error state (do not swallow it).
3. Show a visible error toast when policy requires (see trigger classification).
4. Prevent the UI from presenting false success or fake-empty states.

This is mandatory during development.

---

## Definitions: User-Triggered vs Background

This repo differentiates between **user-triggered** and **background** failures.

### User-triggered (toast + console.error + error state)
User-triggered includes (non-exhaustive):

- Clicking Save/Submit/Update
- Clicking Retry/Refresh
- Upload actions
- Switching organizations
- Mark-as-read / notification actions
- Navigating to a page that performs a data load as a result of the user action (e.g., visiting the Notifications page)
- Any button click that initiates a backend call

### Background (console.error + error state, no toast by default)
Background includes (non-exhaustive):

- Initial session restore / bootstrap hydration
- Passive query refetch on mount
- Interval polling / stale refetch
- Preloads that occur without direct user action

Exception policy:

- **User-triggered failures:** toast + console.error + preserved error state
- **Background failures:** console.error + preserved error state (toast only if UX explicitly requires)

---

## Scope (Applies To)

This rule applies to all backend-bound operations, including:

- Supabase RPC calls (required access pattern)
- Edge Functions
- Storage operations (allowed only via wrappers; see Storage Boundary Exception)
- Auth operations
- Realtime subscriptions
- TanStack Query fetches
- TanStack Query mutations
- Background polling
- Settings snapshot loads
- Notification filtering logic
- Any derived UI state that depends on backend state

Note:

All application data access must use RPC functions. Direct table queries from frontend application code are not permitted per project rules.

---

## Required Behavior On Error

### 1) Console Logging (Always Required)

A structured `console.error` must be emitted for every backend failure.

The log must include:

- Module name
- Operation name
- Full error object
- Any relevant identifiers (orgId, projectId, recordId, notificationId, etc.)
- Trigger type (`user` or `background`)

Example pattern:

```ts
if (error) {
  console.error('[Notifications] loadUserSettings failed', {
    error,
    userId,
    organizationId,
    trigger: 'user' // or 'background'
  })
}
```

Console logs must not be removed or downgraded during development.

---

### 2) Visible Toast (When Required)

For user-triggered failures (and any other explicitly-designated UX flows), a user-visible error toast must appear.

The toast must clearly include:

- The module or feature name
- The operation that failed
- The returned error message

Example:

```
[Notifications] Failed to load user settings: permission denied for function get_my_notification_settings
```

Generic messages like "Something went wrong" are not acceptable.

---

### 3) Error Propagation / Error State (Never Swallow)

Backend failures must preserve error state and must not be converted into fake success or fake-empty states.

Rules by operation type:

#### Queries (TanStack Query)

- Preserve `isError`; never map failures to empty/default data.
- Background query failures: `console.error` + preserve `isError` state (no toast by default).
- User-triggered query failures (manual refetch or user navigation that triggers a load): one toast + `console.error` + preserve `isError`.
- Components must render explicit error UI when `isError` is true for key surfaces (notifications is mandatory).

#### Mutations (TanStack Query)

- Mutations are user-triggered by default.
- On error: one toast + `console.error`.
- Do not return boolean “success” flags that hide failure.
- Do not proceed to success UI or navigation on failure.
- Prefer rethrowing the error (or returning a typed error result) so calling code cannot mistakenly treat failures as success.

#### Non-query async loaders / custom hooks

- Either throw to an ErrorBoundary, or set and render explicit error UI state.
- Must not return `null`/`[]` as a silent fallback when backend failed.

---

## Toast Ownership (Prevent Double-Toasts)

To avoid toast spam, each backend failure should produce **at most one toast**.

Rules:

- If a shared wrapper/helper already emits a toast for a given call, callsites must not emit a second toast for the same error.
- Query toasts belong at the **user-triggered entry point** (e.g., a click handler that calls `refetch`, or the page navigation load), not inside background observers.
- Mutation toasts belong in the **mutation wrapper/hook by default** (or the component), but not both.
- If a shared wrapper toasts, downstream callsites only log/state-handle and must not toast again.

---

## Notifications Special Rule (No Fake Empty State)

Notifications must never render a normal “empty” state if backend calls fail.

If notification fetch/settings/filtering fails:

- Render an explicit error UI state (e.g., “Failed to load notifications” + Retry).
- Apply the trigger policy:
  - User navigated to notifications page / clicked refresh: one toast + `console.error` + error state.
  - Background refetch fails: `console.error` + error state (no forced toast).

---

## Explicitly Forbidden Patterns

The following are not allowed during development:

- Returning empty arrays on failure (unless the backend actually returned an empty array successfully)
- Returning default objects on failure
- Catching errors and only logging to console without preserving error state
- Showing a toast without logging to console
- Silent fallback flags (e.g. `backendReady` checks)
- Ignoring missing RPCs and continuing
- Navigating after a failed mutation
- Mark-as-read failures that still route
- Silently skipping filtering because settings failed to load
- Auto-disabling features due to missing backend responses
- Swallowing errors in catch blocks

Incorrect example:

```ts
try {
  await rpcCall()
} catch {
  return []
}
```

If the backend fails, we must know immediately.

---

## RPC Boundary Enforcement (Frontend)

Frontend application code must not perform direct table access.

Requirements:

- No `supabase.from('...')` calls in frontend application code.
- All database table access must go through RPC contracts and typed RPC wrappers.

Every enforcement pass must include a mechanical search to confirm compliance:

- Search for `supabase.from(` usage in `src/`
- Confirm no direct table CRUD remains
- If found, refactor into RPC and update types via migration + `npm run fulldb`

---

## Storage Boundary Exception (Allowed, But Must Be Wrapped)

Storage is not a database table and may require direct Supabase Storage calls.

Rules:

- Direct storage calls are allowed only through approved wrapper utilities.
- Wrappers must enforce fail-loudly rules:
  - `console.error` always
  - toast for user-triggered failures
  - never swallow errors into silent success
  - strict typing (no `any`)
- Do not scatter `supabase.storage.*` calls throughout components/hooks without a wrapper.

---

## QA / Verification Support (Dev Only)

To verify fail-loudly behavior quickly, dev builds may include an optional "force fail" mechanism for manual QA, such as:

- a dev-only flag that forces selected operations to throw
- a debug query param that triggers simulated failures

This must never ship enabled in production behavior.

---

## Rationale

Macadamy is:

- Multi-tenant
- RLS enforced
- RPC driven
- Role-based
- Data-critical (financials, labor, compliance, audit)

Silent failures in this environment can:

- Mask RLS misconfiguration
- Hide org-scoping bugs
- Create cross-org data leakage
- Corrupt audit trails
- Damage user trust
- Introduce undetected logic drift

We are building a Procore-level system.

Correctness and visibility take priority over convenience during development.

---

## Core Principle

If the backend did not respond successfully, the UI must not pretend that it did.

Every failure must be:

- Visible to the user when policy requires (toast)
- Visible to the developer (console.error)
- Preserved in state (not swallowed)